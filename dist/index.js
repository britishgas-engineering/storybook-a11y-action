/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3625:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2087));
const utils_1 = __nccwpck_require__(4803);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 9326:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(3625);
const file_command_1 = __nccwpck_require__(7576);
const utils_1 = __nccwpck_require__(4803);
const os = __importStar(__nccwpck_require__(2087));
const path = __importStar(__nccwpck_require__(5622));
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 */
function error(message) {
    command_1.issue('error', message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds an warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 */
function warning(message) {
    command_1.issue('warning', message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 7576:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(5747));
const os = __importStar(__nccwpck_require__(2087));
const utils_1 = __nccwpck_require__(4803);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 4803:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 9170:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AxePuppeteer = void 0;
const browser_1 = __nccwpck_require__(7021);
function arrayify(src) {
    if (!Array.isArray(src)) {
        return [src];
    }
    return src;
}
function injectJSModule(frame) {
    return frame
        .addScriptTag({
        path: __nccwpck_require__.ab + "axe.js"
    })
        .then(() => undefined);
}
function injectJSSource(frame, source, args = []) {
    return frame.evaluate(source, ...args);
}
function injectJS(frame, { source, selector, logOnError, args }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!frame) {
            return;
        }
        const frames = yield frame.$$(selector);
        const injections = [];
        for (const frameElement of frames) {
            const subFrame = yield frameElement.contentFrame();
            const p = injectJS(subFrame, {
                source,
                selector,
                args,
                logOnError: true
            });
            injections.push(p);
        }
        const reportError = () => {
            console.error(`Failed to inject axe-core into frame (${frame.url()})`);
        };
        let injectP;
        if (!source) {
            injectP = injectJSModule(frame);
        }
        else {
            injectP = injectJSSource(frame, source, args);
        }
        if (logOnError) {
            injectP = injectP.catch(reportError);
        }
        injections.push(injectP);
        return Promise.all(injections).then(() => undefined);
    });
}
function isPage(pageFrame) {
    return pageFrame.mainFrame !== undefined;
}
function getFrame(pageFrame) {
    if (isPage(pageFrame)) {
        return pageFrame.mainFrame();
    }
    return pageFrame;
}
function ensureFrameReady(frame) {
    return __awaiter(this, void 0, void 0, function* () {
        yield frame.waitForSelector('html');
        const pageReady = yield frame.evaluate(browser_1.pageIsLoaded);
        if (!pageReady) {
            throw new Error('Page/Frame is not ready');
        }
    });
}
function normalizeContext(includes, excludes) {
    if (!excludes.length && !includes.length) {
        return null;
    }
    const ctx = {};
    if (excludes.length) {
        ctx.exclude = excludes;
    }
    if (includes.length) {
        ctx.include = includes;
    }
    return ctx;
}
class AxePuppeteer {
    constructor(pageFrame, source) {
        this.frame = getFrame(pageFrame);
        this.source = source;
        this.includes = [];
        this.excludes = [];
        this.axeOptions = null;
        this.config = null;
        this.disabledFrameSelectors = [];
    }
    include(selector) {
        selector = arrayify(selector);
        this.includes.push(selector);
        return this;
    }
    exclude(selector) {
        selector = arrayify(selector);
        this.excludes.push(selector);
        return this;
    }
    options(options) {
        this.axeOptions = options;
        return this;
    }
    withRules(rules) {
        rules = arrayify(rules);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        this.axeOptions.runOnly = {
            type: 'rule',
            values: rules
        };
        return this;
    }
    withTags(tags) {
        tags = arrayify(tags);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        this.axeOptions.runOnly = {
            type: 'tag',
            values: tags
        };
        return this;
    }
    disableRules(rules) {
        rules = arrayify(rules);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        const newRules = {};
        for (const rule of rules) {
            newRules[rule] = {
                enabled: false
            };
        }
        this.axeOptions.rules = newRules;
        return this;
    }
    configure(config) {
        if (typeof config !== 'object') {
            throw new Error('AxePuppeteer needs an object to configure. See axe-core configure API.');
        }
        this.config = config;
        return this;
    }
    disableFrame(selector) {
        this.disabledFrameSelectors.push(selector);
        return this;
    }
    analyze(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield ensureFrameReady(this.frame);
                yield injectJS(this.frame, {
                    source: this.source,
                    selector: this.iframeSelector()
                });
                yield injectJS(this.frame, {
                    source: browser_1.configureAxe,
                    selector: this.iframeSelector(),
                    args: [this.config]
                });
                const context = normalizeContext(this.includes, this.excludes);
                const axeResults = yield this.frame.evaluate(browser_1.runAxe, context, this.axeOptions);
                if (callback) {
                    callback(null, axeResults);
                }
                return axeResults;
            }
            catch (err) {
                if (callback) {
                    callback(err);
                    return null;
                }
                throw err;
            }
        });
    }
    iframeSelector() {
        let selector = 'iframe';
        for (const disabledFrameSelector of this.disabledFrameSelectors) {
            selector += `:not(${disabledFrameSelector})`;
        }
        return selector;
    }
}
exports.AxePuppeteer = AxePuppeteer;
//# sourceMappingURL=axePuppeteer.js.map

/***/ }),

/***/ 7021:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureAxe = exports.pageIsLoaded = exports.runAxe = void 0;
function runAxe(context, options) {
    return window.axe.run(context || document, options || {});
}
exports.runAxe = runAxe;
function pageIsLoaded() {
    return document.readyState === 'complete';
}
exports.pageIsLoaded = pageIsLoaded;
function configureAxe(config) {
    if (config) {
        window.axe.configure(config);
    }
    window.axe.configure({
        allowedOrigins: ['<unsafe_all_origins>'],
        branding: { application: 'axe-puppeteer' }
    });
}
exports.configureAxe = configureAxe;
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 7595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadPage = exports.AxePuppeteer = void 0;
const axePuppeteer_1 = __nccwpck_require__(9170);
Object.defineProperty(exports, "AxePuppeteer", ({ enumerable: true, get: function () { return axePuppeteer_1.AxePuppeteer; } }));
const owning_1 = __nccwpck_require__(2006);
Object.defineProperty(exports, "loadPage", ({ enumerable: true, get: function () { return owning_1.loadPage; } }));
exports.default = axePuppeteer_1.AxePuppeteer;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2006:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadPage = void 0;
const axePuppeteer_1 = __nccwpck_require__(9170);
class OwningAxePuppeteer extends axePuppeteer_1.AxePuppeteer {
    constructor(page, source) {
        super(page, source);
        this.page = page;
    }
    analyze(callback) {
        const _super = Object.create(null, {
            analyze: { get: () => super.analyze }
        });
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield _super.analyze.call(this, callback);
            }
            finally {
                yield this.page.close();
            }
        });
    }
}
function loadPage(browser, url, pageOpts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const page = yield browser.newPage();
        yield page.setBypassCSP(true);
        yield page.goto(url, pageOpts.opts);
        return new OwningAxePuppeteer(page, pageOpts.source);
    });
}
exports.loadPage = loadPage;
//# sourceMappingURL=owning.js.map

/***/ }),

/***/ 4904:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const events_1 = __nccwpck_require__(8614);
const debug_1 = __importDefault(__nccwpck_require__(2423));
const promisify_1 = __importDefault(__nccwpck_require__(7255));
const debug = debug_1.default('agent-base');
function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string')
        return false;
    return stack.split('\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function (createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */
    class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
            super();
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            }
            else if (callback) {
                opts = callback;
            }
            // Timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            // These aren't actually used by `agent-base`, but are required
            // for the TypeScript definition files in `@types/node` :/
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.maxTotalSockets = Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
            this.options = {};
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            return isSecureEndpoint() ? 'https:' : 'http:';
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
            const opts = Object.assign({}, _opts);
            if (typeof opts.secureEndpoint !== 'boolean') {
                opts.secureEndpoint = isSecureEndpoint();
            }
            if (opts.host == null) {
                opts.host = 'localhost';
            }
            if (opts.port == null) {
                opts.port = opts.secureEndpoint ? 443 : 80;
            }
            if (opts.protocol == null) {
                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
            }
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most
                // likely the result of a `url.parse()` call... we need to
                // remove the `path` portion so that `net.connect()` doesn't
                // attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts.timeout || this.timeout;
            const onerror = (err) => {
                if (req._hadError)
                    return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            };
            const ontimeout = () => {
                timeoutId = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            };
            const callbackError = (err) => {
                if (timedOut)
                    return;
                if (timeoutId !== null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                onerror(err);
            };
            const onsocket = (socket) => {
                if (timedOut)
                    return;
                if (timeoutId != null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                if (isAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    debug('Callback returned another Agent instance %o', socket.constructor.name);
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    socket.once('free', () => {
                        this.freeSocket(socket, opts);
                    });
                    req.onSocket(socket);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            };
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    debug('Converting legacy callback function to promise');
                    this.promisifiedCallback = promisify_1.default(this.callback);
                }
                else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            }
            catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            debug('Freeing socket %o %o', socket.constructor.name, opts);
            socket.destroy();
        }
        destroy() {
            debug('Destroying agent %o', this.constructor.name);
        }
    }
    createAgent.Agent = Agent;
    // So that `instanceof` works correctly
    createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));
module.exports = createAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7255:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function promisify(fn) {
    return function (req, opts) {
        return new Promise((resolve, reject) => {
            fn.call(this, req, opts, (err, rtn) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports.default = promisify;
//# sourceMappingURL=promisify.js.map

/***/ }),

/***/ 1097:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 6124:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Buffer } = __nccwpck_require__(4293)
const symbol = Symbol.for('BufferList')

function BufferList (buf) {
  if (!(this instanceof BufferList)) {
    return new BufferList(buf)
  }

  BufferList._init.call(this, buf)
}

BufferList._init = function _init (buf) {
  Object.defineProperty(this, symbol, { value: true })

  this._bufs = []
  this.length = 0

  if (buf) {
    this.append(buf)
  }
}

BufferList.prototype._new = function _new (buf) {
  return new BufferList(buf)
}

BufferList.prototype._offset = function _offset (offset) {
  if (offset === 0) {
    return [0, 0]
  }

  let tot = 0

  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length
    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  const bufferId = blOffset[0]
  let offset = blOffset[1]

  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }

  return offset
}

BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }

  const offset = this._offset(index)

  return this._bufs[offset[0]][offset[1]]
}

BufferList.prototype.slice = function slice (start, end) {
  if (typeof start === 'number' && start < 0) {
    start += this.length
  }

  if (typeof end === 'number' && end < 0) {
    end += this.length
  }

  return this.copy(null, 0, start, end)
}

BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== 'number' || srcStart < 0) {
    srcStart = 0
  }

  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
    srcEnd = this.length
  }

  if (srcStart >= this.length) {
    return dst || Buffer.alloc(0)
  }

  if (srcEnd <= 0) {
    return dst || Buffer.alloc(0)
  }

  const copy = !!dst
  const off = this._offset(srcStart)
  const len = srcEnd - srcStart
  let bytes = len
  let bufoff = (copy && dstStart) || 0
  let start = off[1]

  // copy/slice everything
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy) {
      // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) {
    // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)
  }

  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
      bufoff += l
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      bufoff += l
      break
    }

    bytes -= l

    if (start) {
      start = 0
    }
  }

  // safeguard so that we don't return uninitialized memory
  if (dst.length > bufoff) return dst.slice(0, bufoff)

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0) {
    start += this.length
  }

  if (end < 0) {
    end += this.length
  }

  if (start === end) {
    return this._new()
  }

  const startOffset = this._offset(start)
  const endOffset = this._offset(end)
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] === 0) {
    buffers.pop()
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])
  }

  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1])
  }

  return this._new(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  // first, normalize the argument, in accordance with how Buffer does it
  bytes = Math.trunc(bytes)
  // do nothing if not a positive number
  if (Number.isNaN(bytes) || bytes <= 0) return this

  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }

  return this
}

BufferList.prototype.duplicate = function duplicate () {
  const copy = this._new()

  for (let i = 0; i < this._bufs.length; i++) {
    copy.append(this._bufs[i])
  }

  return copy
}

BufferList.prototype.append = function append (buf) {
  if (buf == null) {
    return this
  }

  if (buf.buffer) {
    // append a view of the underlying ArrayBuffer
    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i])
    }
  } else if (this._isBufferList(buf)) {
    // unwrap argument into individual BufferLists
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i])
    }
  } else {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf === 'number') {
      buf = buf.toString()
    }

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}

BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}

BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }

  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
    search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (this._isBufferList(search)) {
    search = search.slice()
  } else if (Array.isArray(search.buffer)) {
    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)

  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  const blOffset = this._offset(offset)
  let blIndex = blOffset[0] // index of which internal buffer we're working on
  let buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex]

    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset

      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset)

        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }

        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset])

        if (this._match(revOffset, search)) {
          return revOffset
        }

        buffOffset++
      }
    }

    buffOffset = 0
  }

  return -1
}

BufferList.prototype._match = function (offset, search) {
  if (this.length - offset < search.length) {
    return false
  }

  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false
    }
  }
  return true
}

;(function () {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  }

  for (const m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      } else {
        BufferList.prototype[m] = function (offset = 0) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())

// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferList || BufferList.isBufferList(b)
}

BufferList.isBufferList = function isBufferList (b) {
  return b != null && b[symbol]
}

module.exports = BufferList


/***/ }),

/***/ 8969:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const DuplexStream = __nccwpck_require__(2298).Duplex
const inherits = __nccwpck_require__(5588)
const BufferList = __nccwpck_require__(6124)

function BufferListStream (callback) {
  if (!(this instanceof BufferListStream)) {
    return new BufferListStream(callback)
  }

  if (typeof callback === 'function') {
    this._callback = callback

    const piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })

    callback = null
  }

  BufferList._init.call(this, callback)
  DuplexStream.call(this)
}

inherits(BufferListStream, DuplexStream)
Object.assign(BufferListStream.prototype, BufferList.prototype)

BufferListStream.prototype._new = function _new (callback) {
  return new BufferListStream(callback)
}

BufferListStream.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback === 'function') {
    callback()
  }
}

BufferListStream.prototype._read = function _read (size) {
  if (!this.length) {
    return this.push(null)
  }

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}

BufferListStream.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}

BufferListStream.prototype._destroy = function _destroy (err, cb) {
  this._bufs.length = 0
  this.length = 0
  cb(err)
}

BufferListStream.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
}

BufferListStream.isBufferList = BufferList.isBufferList

module.exports = BufferListStream
module.exports.BufferListStream = BufferListStream
module.exports.BufferList = BufferList


/***/ }),

/***/ 391:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(4275);
var balanced = __nccwpck_require__(1097);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 8992:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Buffer = __nccwpck_require__(4293).Buffer;

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
  0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function ensureBuffer(input) {
  if (Buffer.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
      typeof Buffer.alloc === "function" &&
      typeof Buffer.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
  }
  else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
  }
  else {
    throw new Error("input must be buffer, number, or string, received " +
                    typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return (crc ^ -1);
}

function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

module.exports = crc32;


/***/ }),

/***/ 5769:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const fs = __nccwpck_require__(5747)
const path = __nccwpck_require__(5622)

/* istanbul ignore next */
const LCHOWN = fs.lchown ? 'lchown' : 'chown'
/* istanbul ignore next */
const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'

/* istanbul ignore next */
const needEISDIRHandled = fs.lchown &&
  !process.version.match(/v1[1-9]+\./) &&
  !process.version.match(/v10\.[6-9]/)

const lchownSync = (path, uid, gid) => {
  try {
    return fs[LCHOWNSYNC](path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const chownSync = (path, uid, gid) => {
  try {
    return fs.chownSync(path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const handleEISDIR =
  needEISDIRHandled ? (path, uid, gid, cb) => er => {
    // Node prior to v10 had a very questionable implementation of
    // fs.lchown, which would always try to call fs.open on a directory
    // Fall back to fs.chown in those cases.
    if (!er || er.code !== 'EISDIR')
      cb(er)
    else
      fs.chown(path, uid, gid, cb)
  }
  : (_, __, ___, cb) => cb

/* istanbul ignore next */
const handleEISDirSync =
  needEISDIRHandled ? (path, uid, gid) => {
    try {
      return lchownSync(path, uid, gid)
    } catch (er) {
      if (er.code !== 'EISDIR')
        throw er
      chownSync(path, uid, gid)
    }
  }
  : (path, uid, gid) => lchownSync(path, uid, gid)

// fs.readdir could only accept an options object as of node v6
const nodeVersion = process.version
let readdir = (path, options, cb) => fs.readdir(path, options, cb)
let readdirSync = (path, options) => fs.readdirSync(path, options)
/* istanbul ignore next */
if (/^v4\./.test(nodeVersion))
  readdir = (path, options, cb) => fs.readdir(path, cb)

const chown = (cpath, uid, gid, cb) => {
  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    // Skip ENOENT error
    cb(er && er.code !== 'ENOENT' ? er : null)
  }))
}

const chownrKid = (p, child, uid, gid, cb) => {
  if (typeof child === 'string')
    return fs.lstat(path.resolve(p, child), (er, stats) => {
      // Skip ENOENT error
      if (er)
        return cb(er.code !== 'ENOENT' ? er : null)
      stats.name = child
      chownrKid(p, stats, uid, gid, cb)
    })

  if (child.isDirectory()) {
    chownr(path.resolve(p, child.name), uid, gid, er => {
      if (er)
        return cb(er)
      const cpath = path.resolve(p, child.name)
      chown(cpath, uid, gid, cb)
    })
  } else {
    const cpath = path.resolve(p, child.name)
    chown(cpath, uid, gid, cb)
  }
}


const chownr = (p, uid, gid, cb) => {
  readdir(p, { withFileTypes: true }, (er, children) => {
    // any error other than ENOTDIR or ENOTSUP means it's not readable,
    // or doesn't exist.  give up.
    if (er) {
      if (er.code === 'ENOENT')
        return cb()
      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')
        return cb(er)
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb)

    let len = children.length
    let errState = null
    const then = er => {
      if (errState)
        return
      if (er)
        return cb(errState = er)
      if (-- len === 0)
        return chown(p, uid, gid, cb)
    }

    children.forEach(child => chownrKid(p, child, uid, gid, then))
  })
}

const chownrKidSync = (p, child, uid, gid) => {
  if (typeof child === 'string') {
    try {
      const stats = fs.lstatSync(path.resolve(p, child))
      stats.name = child
      child = stats
    } catch (er) {
      if (er.code === 'ENOENT')
        return
      else
        throw er
    }
  }

  if (child.isDirectory())
    chownrSync(path.resolve(p, child.name), uid, gid)

  handleEISDirSync(path.resolve(p, child.name), uid, gid)
}

const chownrSync = (p, uid, gid) => {
  let children
  try {
    children = readdirSync(p, { withFileTypes: true })
  } catch (er) {
    if (er.code === 'ENOENT')
      return
    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')
      return handleEISDirSync(p, uid, gid)
    else
      throw er
  }

  if (children && children.length)
    children.forEach(child => chownrKidSync(p, child, uid, gid))

  return handleEISDirSync(p, uid, gid)
}

module.exports = chownr
chownr.sync = chownrSync


/***/ }),

/***/ 4275:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 2892:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(8088)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 8088:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(5717);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 2423:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(2892);
} else {
	module.exports = __nccwpck_require__(5805);
}


/***/ }),

/***/ 5805:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(3867);
const util = __nccwpck_require__(1669);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(2549);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(8088)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 3359:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var once = __nccwpck_require__(328);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ 8361:
/***/ ((module) => {

"use strict";


const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;

module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	return string.replace(matchOperatorsRegex, '\\$&');
};


/***/ }),

/***/ 6108:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const debug = __nccwpck_require__(2423)('extract-zip')
// eslint-disable-next-line node/no-unsupported-features/node-builtins
const { createWriteStream, promises: fs } = __nccwpck_require__(5747)
const getStream = __nccwpck_require__(7780)
const path = __nccwpck_require__(5622)
const { promisify } = __nccwpck_require__(1669)
const stream = __nccwpck_require__(2413)
const yauzl = __nccwpck_require__(3265)

const openZip = promisify(yauzl.open)
const pipeline = promisify(stream.pipeline)

class Extractor {
  constructor (zipPath, opts) {
    this.zipPath = zipPath
    this.opts = opts
  }

  async extract () {
    debug('opening', this.zipPath, 'with opts', this.opts)

    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })
    this.canceled = false

    return new Promise((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true
        reject(err)
      })
      this.zipfile.readEntry()

      this.zipfile.on('close', () => {
        if (!this.canceled) {
          debug('zip extraction complete')
          resolve()
        }
      })

      this.zipfile.on('entry', async entry => {
        /* istanbul ignore if */
        if (this.canceled) {
          debug('skipping entry', entry.fileName, { cancelled: this.canceled })
          return
        }

        debug('zipfile entry', entry.fileName)

        if (entry.fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry()
          return
        }

        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))

        try {
          await fs.mkdir(destDir, { recursive: true })

          const canonicalDestDir = await fs.realpath(destDir)
          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)

          if (relativeDestDir.split(path.sep).includes('..')) {
            throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`)
          }

          await this.extractEntry(entry)
          debug('finished processing', entry.fileName)
          this.zipfile.readEntry()
        } catch (err) {
          this.canceled = true
          this.zipfile.close()
          reject(err)
        }
      })
    })
  }

  async extractEntry (entry) {
    /* istanbul ignore if */
    if (this.canceled) {
      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })
      return
    }

    if (this.opts.onEntry) {
      this.opts.onEntry(entry, this.zipfile)
    }

    const dest = path.join(this.opts.dir, entry.fileName)

    // convert external file attr int into a fs stat mode int
    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF
    // check if it's a symlink or dir (using stat mode constants)
    const IFMT = 61440
    const IFDIR = 16384
    const IFLNK = 40960
    const symlink = (mode & IFMT) === IFLNK
    let isDir = (mode & IFMT) === IFDIR

    // Failsafe, borrowed from jsZip
    if (!isDir && entry.fileName.endsWith('/')) {
      isDir = true
    }

    // check for windows weird way of specifying a directory
    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566
    const madeBy = entry.versionMadeBy >> 8
    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)

    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })

    const procMode = this.getExtractedMode(mode, isDir) & 0o777

    // always ensure folders are created
    const destDir = isDir ? dest : path.dirname(dest)

    const mkdirOptions = { recursive: true }
    if (isDir) {
      mkdirOptions.mode = procMode
    }
    debug('mkdir', { dir: destDir, ...mkdirOptions })
    await fs.mkdir(destDir, mkdirOptions)
    if (isDir) return

    debug('opening read stream', dest)
    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)

    if (symlink) {
      const link = await getStream(readStream)
      debug('creating symlink', link, dest)
      await fs.symlink(link, dest)
    } else {
      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))
    }
  }

  getExtractedMode (entryMode, isDir) {
    let mode = entryMode
    // Set defaults, if necessary
    if (mode === 0) {
      if (isDir) {
        if (this.opts.defaultDirMode) {
          mode = parseInt(this.opts.defaultDirMode, 10)
        }

        if (!mode) {
          mode = 0o755
        }
      } else {
        if (this.opts.defaultFileMode) {
          mode = parseInt(this.opts.defaultFileMode, 10)
        }

        if (!mode) {
          mode = 0o644
        }
      }
    }

    return mode
  }
}

module.exports = async function (zipPath, opts) {
  debug('creating target directory', opts.dir)

  if (!path.isAbsolute(opts.dir)) {
    throw new Error('Target directory is expected to be absolute')
  }

  await fs.mkdir(opts.dir, { recursive: true })
  opts.dir = await fs.realpath(opts.dir)
  return new Extractor(zipPath, opts).extract()
}


/***/ }),

/***/ 8021:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var fs = __nccwpck_require__(5747);
var util = __nccwpck_require__(1669);
var stream = __nccwpck_require__(2413);
var Readable = stream.Readable;
var Writable = stream.Writable;
var PassThrough = stream.PassThrough;
var Pend = __nccwpck_require__(4330);
var EventEmitter = __nccwpck_require__(8614).EventEmitter;

exports.createFromBuffer = createFromBuffer;
exports.createFromFd = createFromFd;
exports.BufferSlicer = BufferSlicer;
exports.FdSlicer = FdSlicer;

util.inherits(FdSlicer, EventEmitter);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter.call(this);

  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}

FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
      cb();
      callback(err, bytesRead, buffer);
    });
  });
};

FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
      cb();
      callback(err, written, buffer);
    });
  });
};

FdSlicer.prototype.createReadStream = function(options) {
  return new ReadStream(this, options);
};

FdSlicer.prototype.createWriteStream = function(options) {
  return new WriteStream(this, options);
};

FdSlicer.prototype.ref = function() {
  this.refCount += 1;
};

FdSlicer.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  if (self.autoClose) {
    fs.close(self.fd, onCloseDone);
  }

  function onCloseDone(err) {
    if (err) {
      self.emit('error', err);
    } else {
      self.emit('close');
    }
  }
};

util.inherits(ReadStream, Readable);
function ReadStream(context, options) {
  options = options || {};
  Readable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}

ReadStream.prototype._read = function(n) {
  var self = this;
  if (self.destroyed) return;

  var toRead = Math.min(self._readableState.highWaterMark, n);
  if (self.endOffset != null) {
    toRead = Math.min(toRead, self.endOffset - self.pos);
  }
  if (toRead <= 0) {
    self.destroyed = true;
    self.push(null);
    self.context.unref();
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    var buffer = new Buffer(toRead);
    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
      if (err) {
        self.destroy(err);
      } else if (bytesRead === 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
      } else {
        self.pos += bytesRead;
        self.push(buffer.slice(0, bytesRead));
      }
      cb();
    });
  });
};

ReadStream.prototype.destroy = function(err) {
  if (this.destroyed) return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit('error', err);
  this.context.unref();
};

util.inherits(WriteStream, Writable);
function WriteStream(context, options) {
  options = options || {};
  Writable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = (options.end == null) ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;

  this.on('finish', this.destroy.bind(this));
}

WriteStream.prototype._write = function(buffer, encoding, callback) {
  var self = this;
  if (self.destroyed) return;

  if (self.pos + buffer.length > self.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = 'ETOOBIG';
    self.destroy();
    callback(err);
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
      if (err) {
        self.destroy();
        cb();
        callback(err);
      } else {
        self.bytesWritten += bytes;
        self.pos += bytes;
        self.emit('progress');
        cb();
        callback();
      }
    });
  });
};

WriteStream.prototype.destroy = function() {
  if (this.destroyed) return;
  this.destroyed = true;
  this.context.unref();
};

util.inherits(BufferSlicer, EventEmitter);
function BufferSlicer(buffer, options) {
  EventEmitter.call(this);

  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}

BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = (delta > 0) ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function() {
    callback(null, written);
  });
};

BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function() {
    callback(null, length, buffer);
  });
};

BufferSlicer.prototype.createReadStream = function(options) {
  options = options || {};
  var readStream = new PassThrough(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  // by the time this function returns, we'll be done.
  readStream.pos = readStream.endOffset || this.buffer.length;

  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      // last chunk
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }

  readStream.end();
  readStream.destroy = function() {
    readStream.destroyed = true;
  };
  return readStream;
};

BufferSlicer.prototype.createWriteStream = function(options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function(buffer, encoding, callback) {
    if (writeStream.destroyed) return;

    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = 'ETOOBIG';
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit('progress');
    callback();
  };
  writeStream.destroy = function() {
    writeStream.destroyed = true;
  };
  return writeStream;
};

BufferSlicer.prototype.ref = function() {
  this.refCount += 1;
};

BufferSlicer.prototype.unref = function() {
  this.refCount -= 1;

  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};

function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}

function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}


/***/ }),

/***/ 6303:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const path = __nccwpck_require__(5622);
const locatePath = __nccwpck_require__(7468);
const pathExists = __nccwpck_require__(1507);

const stop = Symbol('findUp.stop');

module.exports = async (name, options = {}) => {
	let directory = path.resolve(options.cwd || '');
	const {root} = path.parse(directory);
	const paths = [].concat(name);

	const runMatcher = async locateOptions => {
		if (typeof name !== 'function') {
			return locatePath(paths, locateOptions);
		}

		const foundPath = await name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePath([foundPath], locateOptions);
		}

		return foundPath;
	};

	// eslint-disable-next-line no-constant-condition
	while (true) {
		// eslint-disable-next-line no-await-in-loop
		const foundPath = await runMatcher({...options, cwd: directory});

		if (foundPath === stop) {
			return;
		}

		if (foundPath) {
			return path.resolve(directory, foundPath);
		}

		if (directory === root) {
			return;
		}

		directory = path.dirname(directory);
	}
};

module.exports.sync = (name, options = {}) => {
	let directory = path.resolve(options.cwd || '');
	const {root} = path.parse(directory);
	const paths = [].concat(name);

	const runMatcher = locateOptions => {
		if (typeof name !== 'function') {
			return locatePath.sync(paths, locateOptions);
		}

		const foundPath = name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePath.sync([foundPath], locateOptions);
		}

		return foundPath;
	};

	// eslint-disable-next-line no-constant-condition
	while (true) {
		const foundPath = runMatcher({...options, cwd: directory});

		if (foundPath === stop) {
			return;
		}

		if (foundPath) {
			return path.resolve(directory, foundPath);
		}

		if (directory === root) {
			return;
		}

		directory = path.dirname(directory);
	}
};

module.exports.exists = pathExists;

module.exports.sync.exists = pathExists.sync;

module.exports.stop = stop;


/***/ }),

/***/ 3918:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(5747).constants || __nccwpck_require__(7619)


/***/ }),

/***/ 5555:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __nccwpck_require__(5747)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __nccwpck_require__(6092)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ 6092:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __nccwpck_require__(5622);
var isWindows = process.platform === 'win32';
var fs = __nccwpck_require__(5747);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ 5745:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __nccwpck_require__(2413);

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),

/***/ 7780:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {constants: BufferConstants} = __nccwpck_require__(4293);
const pump = __nccwpck_require__(7854);
const bufferStream = __nccwpck_require__(5745);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports.default = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),

/***/ 5551:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __nccwpck_require__(5622)
var minimatch = __nccwpck_require__(2948)
var isAbsolute = __nccwpck_require__(1768)
var Minimatch = minimatch.Minimatch

function alphasort (a, b) {
  return a.localeCompare(b, 'en')
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ 2216:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __nccwpck_require__(5747)
var rp = __nccwpck_require__(5555)
var minimatch = __nccwpck_require__(2948)
var Minimatch = minimatch.Minimatch
var inherits = __nccwpck_require__(5588)
var EE = __nccwpck_require__(8614).EventEmitter
var path = __nccwpck_require__(5622)
var assert = __nccwpck_require__(2357)
var isAbsolute = __nccwpck_require__(1768)
var globSync = __nccwpck_require__(8581)
var common = __nccwpck_require__(5551)
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __nccwpck_require__(1606)
var util = __nccwpck_require__(1669)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __nccwpck_require__(328)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ 8581:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __nccwpck_require__(5747)
var rp = __nccwpck_require__(5555)
var minimatch = __nccwpck_require__(2948)
var Minimatch = minimatch.Minimatch
var Glob = __nccwpck_require__(2216).Glob
var util = __nccwpck_require__(1669)
var path = __nccwpck_require__(5622)
var assert = __nccwpck_require__(2357)
var isAbsolute = __nccwpck_require__(1768)
var common = __nccwpck_require__(5551)
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ 4819:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __importDefault(__nccwpck_require__(1631));
const tls_1 = __importDefault(__nccwpck_require__(4016));
const url_1 = __importDefault(__nccwpck_require__(8835));
const assert_1 = __importDefault(__nccwpck_require__(2357));
const debug_1 = __importDefault(__nccwpck_require__(2423));
const agent_base_1 = __nccwpck_require__(4904);
const parse_proxy_response_1 = __importDefault(__nccwpck_require__(4329));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */
class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) {
            proxy.ALPNProtocols = ['http 1.1'];
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts.host}:${opts.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;
            }
            // The `Host` header should only include the port
            // number when it is not the default port.
            let { host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) {
                host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)) {
                payload += `${name}: ${headers[name]}\r\n`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r\n`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
                req.once('socket', resume);
                if (opts.secureEndpoint) {
                    const servername = opts.servername || opts.host;
                    if (!servername) {
                        throw new Error('Could not determine "servername"');
                    }
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,
                        servername }));
                }
                return socket;
            }
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket();
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s) => {
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
            });
            return fakeSocket;
        });
    }
}
exports.default = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function isDefaultPort(port, secure) {
    return Boolean((!secure && port === 80) || (secure && port === 443));
}
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
}
//# sourceMappingURL=agent.js.map

/***/ }),

/***/ 7562:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__nccwpck_require__(4819));
function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent.prototype = agent_1.default.prototype;
})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
module.exports = createHttpsProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4329:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__nccwpck_require__(2423));
const debug = debug_1.default('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b)
                ondata(b);
            else
                socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('close', onclose);
            socket.removeListener('readable', read);
        }
        function onclose(err) {
            debug('onclose had error %o', err);
        }
        function onend() {
            debug('onend');
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\r\n'));
            const statusCode = +firstLine.split(' ')[1];
            debug('got proxy server response: %o', firstLine);
            resolve({
                statusCode,
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('close', onclose);
        socket.on('end', onend);
        read();
    });
}
exports.default = parseProxyResponse;
//# sourceMappingURL=parse-proxy-response.js.map

/***/ }),

/***/ 1606:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(7320)
var reqs = Object.create(null)
var once = __nccwpck_require__(328)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ 5588:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

try {
  var util = __nccwpck_require__(1669);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __nccwpck_require__(8828);
}


/***/ }),

/***/ 8828:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 2816:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var encode = __nccwpck_require__(8104),
    decode = __nccwpck_require__(9514);

module.exports = {
  encode: encode,
  decode: decode
};


/***/ }),

/***/ 9514:
/***/ ((module) => {

/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
     0,
     1,  8,
    16,  9,  2,
     3, 10, 17, 24,
    32, 25, 18, 11, 4,
     5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13,  6,
     7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1  =  4017   // cos(pi/16)
  var dctSin1  =   799   // sin(pi/16)
  var dctCos3  =  3406   // cos(3*pi/16)
  var dctSin3  =  2276   // sin(3*pi/16)
  var dctCos6  =  1567   // cos(6*pi/16)
  var dctSin6  =  3784   // sin(6*pi/16)
  var dctSqrt2 =  5793   // sqrt(2)
  var dctSqrt1d2 = 2896  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          if (code.length === 0)
            throw new Error('Could not recreate Huffman Table');
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive, opts) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;
    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw new Error("unexpected marker: " + ((bitsData << 8) | nextByte).toString(16));
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }
    function decodeHuffman(tree) {
      var node = tree, bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw new Error("invalid huffman sequence");
      }
      return null;
    }
    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null) return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }
    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }
    function decodeBaseline(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      zz[0]= (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s);
        k++;
      }
    }
    function decodeDCFirst(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      zz[0] = (component.pred += diff);
    }
    function decodeDCSuccessive(component, zz) {
      zz[0] |= readBit() << successive;
    }
    var eobrun = 0;
    function decodeACFirst(component, zz) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, zz) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        var direction = zz[z] < 0 ? -1 : 1;
        switch (successiveACState) {
        case 0: // initial state
          var rs = decodeHuffman(component.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1)
              throw new Error("invalid ACn encoding");
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1: // skipping r zero items
        case 2:
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          else {
            r--;
            if (r === 0)
              successiveACState = successiveACState == 2 ? 3 : 0;
          }
          break;
        case 3: // set value for a zero item
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          else {
            zz[z] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }
    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      // If the block is missing and we're in tolerant mode, just skip it.
      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
        return;
      decode(component, component.blocks[blockRow][blockCol]);
    }
    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      // If the block is missing and we're in tolerant mode, just skip it.
      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
        return;
      decode(component, component.blocks[blockRow][blockCol]);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) resetInterval = mcuExpected;

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++)
        components[i].pred = 0;
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;

          // If we've reached our expected MCU's, stop decoding
          if (mcu === mcuExpected) break;
        }
      }

      if (mcu === mcuExpected) {
        // Skip trailing bytes at the end of the scan - until we reach the next marker
        do {
          if (data[offset] === 0xFF) {
            if (data[offset + 1] !== 0x00) {
              break;
            }
          }
          offset += 1;
        } while (offset < data.length - 2);
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker < 0xFF00) {
        throw new Error("marker was not found");
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      }
      else
        break;
    }

    return offset - startOffset;
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.
    var R = new Int32Array(64), r = new Uint8Array(64);

    // A port of poppler's IDCT method which in turn is taken from:
    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
    //   988-991.
    function quantizeAndInverse(zz, dataOut, dataIn) {
      var qt = component.quantizationTable;
      var v0, v1, v2, v3, v4, v5, v6, v7, t;
      var p = dataIn;
      var i;

      // dequant
      for (i = 0; i < 64; i++)
        p[i] = zz[i] * qt[i];

      // inverse DCT on rows
      for (i = 0; i < 8; ++i) {
        var row = 8 * i;

        // check for all-zero AC coefficients
        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
            p[7 + row] == 0) {
          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
          p[0 + row] = t;
          p[1 + row] = t;
          p[2 + row] = t;
          p[3 + row] = t;
          p[4 + row] = t;
          p[5 + row] = t;
          p[6 + row] = t;
          p[7 + row] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
        v2 = p[2 + row];
        v3 = p[6 + row];
        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
        v5 = p[3 + row] << 4;
        v6 = p[5 + row] << 4;

        // stage 3
        t = (v0 - v1+ 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0 + row] = v0 + v7;
        p[7 + row] = v0 - v7;
        p[1 + row] = v1 + v6;
        p[6 + row] = v1 - v6;
        p[2 + row] = v2 + v5;
        p[5 + row] = v2 - v5;
        p[3 + row] = v3 + v4;
        p[4 + row] = v3 - v4;
      }

      // inverse DCT on columns
      for (i = 0; i < 8; ++i) {
        var col = i;

        // check for all-zero AC coefficients
        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
            p[7*8 + col] == 0) {
          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
          p[0*8 + col] = t;
          p[1*8 + col] = t;
          p[2*8 + col] = t;
          p[3*8 + col] = t;
          p[4*8 + col] = t;
          p[5*8 + col] = t;
          p[6*8 + col] = t;
          p[7*8 + col] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
        v2 = p[2*8 + col];
        v3 = p[6*8 + col];
        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
        v5 = p[3*8 + col];
        v6 = p[5*8 + col];

        // stage 3
        t = (v0 - v1 + 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0*8 + col] = v0 + v7;
        p[7*8 + col] = v0 - v7;
        p[1*8 + col] = v1 + v6;
        p[6*8 + col] = v1 - v6;
        p[2*8 + col] = v2 + v5;
        p[5*8 + col] = v2 - v5;
        p[3*8 + col] = v3 + v4;
        p[4*8 + col] = v3 - v4;
      }

      // convert to 8-bit integers
      for (i = 0; i < 64; ++i) {
        var sample = 128 + ((p[i] + 8) >> 4);
        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
      }
    }

    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);

    var i, j;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      var scanLine = blockRow << 3;
      for (i = 0; i < 8; i++)
        lines.push(new Uint8Array(samplesPerLine));
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

        var offset = 0, sample = blockCol << 3;
        for (j = 0; j < 8; j++) {
          var line = lines[scanLine + j];
          for (i = 0; i < 8; i++)
            line[sample + i] = r[offset++];
        }
      }
    }
    return lines;
  }

  function clampTo8bit(a) {
    return a < 0 ? 0 : a > 255 ? 255 : a;
  }

  constructor.prototype = {
    load: function load(path) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = (function() {
        // TODO catch parse error
        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);
      xhr.send(null);
    },
    parse: function parse(data) {
      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
      var offset = 0, length = data.length;
      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }
      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }
      function prepareComponents(frame) {
        var maxH = 0, maxV = 0;
        var component, componentId;
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            if (maxH < component.h) maxH = component.h;
            if (maxV < component.v) maxV = component.v;
          }
        }
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
            var blocksPerLineForMcu = mcusPerLine * component.h;
            var blocksPerColumnForMcu = mcusPerColumn * component.v;
            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
            var blocks = [];

            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)
            requestMemoryAllocation(blocksToAllocate * 256);

            for (var i = 0; i < blocksPerColumnForMcu; i++) {
              var row = [];
              for (var j = 0; j < blocksPerLineForMcu; j++)
                row.push(new Int32Array(64));
              blocks.push(row);
            }
            component.blocksPerLine = blocksPerLine;
            component.blocksPerColumn = blocksPerColumn;
            component.blocks = blocks;
          }
        }
        frame.maxH = maxH;
        frame.maxV = maxV;
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [], frames = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      var malformedDataOffset = -1;
      this.comments = [];
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw new Error("SOI not found");
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch(fileMarker) {
          case 0xFF00: break;
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFFE) {
              var comment = String.fromCharCode.apply(null, appData);
              this.comments.push(comment);
            }

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: { major: appData[5], minor: appData[6] },
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFE1) {
              if (appData[0] === 0x45 &&
                appData[1] === 0x78 &&
                appData[2] === 0x69 &&
                appData[3] === 0x66 &&
                appData[4] === 0) { // 'EXIF\x00'
                this.exifBuffer = appData.subarray(5, appData.length);
              }
            }

            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              requestMemoryAllocation(64 * 4);
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else
                throw new Error("DQT: invalid table spec");
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = {};
            frame.componentsOrder = [];

            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
            if (pixelsInFrame > maxResolutionInPixels) {
              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
            }

            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              var qId = data[offset + 2];
              frame.componentsOrder.push(componentId);
              frame.components[componentId] = {
                h: h,
                v: v,
                quantizationIdx: qId
              };
              offset += 3;
            }
            prepareComponents(frame);
            frames.push(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++) {
                codeLengthSum += (codeLengths[j] = data[offset]);
              }
              requestMemoryAllocation(16 + codeLengthSum);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDC: // Number of Lines marker
            readUint16() // skip data length
            readUint16() // Ignore this data since it represents the image height
            break;
            
          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              component = frame.components[data[offset++]];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15, this.opts);
            offset += processed;
            break;

          case 0xFFFF: // Fill bytes
            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
              offset--;
            }
            break;
          default:
            if (data[offset - 3] == 0xFF &&
                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            else if (fileMarker === 0xE0 || fileMarker == 0xE1) {
              // Recover from malformed APP1 markers popular in some phone models.
              // See https://github.com/eugeneware/jpeg-js/issues/82
              if (malformedDataOffset !== -1) {
                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
              }
              malformedDataOffset = offset - 1;
              const nextOffset = readUint16();
              if (data[offset + nextOffset - 2] === 0xFF) {
                offset += nextOffset - 2;
                break;
              }
            }
            throw new Error("unknown JPEG marker " + fileMarker.toString(16));
        }
        fileMarker = readUint16();
      }
      if (frames.length != 1)
        throw new Error("only single frame JPEGs supported");

      // set each frame's components quantization table
      for (var i = 0; i < frames.length; i++) {
        var cp = frames[i].components;
        for (var j in cp) {
          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
          delete cp[j].quantizationIdx;
        }
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      for (var i = 0; i < frame.componentsOrder.length; i++) {
        var component = frame.components[frame.componentsOrder[i]];
        this.components.push({
          lines: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV
        });
      }
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component1, component2, component3, component4;
      var component1Line, component2Line, component3Line, component4Line;
      var x, y;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var dataLength = width * height * this.components.length;
      requestMemoryAllocation(dataLength);
      var data = new Uint8Array(dataLength);
      switch (this.components.length) {
        case 1:
          component1 = this.components[0];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

              data[offset++] = Y;
            }
          }
          break;
        case 2:
          // PDF might compress two component data in custom colorspace
          component1 = this.components[0];
          component2 = this.components[1];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
              data[offset++] = Y;
              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
              data[offset++] = Y;
            }
          }
          break;
        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.opts.colorTransform !== 'undefined')
            colorTransform = !!this.opts.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                R = component1Line[0 | (x * component1.scaleX * scaleX)];
                G = component2Line[0 | (x * component2.scaleX * scaleX)];
                B = component3Line[0 | (x * component3.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

                R = clampTo8bit(Y + 1.402 * (Cr - 128));
                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                B = clampTo8bit(Y + 1.772 * (Cb - 128));
              }

              data[offset++] = R;
              data[offset++] = G;
              data[offset++] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw new Error('Unsupported color mode (4 components)');
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.opts.colorTransform !== 'undefined')
            colorTransform = !!this.opts.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          component4 = this.components[3];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                C = component1Line[0 | (x * component1.scaleX * scaleX)];
                M = component2Line[0 | (x * component2.scaleX * scaleX)];
                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];

                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
              }
              data[offset++] = 255-C;
              data[offset++] = 255-M;
              data[offset++] = 255-Ye;
              data[offset++] = 255-K;
            }
          }
          break;
        default:
          throw new Error('Unsupported color mode');
      }
      return data;
    },
    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
      var width = imageData.width, height = imageData.height;
      var imageDataArray = imageData.data;
      var data = this.getData(width, height);
      var i = 0, j = 0, x, y;
      var Y, K, C, M, R, G, B;
      switch (this.components.length) {
        case 1:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              Y = data[i++];

              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              if (formatAsRGBA) {
                imageDataArray[j++] = 255;
              }
            }
          }
          break;
        case 3:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              R = data[i++];
              G = data[i++];
              B = data[i++];

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              if (formatAsRGBA) {
                imageDataArray[j++] = 255;
              }
            }
          }
          break;
        case 4:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              C = data[i++];
              M = data[i++];
              Y = data[i++];
              K = data[i++];

              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              if (formatAsRGBA) {
                imageDataArray[j++] = 255;
              }
            }
          }
          break;
        default:
          throw new Error('Unsupported color mode');
      }
    }
  };


  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.
  var totalBytesAllocated = 0;
  var maxMemoryUsageBytes = 0;
  function requestMemoryAllocation(increaseAmount = 0) {
    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
    }

    totalBytesAllocated = totalMemoryImpactBytes;
  }

  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {
    totalBytesAllocated = 0;
    maxMemoryUsageBytes = maxMemoryUsageBytes_;
  };

  constructor.getBytesAllocated = function () {
    return totalBytesAllocated;
  };

  constructor.requestMemoryAllocation = requestMemoryAllocation;

  return constructor;
})();

if (true) {
	module.exports = decode;
} else {}

function decode(jpegData, userOpts = {}) {
  var defaultOpts = {
    // "undefined" means "Choose whether to transform colors based on the image’s color model."
    colorTransform: undefined,
    useTArray: false,
    formatAsRGBA: true,
    tolerantDecoding: true,
    maxResolutionInMP: 100, // Don't decode more than 100 megapixels
    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB
  };

  var opts = {...defaultOpts, ...userOpts};
  var arr = new Uint8Array(jpegData);
  var decoder = new JpegImage();
  decoder.opts = opts;
  // If this constructor ever supports async decoding this will need to be done differently.
  // Until then, treating as singleton limit is fine.
  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
  decoder.parse(arr);

  var channels = (opts.formatAsRGBA) ? 4 : 3;
  var bytesNeeded = decoder.width * decoder.height * channels;
  try {
    JpegImage.requestMemoryAllocation(bytesNeeded);
    var image = {
      width: decoder.width,
      height: decoder.height,
      exifBuffer: decoder.exifBuffer,
      data: opts.useTArray ?
        new Uint8Array(bytesNeeded) :
        Buffer.alloc(bytesNeeded)
    };
    if(decoder.comments.length > 0) {
      image["comments"] = decoder.comments;
    }
  } catch (err){
    if (err instanceof RangeError){
      throw new Error("Could not allocate enough memory for the image. " +
                      "Required: " + bytesNeeded);
    } else {
      throw err;
    }
  }

  decoder.copyToImageData(image, opts.formatAsRGBA);

  return image;
}


/***/ }),

/***/ 8104:
/***/ ((module) => {

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009

Basic GUI blocking jpeg encoder
*/

var btoa = btoa || function(buf) {
  return Buffer.from(buf).toString('base64');
};

function JPEGEncoder(quality) {
  var self = this;
	var fround = Math.round;
	var ffloor = Math.floor;
	var YTable = new Array(64);
	var UVTable = new Array(64);
	var fdtbl_Y = new Array(64);
	var fdtbl_UV = new Array(64);
	var YDC_HT;
	var UVDC_HT;
	var YAC_HT;
	var UVAC_HT;
	
	var bitcode = new Array(65535);
	var category = new Array(65535);
	var outputfDCTQuant = new Array(64);
	var DU = new Array(64);
	var byteout = [];
	var bytenew = 0;
	var bytepos = 7;
	
	var YDU = new Array(64);
	var UDU = new Array(64);
	var VDU = new Array(64);
	var clt = new Array(256);
	var RGB_YUV_TABLE = new Array(2048);
	var currentQuality;
	
	var ZigZag = [
			 0, 1, 5, 6,14,15,27,28,
			 2, 4, 7,13,16,26,29,42,
			 3, 8,12,17,25,30,41,43,
			 9,11,18,24,31,40,44,53,
			10,19,23,32,39,45,52,54,
			20,22,33,38,46,51,55,60,
			21,34,37,47,50,56,59,61,
			35,36,48,49,57,58,62,63
		];
	
	var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
	var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
	var std_ac_luminance_values = [
			0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
			0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
			0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
			0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
			0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
			0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
			0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
			0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
			0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
			0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
			0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
			0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
			0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
			0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
			0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
			0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
			0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
			0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
			0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
			0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
	var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
	var std_ac_chrominance_values = [
			0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
			0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
			0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
			0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
			0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
			0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
			0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
			0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
			0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
			0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
			0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
			0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
			0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
			0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
			0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
			0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
			0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
			0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
			0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
			0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	function initQuantTables(sf){
			var YQT = [
				16, 11, 10, 16, 24, 40, 51, 61,
				12, 12, 14, 19, 26, 58, 60, 55,
				14, 13, 16, 24, 40, 57, 69, 56,
				14, 17, 22, 29, 51, 87, 80, 62,
				18, 22, 37, 56, 68,109,103, 77,
				24, 35, 55, 64, 81,104,113, 92,
				49, 64, 78, 87,103,121,120,101,
				72, 92, 95, 98,112,100,103, 99
			];
			
			for (var i = 0; i < 64; i++) {
				var t = ffloor((YQT[i]*sf+50)/100);
				if (t < 1) {
					t = 1;
				} else if (t > 255) {
					t = 255;
				}
				YTable[ZigZag[i]] = t;
			}
			var UVQT = [
				17, 18, 24, 47, 99, 99, 99, 99,
				18, 21, 26, 66, 99, 99, 99, 99,
				24, 26, 56, 99, 99, 99, 99, 99,
				47, 66, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99
			];
			for (var j = 0; j < 64; j++) {
				var u = ffloor((UVQT[j]*sf+50)/100);
				if (u < 1) {
					u = 1;
				} else if (u > 255) {
					u = 255;
				}
				UVTable[ZigZag[j]] = u;
			}
			var aasf = [
				1.0, 1.387039845, 1.306562965, 1.175875602,
				1.0, 0.785694958, 0.541196100, 0.275899379
			];
			var k = 0;
			for (var row = 0; row < 8; row++)
			{
				for (var col = 0; col < 8; col++)
				{
					fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					k++;
				}
			}
		}
		
		function computeHuffmanTbl(nrcodes, std_table){
			var codevalue = 0;
			var pos_in_table = 0;
			var HT = new Array();
			for (var k = 1; k <= 16; k++) {
				for (var j = 1; j <= nrcodes[k]; j++) {
					HT[std_table[pos_in_table]] = [];
					HT[std_table[pos_in_table]][0] = codevalue;
					HT[std_table[pos_in_table]][1] = k;
					pos_in_table++;
					codevalue++;
				}
				codevalue*=2;
			}
			return HT;
		}
		
		function initHuffmanTbl()
		{
			YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
			UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
			YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
			UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
		}
	
		function initCategoryNumber()
		{
			var nrlower = 1;
			var nrupper = 2;
			for (var cat = 1; cat <= 15; cat++) {
				//Positive numbers
				for (var nr = nrlower; nr<nrupper; nr++) {
					category[32767+nr] = cat;
					bitcode[32767+nr] = [];
					bitcode[32767+nr][1] = cat;
					bitcode[32767+nr][0] = nr;
				}
				//Negative numbers
				for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
					category[32767+nrneg] = cat;
					bitcode[32767+nrneg] = [];
					bitcode[32767+nrneg][1] = cat;
					bitcode[32767+nrneg][0] = nrupper-1+nrneg;
				}
				nrlower <<= 1;
				nrupper <<= 1;
			}
		}
		
		function initRGBYUVTable() {
			for(var i = 0; i < 256;i++) {
				RGB_YUV_TABLE[i]      		=  19595 * i;
				RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
				RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
				RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
				RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
				RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
				RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
				RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
			}
		}
		
		// IO functions
		function writeBits(bs)
		{
			var value = bs[0];
			var posval = bs[1]-1;
			while ( posval >= 0 ) {
				if (value & (1 << posval) ) {
					bytenew |= (1 << bytepos);
				}
				posval--;
				bytepos--;
				if (bytepos < 0) {
					if (bytenew == 0xFF) {
						writeByte(0xFF);
						writeByte(0);
					}
					else {
						writeByte(bytenew);
					}
					bytepos=7;
					bytenew=0;
				}
			}
		}
	
		function writeByte(value)
		{
			//byteout.push(clt[value]); // write char directly instead of converting later
      byteout.push(value);
		}
	
		function writeWord(value)
		{
			writeByte((value>>8)&0xFF);
			writeByte((value   )&0xFF);
		}
		
		// DCT & quantization core
		function fDCTQuant(data, fdtbl)
		{
			var d0, d1, d2, d3, d4, d5, d6, d7;
			/* Pass 1: process rows. */
			var dataOff=0;
			var i;
			var I8 = 8;
			var I64 = 64;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff+1];
				d2 = data[dataOff+2];
				d3 = data[dataOff+3];
				d4 = data[dataOff+4];
				d5 = data[dataOff+5];
				d6 = data[dataOff+6];
				d7 = data[dataOff+7];
				
				var tmp0 = d0 + d7;
				var tmp7 = d0 - d7;
				var tmp1 = d1 + d6;
				var tmp6 = d1 - d6;
				var tmp2 = d2 + d5;
				var tmp5 = d2 - d5;
				var tmp3 = d3 + d4;
				var tmp4 = d3 - d4;
	
				/* Even part */
				var tmp10 = tmp0 + tmp3;	/* phase 2 */
				var tmp13 = tmp0 - tmp3;
				var tmp11 = tmp1 + tmp2;
				var tmp12 = tmp1 - tmp2;
	
				data[dataOff] = tmp10 + tmp11; /* phase 3 */
				data[dataOff+4] = tmp10 - tmp11;
	
				var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
				data[dataOff+2] = tmp13 + z1; /* phase 5 */
				data[dataOff+6] = tmp13 - z1;
	
				/* Odd part */
				tmp10 = tmp4 + tmp5; /* phase 2 */
				tmp11 = tmp5 + tmp6;
				tmp12 = tmp6 + tmp7;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
				var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
				var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
				var z3 = tmp11 * 0.707106781; /* c4 */
	
				var z11 = tmp7 + z3;	/* phase 5 */
				var z13 = tmp7 - z3;
	
				data[dataOff+5] = z13 + z2;	/* phase 6 */
				data[dataOff+3] = z13 - z2;
				data[dataOff+1] = z11 + z4;
				data[dataOff+7] = z11 - z4;
	
				dataOff += 8; /* advance pointer to next row */
			}
	
			/* Pass 2: process columns. */
			dataOff = 0;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff + 8];
				d2 = data[dataOff + 16];
				d3 = data[dataOff + 24];
				d4 = data[dataOff + 32];
				d5 = data[dataOff + 40];
				d6 = data[dataOff + 48];
				d7 = data[dataOff + 56];
				
				var tmp0p2 = d0 + d7;
				var tmp7p2 = d0 - d7;
				var tmp1p2 = d1 + d6;
				var tmp6p2 = d1 - d6;
				var tmp2p2 = d2 + d5;
				var tmp5p2 = d2 - d5;
				var tmp3p2 = d3 + d4;
				var tmp4p2 = d3 - d4;
	
				/* Even part */
				var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
				var tmp13p2 = tmp0p2 - tmp3p2;
				var tmp11p2 = tmp1p2 + tmp2p2;
				var tmp12p2 = tmp1p2 - tmp2p2;
	
				data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
				data[dataOff+32] = tmp10p2 - tmp11p2;
	
				var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
				data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
				data[dataOff+48] = tmp13p2 - z1p2;
	
				/* Odd part */
				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
				tmp11p2 = tmp5p2 + tmp6p2;
				tmp12p2 = tmp6p2 + tmp7p2;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
				var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
				var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
				var z3p2 = tmp11p2 * 0.707106781; /* c4 */
	
				var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
				var z13p2 = tmp7p2 - z3p2;
	
				data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
				data[dataOff+24] = z13p2 - z2p2;
				data[dataOff+ 8] = z11p2 + z4p2;
				data[dataOff+56] = z11p2 - z4p2;
	
				dataOff++; /* advance pointer to next column */
			}
	
			// Quantize/descale the coefficients
			var fDCTQuant;
			for (i=0; i<I64; ++i)
			{
				// Apply the quantization and scaling factor & Round to nearest integer
				fDCTQuant = data[i]*fdtbl[i];
				outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
				//outputfDCTQuant[i] = fround(fDCTQuant);

			}
			return outputfDCTQuant;
		}
		
		function writeAPP0()
		{
			writeWord(0xFFE0); // marker
			writeWord(16); // length
			writeByte(0x4A); // J
			writeByte(0x46); // F
			writeByte(0x49); // I
			writeByte(0x46); // F
			writeByte(0); // = "JFIF",'\0'
			writeByte(1); // versionhi
			writeByte(1); // versionlo
			writeByte(0); // xyunits
			writeWord(1); // xdensity
			writeWord(1); // ydensity
			writeByte(0); // thumbnwidth
			writeByte(0); // thumbnheight
		}

		function writeAPP1(exifBuffer) {
			if (!exifBuffer) return;

			writeWord(0xFFE1); // APP1 marker

			if (exifBuffer[0] === 0x45 &&
					exifBuffer[1] === 0x78 &&
					exifBuffer[2] === 0x69 &&
					exifBuffer[3] === 0x66) {
				// Buffer already starts with EXIF, just use it directly
				writeWord(exifBuffer.length + 2); // length is buffer + length itself!
			} else {
				// Buffer doesn't start with EXIF, write it for them
				writeWord(exifBuffer.length + 5 + 2); // length is buffer + EXIF\0 + length itself!
				writeByte(0x45); // E
				writeByte(0x78); // X
				writeByte(0x69); // I
				writeByte(0x66); // F
				writeByte(0); // = "EXIF",'\0'
			}

			for (var i = 0; i < exifBuffer.length; i++) {
				writeByte(exifBuffer[i]);
			}
		}

		function writeSOF0(width, height)
		{
			writeWord(0xFFC0); // marker
			writeWord(17);   // length, truecolor YUV JPG
			writeByte(8);    // precision
			writeWord(height);
			writeWord(width);
			writeByte(3);    // nrofcomponents
			writeByte(1);    // IdY
			writeByte(0x11); // HVY
			writeByte(0);    // QTY
			writeByte(2);    // IdU
			writeByte(0x11); // HVU
			writeByte(1);    // QTU
			writeByte(3);    // IdV
			writeByte(0x11); // HVV
			writeByte(1);    // QTV
		}
	
		function writeDQT()
		{
			writeWord(0xFFDB); // marker
			writeWord(132);	   // length
			writeByte(0);
			for (var i=0; i<64; i++) {
				writeByte(YTable[i]);
			}
			writeByte(1);
			for (var j=0; j<64; j++) {
				writeByte(UVTable[j]);
			}
		}
	
		function writeDHT()
		{
			writeWord(0xFFC4); // marker
			writeWord(0x01A2); // length
	
			writeByte(0); // HTYDCinfo
			for (var i=0; i<16; i++) {
				writeByte(std_dc_luminance_nrcodes[i+1]);
			}
			for (var j=0; j<=11; j++) {
				writeByte(std_dc_luminance_values[j]);
			}
	
			writeByte(0x10); // HTYACinfo
			for (var k=0; k<16; k++) {
				writeByte(std_ac_luminance_nrcodes[k+1]);
			}
			for (var l=0; l<=161; l++) {
				writeByte(std_ac_luminance_values[l]);
			}
	
			writeByte(1); // HTUDCinfo
			for (var m=0; m<16; m++) {
				writeByte(std_dc_chrominance_nrcodes[m+1]);
			}
			for (var n=0; n<=11; n++) {
				writeByte(std_dc_chrominance_values[n]);
			}
	
			writeByte(0x11); // HTUACinfo
			for (var o=0; o<16; o++) {
				writeByte(std_ac_chrominance_nrcodes[o+1]);
			}
			for (var p=0; p<=161; p++) {
				writeByte(std_ac_chrominance_values[p]);
			}
		}
	
		function writeSOS()
		{
			writeWord(0xFFDA); // marker
			writeWord(12); // length
			writeByte(3); // nrofcomponents
			writeByte(1); // IdY
			writeByte(0); // HTY
			writeByte(2); // IdU
			writeByte(0x11); // HTU
			writeByte(3); // IdV
			writeByte(0x11); // HTV
			writeByte(0); // Ss
			writeByte(0x3f); // Se
			writeByte(0); // Bf
		}
		
		function processDU(CDU, fdtbl, DC, HTDC, HTAC){
			var EOB = HTAC[0x00];
			var M16zeroes = HTAC[0xF0];
			var pos;
			var I16 = 16;
			var I63 = 63;
			var I64 = 64;
			var DU_DCT = fDCTQuant(CDU, fdtbl);
			//ZigZag reorder
			for (var j=0;j<I64;++j) {
				DU[ZigZag[j]]=DU_DCT[j];
			}
			var Diff = DU[0] - DC; DC = DU[0];
			//Encode DC
			if (Diff==0) {
				writeBits(HTDC[0]); // Diff might be 0
			} else {
				pos = 32767+Diff;
				writeBits(HTDC[category[pos]]);
				writeBits(bitcode[pos]);
			}
			//Encode ACs
			var end0pos = 63; // was const... which is crazy
			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};
			//end0pos = first element in reverse order !=0
			if ( end0pos == 0) {
				writeBits(EOB);
				return DC;
			}
			var i = 1;
			var lng;
			while ( i <= end0pos ) {
				var startpos = i;
				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
				var nrzeroes = i-startpos;
				if ( nrzeroes >= I16 ) {
					lng = nrzeroes>>4;
					for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
						writeBits(M16zeroes);
					nrzeroes = nrzeroes&0xF;
				}
				pos = 32767+DU[i];
				writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
				writeBits(bitcode[pos]);
				i++;
			}
			if ( end0pos != I63 ) {
				writeBits(EOB);
			}
			return DC;
		}

		function initCharLookupTable(){
			var sfcc = String.fromCharCode;
			for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
				clt[i] = sfcc(i);
			}
		}
		
		this.encode = function(image,quality) // image data object
		{
			var time_start = new Date().getTime();
			
			if(quality) setQuality(quality);
			
			// Initialize bit writer
			byteout = new Array();
			bytenew=0;
			bytepos=7;
	
			// Add JPEG headers
			writeWord(0xFFD8); // SOI
			writeAPP0();
			writeAPP1(image.exifBuffer);
			writeDQT();
			writeSOF0(image.width,image.height);
			writeDHT();
			writeSOS();

	
			// Encode 8x8 macroblocks
			var DCY=0;
			var DCU=0;
			var DCV=0;
			
			bytenew=0;
			bytepos=7;
			
			
			this.encode.displayName = "_encode_";

			var imageData = image.data;
			var width = image.width;
			var height = image.height;

			var quadWidth = width*4;
			var tripleWidth = width*3;
			
			var x, y = 0;
			var r, g, b;
			var start,p, col,row,pos;
			while(y < height){
				x = 0;
				while(x < quadWidth){
				start = quadWidth * y + x;
				p = start;
				col = -1;
				row = 0;
				
				for(pos=0; pos < 64; pos++){
					row = pos >> 3;// /8
					col = ( pos & 7 ) * 4; // %8
					p = start + ( row * quadWidth ) + col;		
					
					if(y+row >= height){ // padding bottom
						p-= (quadWidth*(y+1+row-height));
					}

					if(x+col >= quadWidth){ // padding right	
						p-= ((x+col) - quadWidth +4)
					}
					
					r = imageData[ p++ ];
					g = imageData[ p++ ];
					b = imageData[ p++ ];
					
					
					/* // calculate YUV values dynamically
					YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
					UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
					VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
					*/
					
					// use lookup table (slightly faster)
					YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
					UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
					VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

				}
				
				DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
				DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
				DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
				x+=32;
				}
				y+=8;
			}
			
			
			////////////////////////////////////////////////////////////////
	
			// Do the bit alignment of the EOI marker
			if ( bytepos >= 0 ) {
				var fillbits = [];
				fillbits[1] = bytepos+1;
				fillbits[0] = (1<<(bytepos+1))-1;
				writeBits(fillbits);
			}
	
			writeWord(0xFFD9); //EOI

			if (false) {}
      return Buffer.from(byteout);

			var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));
			
			byteout = [];
			
			// benchmarking
			var duration = new Date().getTime() - time_start;
    		//console.log('Encoding time: '+ duration + 'ms');
    		//
			
			return jpegDataUri			
	}
	
	function setQuality(quality){
		if (quality <= 0) {
			quality = 1;
		}
		if (quality > 100) {
			quality = 100;
		}
		
		if(currentQuality == quality) return // don't recalc if unchanged
		
		var sf = 0;
		if (quality < 50) {
			sf = Math.floor(5000 / quality);
		} else {
			sf = Math.floor(200 - quality*2);
		}
		
		initQuantTables(sf);
		currentQuality = quality;
		//console.log('Quality set to: '+quality +'%');
	}
	
	function init(){
		var time_start = new Date().getTime();
		if(!quality) quality = 50;
		// Create tables
		initCharLookupTable()
		initHuffmanTbl();
		initCategoryNumber();
		initRGBYUVTable();
		
		setQuality(quality);
		var duration = new Date().getTime() - time_start;
    	//console.log('Initialization '+ duration + 'ms');
	}
	
	init();
	
};

if (true) {
	module.exports = encode;
} else {}

function encode(imgData, qu) {
  if (typeof qu === 'undefined') qu = 50;
  var encoder = new JPEGEncoder(qu);
	var data = encoder.encode(imgData, qu);
  return {
    data: data,
    width: imgData.width,
    height: imgData.height
  };
}

// helper function to get the imageData of an existing image on the current page.
function getImageDataFromImage(idOrElement){
	var theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;
	var cvs = document.createElement('canvas');
	cvs.width = theImg.width;
	cvs.height = theImg.height;
	var ctx = cvs.getContext("2d");
	ctx.drawImage(theImg,0,0);
	
	return (ctx.getImageData(0, 0, cvs.width, cvs.height));
}


/***/ }),

/***/ 7468:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const path = __nccwpck_require__(5622);
const fs = __nccwpck_require__(5747);
const {promisify} = __nccwpck_require__(1669);
const pLocate = __nccwpck_require__(2197);

const fsStat = promisify(fs.stat);
const fsLStat = promisify(fs.lstat);

const typeMappings = {
	directory: 'isDirectory',
	file: 'isFile'
};

function checkType({type}) {
	if (type in typeMappings) {
		return;
	}

	throw new Error(`Invalid type specified: ${type}`);
}

const matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();

module.exports = async (paths, options) => {
	options = {
		cwd: process.cwd(),
		type: 'file',
		allowSymlinks: true,
		...options
	};
	checkType(options);
	const statFn = options.allowSymlinks ? fsStat : fsLStat;

	return pLocate(paths, async path_ => {
		try {
			const stat = await statFn(path.resolve(options.cwd, path_));
			return matchType(options.type, stat);
		} catch (_) {
			return false;
		}
	}, options);
};

module.exports.sync = (paths, options) => {
	options = {
		cwd: process.cwd(),
		allowSymlinks: true,
		type: 'file',
		...options
	};
	checkType(options);
	const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;

	for (const path_ of paths) {
		try {
			const stat = statFn(path.resolve(options.cwd, path_));

			if (matchType(options.type, stat)) {
				return path_;
			}
		} catch (_) {
		}
	}
};


/***/ }),

/***/ 5532:
/***/ ((module) => {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ }),

/***/ 8640:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Mime = __nccwpck_require__(5532);
module.exports = new Mime(__nccwpck_require__(9438), __nccwpck_require__(635));


/***/ }),

/***/ 635:
/***/ ((module) => {

module.exports = {"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};

/***/ }),

/***/ 9438:
/***/ ((module) => {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/mrb-consumer+xml":["*xdf"],"application/mrb-publish+xml":["*xdf"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["*xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-error+xml":["xer"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ }),

/***/ 2948:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __nccwpck_require__(5622)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(391)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 9573:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var path = __nccwpck_require__(5622);
var fs = __nccwpck_require__(5747);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ 5717:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 9030:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(__nccwpck_require__(2413));
var http = _interopDefault(__nccwpck_require__(8605));
var Url = _interopDefault(__nccwpck_require__(8835));
var https = _interopDefault(__nccwpck_require__(7211));
var zlib = _interopDefault(__nccwpck_require__(8761));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = __nccwpck_require__(3632).convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;
const resolve_url = Url.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https : http).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

module.exports = exports = fetch;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.default = exports;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.FetchError = FetchError;


/***/ }),

/***/ 328:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(7320)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 4756:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const pTry = __nccwpck_require__(234);

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	const run = (fn, resolve, ...args) => {
		activeCount++;

		const result = pTry(fn, ...args);

		resolve(result);

		result.then(next, next);
	};

	const enqueue = (fn, resolve, ...args) => {
		if (activeCount < concurrency) {
			run(fn, resolve, ...args);
		} else {
			queue.push(run.bind(null, fn, resolve, ...args));
		}
	};

	const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.length
		},
		clearQueue: {
			value: () => {
				queue.length = 0;
			}
		}
	});

	return generator;
};

module.exports = pLimit;
module.exports.default = pLimit;


/***/ }),

/***/ 2197:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const pLimit = __nccwpck_require__(4756);

class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// The input can also be a promise, so we await it
const testElement = async (element, tester) => tester(await element);

// The input can also be a promise, so we `Promise.all()` them both
const finder = async element => {
	const values = await Promise.all(element);
	if (values[1] === true) {
		throw new EndError(values[0]);
	}

	return false;
};

const pLocate = async (iterable, tester, options) => {
	options = {
		concurrency: Infinity,
		preserveOrder: true,
		...options
	};

	const limit = pLimit(options.concurrency);

	// Start all the promises concurrently with optional limit
	const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

	// Check the promises either serially or concurrently
	const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);

	try {
		await Promise.all(items.map(element => checkLimit(finder, element)));
	} catch (error) {
		if (error instanceof EndError) {
			return error.value;
		}

		throw error;
	}
};

module.exports = pLocate;
// TODO: Remove this for the next major release
module.exports.default = pLocate;


/***/ }),

/***/ 234:
/***/ ((module) => {

"use strict";


const pTry = (fn, ...arguments_) => new Promise(resolve => {
	resolve(fn(...arguments_));
});

module.exports = pTry;
// TODO: remove this in the next major version
module.exports.default = pTry;


/***/ }),

/***/ 1507:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const fs = __nccwpck_require__(5747);
const {promisify} = __nccwpck_require__(1669);

const pAccess = promisify(fs.access);

module.exports = async path => {
	try {
		await pAccess(path);
		return true;
	} catch (_) {
		return false;
	}
};

module.exports.sync = path => {
	try {
		fs.accessSync(path);
		return true;
	} catch (_) {
		return false;
	}
};


/***/ }),

/***/ 1768:
/***/ ((module) => {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ 4330:
/***/ ((module) => {

module.exports = Pend;

function Pend() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend.prototype.hold = function() {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}


/***/ }),

/***/ 6832:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const path = __nccwpck_require__(5622);
const findUp = __nccwpck_require__(6303);

const pkgDir = async cwd => {
	const filePath = await findUp('package.json', {cwd});
	return filePath && path.dirname(filePath);
};

module.exports = pkgDir;
// TODO: Remove this for the next major release
module.exports.default = pkgDir;

module.exports.sync = cwd => {
	const filePath = findUp.sync('package.json', {cwd});
	return filePath && path.dirname(filePath);
};


/***/ }),

/***/ 2243:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = __nccwpck_require__(8842);


/***/ }),

/***/ 3483:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserServerLauncherImpl = void 0;
const browser_1 = __nccwpck_require__(6169);
const ws_1 = __nccwpck_require__(7550);
const dispatcher_1 = __nccwpck_require__(5031);
const browserContextDispatcher_1 = __nccwpck_require__(8312);
const clientHelper_1 = __nccwpck_require__(9556);
const utils_1 = __nccwpck_require__(6416);
const selectorsDispatcher_1 = __nccwpck_require__(7503);
const selectors_1 = __nccwpck_require__(5615);
const instrumentation_1 = __nccwpck_require__(7490);
const playwright_1 = __nccwpck_require__(8508);
const playwrightDispatcher_1 = __nccwpck_require__(930);
const playwrightServer_1 = __nccwpck_require__(4960);
const browserContext_1 = __nccwpck_require__(7533);
const cdpSessionDispatcher_1 = __nccwpck_require__(6632);
class BrowserServerLauncherImpl {
    constructor(browserName) {
        this._browserName = browserName;
    }
    async launchServer(options = {}) {
        const playwright = playwright_1.createPlaywright();
        if (options._acceptForwardedPorts)
            await playwright._enablePortForwarding();
        // 1. Pre-launch the browser
        const browser = await playwright[this._browserName].launch(instrumentation_1.internalCallMetadata(), {
            ...options,
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? clientHelper_1.envObjectToArray(options.env) : undefined,
        }, toProtocolLogger(options.logger));
        // 2. Start the server
        const delegate = {
            path: '/' + utils_1.createGuid(),
            allowMultipleClients: options._acceptForwardedPorts ? false : true,
            onClose: () => {
                playwright._disablePortForwarding();
            },
            onConnect: this._onConnect.bind(this, playwright, browser),
        };
        const server = new playwrightServer_1.PlaywrightServer(delegate);
        const wsEndpoint = await server.listen(options.port);
        // 3. Return the BrowserServer interface
        const browserServer = new ws_1.EventEmitter();
        browserServer.process = () => browser.options.browserProcess.process;
        browserServer.wsEndpoint = () => wsEndpoint;
        browserServer.close = () => browser.options.browserProcess.close();
        browserServer.kill = () => browser.options.browserProcess.kill();
        browserServer._disconnectForTest = () => server.close();
        browser.options.browserProcess.onclose = async (exitCode, signal) => {
            server.close();
            browserServer.emit('close', exitCode, signal);
        };
        return browserServer;
    }
    async _onConnect(playwright, browser, scope, forceDisconnect) {
        const selectors = new selectors_1.Selectors();
        const selectorsDispatcher = new selectorsDispatcher_1.SelectorsDispatcher(scope, selectors);
        const browserDispatcher = new ConnectedBrowserDispatcher(scope, browser, selectors);
        browser.on(browser_1.Browser.Events.Disconnected, () => {
            // Underlying browser did close for some reason - force disconnect the client.
            forceDisconnect();
        });
        new playwrightDispatcher_1.PlaywrightDispatcher(scope, playwright, selectorsDispatcher, browserDispatcher);
        return () => {
            // Cleanup contexts upon disconnect.
            browserDispatcher.cleanupContexts().catch(e => { });
        };
    }
}
exports.BrowserServerLauncherImpl = BrowserServerLauncherImpl;
// This class implements multiplexing browser dispatchers over a single Browser instance.
class ConnectedBrowserDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, browser, selectors) {
        super(scope, browser, 'Browser', { version: browser.version(), name: browser.options.name }, true);
        this._contexts = new Set();
        this._selectors = selectors;
    }
    async newContext(params, metadata) {
        if (params.recordVideo)
            params.recordVideo.dir = this._object.options.artifactsDir;
        const context = await this._object.newContext(params);
        this._contexts.add(context);
        context._setSelectors(this._selectors);
        context.on(browserContext_1.BrowserContext.Events.Close, () => this._contexts.delete(context));
        if (params.storageState)
            await context.setStorageState(metadata, params.storageState);
        return { context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, context) };
    }
    async close() {
        // Client should not send us Browser.close.
    }
    async killForTests() {
        // Client should not send us Browser.killForTests.
    }
    async newBrowserCDPSession() {
        if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
        const crBrowser = this._object;
        return { session: new cdpSessionDispatcher_1.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession()) };
    }
    async startTracing(params) {
        if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        await crBrowser.startTracing(params.page ? params.page._object : undefined, params);
    }
    async stopTracing() {
        if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        const buffer = await crBrowser.stopTracing();
        return { binary: buffer.toString('base64') };
    }
    async cleanupContexts() {
        await Promise.all(Array.from(this._contexts).map(context => context.close(instrumentation_1.internalCallMetadata())));
    }
}
function toProtocolLogger(logger) {
    return logger ? (direction, message) => {
        if (logger.isEnabled('protocol', 'verbose'))
            logger.log('protocol', 'verbose', (direction === 'send' ? 'SEND ► ' : '◀ RECV ') + JSON.stringify(message), [], {});
    } : undefined;
}
//# sourceMappingURL=browserServerImpl.js.map

/***/ }),

/***/ 8820:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Accessibility = void 0;
function axNodeFromProtocol(axNode) {
    const result = {
        ...axNode,
        value: axNode.valueNumber !== undefined ? axNode.valueNumber : axNode.valueString,
        checked: axNode.checked === 'checked' ? true : axNode.checked === 'unchecked' ? false : axNode.checked,
        pressed: axNode.pressed === 'pressed' ? true : axNode.pressed === 'released' ? false : axNode.pressed,
        children: axNode.children ? axNode.children.map(axNodeFromProtocol) : undefined,
    };
    delete result.valueNumber;
    delete result.valueString;
    return result;
}
class Accessibility {
    constructor(channel) {
        this._channel = channel;
    }
    async snapshot(options = {}) {
        const root = options.root ? options.root._elementChannel : undefined;
        const result = await this._channel.accessibilitySnapshot({ interestingOnly: options.interestingOnly, root });
        return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
    }
}
exports.Accessibility = Accessibility;
//# sourceMappingURL=accessibility.js.map

/***/ }),

/***/ 9779:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AndroidWebView = exports.AndroidInput = exports.AndroidSocket = exports.AndroidDevice = exports.Android = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const utils_1 = __nccwpck_require__(6416);
const events_1 = __nccwpck_require__(2387);
const browserContext_1 = __nccwpck_require__(3752);
const channelOwner_1 = __nccwpck_require__(772);
const timeoutSettings_1 = __nccwpck_require__(9255);
const waiter_1 = __nccwpck_require__(5338);
const events_2 = __nccwpck_require__(8614);
class Android extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
    }
    static from(android) {
        return android._object;
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({ timeout });
    }
    async devices() {
        return this._wrapApiCall('android.devices', async (channel) => {
            const { devices } = await channel.devices();
            return devices.map(d => AndroidDevice.from(d));
        });
    }
}
exports.Android = Android;
class AndroidDevice extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._webViews = new Map();
        this.input = new AndroidInput(this);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(parent._timeoutSettings);
        this._channel.on('webViewAdded', ({ webView }) => this._onWebViewAdded(webView));
        this._channel.on('webViewRemoved', ({ pid }) => this._onWebViewRemoved(pid));
    }
    static from(androidDevice) {
        return androidDevice._object;
    }
    _onWebViewAdded(webView) {
        const view = new AndroidWebView(this, webView);
        this._webViews.set(webView.pid, view);
        this.emit(events_1.Events.AndroidDevice.WebView, view);
    }
    _onWebViewRemoved(pid) {
        const view = this._webViews.get(pid);
        this._webViews.delete(pid);
        if (view)
            view.emit(events_1.Events.AndroidWebView.Close);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({ timeout });
    }
    serial() {
        return this._initializer.serial;
    }
    model() {
        return this._initializer.model;
    }
    webViews() {
        return [...this._webViews.values()];
    }
    async webView(selector, options) {
        const webView = [...this._webViews.values()].find(v => v.pkg() === selector.pkg);
        if (webView)
            return webView;
        return this.waitForEvent('webview', {
            ...options,
            predicate: (view) => view.pkg() === selector.pkg
        });
    }
    async wait(selector, options) {
        await this._wrapApiCall('androidDevice.wait', async (channel) => {
            await channel.wait({ selector: toSelectorChannel(selector), ...options });
        });
    }
    async fill(selector, text, options) {
        await this._wrapApiCall('androidDevice.fill', async (channel) => {
            await channel.fill({ selector: toSelectorChannel(selector), text, ...options });
        });
    }
    async press(selector, key, options) {
        await this.tap(selector, options);
        await this.input.press(key);
    }
    async tap(selector, options) {
        await this._wrapApiCall('androidDevice.tap', async (channel) => {
            await channel.tap({ selector: toSelectorChannel(selector), ...options });
        });
    }
    async drag(selector, dest, options) {
        await this._wrapApiCall('androidDevice.drag', async (channel) => {
            await channel.drag({ selector: toSelectorChannel(selector), dest, ...options });
        });
    }
    async fling(selector, direction, options) {
        await this._wrapApiCall('androidDevice.fling', async (channel) => {
            await channel.fling({ selector: toSelectorChannel(selector), direction, ...options });
        });
    }
    async longTap(selector, options) {
        await this._wrapApiCall('androidDevice.longTap', async (channel) => {
            await channel.longTap({ selector: toSelectorChannel(selector), ...options });
        });
    }
    async pinchClose(selector, percent, options) {
        await this._wrapApiCall('androidDevice.pinchClose', async (channel) => {
            await channel.pinchClose({ selector: toSelectorChannel(selector), percent, ...options });
        });
    }
    async pinchOpen(selector, percent, options) {
        await this._wrapApiCall('androidDevice.pinchOpen', async (channel) => {
            await channel.pinchOpen({ selector: toSelectorChannel(selector), percent, ...options });
        });
    }
    async scroll(selector, direction, percent, options) {
        await this._wrapApiCall('androidDevice.scroll', async (channel) => {
            await channel.scroll({ selector: toSelectorChannel(selector), direction, percent, ...options });
        });
    }
    async swipe(selector, direction, percent, options) {
        await this._wrapApiCall('androidDevice.swipe', async (channel) => {
            await channel.swipe({ selector: toSelectorChannel(selector), direction, percent, ...options });
        });
    }
    async info(selector) {
        return await this._wrapApiCall('androidDevice.info', async (channel) => {
            return (await channel.info({ selector: toSelectorChannel(selector) })).info;
        });
    }
    async screenshot(options = {}) {
        return await this._wrapApiCall('androidDevice.screenshot', async (channel) => {
            const { binary } = await channel.screenshot();
            const buffer = Buffer.from(binary, 'base64');
            if (options.path)
                await fs_1.default.promises.writeFile(options.path, buffer);
            return buffer;
        });
    }
    async close() {
        return this._wrapApiCall('androidDevice.close', async (channel) => {
            await channel.close();
            this.emit(events_1.Events.AndroidDevice.Close);
        });
    }
    async shell(command) {
        return this._wrapApiCall('androidDevice.shell', async (channel) => {
            const { result } = await channel.shell({ command });
            return Buffer.from(result, 'base64');
        });
    }
    async open(command) {
        return this._wrapApiCall('androidDevice.open', async (channel) => {
            return AndroidSocket.from((await channel.open({ command })).socket);
        });
    }
    async installApk(file, options) {
        return this._wrapApiCall('androidDevice.installApk', async (channel) => {
            await channel.installApk({ file: await loadFile(file), args: options && options.args });
        });
    }
    async push(file, path, options) {
        return this._wrapApiCall('androidDevice.push', async (channel) => {
            await channel.push({ file: await loadFile(file), path, mode: options ? options.mode : undefined });
        });
    }
    async launchBrowser(options = {}) {
        return this._wrapApiCall('androidDevice.launchBrowser', async (channel) => {
            const contextOptions = await browserContext_1.prepareBrowserContextParams(options);
            const { context } = await channel.launchBrowser(contextOptions);
            return browserContext_1.BrowserContext.from(context);
        });
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, 'androidDevice', event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.AndroidDevice.Close)
            waiter.rejectOnEvent(this, events_1.Events.AndroidDevice.Close, new Error('Device closed'));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
    }
}
exports.AndroidDevice = AndroidDevice;
class AndroidSocket extends channelOwner_1.ChannelOwner {
    static from(androidDevice) {
        return androidDevice._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on('data', ({ data }) => this.emit(events_1.Events.AndroidSocket.Data, Buffer.from(data, 'base64')));
        this._channel.on('close', () => this.emit(events_1.Events.AndroidSocket.Close));
    }
    async write(data) {
        return this._wrapApiCall('androidDevice.write', async (channel) => {
            await channel.write({ data: data.toString('base64') });
        });
    }
    async close() {
        return this._wrapApiCall('androidDevice.close', async (channel) => {
            await channel.close();
        });
    }
}
exports.AndroidSocket = AndroidSocket;
async function loadFile(file) {
    if (utils_1.isString(file))
        return fs_1.default.promises.readFile(file, { encoding: 'base64' }).toString();
    return file.toString('base64');
}
class AndroidInput {
    constructor(device) {
        this._device = device;
    }
    async type(text) {
        return this._device._wrapApiCall('androidDevice.inputType', async (channel) => {
            await channel.inputType({ text });
        });
    }
    async press(key) {
        return this._device._wrapApiCall('androidDevice.inputPress', async (channel) => {
            await channel.inputPress({ key });
        });
    }
    async tap(point) {
        return this._device._wrapApiCall('androidDevice.inputTap', async (channel) => {
            await channel.inputTap({ point });
        });
    }
    async swipe(from, segments, steps) {
        return this._device._wrapApiCall('androidDevice.inputSwipe', async (channel) => {
            await channel.inputSwipe({ segments, steps });
        });
    }
    async drag(from, to, steps) {
        return this._device._wrapApiCall('androidDevice.inputDragAndDrop', async (channel) => {
            await channel.inputDrag({ from, to, steps });
        });
    }
}
exports.AndroidInput = AndroidInput;
function toSelectorChannel(selector) {
    const { checkable, checked, clazz, clickable, depth, desc, enabled, focusable, focused, hasChild, hasDescendant, longClickable, pkg, res, scrollable, selected, text, } = selector;
    const toRegex = (value) => {
        if (value === undefined)
            return undefined;
        if (value instanceof RegExp)
            return value.source;
        return '^' + value.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d') + '$';
    };
    return {
        checkable,
        checked,
        clazz: toRegex(clazz),
        pkg: toRegex(pkg),
        desc: toRegex(desc),
        res: toRegex(res),
        text: toRegex(text),
        clickable,
        depth,
        enabled,
        focusable,
        focused,
        hasChild: hasChild ? { selector: toSelectorChannel(hasChild.selector) } : undefined,
        hasDescendant: hasDescendant ? { selector: toSelectorChannel(hasDescendant.selector), maxDepth: hasDescendant.maxDepth } : undefined,
        longClickable,
        scrollable,
        selected,
    };
}
class AndroidWebView extends events_2.EventEmitter {
    constructor(device, data) {
        super();
        this._device = device;
        this._data = data;
    }
    pid() {
        return this._data.pid;
    }
    pkg() {
        return this._data.pkg;
    }
    async page() {
        if (!this._pagePromise)
            this._pagePromise = this._fetchPage();
        return this._pagePromise;
    }
    async _fetchPage() {
        return this._device._wrapApiCall('androidWebView.page', async (channel) => {
            const { context } = await channel.connectToWebView({ pid: this._data.pid, sdkLanguage: 'javascript' });
            return browserContext_1.BrowserContext.from(context).pages()[0];
        });
    }
}
exports.AndroidWebView = AndroidWebView;
//# sourceMappingURL=android.js.map

/***/ }),

/***/ 9214:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Artifact = void 0;
const fs = __importStar(__nccwpck_require__(5747));
const stream_1 = __nccwpck_require__(5377);
const utils_1 = __nccwpck_require__(6416);
const channelOwner_1 = __nccwpck_require__(772);
class Artifact extends channelOwner_1.ChannelOwner {
    constructor() {
        super(...arguments);
        this._isRemote = false;
        this._apiName = '';
    }
    static from(channel) {
        return channel._object;
    }
    async pathAfterFinished() {
        if (this._isRemote)
            throw new Error(`Path is not available when using browserType.connect(). Use saveAs() to save a local copy.`);
        return this._wrapApiCall(`${this._apiName}.path`, async (channel) => {
            return (await channel.pathAfterFinished()).value || null;
        });
    }
    async saveAs(path) {
        return this._wrapApiCall(`${this._apiName}.saveAs`, async (channel) => {
            if (!this._isRemote) {
                await channel.saveAs({ path });
                return;
            }
            const result = await channel.saveAsStream();
            const stream = stream_1.Stream.from(result.stream);
            await utils_1.mkdirIfNeeded(path);
            await new Promise((resolve, reject) => {
                stream.stream().pipe(fs.createWriteStream(path))
                    .on('finish', resolve)
                    .on('error', reject);
            });
        });
    }
    async failure() {
        return this._wrapApiCall(`${this._apiName}.failure`, async (channel) => {
            return (await channel.failure()).error || null;
        });
    }
    async createReadStream() {
        return this._wrapApiCall(`${this._apiName}.createReadStream`, async (channel) => {
            const result = await channel.stream();
            if (!result.stream)
                return null;
            const stream = stream_1.Stream.from(result.stream);
            return stream.stream();
        });
    }
    async delete() {
        return this._wrapApiCall(`${this._apiName}.delete`, async (channel) => {
            return channel.delete();
        });
    }
}
exports.Artifact = Artifact;
//# sourceMappingURL=artifact.js.map

/***/ }),

/***/ 6722:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Browser = void 0;
const browserContext_1 = __nccwpck_require__(3752);
const channelOwner_1 = __nccwpck_require__(772);
const events_1 = __nccwpck_require__(2387);
const errors_1 = __nccwpck_require__(4949);
const cdpSession_1 = __nccwpck_require__(703);
class Browser extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._contexts = new Set();
        this._isConnected = true;
        this._remoteType = null;
        this._name = initializer.name;
        this._channel.on('close', () => this._didClose());
        this._closedPromise = new Promise(f => this.once(events_1.Events.Browser.Disconnected, f));
    }
    static from(browser) {
        return browser._object;
    }
    static fromNullable(browser) {
        return browser ? Browser.from(browser) : null;
    }
    async newContext(options = {}) {
        return this._wrapApiCall('browser.newContext', async (channel) => {
            const contextOptions = await browserContext_1.prepareBrowserContextParams(options);
            const context = browserContext_1.BrowserContext.from((await channel.newContext(contextOptions)).context);
            context._options = contextOptions;
            this._contexts.add(context);
            context._logger = options.logger || this._logger;
            return context;
        });
    }
    contexts() {
        return [...this._contexts];
    }
    version() {
        return this._initializer.version;
    }
    async newPage(options = {}) {
        const context = await this.newContext(options);
        const page = await context.newPage();
        page._ownedContext = context;
        context._ownerPage = page;
        return page;
    }
    isConnected() {
        return this._isConnected;
    }
    async newBrowserCDPSession() {
        return this._wrapApiCall('browser.newBrowserCDPSession', async (channel) => {
            return cdpSession_1.CDPSession.from((await channel.newBrowserCDPSession()).session);
        });
    }
    async startTracing(page, options = {}) {
        return this._wrapApiCall('browser.startTracing', async (channel) => {
            await channel.startTracing({ ...options, page: page ? page._channel : undefined });
        });
    }
    async stopTracing() {
        return this._wrapApiCall('browser.stopTracing', async (channel) => {
            return Buffer.from((await channel.stopTracing()).binary, 'base64');
        });
    }
    async close() {
        try {
            await this._wrapApiCall('browser.close', async (channel) => {
                if (this._remoteType === 'owns-connection')
                    this._connection.close();
                else
                    await channel.close();
                await this._closedPromise;
            });
        }
        catch (e) {
            if (errors_1.isSafeCloseError(e))
                return;
            throw e;
        }
    }
    _didClose() {
        this._isConnected = false;
        this.emit(events_1.Events.Browser.Disconnected, this);
    }
}
exports.Browser = Browser;
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 3752:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareBrowserContextParams = exports.BrowserContext = void 0;
const page_1 = __nccwpck_require__(4713);
const network = __importStar(__nccwpck_require__(3510));
const fs_1 = __importDefault(__nccwpck_require__(5747));
const channelOwner_1 = __nccwpck_require__(772);
const clientHelper_1 = __nccwpck_require__(9556);
const browser_1 = __nccwpck_require__(6722);
const worker_1 = __nccwpck_require__(5321);
const events_1 = __nccwpck_require__(2387);
const timeoutSettings_1 = __nccwpck_require__(9255);
const waiter_1 = __nccwpck_require__(5338);
const utils_1 = __nccwpck_require__(6416);
const errors_1 = __nccwpck_require__(4949);
const cdpSession_1 = __nccwpck_require__(703);
const tracing_1 = __nccwpck_require__(9464);
class BrowserContext extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        var _a;
        super(parent, type, guid, initializer);
        this._pages = new Set();
        this._routes = [];
        this._browser = null;
        this._bindings = new Map();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._options = {
            sdkLanguage: 'javascript'
        };
        this._backgroundPages = new Set();
        this._serviceWorkers = new Set();
        if (parent instanceof browser_1.Browser)
            this._browser = parent;
        this._isChromium = ((_a = this._browser) === null || _a === void 0 ? void 0 : _a._name) === 'chromium';
        this.tracing = new tracing_1.Tracing(this);
        this._channel.on('bindingCall', ({ binding }) => this._onBinding(page_1.BindingCall.from(binding)));
        this._channel.on('close', () => this._onClose());
        this._channel.on('page', ({ page }) => this._onPage(page_1.Page.from(page)));
        this._channel.on('route', ({ route, request }) => this._onRoute(network.Route.from(route), network.Request.from(request)));
        this._channel.on('backgroundPage', ({ page }) => {
            const backgroundPage = page_1.Page.from(page);
            this._backgroundPages.add(backgroundPage);
            this.emit(events_1.Events.BrowserContext.BackgroundPage, backgroundPage);
        });
        this._channel.on('serviceWorker', ({ worker }) => {
            const serviceWorker = worker_1.Worker.from(worker);
            serviceWorker._context = this;
            this._serviceWorkers.add(serviceWorker);
            this.emit(events_1.Events.BrowserContext.ServiceWorker, serviceWorker);
        });
        this._channel.on('request', ({ request, page }) => this._onRequest(network.Request.from(request), page_1.Page.fromNullable(page)));
        this._channel.on('requestFailed', ({ request, failureText, responseEndTiming, page }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, page_1.Page.fromNullable(page)));
        this._channel.on('requestFinished', ({ request, responseEndTiming, page }) => this._onRequestFinished(network.Request.from(request), responseEndTiming, page_1.Page.fromNullable(page)));
        this._channel.on('response', ({ response, page }) => this._onResponse(network.Response.from(response), page_1.Page.fromNullable(page)));
        this._closedPromise = new Promise(f => this.once(events_1.Events.BrowserContext.Close, f));
    }
    static from(context) {
        return context._object;
    }
    static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
    }
    _onPage(page) {
        this._pages.add(page);
        this.emit(events_1.Events.BrowserContext.Page, page);
        if (page._opener && !page._opener.isClosed())
            page._opener.emit(events_1.Events.Page.Popup, page);
    }
    _onRequest(request, page) {
        this.emit(events_1.Events.BrowserContext.Request, request);
        if (page)
            page.emit(events_1.Events.Page.Request, request);
    }
    _onResponse(response, page) {
        this.emit(events_1.Events.BrowserContext.Response, response);
        if (page)
            page.emit(events_1.Events.Page.Response, response);
    }
    _onRequestFailed(request, responseEndTiming, failureText, page) {
        request._failureText = failureText || null;
        if (request._timing)
            request._timing.responseEnd = responseEndTiming;
        this.emit(events_1.Events.BrowserContext.RequestFailed, request);
        if (page)
            page.emit(events_1.Events.Page.RequestFailed, request);
    }
    _onRequestFinished(request, responseEndTiming, page) {
        if (request._timing)
            request._timing.responseEnd = responseEndTiming;
        this.emit(events_1.Events.BrowserContext.RequestFinished, request);
        if (page)
            page.emit(events_1.Events.Page.RequestFinished, request);
    }
    _onRoute(route, request) {
        for (const { url, handler } of this._routes) {
            if (clientHelper_1.urlMatches(request.url(), url)) {
                handler(route, request);
                return;
            }
        }
        // it can race with BrowserContext.close() which then throws since its closed
        route.continue().catch(() => { });
    }
    async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (!func)
            return;
        await bindingCall.call(func);
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._channel.setDefaultNavigationTimeoutNoReply({ timeout });
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({ timeout });
    }
    browser() {
        return this._browser;
    }
    pages() {
        return [...this._pages];
    }
    async newPage() {
        return this._wrapApiCall('browserContext.newPage', async (channel) => {
            if (this._ownerPage)
                throw new Error('Please use browser.newContext()');
            return page_1.Page.from((await channel.newPage()).page);
        });
    }
    async cookies(urls) {
        if (!urls)
            urls = [];
        if (urls && typeof urls === 'string')
            urls = [urls];
        return this._wrapApiCall('browserContext.cookies', async (channel) => {
            return (await channel.cookies({ urls: urls })).cookies;
        });
    }
    async addCookies(cookies) {
        return this._wrapApiCall('browserContext.addCookies', async (channel) => {
            await channel.addCookies({ cookies });
        });
    }
    async clearCookies() {
        return this._wrapApiCall('browserContext.clearCookies', async (channel) => {
            await channel.clearCookies();
        });
    }
    async grantPermissions(permissions, options) {
        return this._wrapApiCall('browserContext.grantPermissions', async (channel) => {
            await channel.grantPermissions({ permissions, ...options });
        });
    }
    async clearPermissions() {
        return this._wrapApiCall('browserContext.clearPermissions', async (channel) => {
            await channel.clearPermissions();
        });
    }
    async setGeolocation(geolocation) {
        return this._wrapApiCall('browserContext.setGeolocation', async (channel) => {
            await channel.setGeolocation({ geolocation: geolocation || undefined });
        });
    }
    async setExtraHTTPHeaders(headers) {
        return this._wrapApiCall('browserContext.setExtraHTTPHeaders', async (channel) => {
            network.validateHeaders(headers);
            await channel.setExtraHTTPHeaders({ headers: utils_1.headersObjectToArray(headers) });
        });
    }
    async setOffline(offline) {
        return this._wrapApiCall('browserContext.setOffline', async (channel) => {
            await channel.setOffline({ offline });
        });
    }
    async setHTTPCredentials(httpCredentials) {
        if (!utils_1.isUnderTest())
            clientHelper_1.deprecate(`context.setHTTPCredentials`, `warning: method |context.setHTTPCredentials()| is deprecated. Instead of changing credentials, create another browser context with new credentials.`);
        return this._wrapApiCall('browserContext.setHTTPCredentials', async (channel) => {
            await channel.setHTTPCredentials({ httpCredentials: httpCredentials || undefined });
        });
    }
    async addInitScript(script, arg) {
        return this._wrapApiCall('browserContext.addInitScript', async (channel) => {
            const source = await clientHelper_1.evaluationScript(script, arg);
            await channel.addInitScript({ source });
        });
    }
    async exposeBinding(name, callback, options = {}) {
        return this._wrapApiCall('browserContext.exposeBinding', async (channel) => {
            await channel.exposeBinding({ name, needsHandle: options.handle });
            this._bindings.set(name, callback);
        });
    }
    async exposeFunction(name, callback) {
        return this._wrapApiCall('browserContext.exposeFunction', async (channel) => {
            await channel.exposeBinding({ name });
            const binding = (source, ...args) => callback(...args);
            this._bindings.set(name, binding);
        });
    }
    async route(url, handler) {
        return this._wrapApiCall('browserContext.route', async (channel) => {
            this._routes.push({ url, handler });
            if (this._routes.length === 1)
                await channel.setNetworkInterceptionEnabled({ enabled: true });
        });
    }
    async unroute(url, handler) {
        return this._wrapApiCall('browserContext.unroute', async (channel) => {
            this._routes = this._routes.filter(route => route.url !== url || (handler && route.handler !== handler));
            if (this._routes.length === 0)
                await channel.setNetworkInterceptionEnabled({ enabled: false });
        });
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, 'browserContext', event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.BrowserContext.Close)
            waiter.rejectOnEvent(this, events_1.Events.BrowserContext.Close, new Error('Context closed'));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
    }
    async storageState(options = {}) {
        return await this._wrapApiCall('browserContext.storageState', async (channel) => {
            const state = await channel.storageState();
            if (options.path) {
                await utils_1.mkdirIfNeeded(options.path);
                await fs_1.default.promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');
            }
            return state;
        });
    }
    backgroundPages() {
        return [...this._backgroundPages];
    }
    serviceWorkers() {
        return [...this._serviceWorkers];
    }
    async newCDPSession(page) {
        return this._wrapApiCall('browserContext.newCDPSession', async (channel) => {
            const result = await channel.newCDPSession({ page: page._channel });
            return cdpSession_1.CDPSession.from(result.session);
        });
    }
    _onClose() {
        if (this._browser)
            this._browser._contexts.delete(this);
        this.emit(events_1.Events.BrowserContext.Close, this);
    }
    async close() {
        try {
            await this._wrapApiCall('browserContext.close', async (channel) => {
                await channel.close();
                await this._closedPromise;
            });
        }
        catch (e) {
            if (errors_1.isSafeCloseError(e))
                return;
            throw e;
        }
    }
    async _enableRecorder(params) {
        await this._channel.recorderSupplementEnable(params);
    }
}
exports.BrowserContext = BrowserContext;
async function prepareBrowserContextParams(options) {
    if (options.videoSize && !options.videosPath)
        throw new Error(`"videoSize" option requires "videosPath" to be specified`);
    if (options.extraHTTPHeaders)
        network.validateHeaders(options.extraHTTPHeaders);
    const contextParams = {
        sdkLanguage: 'javascript',
        ...options,
        viewport: options.viewport === null ? undefined : options.viewport,
        noDefaultViewport: options.viewport === null,
        extraHTTPHeaders: options.extraHTTPHeaders ? utils_1.headersObjectToArray(options.extraHTTPHeaders) : undefined,
        storageState: typeof options.storageState === 'string' ? JSON.parse(await fs_1.default.promises.readFile(options.storageState, 'utf8')) : options.storageState,
    };
    if (!contextParams.recordVideo && options.videosPath) {
        contextParams.recordVideo = {
            dir: options.videosPath,
            size: options.videoSize
        };
    }
    return contextParams;
}
exports.prepareBrowserContextParams = prepareBrowserContextParams;
//# sourceMappingURL=browserContext.js.map

/***/ }),

/***/ 1474:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserType = void 0;
const browser_1 = __nccwpck_require__(6722);
const browserContext_1 = __nccwpck_require__(3752);
const channelOwner_1 = __nccwpck_require__(772);
const ws_1 = __importDefault(__nccwpck_require__(7550));
const connection_1 = __nccwpck_require__(4466);
const events_1 = __nccwpck_require__(2387);
const timeoutSettings_1 = __nccwpck_require__(9255);
const clientHelper_1 = __nccwpck_require__(9556);
const utils_1 = __nccwpck_require__(6416);
const errors_1 = __nccwpck_require__(4949);
class BrowserType extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
    }
    static from(browserType) {
        return browserType._object;
    }
    executablePath() {
        if (!this._initializer.executablePath)
            throw new Error('Browser is not supported on current platform');
        return this._initializer.executablePath;
    }
    name() {
        return this._initializer.name;
    }
    async launch(options = {}) {
        const logger = options.logger;
        return this._wrapApiCall('browserType.launch', async (channel) => {
            utils_1.assert(!options.userDataDir, 'userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead');
            utils_1.assert(!options.port, 'Cannot specify a port without launching as a server.');
            const launchOptions = {
                ...options,
                ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,
                ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
                env: options.env ? clientHelper_1.envObjectToArray(options.env) : undefined,
            };
            const browser = browser_1.Browser.from((await channel.launch(launchOptions)).browser);
            browser._logger = logger;
            return browser;
        }, logger);
    }
    async launchServer(options = {}) {
        if (!this._serverLauncher)
            throw new Error('Launching server is not supported');
        return this._serverLauncher.launchServer(options);
    }
    async launchPersistentContext(userDataDir, options = {}) {
        return this._wrapApiCall('browserType.launchPersistentContext', async (channel) => {
            utils_1.assert(!options.port, 'Cannot specify a port without launching as a server.');
            const contextParams = await browserContext_1.prepareBrowserContextParams(options);
            const persistentParams = {
                ...contextParams,
                ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,
                ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
                env: options.env ? clientHelper_1.envObjectToArray(options.env) : undefined,
                channel: options.channel,
                userDataDir,
            };
            const result = await channel.launchPersistentContext(persistentParams);
            const context = browserContext_1.BrowserContext.from(result.context);
            context._options = contextParams;
            context._logger = options.logger;
            return context;
        }, options.logger);
    }
    async connect(params) {
        const logger = params.logger;
        const paramsHeaders = Object.assign({ 'User-Agent': utils_1.getUserAgent() }, params.headers);
        return this._wrapApiCall('browserType.connect', async () => {
            const ws = new ws_1.default(params.wsEndpoint, [], {
                perMessageDeflate: false,
                maxPayload: 256 * 1024 * 1024,
                handshakeTimeout: this._timeoutSettings.timeout(params),
                headers: paramsHeaders,
            });
            const connection = new connection_1.Connection(() => ws.close());
            // The 'ws' module in node sometimes sends us multiple messages in a single task.
            const waitForNextTask = params.slowMo
                ? (cb) => setTimeout(cb, params.slowMo)
                : utils_1.makeWaitForNextTask();
            connection.onmessage = message => {
                // Connection should handle all outgoing message in disconnected().
                if (ws.readyState !== ws_1.default.OPEN)
                    return;
                ws.send(JSON.stringify(message));
            };
            ws.addEventListener('message', event => {
                waitForNextTask(() => {
                    try {
                        // Since we may slow down the messages, but disconnect
                        // synchronously, we might come here with a message
                        // after disconnect.
                        if (!connection.isDisconnected())
                            connection.dispatch(JSON.parse(event.data));
                    }
                    catch (e) {
                        console.error(`Playwright: Connection dispatch error`);
                        console.error(e);
                        ws.close();
                    }
                });
            });
            let timeoutCallback = (e) => { };
            const timeoutPromise = new Promise((f, r) => timeoutCallback = r);
            const timer = params.timeout ? setTimeout(() => timeoutCallback(new Error(`Timeout ${params.timeout}ms exceeded.`)), params.timeout) : undefined;
            const successPromise = new Promise(async (fulfill, reject) => {
                if (params.__testHookBeforeCreateBrowser) {
                    try {
                        await params.__testHookBeforeCreateBrowser();
                    }
                    catch (e) {
                        reject(e);
                    }
                }
                ws.addEventListener('open', async () => {
                    const prematureCloseListener = (event) => {
                        reject(new Error(`WebSocket server disconnected (${event.code}) ${event.reason}`));
                    };
                    ws.addEventListener('close', prematureCloseListener);
                    const playwright = await connection.waitForObjectWithKnownName('Playwright');
                    if (!playwright._initializer.preLaunchedBrowser) {
                        reject(new Error('Malformed endpoint. Did you use launchServer method?'));
                        ws.close();
                        return;
                    }
                    const browser = browser_1.Browser.from(playwright._initializer.preLaunchedBrowser);
                    browser._logger = logger;
                    browser._remoteType = 'owns-connection';
                    const closeListener = () => {
                        // Emulate all pages, contexts and the browser closing upon disconnect.
                        for (const context of browser.contexts()) {
                            for (const page of context.pages())
                                page._onClose();
                            context._onClose();
                        }
                        browser._didClose();
                        connection.didDisconnect(errors_1.kBrowserClosedError);
                    };
                    ws.removeEventListener('close', prematureCloseListener);
                    ws.addEventListener('close', closeListener);
                    browser.on(events_1.Events.Browser.Disconnected, () => {
                        playwright._cleanup();
                        ws.removeEventListener('close', closeListener);
                        ws.close();
                    });
                    if (params._forwardPorts) {
                        try {
                            await playwright._enablePortForwarding(params._forwardPorts);
                        }
                        catch (err) {
                            reject(err);
                            return;
                        }
                    }
                    fulfill(browser);
                });
                ws.addEventListener('error', event => {
                    ws.close();
                    reject(new Error(event.message + '. Most likely ws endpoint is incorrect'));
                });
            });
            try {
                return await Promise.race([successPromise, timeoutPromise]);
            }
            finally {
                if (timer)
                    clearTimeout(timer);
            }
        }, logger);
    }
    async connectOverCDP(params) {
        if (this.name() !== 'chromium')
            throw new Error('Connecting over CDP is only supported in Chromium.');
        const logger = params.logger;
        return this._wrapApiCall('browserType.connectOverCDP', async (channel) => {
            const paramsHeaders = Object.assign({ 'User-Agent': utils_1.getUserAgent() }, params.headers);
            const headers = paramsHeaders ? utils_1.headersObjectToArray(paramsHeaders) : undefined;
            const result = await channel.connectOverCDP({
                sdkLanguage: 'javascript',
                endpointURL: 'endpointURL' in params ? params.endpointURL : params.wsEndpoint,
                headers,
                slowMo: params.slowMo,
                timeout: params.timeout
            });
            const browser = browser_1.Browser.from(result.browser);
            if (result.defaultContext)
                browser._contexts.add(browserContext_1.BrowserContext.from(result.defaultContext));
            browser._remoteType = 'uses-connection';
            browser._logger = logger;
            return browser;
        }, logger);
    }
}
exports.BrowserType = BrowserType;
//# sourceMappingURL=browserType.js.map

/***/ }),

/***/ 703:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDPSession = void 0;
const channelOwner_1 = __nccwpck_require__(772);
class CDPSession extends channelOwner_1.ChannelOwner {
    static from(cdpSession) {
        return cdpSession._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on('event', ({ method, params }) => {
            this.emit(method, params);
        });
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    async send(method, params) {
        return this._wrapApiCall('cdpSession.send', async (channel) => {
            const result = await channel.send({ method, params });
            return result.result;
        });
    }
    async detach() {
        return this._wrapApiCall('cdpSession.detach', async (channel) => {
            return channel.detach();
        });
    }
}
exports.CDPSession = CDPSession;
//# sourceMappingURL=cdpSession.js.map

/***/ }),

/***/ 772:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelOwner = void 0;
const events_1 = __nccwpck_require__(8614);
const validator_1 = __nccwpck_require__(6423);
const debugLogger_1 = __nccwpck_require__(5203);
const stackTrace_1 = __nccwpck_require__(6010);
class ChannelOwner extends events_1.EventEmitter {
    constructor(parent, type, guid, initializer) {
        super();
        this._objects = new Map();
        this.setMaxListeners(0);
        this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
        this._type = type;
        this._guid = guid;
        this._parent = parent instanceof ChannelOwner ? parent : undefined;
        this._connection._objects.set(guid, this);
        if (this._parent) {
            this._parent._objects.set(guid, this);
            this._logger = this._parent._logger;
        }
        this._channel = this._createChannel(new events_1.EventEmitter(), '');
        this._initializer = initializer;
    }
    _dispose() {
        // Clean up from parent and connection.
        if (this._parent)
            this._parent._objects.delete(this._guid);
        this._connection._objects.delete(this._guid);
        // Dispose all children.
        for (const object of [...this._objects.values()])
            object._dispose();
        this._objects.clear();
    }
    _debugScopeState() {
        return {
            _guid: this._guid,
            objects: Array.from(this._objects.values()).map(o => o._debugScopeState()),
        };
    }
    _createChannel(base, apiName) {
        const channel = new Proxy(base, {
            get: (obj, prop) => {
                if (prop === 'debugScopeState')
                    return (params) => this._connection.sendMessageToServer(this._guid, prop, params, apiName);
                if (typeof prop === 'string') {
                    const validator = scheme[paramsName(this._type, prop)];
                    if (validator)
                        return (params) => this._connection.sendMessageToServer(this._guid, prop, validator(params, ''), apiName);
                }
                return obj[prop];
            },
        });
        channel._object = this;
        return channel;
    }
    async _wrapApiCall(apiName, func, logger) {
        logger = logger || this._logger;
        try {
            logApiCall(logger, `=> ${apiName} started`);
            const channel = this._createChannel({}, apiName);
            const result = await func(channel);
            logApiCall(logger, `<= ${apiName} succeeded`);
            return result;
        }
        catch (e) {
            logApiCall(logger, `<= ${apiName} failed`);
            stackTrace_1.rewriteErrorMessage(e, `${apiName}: ` + e.message);
            throw e;
        }
    }
    _waitForEventInfoBefore(waitId, apiName) {
        this._connection.sendMessageToServer(this._guid, 'waitForEventInfo', { info: { apiName, waitId, phase: 'before' } }, undefined).catch(() => { });
    }
    _waitForEventInfoAfter(waitId, error) {
        this._connection.sendMessageToServer(this._guid, 'waitForEventInfo', { info: { waitId, phase: 'after', error } }, undefined).catch(() => { });
    }
    _waitForEventInfoLog(waitId, message) {
        this._connection.sendMessageToServer(this._guid, 'waitForEventInfo', { info: { waitId, phase: 'log', message } }, undefined).catch(() => { });
    }
    toJSON() {
        // Jest's expect library tries to print objects sometimes.
        // RPC objects can contain links to lots of other objects,
        // which can cause jest to crash. Let's help it out
        // by just returning the important values.
        return {
            _type: this._type,
            _guid: this._guid,
        };
    }
}
exports.ChannelOwner = ChannelOwner;
function logApiCall(logger, message) {
    if (logger && logger.isEnabled('api', 'info'))
        logger.log('api', 'info', message, [], { color: 'cyan' });
    debugLogger_1.debugLogger.log('api', message);
}
function paramsName(type, method) {
    return type + method[0].toUpperCase() + method.substring(1) + 'Params';
}
const tChannel = (name) => {
    return (arg, path) => {
        if (arg._object instanceof ChannelOwner && (name === '*' || arg._object._type === name))
            return { guid: arg._object._guid };
        throw new validator_1.ValidationError(`${path}: expected ${name}`);
    };
};
const scheme = validator_1.createScheme(tChannel);
//# sourceMappingURL=channelOwner.js.map

/***/ }),

/***/ 9556:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globToRegex = exports.urlMatches = exports.parsedURL = exports.evaluationScript = exports.envObjectToArray = exports.deprecate = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const utils_1 = __nccwpck_require__(6416);
const deprecatedHits = new Set();
function deprecate(methodName, message) {
    if (deprecatedHits.has(methodName))
        return;
    deprecatedHits.add(methodName);
    console.warn(message);
}
exports.deprecate = deprecate;
function envObjectToArray(env) {
    const result = [];
    for (const name in env) {
        if (!Object.is(env[name], undefined))
            result.push({ name, value: String(env[name]) });
    }
    return result;
}
exports.envObjectToArray = envObjectToArray;
async function evaluationScript(fun, arg, addSourceUrl = true) {
    if (typeof fun === 'function') {
        const source = fun.toString();
        const argString = Object.is(arg, undefined) ? 'undefined' : JSON.stringify(arg);
        return `(${source})(${argString})`;
    }
    if (arg !== undefined)
        throw new Error('Cannot evaluate a string with arguments');
    if (utils_1.isString(fun))
        return fun;
    if (fun.content !== undefined)
        return fun.content;
    if (fun.path !== undefined) {
        let source = await fs_1.default.promises.readFile(fun.path, 'utf8');
        if (addSourceUrl)
            source += '//# sourceURL=' + fun.path.replace(/\n/g, '');
        return source;
    }
    throw new Error('Either path or content property must be present');
}
exports.evaluationScript = evaluationScript;
function parsedURL(url) {
    try {
        return new URL(url);
    }
    catch (e) {
        return null;
    }
}
exports.parsedURL = parsedURL;
function urlMatches(urlString, match) {
    if (match === undefined || match === '')
        return true;
    if (utils_1.isString(match))
        match = globToRegex(match);
    if (utils_1.isRegExp(match))
        return match.test(urlString);
    if (typeof match === 'string' && match === urlString)
        return true;
    const url = parsedURL(urlString);
    if (!url)
        return false;
    if (typeof match === 'string')
        return url.pathname === match;
    if (typeof match !== 'function')
        throw new Error('url parameter should be string, RegExp or function');
    return match(url);
}
exports.urlMatches = urlMatches;
const escapeGlobChars = new Set(['/', '$', '^', '+', '.', '(', ')', '=', '!', '|']);
function globToRegex(glob) {
    const tokens = ['^'];
    let inGroup;
    for (let i = 0; i < glob.length; ++i) {
        const c = glob[i];
        if (escapeGlobChars.has(c)) {
            tokens.push('\\' + c);
            continue;
        }
        if (c === '*') {
            const beforeDeep = glob[i - 1];
            let starCount = 1;
            while (glob[i + 1] === '*') {
                starCount++;
                i++;
            }
            const afterDeep = glob[i + 1];
            const isDeep = starCount > 1 &&
                (beforeDeep === '/' || beforeDeep === undefined) &&
                (afterDeep === '/' || afterDeep === undefined);
            if (isDeep) {
                tokens.push('((?:[^/]*(?:\/|$))*)');
                i++;
            }
            else {
                tokens.push('([^/]*)');
            }
            continue;
        }
        switch (c) {
            case '?':
                tokens.push('.');
                break;
            case '{':
                inGroup = true;
                tokens.push('(');
                break;
            case '}':
                inGroup = false;
                tokens.push(')');
                break;
            case ',':
                if (inGroup) {
                    tokens.push('|');
                    break;
                }
                tokens.push('\\' + c);
                break;
            default:
                tokens.push(c);
        }
    }
    tokens.push('$');
    return new RegExp(tokens.join(''));
}
exports.globToRegex = globToRegex;
//# sourceMappingURL=clientHelper.js.map

/***/ }),

/***/ 4466:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Connection = void 0;
const browser_1 = __nccwpck_require__(6722);
const browserContext_1 = __nccwpck_require__(3752);
const browserType_1 = __nccwpck_require__(1474);
const channelOwner_1 = __nccwpck_require__(772);
const elementHandle_1 = __nccwpck_require__(4460);
const frame_1 = __nccwpck_require__(1408);
const jsHandle_1 = __nccwpck_require__(7540);
const network_1 = __nccwpck_require__(3510);
const page_1 = __nccwpck_require__(4713);
const worker_1 = __nccwpck_require__(5321);
const consoleMessage_1 = __nccwpck_require__(4141);
const dialog_1 = __nccwpck_require__(7662);
const serializers_1 = __nccwpck_require__(9546);
const cdpSession_1 = __nccwpck_require__(703);
const playwright_1 = __nccwpck_require__(601);
const electron_1 = __nccwpck_require__(1322);
const stream_1 = __nccwpck_require__(5377);
const debugLogger_1 = __nccwpck_require__(5203);
const selectors_1 = __nccwpck_require__(7489);
const utils_1 = __nccwpck_require__(6416);
const android_1 = __nccwpck_require__(9779);
const socksSocket_1 = __nccwpck_require__(5904);
const stackTrace_1 = __nccwpck_require__(6010);
const artifact_1 = __nccwpck_require__(9214);
const events_1 = __nccwpck_require__(8614);
class Root extends channelOwner_1.ChannelOwner {
    constructor(connection) {
        super(connection, '', '', {});
    }
}
class Connection extends events_1.EventEmitter {
    constructor(onClose) {
        super();
        this._objects = new Map();
        this._waitingForObject = new Map();
        this.onmessage = (message) => { };
        this._lastId = 0;
        this._callbacks = new Map();
        this._rootObject = new Root(this);
        this._onClose = onClose;
    }
    async waitForObjectWithKnownName(guid) {
        if (this._objects.has(guid))
            return this._objects.get(guid);
        return new Promise(f => this._waitingForObject.set(guid, f));
    }
    getObjectWithKnownName(guid) {
        return this._objects.get(guid);
    }
    async sendMessageToServer(guid, method, params, apiName) {
        const { stack, frames } = stackTrace_1.captureStackTrace();
        const id = ++this._lastId;
        const converted = { id, guid, method, params };
        // Do not include metadata in debug logs to avoid noise.
        debugLogger_1.debugLogger.log('channel:command', converted);
        this.onmessage({ ...converted, metadata: { stack: frames, apiName } });
        try {
            if (this._disconnectedErrorMessage)
                throw new Error(this._disconnectedErrorMessage);
            return await new Promise((resolve, reject) => this._callbacks.set(id, { resolve, reject }));
        }
        catch (e) {
            const innerStack = ((process.env.PWDEBUGIMPL || utils_1.isUnderTest()) && e.stack) ? e.stack.substring(e.stack.indexOf(e.message) + e.message.length) : '';
            e.stack = e.message + innerStack + '\n' + stack;
            throw e;
        }
    }
    _debugScopeState() {
        return this._rootObject._debugScopeState();
    }
    dispatch(message) {
        const { id, guid, method, params, result, error } = message;
        if (id) {
            debugLogger_1.debugLogger.log('channel:response', message);
            const callback = this._callbacks.get(id);
            if (!callback)
                throw new Error(`Cannot find command to respond: ${id}`);
            this._callbacks.delete(id);
            if (error)
                callback.reject(serializers_1.parseError(error));
            else
                callback.resolve(this._replaceGuidsWithChannels(result));
            return;
        }
        debugLogger_1.debugLogger.log('channel:event', message);
        if (method === '__create__') {
            this._createRemoteObject(guid, params.type, params.guid, params.initializer);
            return;
        }
        if (method === '__dispose__') {
            const object = this._objects.get(guid);
            if (!object)
                throw new Error(`Cannot find object to dispose: ${guid}`);
            object._dispose();
            return;
        }
        const object = this._objects.get(guid);
        if (!object)
            throw new Error(`Cannot find object to emit "${method}": ${guid}`);
        object._channel.emit(method, this._replaceGuidsWithChannels(params));
    }
    close() {
        if (this._onClose)
            this._onClose();
    }
    didDisconnect(errorMessage) {
        this._disconnectedErrorMessage = errorMessage;
        for (const callback of this._callbacks.values())
            callback.reject(new Error(errorMessage));
        this._callbacks.clear();
        this.emit('disconnect');
    }
    isDisconnected() {
        return !!this._disconnectedErrorMessage;
    }
    _replaceGuidsWithChannels(payload) {
        if (!payload)
            return payload;
        if (Array.isArray(payload))
            return payload.map(p => this._replaceGuidsWithChannels(p));
        if (payload.guid && this._objects.has(payload.guid))
            return this._objects.get(payload.guid)._channel;
        if (typeof payload === 'object') {
            const result = {};
            for (const key of Object.keys(payload))
                result[key] = this._replaceGuidsWithChannels(payload[key]);
            return result;
        }
        return payload;
    }
    _createRemoteObject(parentGuid, type, guid, initializer) {
        const parent = this._objects.get(parentGuid);
        if (!parent)
            throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
        let result;
        initializer = this._replaceGuidsWithChannels(initializer);
        switch (type) {
            case 'Android':
                result = new android_1.Android(parent, type, guid, initializer);
                break;
            case 'AndroidSocket':
                result = new android_1.AndroidSocket(parent, type, guid, initializer);
                break;
            case 'AndroidDevice':
                result = new android_1.AndroidDevice(parent, type, guid, initializer);
                break;
            case 'Artifact':
                result = new artifact_1.Artifact(parent, type, guid, initializer);
                break;
            case 'BindingCall':
                result = new page_1.BindingCall(parent, type, guid, initializer);
                break;
            case 'Browser':
                result = new browser_1.Browser(parent, type, guid, initializer);
                break;
            case 'BrowserContext':
                result = new browserContext_1.BrowserContext(parent, type, guid, initializer);
                break;
            case 'BrowserType':
                result = new browserType_1.BrowserType(parent, type, guid, initializer);
                break;
            case 'CDPSession':
                result = new cdpSession_1.CDPSession(parent, type, guid, initializer);
                break;
            case 'ConsoleMessage':
                result = new consoleMessage_1.ConsoleMessage(parent, type, guid, initializer);
                break;
            case 'Dialog':
                result = new dialog_1.Dialog(parent, type, guid, initializer);
                break;
            case 'Electron':
                result = new electron_1.Electron(parent, type, guid, initializer);
                break;
            case 'ElectronApplication':
                result = new electron_1.ElectronApplication(parent, type, guid, initializer);
                break;
            case 'ElementHandle':
                result = new elementHandle_1.ElementHandle(parent, type, guid, initializer);
                break;
            case 'Frame':
                result = new frame_1.Frame(parent, type, guid, initializer);
                break;
            case 'JSHandle':
                result = new jsHandle_1.JSHandle(parent, type, guid, initializer);
                break;
            case 'Page':
                result = new page_1.Page(parent, type, guid, initializer);
                break;
            case 'Playwright':
                result = new playwright_1.Playwright(parent, type, guid, initializer);
                break;
            case 'Request':
                result = new network_1.Request(parent, type, guid, initializer);
                break;
            case 'Response':
                result = new network_1.Response(parent, type, guid, initializer);
                break;
            case 'Route':
                result = new network_1.Route(parent, type, guid, initializer);
                break;
            case 'Stream':
                result = new stream_1.Stream(parent, type, guid, initializer);
                break;
            case 'Selectors':
                result = new selectors_1.SelectorsOwner(parent, type, guid, initializer);
                break;
            case 'WebSocket':
                result = new network_1.WebSocket(parent, type, guid, initializer);
                break;
            case 'Worker':
                result = new worker_1.Worker(parent, type, guid, initializer);
                break;
            case 'SocksSocket':
                result = new socksSocket_1.SocksSocket(parent, type, guid, initializer);
                break;
            default:
                throw new Error('Missing type ' + type);
        }
        const callback = this._waitingForObject.get(guid);
        if (callback) {
            callback(result);
            this._waitingForObject.delete(guid);
        }
        return result;
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 4141:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleMessage = void 0;
const util = __importStar(__nccwpck_require__(1669));
const jsHandle_1 = __nccwpck_require__(7540);
const channelOwner_1 = __nccwpck_require__(772);
class ConsoleMessage extends channelOwner_1.ChannelOwner {
    static from(message) {
        return message._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
    }
    type() {
        return this._initializer.type;
    }
    text() {
        return this._initializer.text;
    }
    args() {
        return this._initializer.args.map(jsHandle_1.JSHandle.from);
    }
    location() {
        return this._initializer.location;
    }
    [util.inspect.custom]() {
        return this.text();
    }
}
exports.ConsoleMessage = ConsoleMessage;
//# sourceMappingURL=consoleMessage.js.map

/***/ }),

/***/ 215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Coverage = void 0;
class Coverage {
    constructor(channel) {
        this._channel = channel;
    }
    async startJSCoverage(options = {}) {
        await this._channel.startJSCoverage(options);
    }
    async stopJSCoverage() {
        return (await this._channel.stopJSCoverage()).entries;
    }
    async startCSSCoverage(options = {}) {
        await this._channel.startCSSCoverage(options);
    }
    async stopCSSCoverage() {
        return (await this._channel.stopCSSCoverage()).entries;
    }
}
exports.Coverage = Coverage;
//# sourceMappingURL=coverage.js.map

/***/ }),

/***/ 7662:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dialog = void 0;
const channelOwner_1 = __nccwpck_require__(772);
class Dialog extends channelOwner_1.ChannelOwner {
    static from(dialog) {
        return dialog._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
    }
    type() {
        return this._initializer.type;
    }
    message() {
        return this._initializer.message;
    }
    defaultValue() {
        return this._initializer.defaultValue;
    }
    async accept(promptText) {
        return this._wrapApiCall('dialog.accept', async (channel) => {
            await channel.accept({ promptText });
        });
    }
    async dismiss() {
        return this._wrapApiCall('dialog.dismiss', async (channel) => {
            await channel.dismiss();
        });
    }
}
exports.Dialog = Dialog;
//# sourceMappingURL=dialog.js.map

/***/ }),

/***/ 8810:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Download = void 0;
class Download {
    constructor(page, url, suggestedFilename, artifact) {
        this._page = page;
        this._url = url;
        this._suggestedFilename = suggestedFilename;
        this._artifact = artifact;
    }
    page() {
        return this._page;
    }
    url() {
        return this._url;
    }
    suggestedFilename() {
        return this._suggestedFilename;
    }
    async path() {
        return this._artifact.pathAfterFinished();
    }
    async saveAs(path) {
        return this._artifact.saveAs(path);
    }
    async failure() {
        return this._artifact.failure();
    }
    async createReadStream() {
        return this._artifact.createReadStream();
    }
    async delete() {
        return this._artifact.delete();
    }
}
exports.Download = Download;
//# sourceMappingURL=download.js.map

/***/ }),

/***/ 1322:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElectronApplication = exports.Electron = void 0;
const timeoutSettings_1 = __nccwpck_require__(9255);
const utils_1 = __nccwpck_require__(6416);
const browserContext_1 = __nccwpck_require__(3752);
const channelOwner_1 = __nccwpck_require__(772);
const clientHelper_1 = __nccwpck_require__(9556);
const events_1 = __nccwpck_require__(2387);
const jsHandle_1 = __nccwpck_require__(7540);
const waiter_1 = __nccwpck_require__(5338);
class Electron extends channelOwner_1.ChannelOwner {
    static from(electron) {
        return electron._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
    }
    async launch(options = {}) {
        return this._wrapApiCall('electron.launch', async (channel) => {
            const params = {
                sdkLanguage: 'javascript',
                ...options,
                extraHTTPHeaders: options.extraHTTPHeaders && utils_1.headersObjectToArray(options.extraHTTPHeaders),
                env: clientHelper_1.envObjectToArray(options.env ? options.env : process.env),
            };
            return ElectronApplication.from((await channel.launch(params)).electronApplication);
        });
    }
}
exports.Electron = Electron;
class ElectronApplication extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._windows = new Set();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._context = browserContext_1.BrowserContext.from(initializer.context);
        for (const page of this._context._pages)
            this._onPage(page);
        this._context.on(events_1.Events.BrowserContext.Page, page => this._onPage(page));
        this._channel.on('close', () => this.emit(events_1.Events.ElectronApplication.Close));
    }
    static from(electronApplication) {
        return electronApplication._object;
    }
    _onPage(page) {
        this._windows.add(page);
        this.emit(events_1.Events.ElectronApplication.Window, page);
        page.once(events_1.Events.Page.Close, () => this._windows.delete(page));
    }
    windows() {
        // TODO: add ElectronPage class inherting from Page.
        return [...this._windows];
    }
    async firstWindow() {
        return this._wrapApiCall('electronApplication.firstWindow', async (channel) => {
            if (this._windows.size)
                return this._windows.values().next().value;
            return this.waitForEvent('window');
        });
    }
    context() {
        return this._context;
    }
    async close() {
        await this._channel.close();
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, 'electronApplication', event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.ElectronApplication.Close)
            waiter.rejectOnEvent(this, events_1.Events.ElectronApplication.Close, new Error('Electron application closed'));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
    }
    async browserWindow(page) {
        return this._wrapApiCall('electronApplication.browserWindow', async (channel) => {
            const result = await channel.browserWindow({ page: page._channel });
            return jsHandle_1.JSHandle.from(result.handle);
        });
    }
    async evaluate(pageFunction, arg) {
        return this._wrapApiCall('electronApplication.evaluate', async (channel) => {
            const result = await channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async evaluateHandle(pageFunction, arg) {
        return this._wrapApiCall('electronApplication.evaluateHandle', async (channel) => {
            const result = await channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.JSHandle.from(result.handle);
        });
    }
}
exports.ElectronApplication = ElectronApplication;
//# sourceMappingURL=electron.js.map

/***/ }),

/***/ 4460:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.determineScreenshotType = exports.convertInputFiles = exports.convertSelectOptionValues = exports.ElementHandle = void 0;
const frame_1 = __nccwpck_require__(1408);
const jsHandle_1 = __nccwpck_require__(7540);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const mime = __importStar(__nccwpck_require__(8640));
const path_1 = __importDefault(__nccwpck_require__(5622));
const utils_1 = __nccwpck_require__(6416);
class ElementHandle extends jsHandle_1.JSHandle {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._elementChannel = this._channel;
    }
    static from(handle) {
        return handle._object;
    }
    static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
    }
    asElement() {
        return this;
    }
    async ownerFrame() {
        return this._wrapApiCall('elementHandle.ownerFrame', async (channel) => {
            return frame_1.Frame.fromNullable((await channel.ownerFrame()).frame);
        });
    }
    async contentFrame() {
        return this._wrapApiCall('elementHandle.contentFrame', async (channel) => {
            return frame_1.Frame.fromNullable((await channel.contentFrame()).frame);
        });
    }
    async getAttribute(name) {
        return this._wrapApiCall('elementHandle.getAttribute', async (channel) => {
            const value = (await channel.getAttribute({ name })).value;
            return value === undefined ? null : value;
        });
    }
    async textContent() {
        return this._wrapApiCall('elementHandle.textContent', async (channel) => {
            const value = (await channel.textContent()).value;
            return value === undefined ? null : value;
        });
    }
    async innerText() {
        return this._wrapApiCall('elementHandle.innerText', async (channel) => {
            return (await channel.innerText()).value;
        });
    }
    async innerHTML() {
        return this._wrapApiCall('elementHandle.innerHTML', async (channel) => {
            return (await channel.innerHTML()).value;
        });
    }
    async isChecked() {
        return this._wrapApiCall('elementHandle.isChecked', async (channel) => {
            return (await channel.isChecked()).value;
        });
    }
    async isDisabled() {
        return this._wrapApiCall('elementHandle.isDisabled', async (channel) => {
            return (await channel.isDisabled()).value;
        });
    }
    async isEditable() {
        return this._wrapApiCall('elementHandle.isEditable', async (channel) => {
            return (await channel.isEditable()).value;
        });
    }
    async isEnabled() {
        return this._wrapApiCall('elementHandle.isEnabled', async (channel) => {
            return (await channel.isEnabled()).value;
        });
    }
    async isHidden() {
        return this._wrapApiCall('elementHandle.isHidden', async (channel) => {
            return (await channel.isHidden()).value;
        });
    }
    async isVisible() {
        return this._wrapApiCall('elementHandle.isVisible', async (channel) => {
            return (await channel.isVisible()).value;
        });
    }
    async dispatchEvent(type, eventInit = {}) {
        return this._wrapApiCall('elementHandle.dispatchEvent', async (channel) => {
            await channel.dispatchEvent({ type, eventInit: jsHandle_1.serializeArgument(eventInit) });
        });
    }
    async scrollIntoViewIfNeeded(options = {}) {
        return this._wrapApiCall('elementHandle.scrollIntoViewIfNeeded', async (channel) => {
            await channel.scrollIntoViewIfNeeded(options);
        });
    }
    async hover(options = {}) {
        return this._wrapApiCall('elementHandle.hover', async (channel) => {
            await channel.hover(options);
        });
    }
    async click(options = {}) {
        return this._wrapApiCall('elementHandle.click', async (channel) => {
            return await channel.click(options);
        });
    }
    async dblclick(options = {}) {
        return this._wrapApiCall('elementHandle.dblclick', async (channel) => {
            return await channel.dblclick(options);
        });
    }
    async tap(options = {}) {
        return this._wrapApiCall('elementHandle.tap', async (channel) => {
            return await channel.tap(options);
        });
    }
    async selectOption(values, options = {}) {
        return this._wrapApiCall('elementHandle.selectOption', async (channel) => {
            const result = await channel.selectOption({ ...convertSelectOptionValues(values), ...options });
            return result.values;
        });
    }
    async fill(value, options = {}) {
        return this._wrapApiCall('elementHandle.fill', async (channel) => {
            return await channel.fill({ value, ...options });
        });
    }
    async selectText(options = {}) {
        return this._wrapApiCall('elementHandle.selectText', async (channel) => {
            await channel.selectText(options);
        });
    }
    async setInputFiles(files, options = {}) {
        return this._wrapApiCall('elementHandle.setInputFiles', async (channel) => {
            await channel.setInputFiles({ files: await convertInputFiles(files), ...options });
        });
    }
    async focus() {
        return this._wrapApiCall('elementHandle.focus', async (channel) => {
            await channel.focus();
        });
    }
    async type(text, options = {}) {
        return this._wrapApiCall('elementHandle.type', async (channel) => {
            await channel.type({ text, ...options });
        });
    }
    async press(key, options = {}) {
        return this._wrapApiCall('elementHandle.press', async (channel) => {
            await channel.press({ key, ...options });
        });
    }
    async check(options = {}) {
        return this._wrapApiCall('elementHandle.check', async (channel) => {
            return await channel.check(options);
        });
    }
    async uncheck(options = {}) {
        return this._wrapApiCall('elementHandle.uncheck', async (channel) => {
            return await channel.uncheck(options);
        });
    }
    async boundingBox() {
        return this._wrapApiCall('elementHandle.boundingBox', async (channel) => {
            const value = (await channel.boundingBox()).value;
            return value === undefined ? null : value;
        });
    }
    async screenshot(options = {}) {
        return this._wrapApiCall('elementHandle.screenshot', async (channel) => {
            const copy = { ...options };
            if (!copy.type)
                copy.type = determineScreenshotType(options);
            const result = await channel.screenshot(copy);
            const buffer = Buffer.from(result.binary, 'base64');
            if (options.path) {
                await utils_1.mkdirIfNeeded(options.path);
                await fs_1.default.promises.writeFile(options.path, buffer);
            }
            return buffer;
        });
    }
    async $(selector) {
        return this._wrapApiCall('elementHandle.$', async (channel) => {
            return ElementHandle.fromNullable((await channel.querySelector({ selector })).element);
        });
    }
    async $$(selector) {
        return this._wrapApiCall('elementHandle.$$', async (channel) => {
            const result = await channel.querySelectorAll({ selector });
            return result.elements.map(h => ElementHandle.from(h));
        });
    }
    async $eval(selector, pageFunction, arg) {
        return this._wrapApiCall('elementHandle.$eval', async (channel) => {
            const result = await channel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async $$eval(selector, pageFunction, arg) {
        return this._wrapApiCall('elementHandle.$$eval', async (channel) => {
            const result = await channel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async waitForElementState(state, options = {}) {
        return this._wrapApiCall('elementHandle.waitForElementState', async (channel) => {
            return await channel.waitForElementState({ state, ...options });
        });
    }
    async waitForSelector(selector, options = {}) {
        return this._wrapApiCall('elementHandle.waitForSelector', async (channel) => {
            const result = await channel.waitForSelector({ selector, ...options });
            return ElementHandle.fromNullable(result.element);
        });
    }
}
exports.ElementHandle = ElementHandle;
function convertSelectOptionValues(values) {
    if (values === null)
        return {};
    if (!Array.isArray(values))
        values = [values];
    if (!values.length)
        return {};
    for (let i = 0; i < values.length; i++)
        utils_1.assert(values[i] !== null, `options[${i}]: expected object, got null`);
    if (values[0] instanceof ElementHandle)
        return { elements: values.map((v) => v._elementChannel) };
    if (utils_1.isString(values[0]))
        return { options: values.map(value => ({ value })) };
    return { options: values };
}
exports.convertSelectOptionValues = convertSelectOptionValues;
async function convertInputFiles(files) {
    const items = Array.isArray(files) ? files : [files];
    const filePayloads = await Promise.all(items.map(async (item) => {
        if (typeof item === 'string') {
            return {
                name: path_1.default.basename(item),
                buffer: (await fs_1.default.promises.readFile(item)).toString('base64')
            };
        }
        else {
            return {
                name: item.name,
                mimeType: item.mimeType,
                buffer: item.buffer.toString('base64'),
            };
        }
    }));
    return filePayloads;
}
exports.convertInputFiles = convertInputFiles;
function determineScreenshotType(options) {
    if (options.path) {
        const mimeType = mime.getType(options.path);
        if (mimeType === 'image/png')
            return 'png';
        else if (mimeType === 'image/jpeg')
            return 'jpeg';
        throw new Error(`path: unsupported mime type "${mimeType}"`);
    }
    return options.type;
}
exports.determineScreenshotType = determineScreenshotType;
//# sourceMappingURL=elementHandle.js.map

/***/ }),

/***/ 2387:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Events = void 0;
exports.Events = {
    AndroidDevice: {
        WebView: 'webview',
        Close: 'close'
    },
    AndroidSocket: {
        Data: 'data',
        Close: 'close'
    },
    AndroidWebView: {
        Close: 'close'
    },
    Browser: {
        Disconnected: 'disconnected'
    },
    BrowserContext: {
        Close: 'close',
        Page: 'page',
        BackgroundPage: 'backgroundpage',
        ServiceWorker: 'serviceworker',
        Request: 'request',
        Response: 'response',
        RequestFailed: 'requestfailed',
        RequestFinished: 'requestfinished',
    },
    BrowserServer: {
        Close: 'close',
    },
    Page: {
        Close: 'close',
        Crash: 'crash',
        Console: 'console',
        Dialog: 'dialog',
        Download: 'download',
        FileChooser: 'filechooser',
        DOMContentLoaded: 'domcontentloaded',
        // Can't use just 'error' due to node.js special treatment of error events.
        // @see https://nodejs.org/api/events.html#events_error_events
        PageError: 'pageerror',
        Request: 'request',
        Response: 'response',
        RequestFailed: 'requestfailed',
        RequestFinished: 'requestfinished',
        FrameAttached: 'frameattached',
        FrameDetached: 'framedetached',
        FrameNavigated: 'framenavigated',
        Load: 'load',
        Popup: 'popup',
        WebSocket: 'websocket',
        Worker: 'worker',
    },
    WebSocket: {
        Close: 'close',
        Error: 'socketerror',
        FrameReceived: 'framereceived',
        FrameSent: 'framesent',
    },
    Worker: {
        Close: 'close',
    },
    ElectronApplication: {
        Close: 'close',
        Window: 'window',
    },
};
//# sourceMappingURL=events.js.map

/***/ }),

/***/ 8796:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChooser = void 0;
class FileChooser {
    constructor(page, elementHandle, isMultiple) {
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
    }
    element() {
        return this._elementHandle;
    }
    isMultiple() {
        return this._isMultiple;
    }
    page() {
        return this._page;
    }
    async setFiles(files, options) {
        return this._page._wrapApiCall('fileChooser.setFiles', async () => {
            return this._elementHandle.setInputFiles(files, options);
        });
    }
}
exports.FileChooser = FileChooser;
//# sourceMappingURL=fileChooser.js.map

/***/ }),

/***/ 1408:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyLoadState = exports.Frame = void 0;
const utils_1 = __nccwpck_require__(6416);
const channelOwner_1 = __nccwpck_require__(772);
const elementHandle_1 = __nccwpck_require__(4460);
const jsHandle_1 = __nccwpck_require__(7540);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const network = __importStar(__nccwpck_require__(3510));
const events_1 = __nccwpck_require__(8614);
const waiter_1 = __nccwpck_require__(5338);
const events_2 = __nccwpck_require__(2387);
const types_1 = __nccwpck_require__(9856);
const clientHelper_1 = __nccwpck_require__(9556);
class Frame extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._parentFrame = null;
        this._url = '';
        this._name = '';
        this._detached = false;
        this._childFrames = new Set();
        this._eventEmitter = new events_1.EventEmitter();
        this._eventEmitter.setMaxListeners(0);
        this._parentFrame = Frame.fromNullable(initializer.parentFrame);
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
        this._name = initializer.name;
        this._url = initializer.url;
        this._loadStates = new Set(initializer.loadStates);
        this._channel.on('loadstate', event => {
            if (event.add) {
                this._loadStates.add(event.add);
                this._eventEmitter.emit('loadstate', event.add);
            }
            if (event.remove)
                this._loadStates.delete(event.remove);
        });
        this._channel.on('navigated', event => {
            this._url = event.url;
            this._name = event.name;
            this._eventEmitter.emit('navigated', event);
            if (!event.error && this._page)
                this._page.emit(events_2.Events.Page.FrameNavigated, this);
        });
    }
    static from(frame) {
        return frame._object;
    }
    static fromNullable(frame) {
        return frame ? Frame.from(frame) : null;
    }
    _apiName(method) {
        return this._page._isPageCall ? 'page.' + method : 'frame.' + method;
    }
    page() {
        return this._page;
    }
    async goto(url, options = {}) {
        return this._wrapApiCall(this._apiName('goto'), async (channel) => {
            const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            return network.Response.fromNullable((await channel.goto({ url, ...options, waitUntil })).response);
        });
    }
    _setupNavigationWaiter(name, options) {
        const waiter = new waiter_1.Waiter(this, name);
        if (this._page.isClosed())
            waiter.rejectImmediately(new Error('Navigation failed because page was closed!'));
        waiter.rejectOnEvent(this._page, events_2.Events.Page.Close, new Error('Navigation failed because page was closed!'));
        waiter.rejectOnEvent(this._page, events_2.Events.Page.Crash, new Error('Navigation failed because page crashed!'));
        waiter.rejectOnEvent(this._page, events_2.Events.Page.FrameDetached, new Error('Navigating frame was detached!'), frame => frame === this);
        const timeout = this._page._timeoutSettings.navigationTimeout(options);
        waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
        return waiter;
    }
    async waitForNavigation(options = {}) {
        return this._wrapApiCall(this._apiName('waitForNavigation'), async (channel) => {
            const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            const waiter = this._setupNavigationWaiter(this._apiName('waitForNavigation'), options);
            const toUrl = typeof options.url === 'string' ? ` to "${options.url}"` : '';
            waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
            const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, 'navigated', event => {
                // Any failed navigation results in a rejection.
                if (event.error)
                    return true;
                waiter.log(`  navigated to "${event.url}"`);
                return clientHelper_1.urlMatches(event.url, options.url);
            });
            if (navigatedEvent.error) {
                const e = new Error(navigatedEvent.error);
                e.stack = '';
                await waiter.waitForPromise(Promise.reject(e));
            }
            if (!this._loadStates.has(waitUntil)) {
                await waiter.waitForEvent(this._eventEmitter, 'loadstate', s => {
                    waiter.log(`  "${s}" event fired`);
                    return s === waitUntil;
                });
            }
            const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
            const response = request ? await waiter.waitForPromise(request._finalRequest().response()) : null;
            waiter.dispose();
            return response;
        });
    }
    async waitForLoadState(state = 'load', options = {}) {
        state = verifyLoadState('state', state);
        if (this._loadStates.has(state))
            return;
        return this._wrapApiCall(this._apiName('waitForLoadState'), async (channel) => {
            const waiter = this._setupNavigationWaiter(this._apiName('waitForLoadState'), options);
            await waiter.waitForEvent(this._eventEmitter, 'loadstate', s => {
                waiter.log(`  "${s}" event fired`);
                return s === state;
            });
            waiter.dispose();
        });
    }
    async waitForURL(url, options = {}) {
        if (clientHelper_1.urlMatches(this.url(), url))
            return await this.waitForLoadState(options === null || options === void 0 ? void 0 : options.waitUntil, options);
        await this.waitForNavigation({ url, ...options });
    }
    async frameElement() {
        return this._wrapApiCall(this._apiName('frameElement'), async (channel) => {
            return elementHandle_1.ElementHandle.from((await channel.frameElement()).element);
        });
    }
    async evaluateHandle(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall(this._apiName('evaluateHandle'), async (channel) => {
            const result = await channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.JSHandle.from(result.handle);
        });
    }
    async evaluate(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall(this._apiName('evaluate'), async (channel) => {
            const result = await channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async $(selector) {
        return this._wrapApiCall(this._apiName('$'), async (channel) => {
            const result = await channel.querySelector({ selector });
            return elementHandle_1.ElementHandle.fromNullable(result.element);
        });
    }
    async waitForSelector(selector, options = {}) {
        return this._wrapApiCall(this._apiName('waitForSelector'), async (channel) => {
            if (options.visibility)
                throw new Error('options.visibility is not supported, did you mean options.state?');
            if (options.waitFor && options.waitFor !== 'visible')
                throw new Error('options.waitFor is not supported, did you mean options.state?');
            const result = await channel.waitForSelector({ selector, ...options });
            return elementHandle_1.ElementHandle.fromNullable(result.element);
        });
    }
    async dispatchEvent(selector, type, eventInit, options = {}) {
        return this._wrapApiCall(this._apiName('dispatchEvent'), async (channel) => {
            await channel.dispatchEvent({ selector, type, eventInit: jsHandle_1.serializeArgument(eventInit), ...options });
        });
    }
    async $eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._wrapApiCall(this._apiName('$eval'), async (channel) => {
            const result = await channel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async $$eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._wrapApiCall(this._apiName('$$eval'), async (channel) => {
            const result = await channel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async $$(selector) {
        return this._wrapApiCall(this._apiName('$$'), async (channel) => {
            const result = await channel.querySelectorAll({ selector });
            return result.elements.map(e => elementHandle_1.ElementHandle.from(e));
        });
    }
    async content() {
        return this._wrapApiCall(this._apiName('content'), async (channel) => {
            return (await channel.content()).value;
        });
    }
    async setContent(html, options = {}) {
        return this._wrapApiCall(this._apiName('setContent'), async (channel) => {
            const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            await channel.setContent({ html, ...options, waitUntil });
        });
    }
    name() {
        return this._name || '';
    }
    url() {
        return this._url;
    }
    parentFrame() {
        return this._parentFrame;
    }
    childFrames() {
        return Array.from(this._childFrames);
    }
    isDetached() {
        return this._detached;
    }
    async addScriptTag(options = {}) {
        return this._wrapApiCall(this._apiName('addScriptTag'), async (channel) => {
            const copy = { ...options };
            if (copy.path) {
                copy.content = (await fs_1.default.promises.readFile(copy.path)).toString();
                copy.content += '//# sourceURL=' + copy.path.replace(/\n/g, '');
            }
            return elementHandle_1.ElementHandle.from((await channel.addScriptTag({ ...copy })).element);
        });
    }
    async addStyleTag(options = {}) {
        return this._wrapApiCall(this._apiName('addStyleTag'), async (channel) => {
            const copy = { ...options };
            if (copy.path) {
                copy.content = (await fs_1.default.promises.readFile(copy.path)).toString();
                copy.content += '/*# sourceURL=' + copy.path.replace(/\n/g, '') + '*/';
            }
            return elementHandle_1.ElementHandle.from((await channel.addStyleTag({ ...copy })).element);
        });
    }
    async click(selector, options = {}) {
        return this._wrapApiCall(this._apiName('click'), async (channel) => {
            return await channel.click({ selector, ...options });
        });
    }
    async dblclick(selector, options = {}) {
        return this._wrapApiCall(this._apiName('dblclick'), async (channel) => {
            return await channel.dblclick({ selector, ...options });
        });
    }
    async tap(selector, options = {}) {
        return this._wrapApiCall(this._apiName('tap'), async (channel) => {
            return await channel.tap({ selector, ...options });
        });
    }
    async fill(selector, value, options = {}) {
        return this._wrapApiCall(this._apiName('fill'), async (channel) => {
            return await channel.fill({ selector, value, ...options });
        });
    }
    async focus(selector, options = {}) {
        return this._wrapApiCall(this._apiName('focus'), async (channel) => {
            await channel.focus({ selector, ...options });
        });
    }
    async textContent(selector, options = {}) {
        return this._wrapApiCall(this._apiName('textContent'), async (channel) => {
            const value = (await channel.textContent({ selector, ...options })).value;
            return value === undefined ? null : value;
        });
    }
    async innerText(selector, options = {}) {
        return this._wrapApiCall(this._apiName('innerText'), async (channel) => {
            return (await channel.innerText({ selector, ...options })).value;
        });
    }
    async innerHTML(selector, options = {}) {
        return this._wrapApiCall(this._apiName('innerHTML'), async (channel) => {
            return (await channel.innerHTML({ selector, ...options })).value;
        });
    }
    async getAttribute(selector, name, options = {}) {
        return this._wrapApiCall(this._apiName('getAttribute'), async (channel) => {
            const value = (await channel.getAttribute({ selector, name, ...options })).value;
            return value === undefined ? null : value;
        });
    }
    async isChecked(selector, options = {}) {
        return this._wrapApiCall(this._apiName('isChecked'), async (channel) => {
            return (await channel.isChecked({ selector, ...options })).value;
        });
    }
    async isDisabled(selector, options = {}) {
        return this._wrapApiCall(this._apiName('isDisabled'), async (channel) => {
            return (await channel.isDisabled({ selector, ...options })).value;
        });
    }
    async isEditable(selector, options = {}) {
        return this._wrapApiCall(this._apiName('isEditable'), async (channel) => {
            return (await channel.isEditable({ selector, ...options })).value;
        });
    }
    async isEnabled(selector, options = {}) {
        return this._wrapApiCall(this._apiName('isEnabled'), async (channel) => {
            return (await channel.isEnabled({ selector, ...options })).value;
        });
    }
    async isHidden(selector, options = {}) {
        return this._wrapApiCall(this._apiName('isHidden'), async (channel) => {
            return (await channel.isHidden({ selector, ...options })).value;
        });
    }
    async isVisible(selector, options = {}) {
        return this._wrapApiCall(this._apiName('isVisible'), async (channel) => {
            return (await channel.isVisible({ selector, ...options })).value;
        });
    }
    async hover(selector, options = {}) {
        return this._wrapApiCall(this._apiName('hover'), async (channel) => {
            await channel.hover({ selector, ...options });
        });
    }
    async selectOption(selector, values, options = {}) {
        return this._wrapApiCall(this._apiName('selectOption'), async (channel) => {
            return (await channel.selectOption({ selector, ...elementHandle_1.convertSelectOptionValues(values), ...options })).values;
        });
    }
    async setInputFiles(selector, files, options = {}) {
        return this._wrapApiCall(this._apiName('setInputFiles'), async (channel) => {
            await channel.setInputFiles({ selector, files: await elementHandle_1.convertInputFiles(files), ...options });
        });
    }
    async type(selector, text, options = {}) {
        return this._wrapApiCall(this._apiName('type'), async (channel) => {
            await channel.type({ selector, text, ...options });
        });
    }
    async press(selector, key, options = {}) {
        return this._wrapApiCall(this._apiName('press'), async (channel) => {
            await channel.press({ selector, key, ...options });
        });
    }
    async check(selector, options = {}) {
        return this._wrapApiCall(this._apiName('check'), async (channel) => {
            await channel.check({ selector, ...options });
        });
    }
    async uncheck(selector, options = {}) {
        return this._wrapApiCall(this._apiName('uncheck'), async (channel) => {
            await channel.uncheck({ selector, ...options });
        });
    }
    async waitForTimeout(timeout) {
        return this._wrapApiCall(this._apiName('waitForTimeout'), async (channel) => {
            await new Promise(fulfill => setTimeout(fulfill, timeout));
        });
    }
    async waitForFunction(pageFunction, arg, options = {}) {
        return this._wrapApiCall(this._apiName('waitForFunction'), async (channel) => {
            if (typeof options.polling === 'string')
                utils_1.assert(options.polling === 'raf', 'Unknown polling option: ' + options.polling);
            const result = await channel.waitForFunction({
                ...options,
                pollingInterval: options.polling === 'raf' ? undefined : options.polling,
                expression: String(pageFunction),
                isFunction: typeof pageFunction === 'function',
                arg: jsHandle_1.serializeArgument(arg),
            });
            return jsHandle_1.JSHandle.from(result.handle);
        });
    }
    async title() {
        return this._wrapApiCall(this._apiName('title'), async (channel) => {
            return (await channel.title()).value;
        });
    }
}
exports.Frame = Frame;
function verifyLoadState(name, waitUntil) {
    if (waitUntil === 'networkidle0')
        waitUntil = 'networkidle';
    if (!types_1.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle)`);
    return waitUntil;
}
exports.verifyLoadState = verifyLoadState;
//# sourceMappingURL=frame.js.map

/***/ }),

/***/ 4887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;
class Keyboard {
    constructor(channel) {
        this._channel = channel;
    }
    async down(key) {
        await this._channel.keyboardDown({ key });
    }
    async up(key) {
        await this._channel.keyboardUp({ key });
    }
    async insertText(text) {
        await this._channel.keyboardInsertText({ text });
    }
    async type(text, options = {}) {
        await this._channel.keyboardType({ text, ...options });
    }
    async press(key, options = {}) {
        await this._channel.keyboardPress({ key, ...options });
    }
}
exports.Keyboard = Keyboard;
class Mouse {
    constructor(channel) {
        this._channel = channel;
    }
    async move(x, y, options = {}) {
        await this._channel.mouseMove({ x, y, ...options });
    }
    async down(options = {}) {
        await this._channel.mouseDown({ ...options });
    }
    async up(options = {}) {
        await this._channel.mouseUp(options);
    }
    async click(x, y, options = {}) {
        await this._channel.mouseClick({ x, y, ...options });
    }
    async dblclick(x, y, options = {}) {
        await this.click(x, y, { ...options, clickCount: 2 });
    }
}
exports.Mouse = Mouse;
class Touchscreen {
    constructor(channel) {
        this._channel = channel;
    }
    async tap(x, y) {
        await this._channel.touchscreenTap({ x, y });
    }
}
exports.Touchscreen = Touchscreen;
//# sourceMappingURL=input.js.map

/***/ }),

/***/ 7540:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertMaxArguments = exports.parseResult = exports.serializeArgument = exports.JSHandle = void 0;
const channelOwner_1 = __nccwpck_require__(772);
const serializers_1 = __nccwpck_require__(9546);
class JSHandle extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._preview = this._initializer.preview;
        this._channel.on('previewUpdated', ({ preview }) => this._preview = preview);
    }
    static from(handle) {
        return handle._object;
    }
    async evaluate(pageFunction, arg) {
        return this._wrapApiCall('jsHandle.evaluate', async (channel) => {
            const result = await channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });
            return parseResult(result.value);
        });
    }
    async evaluateHandle(pageFunction, arg) {
        return this._wrapApiCall('jsHandle.evaluateHandle', async (channel) => {
            const result = await channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });
            return JSHandle.from(result.handle);
        });
    }
    async getProperty(propertyName) {
        return this._wrapApiCall('jsHandle.getProperty', async (channel) => {
            const result = await channel.getProperty({ name: propertyName });
            return JSHandle.from(result.handle);
        });
    }
    async getProperties() {
        return this._wrapApiCall('jsHandle.getProperties', async (channel) => {
            const map = new Map();
            for (const { name, value } of (await channel.getPropertyList()).properties)
                map.set(name, JSHandle.from(value));
            return map;
        });
    }
    async jsonValue() {
        return this._wrapApiCall('jsHandle.jsonValue', async (channel) => {
            return parseResult((await channel.jsonValue()).value);
        });
    }
    asElement() {
        return null;
    }
    async dispose() {
        return this._wrapApiCall('jsHandle.dispose', async (channel) => {
            return await channel.dispose();
        });
    }
    toString() {
        return this._preview;
    }
}
exports.JSHandle = JSHandle;
// This function takes care of converting all JSHandles to their channels,
// so that generic channel serializer converts them to guids.
function serializeArgument(arg) {
    const handles = [];
    const pushHandle = (channel) => {
        handles.push(channel);
        return handles.length - 1;
    };
    const value = serializers_1.serializeValue(arg, value => {
        if (value instanceof JSHandle)
            return { h: pushHandle(value._channel) };
        return { fallThrough: value };
    }, new Set());
    return { value, handles };
}
exports.serializeArgument = serializeArgument;
function parseResult(value) {
    return serializers_1.parseSerializedValue(value, undefined);
}
exports.parseResult = parseResult;
function assertMaxArguments(count, max) {
    if (count > max)
        throw new Error('Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.');
}
exports.assertMaxArguments = assertMaxArguments;
//# sourceMappingURL=jsHandle.js.map

/***/ }),

/***/ 3510:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateHeaders = exports.WebSocket = exports.Response = exports.Route = exports.Request = void 0;
const url_1 = __nccwpck_require__(8835);
const channelOwner_1 = __nccwpck_require__(772);
const frame_1 = __nccwpck_require__(1408);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const mime = __importStar(__nccwpck_require__(8640));
const utils_1 = __nccwpck_require__(6416);
const events_1 = __nccwpck_require__(2387);
const waiter_1 = __nccwpck_require__(5338);
class Request extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
            this._redirectedFrom._redirectedTo = this;
        this._headers = utils_1.headersArrayToObject(initializer.headers, true /* lowerCase */);
        this._postData = initializer.postData ? Buffer.from(initializer.postData, 'base64') : null;
        this._timing = {
            startTime: 0,
            domainLookupStart: -1,
            domainLookupEnd: -1,
            connectStart: -1,
            secureConnectionStart: -1,
            connectEnd: -1,
            requestStart: -1,
            responseStart: -1,
            responseEnd: -1,
        };
    }
    static from(request) {
        return request._object;
    }
    static fromNullable(request) {
        return request ? Request.from(request) : null;
    }
    url() {
        return this._initializer.url;
    }
    resourceType() {
        return this._initializer.resourceType;
    }
    method() {
        return this._initializer.method;
    }
    postData() {
        return this._postData ? this._postData.toString('utf8') : null;
    }
    postDataBuffer() {
        return this._postData;
    }
    postDataJSON() {
        const postData = this.postData();
        if (!postData)
            return null;
        const contentType = this.headers()['content-type'];
        if (contentType === 'application/x-www-form-urlencoded') {
            const entries = {};
            const parsed = new url_1.URLSearchParams(postData);
            for (const [k, v] of parsed.entries())
                entries[k] = v;
            return entries;
        }
        try {
            return JSON.parse(postData);
        }
        catch (e) {
            throw new Error('POST data is not a valid JSON object: ' + postData);
        }
    }
    headers() {
        return { ...this._headers };
    }
    async response() {
        return this._wrapApiCall('request.response', async (channel) => {
            return Response.fromNullable((await channel.response()).response);
        });
    }
    frame() {
        return frame_1.Frame.from(this._initializer.frame);
    }
    isNavigationRequest() {
        return this._initializer.isNavigationRequest;
    }
    redirectedFrom() {
        return this._redirectedFrom;
    }
    redirectedTo() {
        return this._redirectedTo;
    }
    failure() {
        if (this._failureText === null)
            return null;
        return {
            errorText: this._failureText
        };
    }
    timing() {
        return this._timing;
    }
    _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
    }
}
exports.Request = Request;
class Route extends channelOwner_1.ChannelOwner {
    static from(route) {
        return route._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
    }
    request() {
        return Request.from(this._initializer.request);
    }
    async abort(errorCode) {
        return this._wrapApiCall('route.abort', async (channel) => {
            await channel.abort({ errorCode });
        });
    }
    async fulfill(options = {}) {
        return this._wrapApiCall('route.fulfill', async (channel) => {
            let body = '';
            let isBase64 = false;
            let length = 0;
            if (options.path) {
                const buffer = await fs_1.default.promises.readFile(options.path);
                body = buffer.toString('base64');
                isBase64 = true;
                length = buffer.length;
            }
            else if (utils_1.isString(options.body)) {
                body = options.body;
                isBase64 = false;
                length = Buffer.byteLength(body);
            }
            else if (options.body) {
                body = options.body.toString('base64');
                isBase64 = true;
                length = options.body.length;
            }
            const headers = {};
            for (const header of Object.keys(options.headers || {}))
                headers[header.toLowerCase()] = String(options.headers[header]);
            if (options.contentType)
                headers['content-type'] = String(options.contentType);
            else if (options.path)
                headers['content-type'] = mime.getType(options.path) || 'application/octet-stream';
            if (length && !('content-length' in headers))
                headers['content-length'] = String(length);
            await channel.fulfill({
                status: options.status || 200,
                headers: utils_1.headersObjectToArray(headers),
                body,
                isBase64
            });
        });
    }
    async continue(options = {}) {
        return this._wrapApiCall('route.continue', async (channel) => {
            const postDataBuffer = utils_1.isString(options.postData) ? Buffer.from(options.postData, 'utf8') : options.postData;
            await channel.continue({
                url: options.url,
                method: options.method,
                headers: options.headers ? utils_1.headersObjectToArray(options.headers) : undefined,
                postData: postDataBuffer ? postDataBuffer.toString('base64') : undefined,
            });
        });
    }
}
exports.Route = Route;
class Response extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._headers = utils_1.headersArrayToObject(initializer.headers, true /* lowerCase */);
        this._request = Request.from(this._initializer.request);
        this._request._headers = utils_1.headersArrayToObject(initializer.requestHeaders, true /* lowerCase */);
        Object.assign(this._request._timing, this._initializer.timing);
    }
    static from(response) {
        return response._object;
    }
    static fromNullable(response) {
        return response ? Response.from(response) : null;
    }
    url() {
        return this._initializer.url;
    }
    ok() {
        return this._initializer.status === 0 || (this._initializer.status >= 200 && this._initializer.status <= 299);
    }
    status() {
        return this._initializer.status;
    }
    statusText() {
        return this._initializer.statusText;
    }
    headers() {
        return { ...this._headers };
    }
    async finished() {
        const result = await this._channel.finished();
        if (result.error)
            return new Error(result.error);
        return null;
    }
    async body() {
        return this._wrapApiCall('response.body', async (channel) => {
            return Buffer.from((await channel.body()).binary, 'base64');
        });
    }
    async text() {
        const content = await this.body();
        return content.toString('utf8');
    }
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    request() {
        return this._request;
    }
    frame() {
        return this._request.frame();
    }
}
exports.Response = Response;
class WebSocket extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._isClosed = false;
        this._page = parent;
        this._channel.on('frameSent', (event) => {
            const payload = event.opcode === 2 ? Buffer.from(event.data, 'base64') : event.data;
            this.emit(events_1.Events.WebSocket.FrameSent, { payload });
        });
        this._channel.on('frameReceived', (event) => {
            const payload = event.opcode === 2 ? Buffer.from(event.data, 'base64') : event.data;
            this.emit(events_1.Events.WebSocket.FrameReceived, { payload });
        });
        this._channel.on('socketError', ({ error }) => this.emit(events_1.Events.WebSocket.Error, error));
        this._channel.on('close', () => {
            this._isClosed = true;
            this.emit(events_1.Events.WebSocket.Close, this);
        });
    }
    static from(webSocket) {
        return webSocket._object;
    }
    url() {
        return this._initializer.url;
    }
    isClosed() {
        return this._isClosed;
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, 'webSocket', event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.WebSocket.Error)
            waiter.rejectOnEvent(this, events_1.Events.WebSocket.Error, new Error('Socket error'));
        if (event !== events_1.Events.WebSocket.Close)
            waiter.rejectOnEvent(this, events_1.Events.WebSocket.Close, new Error('Socket closed'));
        waiter.rejectOnEvent(this._page, events_1.Events.Page.Close, new Error('Page closed'));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
    }
}
exports.WebSocket = WebSocket;
function validateHeaders(headers) {
    for (const key of Object.keys(headers)) {
        const value = headers[key];
        if (!Object.is(value, undefined) && !utils_1.isString(value))
            throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
    }
}
exports.validateHeaders = validateHeaders;
//# sourceMappingURL=network.js.map

/***/ }),

/***/ 4713:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BindingCall = exports.Page = void 0;
const events_1 = __nccwpck_require__(2387);
const utils_1 = __nccwpck_require__(6416);
const timeoutSettings_1 = __nccwpck_require__(9255);
const serializers_1 = __nccwpck_require__(9546);
const accessibility_1 = __nccwpck_require__(8820);
const channelOwner_1 = __nccwpck_require__(772);
const consoleMessage_1 = __nccwpck_require__(4141);
const dialog_1 = __nccwpck_require__(7662);
const download_1 = __nccwpck_require__(8810);
const elementHandle_1 = __nccwpck_require__(4460);
const worker_1 = __nccwpck_require__(5321);
const frame_1 = __nccwpck_require__(1408);
const input_1 = __nccwpck_require__(4887);
const jsHandle_1 = __nccwpck_require__(7540);
const network_1 = __nccwpck_require__(3510);
const fileChooser_1 = __nccwpck_require__(8796);
const buffer_1 = __nccwpck_require__(4293);
const coverage_1 = __nccwpck_require__(215);
const waiter_1 = __nccwpck_require__(5338);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
const clientHelper_1 = __nccwpck_require__(9556);
const utils_2 = __nccwpck_require__(6416);
const errors_1 = __nccwpck_require__(4949);
const video_1 = __nccwpck_require__(3103);
const artifact_1 = __nccwpck_require__(9214);
class Page extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._frames = new Set();
        this._workers = new Set();
        this._closed = false;
        this._routes = [];
        this._bindings = new Map();
        this._isPageCall = false;
        this._video = null;
        this._browserContext = parent;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(this._browserContext._timeoutSettings);
        this.accessibility = new accessibility_1.Accessibility(this._channel);
        this.keyboard = new input_1.Keyboard(this._channel);
        this.mouse = new input_1.Mouse(this._channel);
        this.touchscreen = new input_1.Touchscreen(this._channel);
        this._mainFrame = frame_1.Frame.from(initializer.mainFrame);
        this._mainFrame._page = this;
        this._frames.add(this._mainFrame);
        this._viewportSize = initializer.viewportSize || null;
        this._closed = initializer.isClosed;
        this._opener = Page.fromNullable(initializer.opener);
        this._channel.on('bindingCall', ({ binding }) => this._onBinding(BindingCall.from(binding)));
        this._channel.on('close', () => this._onClose());
        this._channel.on('console', ({ message }) => this.emit(events_1.Events.Page.Console, consoleMessage_1.ConsoleMessage.from(message)));
        this._channel.on('crash', () => this._onCrash());
        this._channel.on('dialog', ({ dialog }) => {
            if (!this.emit(events_1.Events.Page.Dialog, dialog_1.Dialog.from(dialog)))
                dialog.dismiss().catch(() => { });
        });
        this._channel.on('domcontentloaded', () => this.emit(events_1.Events.Page.DOMContentLoaded, this));
        this._channel.on('download', ({ url, suggestedFilename, artifact }) => {
            const artifactObject = artifact_1.Artifact.from(artifact);
            artifactObject._isRemote = !!this._browserContext._browser && !!this._browserContext._browser._remoteType;
            this.emit(events_1.Events.Page.Download, new download_1.Download(this, url, suggestedFilename, artifactObject));
        });
        this._channel.on('fileChooser', ({ element, isMultiple }) => this.emit(events_1.Events.Page.FileChooser, new fileChooser_1.FileChooser(this, elementHandle_1.ElementHandle.from(element), isMultiple)));
        this._channel.on('frameAttached', ({ frame }) => this._onFrameAttached(frame_1.Frame.from(frame)));
        this._channel.on('frameDetached', ({ frame }) => this._onFrameDetached(frame_1.Frame.from(frame)));
        this._channel.on('load', () => this.emit(events_1.Events.Page.Load, this));
        this._channel.on('pageError', ({ error }) => this.emit(events_1.Events.Page.PageError, serializers_1.parseError(error)));
        this._channel.on('route', ({ route, request }) => this._onRoute(network_1.Route.from(route), network_1.Request.from(request)));
        this._channel.on('video', ({ artifact }) => {
            const artifactObject = artifact_1.Artifact.from(artifact);
            this._forceVideo()._artifactReady(artifactObject);
        });
        this._channel.on('webSocket', ({ webSocket }) => this.emit(events_1.Events.Page.WebSocket, network_1.WebSocket.from(webSocket)));
        this._channel.on('worker', ({ worker }) => this._onWorker(worker_1.Worker.from(worker)));
        this.coverage = new coverage_1.Coverage(this._channel);
        this._closedOrCrashedPromise = Promise.race([
            new Promise(f => this.once(events_1.Events.Page.Close, f)),
            new Promise(f => this.once(events_1.Events.Page.Crash, f)),
        ]);
    }
    static from(page) {
        return page._object;
    }
    static fromNullable(page) {
        return page ? Page.from(page) : null;
    }
    _onFrameAttached(frame) {
        frame._page = this;
        this._frames.add(frame);
        if (frame._parentFrame)
            frame._parentFrame._childFrames.add(frame);
        this.emit(events_1.Events.Page.FrameAttached, frame);
    }
    _onFrameDetached(frame) {
        this._frames.delete(frame);
        frame._detached = true;
        if (frame._parentFrame)
            frame._parentFrame._childFrames.delete(frame);
        this.emit(events_1.Events.Page.FrameDetached, frame);
    }
    _onRoute(route, request) {
        for (const { url, handler } of this._routes) {
            if (clientHelper_1.urlMatches(request.url(), url)) {
                handler(route, request);
                return;
            }
        }
        this._browserContext._onRoute(route, request);
    }
    async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (func) {
            await bindingCall.call(func);
            return;
        }
        await this._browserContext._onBinding(bindingCall);
    }
    _onWorker(worker) {
        this._workers.add(worker);
        worker._page = this;
        this.emit(events_1.Events.Page.Worker, worker);
    }
    _onClose() {
        this._closed = true;
        this._browserContext._pages.delete(this);
        this._browserContext._backgroundPages.delete(this);
        this.emit(events_1.Events.Page.Close, this);
    }
    _onCrash() {
        this.emit(events_1.Events.Page.Crash, this);
    }
    context() {
        return this._browserContext;
    }
    async opener() {
        if (!this._opener || this._opener.isClosed())
            return null;
        return this._opener;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frame(frameSelector) {
        const name = utils_2.isString(frameSelector) ? frameSelector : frameSelector.name;
        const url = utils_2.isObject(frameSelector) ? frameSelector.url : undefined;
        utils_1.assert(name || url, 'Either name or url matcher should be specified');
        return this.frames().find(f => {
            if (name)
                return f.name() === name;
            return clientHelper_1.urlMatches(f.url(), url);
        }) || null;
    }
    frames() {
        return [...this._frames];
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._channel.setDefaultNavigationTimeoutNoReply({ timeout });
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({ timeout });
    }
    _forceVideo() {
        if (!this._video)
            this._video = new video_1.Video(this);
        return this._video;
    }
    video() {
        // Note: we are creating Video object lazily, because we do not know
        // BrowserContextOptions when constructing the page - it is assigned
        // too late during launchPersistentContext.
        if (!this._browserContext._options.recordVideo)
            return null;
        return this._forceVideo();
    }
    _attributeToPage(func) {
        try {
            this._isPageCall = true;
            return func();
        }
        finally {
            this._isPageCall = false;
        }
    }
    async $(selector) {
        return this._attributeToPage(() => this._mainFrame.$(selector));
    }
    async waitForSelector(selector, options) {
        return this._attributeToPage(() => this._mainFrame.waitForSelector(selector, options));
    }
    async dispatchEvent(selector, type, eventInit, options) {
        return this._attributeToPage(() => this._mainFrame.dispatchEvent(selector, type, eventInit, options));
    }
    async evaluateHandle(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._attributeToPage(() => this._mainFrame.evaluateHandle(pageFunction, arg));
    }
    async $eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._attributeToPage(() => this._mainFrame.$eval(selector, pageFunction, arg));
    }
    async $$eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._attributeToPage(() => this._mainFrame.$$eval(selector, pageFunction, arg));
    }
    async $$(selector) {
        return this._attributeToPage(() => this._mainFrame.$$(selector));
    }
    async addScriptTag(options = {}) {
        return this._attributeToPage(() => this._mainFrame.addScriptTag(options));
    }
    async addStyleTag(options = {}) {
        return this._attributeToPage(() => this._mainFrame.addStyleTag(options));
    }
    async exposeFunction(name, callback) {
        return this._wrapApiCall('page.exposeFunction', async (channel) => {
            await channel.exposeBinding({ name });
            const binding = (source, ...args) => callback(...args);
            this._bindings.set(name, binding);
        });
    }
    async exposeBinding(name, callback, options = {}) {
        return this._wrapApiCall('page.exposeBinding', async (channel) => {
            await channel.exposeBinding({ name, needsHandle: options.handle });
            this._bindings.set(name, callback);
        });
    }
    async setExtraHTTPHeaders(headers) {
        return this._wrapApiCall('page.setExtraHTTPHeaders', async (channel) => {
            network_1.validateHeaders(headers);
            await channel.setExtraHTTPHeaders({ headers: utils_2.headersObjectToArray(headers) });
        });
    }
    url() {
        return this._attributeToPage(() => this._mainFrame.url());
    }
    async content() {
        return this._attributeToPage(() => this._mainFrame.content());
    }
    async setContent(html, options) {
        return this._attributeToPage(() => this._mainFrame.setContent(html, options));
    }
    async goto(url, options) {
        return this._attributeToPage(() => this._mainFrame.goto(url, options));
    }
    async reload(options = {}) {
        return this._wrapApiCall('page.reload', async (channel) => {
            const waitUntil = frame_1.verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            return network_1.Response.fromNullable((await channel.reload({ ...options, waitUntil })).response);
        });
    }
    async waitForLoadState(state, options) {
        return this._attributeToPage(() => this._mainFrame.waitForLoadState(state, options));
    }
    async waitForNavigation(options) {
        return this._attributeToPage(() => this._mainFrame.waitForNavigation(options));
    }
    async waitForURL(url, options) {
        return this._attributeToPage(() => this._mainFrame.waitForURL(url, options));
    }
    async waitForRequest(urlOrPredicate, options = {}) {
        return this._wrapApiCall('page.waitForRequest', async (channel) => {
            const predicate = (request) => {
                if (utils_2.isString(urlOrPredicate) || utils_2.isRegExp(urlOrPredicate))
                    return clientHelper_1.urlMatches(request.url(), urlOrPredicate);
                return urlOrPredicate(request);
            };
            const trimmedUrl = trimUrl(urlOrPredicate);
            const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : undefined;
            return this._waitForEvent(events_1.Events.Page.Request, { predicate, timeout: options.timeout }, logLine);
        });
    }
    async waitForResponse(urlOrPredicate, options = {}) {
        return this._wrapApiCall('page.waitForResponse', async (channel) => {
            const predicate = (response) => {
                if (utils_2.isString(urlOrPredicate) || utils_2.isRegExp(urlOrPredicate))
                    return clientHelper_1.urlMatches(response.url(), urlOrPredicate);
                return urlOrPredicate(response);
            };
            const trimmedUrl = trimUrl(urlOrPredicate);
            const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : undefined;
            return this._waitForEvent(events_1.Events.Page.Response, { predicate, timeout: options.timeout }, logLine);
        });
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall('page.waitForEvent', async (channel) => {
            return this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
        });
    }
    async _waitForEvent(event, optionsOrPredicate, logLine) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, 'page', event);
        if (logLine)
            waiter.log(logLine);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.Page.Crash)
            waiter.rejectOnEvent(this, events_1.Events.Page.Crash, new Error('Page crashed'));
        if (event !== events_1.Events.Page.Close)
            waiter.rejectOnEvent(this, events_1.Events.Page.Close, new Error('Page closed'));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
    }
    async goBack(options = {}) {
        return this._wrapApiCall('page.goBack', async (channel) => {
            const waitUntil = frame_1.verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            return network_1.Response.fromNullable((await channel.goBack({ ...options, waitUntil })).response);
        });
    }
    async goForward(options = {}) {
        return this._wrapApiCall('page.goForward', async (channel) => {
            const waitUntil = frame_1.verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            return network_1.Response.fromNullable((await channel.goForward({ ...options, waitUntil })).response);
        });
    }
    async emulateMedia(options = {}) {
        return this._wrapApiCall('page.emulateMedia', async (channel) => {
            await channel.emulateMedia({
                media: options.media === null ? 'null' : options.media,
                colorScheme: options.colorScheme === null ? 'null' : options.colorScheme,
                reducedMotion: options.reducedMotion === null ? 'null' : options.reducedMotion,
            });
        });
    }
    async setViewportSize(viewportSize) {
        return this._wrapApiCall('page.setViewportSize', async (channel) => {
            this._viewportSize = viewportSize;
            await channel.setViewportSize({ viewportSize });
        });
    }
    viewportSize() {
        return this._viewportSize;
    }
    async evaluate(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._attributeToPage(() => this._mainFrame.evaluate(pageFunction, arg));
    }
    async addInitScript(script, arg) {
        return this._wrapApiCall('page.addInitScript', async (channel) => {
            const source = await clientHelper_1.evaluationScript(script, arg);
            await channel.addInitScript({ source });
        });
    }
    async route(url, handler) {
        return this._wrapApiCall('page.route', async (channel) => {
            this._routes.push({ url, handler });
            if (this._routes.length === 1)
                await channel.setNetworkInterceptionEnabled({ enabled: true });
        });
    }
    async unroute(url, handler) {
        return this._wrapApiCall('page.unroute', async (channel) => {
            this._routes = this._routes.filter(route => route.url !== url || (handler && route.handler !== handler));
            if (this._routes.length === 0)
                await channel.setNetworkInterceptionEnabled({ enabled: false });
        });
    }
    async screenshot(options = {}) {
        return this._wrapApiCall('page.screenshot', async (channel) => {
            const copy = { ...options };
            if (!copy.type)
                copy.type = elementHandle_1.determineScreenshotType(options);
            const result = await channel.screenshot(copy);
            const buffer = buffer_1.Buffer.from(result.binary, 'base64');
            if (options.path) {
                await utils_2.mkdirIfNeeded(options.path);
                await fs_1.default.promises.writeFile(options.path, buffer);
            }
            return buffer;
        });
    }
    async title() {
        return this._attributeToPage(() => this._mainFrame.title());
    }
    async bringToFront() {
        return this._wrapApiCall('page.bringToFront', async (channel) => {
            await channel.bringToFront();
        });
    }
    async close(options = { runBeforeUnload: undefined }) {
        try {
            await this._wrapApiCall('page.close', async (channel) => {
                await channel.close(options);
                if (this._ownedContext)
                    await this._ownedContext.close();
            });
        }
        catch (e) {
            if (errors_1.isSafeCloseError(e))
                return;
            throw e;
        }
    }
    isClosed() {
        return this._closed;
    }
    async click(selector, options) {
        return this._attributeToPage(() => this._mainFrame.click(selector, options));
    }
    async dblclick(selector, options) {
        return this._attributeToPage(() => this._mainFrame.dblclick(selector, options));
    }
    async tap(selector, options) {
        return this._attributeToPage(() => this._mainFrame.tap(selector, options));
    }
    async fill(selector, value, options) {
        return this._attributeToPage(() => this._mainFrame.fill(selector, value, options));
    }
    async focus(selector, options) {
        return this._attributeToPage(() => this._mainFrame.focus(selector, options));
    }
    async textContent(selector, options) {
        return this._attributeToPage(() => this._mainFrame.textContent(selector, options));
    }
    async innerText(selector, options) {
        return this._attributeToPage(() => this._mainFrame.innerText(selector, options));
    }
    async innerHTML(selector, options) {
        return this._attributeToPage(() => this._mainFrame.innerHTML(selector, options));
    }
    async getAttribute(selector, name, options) {
        return this._attributeToPage(() => this._mainFrame.getAttribute(selector, name, options));
    }
    async isChecked(selector, options) {
        return this._attributeToPage(() => this._mainFrame.isChecked(selector, options));
    }
    async isDisabled(selector, options) {
        return this._attributeToPage(() => this._mainFrame.isDisabled(selector, options));
    }
    async isEditable(selector, options) {
        return this._attributeToPage(() => this._mainFrame.isEditable(selector, options));
    }
    async isEnabled(selector, options) {
        return this._attributeToPage(() => this._mainFrame.isEnabled(selector, options));
    }
    async isHidden(selector, options) {
        return this._attributeToPage(() => this._mainFrame.isHidden(selector, options));
    }
    async isVisible(selector, options) {
        return this._attributeToPage(() => this._mainFrame.isVisible(selector, options));
    }
    async hover(selector, options) {
        return this._attributeToPage(() => this._mainFrame.hover(selector, options));
    }
    async selectOption(selector, values, options) {
        return this._attributeToPage(() => this._mainFrame.selectOption(selector, values, options));
    }
    async setInputFiles(selector, files, options) {
        return this._attributeToPage(() => this._mainFrame.setInputFiles(selector, files, options));
    }
    async type(selector, text, options) {
        return this._attributeToPage(() => this._mainFrame.type(selector, text, options));
    }
    async press(selector, key, options) {
        return this._attributeToPage(() => this._mainFrame.press(selector, key, options));
    }
    async check(selector, options) {
        return this._attributeToPage(() => this._mainFrame.check(selector, options));
    }
    async uncheck(selector, options) {
        return this._attributeToPage(() => this._mainFrame.uncheck(selector, options));
    }
    async waitForTimeout(timeout) {
        return this._attributeToPage(() => this._mainFrame.waitForTimeout(timeout));
    }
    async waitForFunction(pageFunction, arg, options) {
        return this._attributeToPage(() => this._mainFrame.waitForFunction(pageFunction, arg, options));
    }
    workers() {
        return [...this._workers];
    }
    on(event, listener) {
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
            this._channel.setFileChooserInterceptedNoReply({ intercepted: true });
        super.on(event, listener);
        return this;
    }
    addListener(event, listener) {
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
            this._channel.setFileChooserInterceptedNoReply({ intercepted: true });
        super.addListener(event, listener);
        return this;
    }
    off(event, listener) {
        super.off(event, listener);
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
            this._channel.setFileChooserInterceptedNoReply({ intercepted: false });
        return this;
    }
    removeListener(event, listener) {
        super.removeListener(event, listener);
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
            this._channel.setFileChooserInterceptedNoReply({ intercepted: false });
        return this;
    }
    async pause() {
        return this.context()._wrapApiCall('page.pause', async (channel) => {
            await channel.pause();
        });
    }
    async pdf(options = {}) {
        return this._wrapApiCall('page.pdf', async (channel) => {
            const transportOptions = { ...options };
            if (transportOptions.margin)
                transportOptions.margin = { ...transportOptions.margin };
            if (typeof options.width === 'number')
                transportOptions.width = options.width + 'px';
            if (typeof options.height === 'number')
                transportOptions.height = options.height + 'px';
            for (const margin of ['top', 'right', 'bottom', 'left']) {
                const index = margin;
                if (options.margin && typeof options.margin[index] === 'number')
                    transportOptions.margin[index] = transportOptions.margin[index] + 'px';
            }
            const result = await channel.pdf(transportOptions);
            const buffer = buffer_1.Buffer.from(result.pdf, 'base64');
            if (options.path) {
                await fs_1.default.promises.mkdir(path_1.default.dirname(options.path), { recursive: true });
                await fs_1.default.promises.writeFile(options.path, buffer);
            }
            return buffer;
        });
    }
}
exports.Page = Page;
class BindingCall extends channelOwner_1.ChannelOwner {
    static from(channel) {
        return channel._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
    }
    async call(func) {
        try {
            const frame = frame_1.Frame.from(this._initializer.frame);
            const source = {
                context: frame._page.context(),
                page: frame._page,
                frame
            };
            let result;
            if (this._initializer.handle)
                result = await func(source, jsHandle_1.JSHandle.from(this._initializer.handle));
            else
                result = await func(source, ...this._initializer.args.map(jsHandle_1.parseResult));
            this._channel.resolve({ result: jsHandle_1.serializeArgument(result) }).catch(() => { });
        }
        catch (e) {
            this._channel.reject({ error: serializers_1.serializeError(e) }).catch(() => { });
        }
    }
}
exports.BindingCall = BindingCall;
function trimEnd(s) {
    if (s.length > 50)
        s = s.substring(0, 50) + '\u2026';
    return s;
}
function trimUrl(param) {
    if (utils_2.isRegExp(param))
        return `/${trimEnd(param.source)}/${param.flags}`;
    if (utils_2.isString(param))
        return `"${trimEnd(param)}"`;
}
//# sourceMappingURL=page.js.map

/***/ }),

/***/ 601:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Playwright = void 0;
const browserType_1 = __nccwpck_require__(1474);
const channelOwner_1 = __nccwpck_require__(772);
const selectors_1 = __nccwpck_require__(7489);
const electron_1 = __nccwpck_require__(1322);
const errors_1 = __nccwpck_require__(4949);
const android_1 = __nccwpck_require__(9779);
const socksSocket_1 = __nccwpck_require__(5904);
class Playwright extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._forwardPorts = [];
        this.chromium = browserType_1.BrowserType.from(initializer.chromium);
        this.firefox = browserType_1.BrowserType.from(initializer.firefox);
        this.webkit = browserType_1.BrowserType.from(initializer.webkit);
        this._android = android_1.Android.from(initializer.android);
        this._electron = electron_1.Electron.from(initializer.electron);
        this.devices = {};
        for (const { name, descriptor } of initializer.deviceDescriptors)
            this.devices[name] = descriptor;
        this.selectors = selectors_1.sharedSelectors;
        this.errors = { TimeoutError: errors_1.TimeoutError };
        this._selectorsOwner = selectors_1.SelectorsOwner.from(initializer.selectors);
        this.selectors._addChannel(this._selectorsOwner);
        this._channel.on('incomingSocksSocket', ({ socket }) => socksSocket_1.SocksSocket.from(socket));
    }
    async _enablePortForwarding(ports) {
        this._forwardPorts = ports;
        await this._channel.setForwardedPorts({ ports });
    }
    _cleanup() {
        this.selectors._removeChannel(this._selectorsOwner);
    }
}
exports.Playwright = Playwright;
//# sourceMappingURL=playwright.js.map

/***/ }),

/***/ 7489:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedSelectors = exports.SelectorsOwner = exports.Selectors = void 0;
const clientHelper_1 = __nccwpck_require__(9556);
const channelOwner_1 = __nccwpck_require__(772);
class Selectors {
    constructor() {
        this._channels = new Set();
        this._registrations = [];
    }
    async register(name, script, options = {}) {
        const source = await clientHelper_1.evaluationScript(script, undefined, false);
        const params = { ...options, name, source };
        for (const channel of this._channels)
            await channel._channel.register(params);
        this._registrations.push(params);
    }
    _addChannel(channel) {
        this._channels.add(channel);
        for (const params of this._registrations) {
            // This should not fail except for connection closure, but just in case we catch.
            channel._channel.register(params).catch(e => { });
        }
    }
    _removeChannel(channel) {
        this._channels.delete(channel);
    }
}
exports.Selectors = Selectors;
class SelectorsOwner extends channelOwner_1.ChannelOwner {
    static from(browser) {
        return browser._object;
    }
}
exports.SelectorsOwner = SelectorsOwner;
exports.sharedSelectors = new Selectors();
//# sourceMappingURL=selectors.js.map

/***/ }),

/***/ 5904:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocksSocket = void 0;
const net_1 = __importDefault(__nccwpck_require__(1631));
const playwright_1 = __nccwpck_require__(601);
const utils_1 = __nccwpck_require__(6416);
const channelOwner_1 = __nccwpck_require__(772);
class SocksSocket extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        utils_1.assert(parent instanceof playwright_1.Playwright);
        utils_1.assert(parent._forwardPorts.includes(this._initializer.dstPort));
        utils_1.assert(utils_1.isLocalIpAddress(this._initializer.dstAddr));
        if (utils_1.isUnderTest() && process.env.PW_TEST_PROXY_TARGET)
            this._initializer.dstPort = Number(process.env.PW_TEST_PROXY_TARGET);
        this._socket = net_1.default.createConnection(this._initializer.dstPort, this._initializer.dstAddr);
        this._socket.on('error', (err) => this._channel.error({ error: String(err) }));
        this._socket.on('connect', () => {
            this.connected().catch(() => { });
            this._socket.on('data', data => this.write(data).catch(() => { }));
        });
        this._socket.on('close', () => {
            this.end().catch(() => { });
        });
        this._channel.on('data', ({ data }) => {
            if (!this._socket.writable)
                return;
            this._socket.write(Buffer.from(data, 'base64'));
        });
        this._channel.on('close', () => this._socket.end());
        this._connection.on('disconnect', () => this._socket.end());
    }
    static from(socket) {
        return socket._object;
    }
    async write(data) {
        await this._channel.write({ data: data.toString('base64') });
    }
    async end() {
        await this._channel.end();
    }
    async connected() {
        await this._channel.connected();
    }
}
exports.SocksSocket = SocksSocket;
//# sourceMappingURL=socksSocket.js.map

/***/ }),

/***/ 5377:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stream = void 0;
const stream_1 = __nccwpck_require__(2413);
const channelOwner_1 = __nccwpck_require__(772);
class Stream extends channelOwner_1.ChannelOwner {
    static from(Stream) {
        return Stream._object;
    }
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
    }
    stream() {
        return new StreamImpl(this._channel);
    }
}
exports.Stream = Stream;
class StreamImpl extends stream_1.Readable {
    constructor(channel) {
        super();
        this._channel = channel;
    }
    async _read(size) {
        const result = await this._channel.read({ size });
        if (result.binary)
            this.push(Buffer.from(result.binary, 'base64'));
        else
            this.push(null);
    }
    _destroy(error, callback) {
        // Stream might be destroyed after the connection was closed.
        this._channel.close().catch(e => null);
        super._destroy(error, callback);
    }
}
//# sourceMappingURL=stream.js.map

/***/ }),

/***/ 9464:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tracing = void 0;
const artifact_1 = __nccwpck_require__(9214);
class Tracing {
    constructor(channel) {
        this._context = channel;
    }
    async start(options = {}) {
        await this._context._wrapApiCall('tracing.start', async (channel) => {
            return await channel.tracingStart(options);
        });
    }
    async stop(options = {}) {
        await this._context._wrapApiCall('tracing.stop', async (channel) => {
            var _a;
            await channel.tracingStop();
            if (options.path) {
                const result = await channel.tracingExport();
                const artifact = artifact_1.Artifact.from(result.artifact);
                if ((_a = this._context.browser()) === null || _a === void 0 ? void 0 : _a._remoteType)
                    artifact._isRemote = true;
                await artifact.saveAs(options.path);
                await artifact.delete();
            }
        });
    }
}
exports.Tracing = Tracing;
//# sourceMappingURL=tracing.js.map

/***/ }),

/***/ 9856:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kLifecycleEvents = void 0;
exports.kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle']);
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 3103:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Video = void 0;
class Video {
    constructor(page) {
        this._artifact = null;
        this._artifactCallback = (artifact) => { };
        this._isRemote = false;
        const browser = page.context()._browser;
        this._isRemote = !!browser && !!browser._remoteType;
        this._artifact = Promise.race([
            new Promise(f => this._artifactCallback = f),
            page._closedOrCrashedPromise.then(() => null),
        ]);
    }
    _artifactReady(artifact) {
        artifact._isRemote = this._isRemote;
        this._artifactCallback(artifact);
    }
    async path() {
        if (this._isRemote)
            throw new Error(`Path is not available when using browserType.connect(). Use saveAs() to save a local copy.`);
        const artifact = await this._artifact;
        if (!artifact)
            throw new Error('Page did not produce any video frames');
        return artifact._initializer.absolutePath;
    }
    async saveAs(path) {
        const artifact = await this._artifact;
        if (!artifact)
            throw new Error('Page did not produce any video frames');
        return artifact.saveAs(path);
    }
    async delete() {
        const artifact = await this._artifact;
        if (artifact)
            await artifact.delete();
    }
}
exports.Video = Video;
//# sourceMappingURL=video.js.map

/***/ }),

/***/ 5338:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Waiter = void 0;
const stackTrace_1 = __nccwpck_require__(6010);
const errors_1 = __nccwpck_require__(4949);
const utils_1 = __nccwpck_require__(6416);
class Waiter {
    constructor(channelOwner, apiName) {
        this._failures = [];
        // TODO: can/should we move these logs into wrapApiCall?
        this._logs = [];
        this._waitId = utils_1.createGuid();
        this._channelOwner = channelOwner;
        this._channelOwner._waitForEventInfoBefore(this._waitId, apiName);
        this._dispose = [
            () => this._channelOwner._waitForEventInfoAfter(this._waitId, this._error)
        ];
    }
    static createForEvent(channelOwner, target, event) {
        return new Waiter(channelOwner, `${target}.waitForEvent(${event})`);
    }
    async waitForEvent(emitter, event, predicate) {
        const { promise, dispose } = waitForEvent(emitter, event, predicate);
        return this.waitForPromise(promise, dispose);
    }
    rejectOnEvent(emitter, event, error, predicate) {
        const { promise, dispose } = waitForEvent(emitter, event, predicate);
        this._rejectOn(promise.then(() => { throw error; }), dispose);
    }
    rejectOnTimeout(timeout, message) {
        if (!timeout)
            return;
        const { promise, dispose } = waitForTimeout(timeout);
        this._rejectOn(promise.then(() => { throw new errors_1.TimeoutError(message); }), dispose);
    }
    rejectImmediately(error) {
        this._immediateError = error;
    }
    dispose() {
        for (const dispose of this._dispose)
            dispose();
    }
    async waitForPromise(promise, dispose) {
        try {
            if (this._immediateError)
                throw this._immediateError;
            const result = await Promise.race([promise, ...this._failures]);
            if (dispose)
                dispose();
            return result;
        }
        catch (e) {
            if (dispose)
                dispose();
            this._error = e.message;
            this.dispose();
            stackTrace_1.rewriteErrorMessage(e, e.message + formatLogRecording(this._logs) + kLoggingNote);
            throw e;
        }
    }
    log(s) {
        this._logs.push(s);
        this._channelOwner._waitForEventInfoLog(this._waitId, s);
    }
    _rejectOn(promise, dispose) {
        this._failures.push(promise);
        if (dispose)
            this._dispose.push(dispose);
    }
}
exports.Waiter = Waiter;
function waitForEvent(emitter, event, predicate) {
    let listener;
    const promise = new Promise((resolve, reject) => {
        listener = async (eventArg) => {
            try {
                if (predicate && !(await predicate(eventArg)))
                    return;
                emitter.removeListener(event, listener);
                resolve(eventArg);
            }
            catch (e) {
                emitter.removeListener(event, listener);
                reject(e);
            }
        };
        emitter.addListener(event, listener);
    });
    const dispose = () => emitter.removeListener(event, listener);
    return { promise, dispose };
}
function waitForTimeout(timeout) {
    let timeoutId;
    const promise = new Promise(resolve => timeoutId = setTimeout(resolve, timeout));
    const dispose = () => clearTimeout(timeoutId);
    return { promise, dispose };
}
const kLoggingNote = `\nNote: use DEBUG=pw:api environment variable to capture Playwright logs.`;
function formatLogRecording(log) {
    if (!log.length)
        return '';
    const header = ` logs `;
    const headerLength = 60;
    const leftLength = (headerLength - header.length) / 2;
    const rightLength = headerLength - header.length - leftLength;
    return `\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\n${log.join('\n')}\n${'='.repeat(headerLength)}`;
}
//# sourceMappingURL=waiter.js.map

/***/ }),

/***/ 5321:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Worker = void 0;
const events_1 = __nccwpck_require__(2387);
const channelOwner_1 = __nccwpck_require__(772);
const jsHandle_1 = __nccwpck_require__(7540);
class Worker extends channelOwner_1.ChannelOwner {
    constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on('close', () => {
            if (this._page)
                this._page._workers.delete(this);
            if (this._context)
                this._context._serviceWorkers.delete(this);
            this.emit(events_1.Events.Worker.Close, this);
        });
    }
    static from(worker) {
        return worker._object;
    }
    url() {
        return this._initializer.url;
    }
    async evaluate(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall('worker.evaluate', async (channel) => {
            const result = await channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.parseResult(result.value);
        });
    }
    async evaluateHandle(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall('worker.evaluateHandle', async (channel) => {
            const result = await channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) });
            return jsHandle_1.JSHandle.from(result.handle);
        });
    }
}
exports.Worker = Worker;
//# sourceMappingURL=worker.js.map

/***/ }),

/***/ 3893:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AndroidSocketDispatcher = exports.AndroidDeviceDispatcher = exports.AndroidDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const android_1 = __nccwpck_require__(2184);
const browserContextDispatcher_1 = __nccwpck_require__(8312);
class AndroidDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, android) {
        super(scope, android, 'Android', {}, true);
    }
    async devices(params) {
        const devices = await this._object.devices();
        return {
            devices: devices.map(d => AndroidDeviceDispatcher.from(this._scope, d))
        };
    }
    async setDefaultTimeoutNoReply(params) {
        this._object.setDefaultTimeout(params.timeout);
    }
}
exports.AndroidDispatcher = AndroidDispatcher;
class AndroidDeviceDispatcher extends dispatcher_1.Dispatcher {
    static from(scope, device) {
        const result = dispatcher_1.existingDispatcher(device);
        return result || new AndroidDeviceDispatcher(scope, device);
    }
    constructor(scope, device) {
        super(scope, device, 'AndroidDevice', {
            model: device.model,
            serial: device.serial,
        }, true);
        for (const webView of device.webViews())
            this._dispatchEvent('webViewAdded', { webView });
        device.on(android_1.AndroidDevice.Events.WebViewAdded, webView => this._dispatchEvent('webViewAdded', { webView }));
        device.on(android_1.AndroidDevice.Events.WebViewRemoved, pid => this._dispatchEvent('webViewRemoved', { pid }));
    }
    async wait(params) {
        await this._object.send('wait', params);
    }
    async fill(params) {
        await this._object.send('click', { selector: params.selector });
        await this._object.send('fill', params);
    }
    async tap(params) {
        await this._object.send('click', params);
    }
    async drag(params) {
        await this._object.send('drag', params);
    }
    async fling(params) {
        await this._object.send('fling', params);
    }
    async longTap(params) {
        await this._object.send('longClick', params);
    }
    async pinchClose(params) {
        await this._object.send('pinchClose', params);
    }
    async pinchOpen(params) {
        await this._object.send('pinchOpen', params);
    }
    async scroll(params) {
        await this._object.send('scroll', params);
    }
    async swipe(params) {
        await this._object.send('swipe', params);
    }
    async info(params) {
        return { info: await this._object.send('info', params) };
    }
    async inputType(params) {
        const text = params.text;
        const keyCodes = [];
        for (let i = 0; i < text.length; ++i) {
            const code = keyMap.get(text[i].toUpperCase());
            if (code === undefined)
                throw new Error('No mapping for ' + text[i] + ' found');
            keyCodes.push(code);
        }
        await Promise.all(keyCodes.map(keyCode => this._object.send('inputPress', { keyCode })));
    }
    async inputPress(params) {
        if (!keyMap.has(params.key))
            throw new Error('Unknown key: ' + params.key);
        await this._object.send('inputPress', { keyCode: keyMap.get(params.key) });
    }
    async inputTap(params) {
        await this._object.send('inputClick', params);
    }
    async inputSwipe(params) {
        await this._object.send('inputSwipe', params);
    }
    async inputDrag(params) {
        await this._object.send('inputDrag', params);
    }
    async screenshot(params) {
        return { binary: (await this._object.screenshot()).toString('base64') };
    }
    async shell(params) {
        return { result: (await this._object.shell(params.command)).toString('base64') };
    }
    async open(params, metadata) {
        const socket = await this._object.open(params.command);
        return { socket: new AndroidSocketDispatcher(this._scope, socket) };
    }
    async installApk(params) {
        await this._object.installApk(Buffer.from(params.file, 'base64'), { args: params.args });
    }
    async push(params) {
        await this._object.push(Buffer.from(params.file, 'base64'), params.path, params.mode);
    }
    async launchBrowser(params) {
        const context = await this._object.launchBrowser(params.pkg, params);
        return { context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, context) };
    }
    async close(params) {
        await this._object.close();
    }
    async setDefaultTimeoutNoReply(params) {
        this._object.setDefaultTimeout(params.timeout);
    }
    async connectToWebView(params) {
        return { context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, await this._object.connectToWebView(params.pid, params.sdkLanguage)) };
    }
}
exports.AndroidDeviceDispatcher = AndroidDeviceDispatcher;
class AndroidSocketDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, socket) {
        super(scope, socket, 'AndroidSocket', {}, true);
        socket.on('data', (data) => this._dispatchEvent('data', { data: data.toString('base64') }));
        socket.on('close', () => {
            this._dispatchEvent('close');
            this._dispose();
        });
    }
    async write(params, metadata) {
        await this._object.write(Buffer.from(params.data, 'base64'));
    }
    async close(params, metadata) {
        this._object.close();
    }
}
exports.AndroidSocketDispatcher = AndroidSocketDispatcher;
const keyMap = new Map([
    ['Unknown', 0],
    ['SoftLeft', 1],
    ['SoftRight', 2],
    ['Home', 3],
    ['Back', 4],
    ['Call', 5],
    ['EndCall', 6],
    ['0', 7],
    ['1', 8],
    ['2', 9],
    ['3', 10],
    ['4', 11],
    ['5', 12],
    ['6', 13],
    ['7', 14],
    ['8', 15],
    ['9', 16],
    ['Star', 17],
    ['*', 17],
    ['Pound', 18],
    ['#', 18],
    ['DialUp', 19],
    ['DialDown', 20],
    ['DialLeft', 21],
    ['DialRight', 22],
    ['DialCenter', 23],
    ['VolumeUp', 24],
    ['VolumeDown', 25],
    ['Power', 26],
    ['Camera', 27],
    ['Clear', 28],
    ['A', 29],
    ['B', 30],
    ['C', 31],
    ['D', 32],
    ['E', 33],
    ['F', 34],
    ['G', 35],
    ['H', 36],
    ['I', 37],
    ['J', 38],
    ['K', 39],
    ['L', 40],
    ['M', 41],
    ['N', 42],
    ['O', 43],
    ['P', 44],
    ['Q', 45],
    ['R', 46],
    ['S', 47],
    ['T', 48],
    ['U', 49],
    ['V', 50],
    ['W', 51],
    ['X', 52],
    ['Y', 53],
    ['Z', 54],
    ['Comma', 55],
    [',', 55],
    ['Period', 56],
    ['.', 56],
    ['AltLeft', 57],
    ['AltRight', 58],
    ['ShiftLeft', 59],
    ['ShiftRight', 60],
    ['Tab', 61],
    ['\t', 61],
    ['Space', 62],
    [' ', 62],
    ['Sym', 63],
    ['Explorer', 64],
    ['Envelop', 65],
    ['Enter', 66],
    ['Del', 67],
    ['Grave', 68],
    ['Minus', 69],
    ['-', 69],
    ['Equals', 70],
    ['=', 70],
    ['LeftBracket', 71],
    ['(', 71],
    ['RightBracket', 72],
    [')', 72],
    ['Backslash', 73],
    ['\\', 73],
    ['Semicolon', 74],
    [';', 74],
    ['Apostrophe', 75],
    ['`', 75],
    ['Slash', 76],
    ['/', 76],
    ['At', 77],
    ['@', 77],
    ['Num', 78],
    ['HeadsetHook', 79],
    ['Focus', 80],
    ['Plus', 81],
    ['Menu', 82],
    ['Notification', 83],
    ['Search', 84],
    ['AppSwitch', 187],
    ['Assist', 219],
    ['Cut', 277],
    ['Copy', 278],
    ['Paste', 279],
]);
//# sourceMappingURL=androidDispatcher.js.map

/***/ }),

/***/ 5396:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArtifactDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const streamDispatcher_1 = __nccwpck_require__(5871);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const utils_1 = __nccwpck_require__(6416);
class ArtifactDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, artifact) {
        super(scope, artifact, 'Artifact', {
            absolutePath: artifact.localPath(),
        });
    }
    async pathAfterFinished() {
        const path = await this._object.localPathAfterFinished();
        return { value: path || undefined };
    }
    async saveAs(params) {
        return await new Promise((resolve, reject) => {
            this._object.saveAs(async (localPath, error) => {
                if (error !== undefined) {
                    reject(new Error(error));
                    return;
                }
                try {
                    await utils_1.mkdirIfNeeded(params.path);
                    await fs_1.default.promises.copyFile(localPath, params.path);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async saveAsStream() {
        return await new Promise((resolve, reject) => {
            this._object.saveAs(async (localPath, error) => {
                if (error !== undefined) {
                    reject(new Error(error));
                    return;
                }
                try {
                    const readable = fs_1.default.createReadStream(localPath);
                    const stream = new streamDispatcher_1.StreamDispatcher(this._scope, readable);
                    // Resolve with a stream, so that client starts saving the data.
                    resolve({ stream });
                    // Block the Artifact until the stream is consumed.
                    await new Promise(resolve => {
                        readable.on('close', resolve);
                        readable.on('end', resolve);
                        readable.on('error', resolve);
                    });
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async stream() {
        const fileName = await this._object.localPathAfterFinished();
        if (!fileName)
            return {};
        const readable = fs_1.default.createReadStream(fileName);
        return { stream: new streamDispatcher_1.StreamDispatcher(this._scope, readable) };
    }
    async failure() {
        const error = await this._object.failureError();
        return { error: error || undefined };
    }
    async delete() {
        await this._object.delete();
        this._dispose();
    }
}
exports.ArtifactDispatcher = ArtifactDispatcher;
//# sourceMappingURL=artifactDispatcher.js.map

/***/ }),

/***/ 8312:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserContextDispatcher = void 0;
const browserContext_1 = __nccwpck_require__(7533);
const dispatcher_1 = __nccwpck_require__(5031);
const pageDispatcher_1 = __nccwpck_require__(4844);
const networkDispatchers_1 = __nccwpck_require__(6480);
const crBrowser_1 = __nccwpck_require__(6419);
const cdpSessionDispatcher_1 = __nccwpck_require__(6632);
const recorderSupplement_1 = __nccwpck_require__(1865);
const artifactDispatcher_1 = __nccwpck_require__(5396);
class BrowserContextDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, context) {
        super(scope, context, 'BrowserContext', { isChromium: context._browser.options.isChromium }, true);
        this._context = context;
        // Note: when launching persistent context, dispatcher is created very late,
        // so we can already have pages, videos and everything else.
        const onVideo = (artifact) => {
            // Note: Video must outlive Page and BrowserContext, so that client can saveAs it
            // after closing the context. We use |scope| for it.
            const artifactDispatcher = new artifactDispatcher_1.ArtifactDispatcher(scope, artifact);
            this._dispatchEvent('video', { artifact: artifactDispatcher });
        };
        context.on(browserContext_1.BrowserContext.Events.VideoStarted, onVideo);
        for (const video of context._browser._idToVideo.values()) {
            if (video.context === context)
                onVideo(video.artifact);
        }
        for (const page of context.pages())
            this._dispatchEvent('page', { page: new pageDispatcher_1.PageDispatcher(this._scope, page) });
        context.on(browserContext_1.BrowserContext.Events.Page, page => this._dispatchEvent('page', { page: new pageDispatcher_1.PageDispatcher(this._scope, page) }));
        context.on(browserContext_1.BrowserContext.Events.Close, () => {
            this._dispatchEvent('close');
            this._dispose();
        });
        if (context._browser.options.name === 'chromium') {
            for (const page of context.backgroundPages())
                this._dispatchEvent('backgroundPage', { page: new pageDispatcher_1.PageDispatcher(this._scope, page) });
            context.on(crBrowser_1.CRBrowserContext.CREvents.BackgroundPage, page => this._dispatchEvent('backgroundPage', { page: new pageDispatcher_1.PageDispatcher(this._scope, page) }));
            for (const serviceWorker of context.serviceWorkers())
                this._dispatchEvent('serviceWorker', { worker: new pageDispatcher_1.WorkerDispatcher(this._scope, serviceWorker) });
            context.on(crBrowser_1.CRBrowserContext.CREvents.ServiceWorker, serviceWorker => this._dispatchEvent('serviceWorker', { worker: new pageDispatcher_1.WorkerDispatcher(this._scope, serviceWorker) }));
        }
        context.on(browserContext_1.BrowserContext.Events.Request, (request) => {
            return this._dispatchEvent('request', {
                request: networkDispatchers_1.RequestDispatcher.from(this._scope, request),
                page: pageDispatcher_1.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
            });
        });
        context.on(browserContext_1.BrowserContext.Events.Response, (response) => this._dispatchEvent('response', {
            response: networkDispatchers_1.ResponseDispatcher.from(this._scope, response),
            page: pageDispatcher_1.PageDispatcher.fromNullable(this._scope, response.frame()._page.initializedOrUndefined())
        }));
        context.on(browserContext_1.BrowserContext.Events.RequestFailed, (request) => this._dispatchEvent('requestFailed', {
            request: networkDispatchers_1.RequestDispatcher.from(this._scope, request),
            failureText: request._failureText,
            responseEndTiming: request._responseEndTiming,
            page: pageDispatcher_1.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
        context.on(browserContext_1.BrowserContext.Events.RequestFinished, (request) => this._dispatchEvent('requestFinished', {
            request: networkDispatchers_1.RequestDispatcher.from(scope, request),
            responseEndTiming: request._responseEndTiming,
            page: pageDispatcher_1.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
    }
    async setDefaultNavigationTimeoutNoReply(params) {
        this._context.setDefaultNavigationTimeout(params.timeout);
    }
    async setDefaultTimeoutNoReply(params) {
        this._context.setDefaultTimeout(params.timeout);
    }
    async exposeBinding(params) {
        await this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            const binding = new pageDispatcher_1.BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent('bindingCall', { binding });
            return binding.promise();
        }, 'main');
    }
    async newPage(params, metadata) {
        return { page: dispatcher_1.lookupDispatcher(await this._context.newPage(metadata)) };
    }
    async cookies(params) {
        return { cookies: await this._context.cookies(params.urls) };
    }
    async addCookies(params) {
        await this._context.addCookies(params.cookies);
    }
    async clearCookies() {
        await this._context.clearCookies();
    }
    async grantPermissions(params) {
        await this._context.grantPermissions(params.permissions, params.origin);
    }
    async clearPermissions() {
        await this._context.clearPermissions();
    }
    async setGeolocation(params) {
        await this._context.setGeolocation(params.geolocation);
    }
    async setExtraHTTPHeaders(params) {
        await this._context.setExtraHTTPHeaders(params.headers);
    }
    async setOffline(params) {
        await this._context.setOffline(params.offline);
    }
    async setHTTPCredentials(params) {
        await this._context.setHTTPCredentials(params.httpCredentials);
    }
    async addInitScript(params) {
        await this._context._doAddInitScript(params.source);
    }
    async setNetworkInterceptionEnabled(params) {
        if (!params.enabled) {
            await this._context._setRequestInterceptor(undefined);
            return;
        }
        await this._context._setRequestInterceptor((route, request) => {
            this._dispatchEvent('route', { route: networkDispatchers_1.RouteDispatcher.from(this._scope, route), request: networkDispatchers_1.RequestDispatcher.from(this._scope, request) });
        });
    }
    async storageState(params, metadata) {
        return await this._context.storageState(metadata);
    }
    async close(params, metadata) {
        await this._context.close(metadata);
    }
    async recorderSupplementEnable(params) {
        await recorderSupplement_1.RecorderSupplement.show(this._context, params);
    }
    async pause(params, metadata) {
        // Inspector controller will take care of this.
    }
    async newCDPSession(params) {
        if (!this._object._browser.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
        const crBrowserContext = this._object;
        return { session: new cdpSessionDispatcher_1.CDPSessionDispatcher(this._scope, await crBrowserContext.newCDPSession(params.page._object)) };
    }
    async tracingStart(params) {
        await this._context.tracing.start(params);
    }
    async tracingStop(params) {
        await this._context.tracing.stop();
    }
    async tracingExport(params) {
        const artifact = await this._context.tracing.export();
        return { artifact: new artifactDispatcher_1.ArtifactDispatcher(this._scope, artifact) };
    }
}
exports.BrowserContextDispatcher = BrowserContextDispatcher;
//# sourceMappingURL=browserContextDispatcher.js.map

/***/ }),

/***/ 1935:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserDispatcher = void 0;
const browser_1 = __nccwpck_require__(6169);
const browserContextDispatcher_1 = __nccwpck_require__(8312);
const cdpSessionDispatcher_1 = __nccwpck_require__(6632);
const dispatcher_1 = __nccwpck_require__(5031);
class BrowserDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, browser) {
        super(scope, browser, 'Browser', { version: browser.version(), name: browser.options.name }, true);
        browser.on(browser_1.Browser.Events.Disconnected, () => this._didClose());
    }
    _didClose() {
        this._dispatchEvent('close');
        this._dispose();
    }
    async newContext(params, metadata) {
        const context = await this._object.newContext(params);
        if (params.storageState)
            await context.setStorageState(metadata, params.storageState);
        return { context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, context) };
    }
    async close() {
        await this._object.close();
    }
    async killForTests() {
        await this._object.killForTests();
    }
    async newBrowserCDPSession() {
        if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
        const crBrowser = this._object;
        return { session: new cdpSessionDispatcher_1.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession()) };
    }
    async startTracing(params) {
        if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        await crBrowser.startTracing(params.page ? params.page._object : undefined, params);
    }
    async stopTracing() {
        if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        const buffer = await crBrowser.stopTracing();
        return { binary: buffer.toString('base64') };
    }
}
exports.BrowserDispatcher = BrowserDispatcher;
//# sourceMappingURL=browserDispatcher.js.map

/***/ }),

/***/ 2:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserTypeDispatcher = void 0;
const browserDispatcher_1 = __nccwpck_require__(1935);
const dispatcher_1 = __nccwpck_require__(5031);
const browserContextDispatcher_1 = __nccwpck_require__(8312);
class BrowserTypeDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, browserType) {
        super(scope, browserType, 'BrowserType', {
            executablePath: browserType.executablePath(),
            name: browserType.name()
        }, true);
    }
    async launch(params, metadata) {
        const browser = await this._object.launch(metadata, params);
        return { browser: new browserDispatcher_1.BrowserDispatcher(this._scope, browser) };
    }
    async launchPersistentContext(params, metadata) {
        const browserContext = await this._object.launchPersistentContext(metadata, params.userDataDir, params);
        return { context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, browserContext) };
    }
    async connectOverCDP(params, metadata) {
        const browser = await this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
        return {
            browser: new browserDispatcher_1.BrowserDispatcher(this._scope, browser),
            defaultContext: browser._defaultContext ? new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, browser._defaultContext) : undefined,
        };
    }
}
exports.BrowserTypeDispatcher = BrowserTypeDispatcher;
//# sourceMappingURL=browserTypeDispatcher.js.map

/***/ }),

/***/ 6632:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDPSessionDispatcher = void 0;
const crConnection_1 = __nccwpck_require__(8899);
const dispatcher_1 = __nccwpck_require__(5031);
class CDPSessionDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, crSession) {
        super(scope, crSession, 'CDPSession', {}, true);
        crSession._eventListener = (method, params) => {
            this._dispatchEvent('event', { method, params });
        };
        crSession.on(crConnection_1.CRSessionEvents.Disconnected, () => this._dispose());
    }
    async send(params) {
        return { result: await this._object.send(params.method, params.params) };
    }
    async detach() {
        return this._object.detach();
    }
}
exports.CDPSessionDispatcher = CDPSessionDispatcher;
//# sourceMappingURL=cdpSessionDispatcher.js.map

/***/ }),

/***/ 9632:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleMessageDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const elementHandlerDispatcher_1 = __nccwpck_require__(9729);
class ConsoleMessageDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, message) {
        super(scope, message, 'ConsoleMessage', {
            type: message.type(),
            text: message.text(),
            args: message.args().map(a => elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(scope, a)),
            location: message.location(),
        });
    }
}
exports.ConsoleMessageDispatcher = ConsoleMessageDispatcher;
//# sourceMappingURL=consoleMessageDispatcher.js.map

/***/ }),

/***/ 1950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DialogDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
class DialogDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, dialog) {
        super(scope, dialog, 'Dialog', {
            type: dialog.type(),
            message: dialog.message(),
            defaultValue: dialog.defaultValue(),
        });
    }
    async accept(params) {
        await this._object.accept(params.promptText);
    }
    async dismiss() {
        await this._object.dismiss();
    }
}
exports.DialogDispatcher = DialogDispatcher;
//# sourceMappingURL=dialogDispatcher.js.map

/***/ }),

/***/ 5031:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DispatcherConnection = exports.Dispatcher = exports.lookupNullableDispatcher = exports.existingDispatcher = exports.lookupDispatcher = exports.dispatcherSymbol = void 0;
const events_1 = __nccwpck_require__(8614);
const serializers_1 = __nccwpck_require__(9546);
const validator_1 = __nccwpck_require__(6423);
const utils_1 = __nccwpck_require__(6416);
const validatorPrimitives_1 = __nccwpck_require__(5814);
const errors_1 = __nccwpck_require__(4949);
const instrumentation_1 = __nccwpck_require__(7490);
const stackTrace_1 = __nccwpck_require__(6010);
exports.dispatcherSymbol = Symbol('dispatcher');
function lookupDispatcher(object) {
    const result = object[exports.dispatcherSymbol];
    utils_1.debugAssert(result);
    return result;
}
exports.lookupDispatcher = lookupDispatcher;
function existingDispatcher(object) {
    return object[exports.dispatcherSymbol];
}
exports.existingDispatcher = existingDispatcher;
function lookupNullableDispatcher(object) {
    return object ? lookupDispatcher(object) : undefined;
}
exports.lookupNullableDispatcher = lookupNullableDispatcher;
class Dispatcher extends events_1.EventEmitter {
    constructor(parent, object, type, initializer, isScope) {
        super();
        // Only "isScope" channel owners have registered dispatchers inside.
        this._dispatchers = new Map();
        this._disposed = false;
        this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
        this._isScope = !!isScope;
        this._parent = parent instanceof DispatcherConnection ? undefined : parent;
        this._scope = isScope ? this : this._parent;
        const guid = object.guid;
        utils_1.assert(!this._connection._dispatchers.has(guid));
        this._connection._dispatchers.set(guid, this);
        if (this._parent) {
            utils_1.assert(!this._parent._dispatchers.has(guid));
            this._parent._dispatchers.set(guid, this);
        }
        this._type = type;
        this._guid = guid;
        this._object = object;
        object[exports.dispatcherSymbol] = this;
        if (this._parent)
            this._connection.sendMessageToClient(this._parent._guid, type, '__create__', { type, initializer, guid });
    }
    _dispatchEvent(method, params = {}) {
        if (this._disposed) {
            if (utils_1.isUnderTest())
                throw new Error(`${this._guid} is sending "${method}" event after being disposed`);
            // Just ignore this event outside of tests.
            return;
        }
        const sdkObject = this._object instanceof instrumentation_1.SdkObject ? this._object : undefined;
        this._connection.sendMessageToClient(this._guid, this._type, method, params, sdkObject);
    }
    _dispose() {
        utils_1.assert(!this._disposed);
        this._disposed = true;
        // Clean up from parent and connection.
        if (this._parent)
            this._parent._dispatchers.delete(this._guid);
        this._connection._dispatchers.delete(this._guid);
        // Dispose all children.
        for (const dispatcher of [...this._dispatchers.values()])
            dispatcher._dispose();
        this._dispatchers.clear();
        if (this._isScope)
            this._connection.sendMessageToClient(this._guid, this._type, '__dispose__', {});
    }
    _debugScopeState() {
        return {
            _guid: this._guid,
            objects: Array.from(this._dispatchers.values()).map(o => o._debugScopeState()),
        };
    }
    async waitForEventInfo() {
        // Instrumentation takes care of this.
    }
}
exports.Dispatcher = Dispatcher;
class Root extends Dispatcher {
    constructor(connection) {
        super(connection, { guid: '' }, '', {}, true);
    }
}
class DispatcherConnection {
    constructor() {
        this._dispatchers = new Map();
        this.onmessage = (message) => { };
        this._waitOperations = new Map();
        this._rootDispatcher = new Root(this);
        const tChannel = (name) => {
            return (arg, path) => {
                if (arg && typeof arg === 'object' && typeof arg.guid === 'string') {
                    const guid = arg.guid;
                    const dispatcher = this._dispatchers.get(guid);
                    if (!dispatcher)
                        throw new validator_1.ValidationError(`${path}: no object with guid ${guid}`);
                    if (name !== '*' && dispatcher._type !== name)
                        throw new validator_1.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${name}`);
                    return dispatcher;
                }
                throw new validator_1.ValidationError(`${path}: expected ${name}`);
            };
        };
        const scheme = validator_1.createScheme(tChannel);
        this._validateParams = (type, method, params) => {
            if (method === 'waitForEventInfo')
                return validatorPrimitives_1.tOptional(scheme['WaitForEventInfo'])(params.info, '');
            const name = type + method[0].toUpperCase() + method.substring(1) + 'Params';
            if (!scheme[name])
                throw new validator_1.ValidationError(`Unknown scheme for ${type}.${method}`);
            return scheme[name](params, '');
        };
        this._validateMetadata = (metadata) => {
            return validatorPrimitives_1.tOptional(scheme['Metadata'])(metadata, '');
        };
    }
    sendMessageToClient(guid, type, method, params, sdkObject) {
        var _a, _b;
        params = this._replaceDispatchersWithGuids(params);
        if (sdkObject) {
            const eventMetadata = {
                id: `event@${++lastEventId}`,
                objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
                pageId: (_a = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.page) === null || _a === void 0 ? void 0 : _a.guid,
                frameId: (_b = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.frame) === null || _b === void 0 ? void 0 : _b.guid,
                startTime: utils_1.monotonicTime(),
                endTime: 0,
                type,
                method,
                params: params || {},
                log: [],
                snapshots: []
            };
            sdkObject.instrumentation.onEvent(sdkObject, eventMetadata);
        }
        this.onmessage({ guid, method, params });
    }
    rootDispatcher() {
        return this._rootDispatcher;
    }
    async dispatch(message) {
        var _a, _b, _c;
        const { id, guid, method, params, metadata } = message;
        const dispatcher = this._dispatchers.get(guid);
        if (!dispatcher) {
            this.onmessage({ id, error: serializers_1.serializeError(new Error(errors_1.kBrowserOrContextClosedError)) });
            return;
        }
        if (method === 'debugScopeState') {
            this.onmessage({ id, result: this._rootDispatcher._debugScopeState() });
            return;
        }
        let validParams;
        let validMetadata;
        try {
            validParams = this._validateParams(dispatcher._type, method, params);
            validMetadata = this._validateMetadata(metadata);
            if (typeof dispatcher[method] !== 'function')
                throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
        }
        catch (e) {
            this.onmessage({ id, error: serializers_1.serializeError(e) });
            return;
        }
        const sdkObject = dispatcher._object instanceof instrumentation_1.SdkObject ? dispatcher._object : undefined;
        const callMetadata = {
            id: `call@${id}`,
            ...validMetadata,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: (_a = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.page) === null || _a === void 0 ? void 0 : _a.guid,
            frameId: (_b = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.frame) === null || _b === void 0 ? void 0 : _b.guid,
            startTime: utils_1.monotonicTime(),
            endTime: 0,
            type: dispatcher._type,
            method,
            params: params || {},
            log: [],
            snapshots: []
        };
        if (sdkObject && ((_c = params === null || params === void 0 ? void 0 : params.info) === null || _c === void 0 ? void 0 : _c.waitId)) {
            // Process logs for waitForNavigation/waitForLoadState
            const info = params.info;
            switch (info.phase) {
                case 'before': {
                    callMetadata.apiName = info.apiName;
                    this._waitOperations.set(info.waitId, callMetadata);
                    await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
                    return;
                }
                case 'log': {
                    const originalMetadata = this._waitOperations.get(info.waitId);
                    originalMetadata.log.push(info.message);
                    sdkObject.instrumentation.onCallLog('api', info.message, sdkObject, originalMetadata);
                    return;
                }
                case 'after': {
                    const originalMetadata = this._waitOperations.get(info.waitId);
                    originalMetadata.endTime = utils_1.monotonicTime();
                    originalMetadata.error = info.error;
                    this._waitOperations.delete(info.waitId);
                    await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
                    return;
                }
            }
        }
        let result;
        let error;
        await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata));
        try {
            result = await dispatcher[method](validParams, callMetadata);
        }
        catch (e) {
            // Dispatching error
            callMetadata.error = e.message;
            if (callMetadata.log.length)
                stackTrace_1.rewriteErrorMessage(e, e.message + formatLogRecording(callMetadata.log) + kLoggingNote);
            error = serializers_1.serializeError(e);
        }
        finally {
            callMetadata.endTime = utils_1.monotonicTime();
            await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata));
        }
        if (error)
            this.onmessage({ id, error });
        else
            this.onmessage({ id, result: this._replaceDispatchersWithGuids(result) });
    }
    _replaceDispatchersWithGuids(payload) {
        if (!payload)
            return payload;
        if (payload instanceof Dispatcher)
            return { guid: payload._guid };
        if (Array.isArray(payload))
            return payload.map(p => this._replaceDispatchersWithGuids(p));
        if (typeof payload === 'object') {
            const result = {};
            for (const key of Object.keys(payload))
                result[key] = this._replaceDispatchersWithGuids(payload[key]);
            return result;
        }
        return payload;
    }
}
exports.DispatcherConnection = DispatcherConnection;
const kLoggingNote = `\nNote: use DEBUG=pw:api environment variable to capture Playwright logs.`;
function formatLogRecording(log) {
    if (!log.length)
        return '';
    const header = ` logs `;
    const headerLength = 60;
    const leftLength = (headerLength - header.length) / 2;
    const rightLength = headerLength - header.length - leftLength;
    return `\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\n${log.join('\n')}\n${'='.repeat(headerLength)}`;
}
let lastEventId = 0;
//# sourceMappingURL=dispatcher.js.map

/***/ }),

/***/ 8327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElectronApplicationDispatcher = exports.ElectronDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const electron_1 = __nccwpck_require__(8259);
const browserContextDispatcher_1 = __nccwpck_require__(8312);
const jsHandleDispatcher_1 = __nccwpck_require__(4486);
const elementHandlerDispatcher_1 = __nccwpck_require__(9729);
class ElectronDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, electron) {
        super(scope, electron, 'Electron', {}, true);
    }
    async launch(params) {
        const electronApplication = await this._object.launch(params);
        return { electronApplication: new ElectronApplicationDispatcher(this._scope, electronApplication) };
    }
}
exports.ElectronDispatcher = ElectronDispatcher;
class ElectronApplicationDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, electronApplication) {
        super(scope, electronApplication, 'ElectronApplication', {
            context: new browserContextDispatcher_1.BrowserContextDispatcher(scope, electronApplication.context())
        }, true);
        electronApplication.on(electron_1.ElectronApplication.Events.Close, () => {
            this._dispatchEvent('close');
            this._dispose();
        });
    }
    async browserWindow(params) {
        const handle = await this._object.browserWindow(params.page.page());
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, handle) };
    }
    async evaluateExpression(params) {
        const handle = await this._object._nodeElectronHandlePromise;
        return { value: jsHandleDispatcher_1.serializeResult(await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true /* returnByValue */, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evaluateExpressionHandle(params) {
        const handle = await this._object._nodeElectronHandlePromise;
        const result = await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false /* returnByValue */, jsHandleDispatcher_1.parseArgument(params.arg));
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, result) };
    }
    async close() {
        await this._object.close();
    }
}
exports.ElectronApplicationDispatcher = ElectronApplicationDispatcher;
//# sourceMappingURL=electronDispatcher.js.map

/***/ }),

/***/ 9729:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElementHandleDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const jsHandleDispatcher_1 = __nccwpck_require__(4486);
class ElementHandleDispatcher extends jsHandleDispatcher_1.JSHandleDispatcher {
    constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._elementHandle = elementHandle;
    }
    static from(scope, handle) {
        return dispatcher_1.existingDispatcher(handle) || new ElementHandleDispatcher(scope, handle);
    }
    static fromNullable(scope, handle) {
        if (!handle)
            return undefined;
        return dispatcher_1.existingDispatcher(handle) || new ElementHandleDispatcher(scope, handle);
    }
    static fromJSHandle(scope, handle) {
        const result = dispatcher_1.existingDispatcher(handle);
        if (result)
            return result;
        return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new jsHandleDispatcher_1.JSHandleDispatcher(scope, handle);
    }
    async ownerFrame(params, metadata) {
        return { frame: dispatcher_1.lookupNullableDispatcher(await this._elementHandle.ownerFrame()) };
    }
    async contentFrame(params, metadata) {
        return { frame: dispatcher_1.lookupNullableDispatcher(await this._elementHandle.contentFrame()) };
    }
    async getAttribute(params, metadata) {
        const value = await this._elementHandle.getAttribute(params.name);
        return { value: value === null ? undefined : value };
    }
    async textContent(params, metadata) {
        const value = await this._elementHandle.textContent();
        return { value: value === null ? undefined : value };
    }
    async innerText(params, metadata) {
        return { value: await this._elementHandle.innerText() };
    }
    async innerHTML(params, metadata) {
        return { value: await this._elementHandle.innerHTML() };
    }
    async isChecked(params, metadata) {
        return { value: await this._elementHandle.isChecked() };
    }
    async isDisabled(params, metadata) {
        return { value: await this._elementHandle.isDisabled() };
    }
    async isEditable(params, metadata) {
        return { value: await this._elementHandle.isEditable() };
    }
    async isEnabled(params, metadata) {
        return { value: await this._elementHandle.isEnabled() };
    }
    async isHidden(params, metadata) {
        return { value: await this._elementHandle.isHidden() };
    }
    async isVisible(params, metadata) {
        return { value: await this._elementHandle.isVisible() };
    }
    async dispatchEvent(params, metadata) {
        await this._elementHandle.dispatchEvent(params.type, jsHandleDispatcher_1.parseArgument(params.eventInit));
    }
    async scrollIntoViewIfNeeded(params, metadata) {
        await this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
    }
    async hover(params, metadata) {
        return await this._elementHandle.hover(metadata, params);
    }
    async click(params, metadata) {
        return await this._elementHandle.click(metadata, params);
    }
    async dblclick(params, metadata) {
        return await this._elementHandle.dblclick(metadata, params);
    }
    async tap(params, metadata) {
        return await this._elementHandle.tap(metadata, params);
    }
    async selectOption(params, metadata) {
        const elements = (params.elements || []).map(e => e._elementHandle);
        return { values: await this._elementHandle.selectOption(metadata, elements, params.options || [], params) };
    }
    async fill(params, metadata) {
        return await this._elementHandle.fill(metadata, params.value, params);
    }
    async selectText(params, metadata) {
        await this._elementHandle.selectText(metadata, params);
    }
    async setInputFiles(params, metadata) {
        return await this._elementHandle.setInputFiles(metadata, params.files, params);
    }
    async focus(params, metadata) {
        await this._elementHandle.focus(metadata);
    }
    async type(params, metadata) {
        return await this._elementHandle.type(metadata, params.text, params);
    }
    async press(params, metadata) {
        return await this._elementHandle.press(metadata, params.key, params);
    }
    async check(params, metadata) {
        return await this._elementHandle.check(metadata, params);
    }
    async uncheck(params, metadata) {
        return await this._elementHandle.uncheck(metadata, params);
    }
    async boundingBox(params, metadata) {
        const value = await this._elementHandle.boundingBox();
        return { value: value || undefined };
    }
    async screenshot(params, metadata) {
        return { binary: (await this._elementHandle.screenshot(metadata, params)).toString('base64') };
    }
    async querySelector(params, metadata) {
        const handle = await this._elementHandle.$(params.selector);
        return { element: ElementHandleDispatcher.fromNullable(this._scope, handle) };
    }
    async querySelectorAll(params, metadata) {
        const elements = await this._elementHandle.$$(params.selector);
        return { elements: elements.map(e => ElementHandleDispatcher.from(this._scope, e)) };
    }
    async evalOnSelector(params, metadata) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evalOnSelectorAll(params, metadata) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async waitForElementState(params, metadata) {
        await this._elementHandle.waitForElementState(metadata, params.state, params);
    }
    async waitForSelector(params, metadata) {
        return { element: ElementHandleDispatcher.fromNullable(this._scope, await this._elementHandle.waitForSelector(metadata, params.selector, params)) };
    }
}
exports.ElementHandleDispatcher = ElementHandleDispatcher;
//# sourceMappingURL=elementHandlerDispatcher.js.map

/***/ }),

/***/ 8303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrameDispatcher = void 0;
const frames_1 = __nccwpck_require__(3735);
const dispatcher_1 = __nccwpck_require__(5031);
const elementHandlerDispatcher_1 = __nccwpck_require__(9729);
const jsHandleDispatcher_1 = __nccwpck_require__(4486);
const networkDispatchers_1 = __nccwpck_require__(6480);
class FrameDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, frame) {
        super(scope, frame, 'Frame', {
            url: frame.url(),
            name: frame.name(),
            parentFrame: dispatcher_1.lookupNullableDispatcher(frame.parentFrame()),
            loadStates: Array.from(frame._subtreeLifecycleEvents),
        });
        this._frame = frame;
        frame.on(frames_1.Frame.Events.AddLifecycle, lifecycleEvent => {
            this._dispatchEvent('loadstate', { add: lifecycleEvent });
        });
        frame.on(frames_1.Frame.Events.RemoveLifecycle, lifecycleEvent => {
            this._dispatchEvent('loadstate', { remove: lifecycleEvent });
        });
        frame.on(frames_1.Frame.Events.Navigation, (event) => {
            const params = { url: event.url, name: event.name, error: event.error ? event.error.message : undefined };
            if (event.newDocument)
                params.newDocument = { request: networkDispatchers_1.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null) };
            this._dispatchEvent('navigated', params);
        });
    }
    static from(scope, frame) {
        const result = dispatcher_1.existingDispatcher(frame);
        return result || new FrameDispatcher(scope, frame);
    }
    async goto(params, metadata) {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._frame.goto(metadata, params.url, params)) };
    }
    async frameElement() {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, await this._frame.frameElement()) };
    }
    async evaluateExpression(params, metadata) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._frame.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), 'main')) };
    }
    async evaluateExpressionHandle(params, metadata) {
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), 'main')) };
    }
    async waitForSelector(params, metadata) {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.waitForSelector(metadata, params.selector, params)) };
    }
    async dispatchEvent(params, metadata) {
        return this._frame.dispatchEvent(metadata, params.selector, params.type, jsHandleDispatcher_1.parseArgument(params.eventInit), params);
    }
    async evalOnSelector(params, metadata) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._frame.evalOnSelectorAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evalOnSelectorAll(params, metadata) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async querySelector(params, metadata) {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.$(params.selector)) };
    }
    async querySelectorAll(params, metadata) {
        const elements = await this._frame.$$(params.selector);
        return { elements: elements.map(e => elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, e)) };
    }
    async content() {
        return { value: await this._frame.content() };
    }
    async setContent(params, metadata) {
        return await this._frame.setContent(metadata, params.html, params);
    }
    async addScriptTag(params, metadata) {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, await this._frame.addScriptTag(params)) };
    }
    async addStyleTag(params, metadata) {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, await this._frame.addStyleTag(params)) };
    }
    async click(params, metadata) {
        return await this._frame.click(metadata, params.selector, params);
    }
    async dblclick(params, metadata) {
        return await this._frame.dblclick(metadata, params.selector, params);
    }
    async tap(params, metadata) {
        return await this._frame.tap(metadata, params.selector, params);
    }
    async fill(params, metadata) {
        return await this._frame.fill(metadata, params.selector, params.value, params);
    }
    async focus(params, metadata) {
        await this._frame.focus(metadata, params.selector, params);
    }
    async textContent(params, metadata) {
        const value = await this._frame.textContent(metadata, params.selector, params);
        return { value: value === null ? undefined : value };
    }
    async innerText(params, metadata) {
        return { value: await this._frame.innerText(metadata, params.selector, params) };
    }
    async innerHTML(params, metadata) {
        return { value: await this._frame.innerHTML(metadata, params.selector, params) };
    }
    async getAttribute(params, metadata) {
        const value = await this._frame.getAttribute(metadata, params.selector, params.name, params);
        return { value: value === null ? undefined : value };
    }
    async isChecked(params, metadata) {
        return { value: await this._frame.isChecked(metadata, params.selector, params) };
    }
    async isDisabled(params, metadata) {
        return { value: await this._frame.isDisabled(metadata, params.selector, params) };
    }
    async isEditable(params, metadata) {
        return { value: await this._frame.isEditable(metadata, params.selector, params) };
    }
    async isEnabled(params, metadata) {
        return { value: await this._frame.isEnabled(metadata, params.selector, params) };
    }
    async isHidden(params, metadata) {
        return { value: await this._frame.isHidden(metadata, params.selector, params) };
    }
    async isVisible(params, metadata) {
        return { value: await this._frame.isVisible(metadata, params.selector, params) };
    }
    async hover(params, metadata) {
        return await this._frame.hover(metadata, params.selector, params);
    }
    async selectOption(params, metadata) {
        const elements = (params.elements || []).map(e => e._elementHandle);
        return { values: await this._frame.selectOption(metadata, params.selector, elements, params.options || [], params) };
    }
    async setInputFiles(params, metadata) {
        return await this._frame.setInputFiles(metadata, params.selector, params.files, params);
    }
    async type(params, metadata) {
        return await this._frame.type(metadata, params.selector, params.text, params);
    }
    async press(params, metadata) {
        return await this._frame.press(metadata, params.selector, params.key, params);
    }
    async check(params, metadata) {
        return await this._frame.check(metadata, params.selector, params);
    }
    async uncheck(params, metadata) {
        return await this._frame.uncheck(metadata, params.selector, params);
    }
    async waitForFunction(params, metadata) {
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), params)) };
    }
    async title(params, metadata) {
        return { value: await this._frame.title() };
    }
}
exports.FrameDispatcher = FrameDispatcher;
//# sourceMappingURL=frameDispatcher.js.map

/***/ }),

/***/ 4486:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeResult = exports.parseValue = exports.parseArgument = exports.JSHandleDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const elementHandlerDispatcher_1 = __nccwpck_require__(9729);
const serializers_1 = __nccwpck_require__(9546);
class JSHandleDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, jsHandle) {
        // Do not call this directly, use createHandle() instead.
        super(scope, jsHandle, jsHandle.asElement() ? 'ElementHandle' : 'JSHandle', {
            preview: jsHandle.toString(),
        });
        jsHandle._setPreviewCallback(preview => this._dispatchEvent('previewUpdated', { preview }));
    }
    async evaluateExpression(params) {
        return { value: serializeResult(await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true /* returnByValue */, parseArgument(params.arg))) };
    }
    async evaluateExpressionHandle(params) {
        const jsHandle = await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false /* returnByValue */, parseArgument(params.arg));
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle) };
    }
    async getProperty(params) {
        const jsHandle = await this._object.getProperty(params.name);
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle) };
    }
    async getPropertyList() {
        const map = await this._object.getProperties();
        const properties = [];
        for (const [name, value] of map)
            properties.push({ name, value: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, value) });
        return { properties };
    }
    async jsonValue() {
        return { value: serializeResult(await this._object.jsonValue()) };
    }
    async dispose() {
        await this._object.dispose();
    }
}
exports.JSHandleDispatcher = JSHandleDispatcher;
// Generic channel parser converts guids to JSHandleDispatchers,
// and this function takes care of coverting them into underlying JSHandles.
function parseArgument(arg) {
    return serializers_1.parseSerializedValue(arg.value, arg.handles.map(a => a._object));
}
exports.parseArgument = parseArgument;
function parseValue(v) {
    return serializers_1.parseSerializedValue(v, []);
}
exports.parseValue = parseValue;
function serializeResult(arg) {
    return serializers_1.serializeValue(arg, value => ({ fallThrough: value }), new Set());
}
exports.serializeResult = serializeResult;
//# sourceMappingURL=jsHandleDispatcher.js.map

/***/ }),

/***/ 6480:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketDispatcher = exports.RouteDispatcher = exports.ResponseDispatcher = exports.RequestDispatcher = void 0;
const network_1 = __nccwpck_require__(8781);
const dispatcher_1 = __nccwpck_require__(5031);
const frameDispatcher_1 = __nccwpck_require__(8303);
class RequestDispatcher extends dispatcher_1.Dispatcher {
    static from(scope, request) {
        const result = dispatcher_1.existingDispatcher(request);
        return result || new RequestDispatcher(scope, request);
    }
    static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : undefined;
    }
    constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, 'Request', {
            frame: frameDispatcher_1.FrameDispatcher.from(scope, request.frame()),
            url: request.url(),
            resourceType: request.resourceType(),
            method: request.method(),
            postData: postData === null ? undefined : postData.toString('base64'),
            headers: request.headers(),
            isNavigationRequest: request.isNavigationRequest(),
            redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom()),
        });
    }
    async response() {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._object.response()) };
    }
}
exports.RequestDispatcher = RequestDispatcher;
class ResponseDispatcher extends dispatcher_1.Dispatcher {
    static from(scope, response) {
        const result = dispatcher_1.existingDispatcher(response);
        return result || new ResponseDispatcher(scope, response);
    }
    static fromNullable(scope, response) {
        return response ? ResponseDispatcher.from(scope, response) : undefined;
    }
    constructor(scope, response) {
        super(scope, response, 'Response', {
            // TODO: responses in popups can point to non-reported requests.
            request: RequestDispatcher.from(scope, response.request()),
            url: response.url(),
            status: response.status(),
            statusText: response.statusText(),
            requestHeaders: response.request().headers(),
            headers: response.headers(),
            timing: response.timing()
        });
    }
    async finished() {
        return await this._object._finishedPromise;
    }
    async body() {
        return { binary: (await this._object.body()).toString('base64') };
    }
}
exports.ResponseDispatcher = ResponseDispatcher;
class RouteDispatcher extends dispatcher_1.Dispatcher {
    static from(scope, route) {
        const result = dispatcher_1.existingDispatcher(route);
        return result || new RouteDispatcher(scope, route);
    }
    static fromNullable(scope, route) {
        return route ? RouteDispatcher.from(scope, route) : undefined;
    }
    constructor(scope, route) {
        super(scope, route, 'Route', {
            // Context route can point to a non-reported request.
            request: RequestDispatcher.from(scope, route.request())
        });
    }
    async continue(params) {
        await this._object.continue({
            url: params.url,
            method: params.method,
            headers: params.headers,
            postData: params.postData ? Buffer.from(params.postData, 'base64') : undefined,
        });
    }
    async fulfill(params) {
        await this._object.fulfill(params);
    }
    async abort(params) {
        await this._object.abort(params.errorCode || 'failed');
    }
}
exports.RouteDispatcher = RouteDispatcher;
class WebSocketDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, webSocket) {
        super(scope, webSocket, 'WebSocket', {
            url: webSocket.url(),
        });
        webSocket.on(network_1.WebSocket.Events.FrameSent, (event) => this._dispatchEvent('frameSent', event));
        webSocket.on(network_1.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent('frameReceived', event));
        webSocket.on(network_1.WebSocket.Events.SocketError, (error) => this._dispatchEvent('socketError', { error }));
        webSocket.on(network_1.WebSocket.Events.Close, () => this._dispatchEvent('close', {}));
    }
}
exports.WebSocketDispatcher = WebSocketDispatcher;
//# sourceMappingURL=networkDispatchers.js.map

/***/ }),

/***/ 4844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BindingCallDispatcher = exports.WorkerDispatcher = exports.PageDispatcher = void 0;
const page_1 = __nccwpck_require__(9406);
const dispatcher_1 = __nccwpck_require__(5031);
const serializers_1 = __nccwpck_require__(9546);
const consoleMessageDispatcher_1 = __nccwpck_require__(9632);
const dialogDispatcher_1 = __nccwpck_require__(1950);
const frameDispatcher_1 = __nccwpck_require__(8303);
const networkDispatchers_1 = __nccwpck_require__(6480);
const jsHandleDispatcher_1 = __nccwpck_require__(4486);
const elementHandlerDispatcher_1 = __nccwpck_require__(9729);
const artifactDispatcher_1 = __nccwpck_require__(5396);
const utils_1 = __nccwpck_require__(6416);
class PageDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, page) {
        // TODO: theoretically, there could be more than one frame already.
        // If we split pageCreated and pageReady, there should be no main frame during pageCreated.
        super(scope, page, 'Page', {
            mainFrame: frameDispatcher_1.FrameDispatcher.from(scope, page.mainFrame()),
            viewportSize: page.viewportSize() || undefined,
            isClosed: page.isClosed(),
            opener: PageDispatcher.fromNullable(scope, page.opener())
        }, true);
        this._page = page;
        page.on(page_1.Page.Events.Close, () => {
            this._dispatchEvent('close');
            this._dispose();
        });
        page.on(page_1.Page.Events.Console, message => this._dispatchEvent('console', { message: new consoleMessageDispatcher_1.ConsoleMessageDispatcher(this._scope, message) }));
        page.on(page_1.Page.Events.Crash, () => this._dispatchEvent('crash'));
        page.on(page_1.Page.Events.DOMContentLoaded, () => this._dispatchEvent('domcontentloaded'));
        page.on(page_1.Page.Events.Dialog, dialog => this._dispatchEvent('dialog', { dialog: new dialogDispatcher_1.DialogDispatcher(this._scope, dialog) }));
        page.on(page_1.Page.Events.Download, (download) => {
            this._dispatchEvent('download', { url: download.url, suggestedFilename: download.suggestedFilename(), artifact: new artifactDispatcher_1.ArtifactDispatcher(scope, download.artifact) });
        });
        this._page.on(page_1.Page.Events.FileChooser, (fileChooser) => this._dispatchEvent('fileChooser', {
            element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, fileChooser.element()),
            isMultiple: fileChooser.isMultiple()
        }));
        page.on(page_1.Page.Events.FrameAttached, frame => this._onFrameAttached(frame));
        page.on(page_1.Page.Events.FrameDetached, frame => this._onFrameDetached(frame));
        page.on(page_1.Page.Events.Load, () => this._dispatchEvent('load'));
        page.on(page_1.Page.Events.PageError, error => this._dispatchEvent('pageError', { error: serializers_1.serializeError(error) }));
        page.on(page_1.Page.Events.WebSocket, webSocket => this._dispatchEvent('webSocket', { webSocket: new networkDispatchers_1.WebSocketDispatcher(this._scope, webSocket) }));
        page.on(page_1.Page.Events.Worker, worker => this._dispatchEvent('worker', { worker: new WorkerDispatcher(this._scope, worker) }));
        page.on(page_1.Page.Events.Video, (artifact) => this._dispatchEvent('video', { artifact: dispatcher_1.existingDispatcher(artifact) }));
        if (page._video)
            this._dispatchEvent('video', { artifact: dispatcher_1.existingDispatcher(page._video) });
    }
    static fromNullable(scope, page) {
        if (!page)
            return undefined;
        const result = dispatcher_1.existingDispatcher(page);
        return result || new PageDispatcher(scope, page);
    }
    page() {
        return this._page;
    }
    async setDefaultNavigationTimeoutNoReply(params, metadata) {
        this._page.setDefaultNavigationTimeout(params.timeout);
    }
    async setDefaultTimeoutNoReply(params, metadata) {
        this._page.setDefaultTimeout(params.timeout);
    }
    async exposeBinding(params, metadata) {
        await this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            const binding = new BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent('bindingCall', { binding });
            return binding.promise();
        });
    }
    async setExtraHTTPHeaders(params, metadata) {
        await this._page.setExtraHTTPHeaders(params.headers);
    }
    async reload(params, metadata) {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._page.reload(metadata, params)) };
    }
    async goBack(params, metadata) {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._page.goBack(metadata, params)) };
    }
    async goForward(params, metadata) {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._page.goForward(metadata, params)) };
    }
    async emulateMedia(params, metadata) {
        await this._page.emulateMedia({
            media: params.media === 'null' ? null : params.media,
            colorScheme: params.colorScheme === 'null' ? null : params.colorScheme,
            reducedMotion: params.reducedMotion === 'null' ? null : params.reducedMotion,
        });
    }
    async setViewportSize(params, metadata) {
        await this._page.setViewportSize(params.viewportSize);
    }
    async addInitScript(params, metadata) {
        await this._page._addInitScriptExpression(params.source);
    }
    async setNetworkInterceptionEnabled(params, metadata) {
        if (!params.enabled) {
            await this._page._setClientRequestInterceptor(undefined);
            return;
        }
        await this._page._setClientRequestInterceptor((route, request) => {
            this._dispatchEvent('route', { route: networkDispatchers_1.RouteDispatcher.from(this._scope, route), request: networkDispatchers_1.RequestDispatcher.from(this._scope, request) });
        });
    }
    async screenshot(params, metadata) {
        return { binary: (await this._page.screenshot(metadata, params)).toString('base64') };
    }
    async close(params, metadata) {
        await this._page.close(metadata, params);
    }
    async setFileChooserInterceptedNoReply(params, metadata) {
        await this._page._setFileChooserIntercepted(params.intercepted);
    }
    async keyboardDown(params, metadata) {
        await this._page.keyboard.down(params.key);
    }
    async keyboardUp(params, metadata) {
        await this._page.keyboard.up(params.key);
    }
    async keyboardInsertText(params, metadata) {
        await this._page.keyboard.insertText(params.text);
    }
    async keyboardType(params, metadata) {
        await this._page.keyboard.type(params.text, params);
    }
    async keyboardPress(params, metadata) {
        await this._page.keyboard.press(params.key, params);
    }
    async mouseMove(params, metadata) {
        await this._page.mouse.move(params.x, params.y, params);
    }
    async mouseDown(params, metadata) {
        await this._page.mouse.down(params);
    }
    async mouseUp(params, metadata) {
        await this._page.mouse.up(params);
    }
    async mouseClick(params, metadata) {
        await this._page.mouse.click(params.x, params.y, params);
    }
    async touchscreenTap(params, metadata) {
        await this._page.touchscreen.tap(params.x, params.y);
    }
    async accessibilitySnapshot(params, metadata) {
        const rootAXNode = await this._page.accessibility.snapshot({
            interestingOnly: params.interestingOnly,
            root: params.root ? params.root._elementHandle : undefined
        });
        return { rootAXNode: rootAXNode || undefined };
    }
    async pdf(params, metadata) {
        if (!this._page.pdf)
            throw new Error('PDF generation is only supported for Headless Chromium');
        const buffer = await this._page.pdf(params);
        return { pdf: buffer.toString('base64') };
    }
    async bringToFront(params, metadata) {
        await this._page.bringToFront();
    }
    async startJSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        await coverage.startJSCoverage(params);
    }
    async stopJSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        return { entries: await coverage.stopJSCoverage() };
    }
    async startCSSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        await coverage.startCSSCoverage(params);
    }
    async stopCSSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        return { entries: await coverage.stopCSSCoverage() };
    }
    _onFrameAttached(frame) {
        this._dispatchEvent('frameAttached', { frame: frameDispatcher_1.FrameDispatcher.from(this._scope, frame) });
    }
    _onFrameDetached(frame) {
        this._dispatchEvent('frameDetached', { frame: dispatcher_1.lookupDispatcher(frame) });
    }
}
exports.PageDispatcher = PageDispatcher;
class WorkerDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, worker) {
        super(scope, worker, 'Worker', {
            url: worker.url()
        });
        worker.on(page_1.Worker.Events.Close, () => this._dispatchEvent('close'));
    }
    async evaluateExpression(params, metadata) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evaluateExpressionHandle(params, metadata) {
        return { handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
}
exports.WorkerDispatcher = WorkerDispatcher;
class BindingCallDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, name, needsHandle, source, args) {
        super(scope, { guid: utils_1.createGuid() }, 'BindingCall', {
            frame: dispatcher_1.lookupDispatcher(source.frame),
            name,
            args: needsHandle ? undefined : args.map(jsHandleDispatcher_1.serializeResult),
            handle: needsHandle ? elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : undefined,
        });
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    promise() {
        return this._promise;
    }
    async resolve(params, metadata) {
        this._resolve(jsHandleDispatcher_1.parseArgument(params.result));
    }
    async reject(params, metadata) {
        this._reject(serializers_1.parseError(params.error));
    }
}
exports.BindingCallDispatcher = BindingCallDispatcher;
//# sourceMappingURL=pageDispatcher.js.map

/***/ }),

/***/ 930:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlaywrightDispatcher = void 0;
const androidDispatcher_1 = __nccwpck_require__(3893);
const browserTypeDispatcher_1 = __nccwpck_require__(2);
const dispatcher_1 = __nccwpck_require__(5031);
const electronDispatcher_1 = __nccwpck_require__(8327);
const selectorsDispatcher_1 = __nccwpck_require__(7503);
const socksSocketDispatcher_1 = __nccwpck_require__(3726);
class PlaywrightDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, playwright, customSelectors, preLaunchedBrowser) {
        const descriptors = __nccwpck_require__(5);
        const deviceDescriptors = Object.entries(descriptors)
            .map(([name, descriptor]) => ({ name, descriptor }));
        super(scope, playwright, 'Playwright', {
            chromium: new browserTypeDispatcher_1.BrowserTypeDispatcher(scope, playwright.chromium),
            firefox: new browserTypeDispatcher_1.BrowserTypeDispatcher(scope, playwright.firefox),
            webkit: new browserTypeDispatcher_1.BrowserTypeDispatcher(scope, playwright.webkit),
            android: new androidDispatcher_1.AndroidDispatcher(scope, playwright.android),
            electron: new electronDispatcher_1.ElectronDispatcher(scope, playwright.electron),
            deviceDescriptors,
            selectors: customSelectors || new selectorsDispatcher_1.SelectorsDispatcher(scope, playwright.selectors),
            preLaunchedBrowser,
        }, false);
        this._object.on('incomingSocksSocket', (socket) => {
            this._dispatchEvent('incomingSocksSocket', { socket: new socksSocketDispatcher_1.SocksSocketDispatcher(this, socket) });
        });
    }
    async setForwardedPorts(params) {
        this._object._setForwardedPorts(params.ports);
    }
}
exports.PlaywrightDispatcher = PlaywrightDispatcher;
//# sourceMappingURL=playwrightDispatcher.js.map

/***/ }),

/***/ 7503:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectorsDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
class SelectorsDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, selectors) {
        super(scope, selectors, 'Selectors', {});
    }
    async register(params) {
        await this._object.register(params.name, params.source, params.contentScript);
    }
}
exports.SelectorsDispatcher = SelectorsDispatcher;
//# sourceMappingURL=selectorsDispatcher.js.map

/***/ }),

/***/ 3726:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocksSocketDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
class SocksSocketDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, socket) {
        super(scope, socket, 'SocksSocket', {
            dstAddr: socket.dstAddr,
            dstPort: socket.dstPort
        }, true);
        socket.on('data', (data) => this._dispatchEvent('data', { data: data.toString('base64') }));
        socket.on('close', () => {
            this._dispatchEvent('close');
            this._dispose();
        });
    }
    async connected() {
        this._object.connected();
    }
    async error(params) {
        this._object.error(params.error);
    }
    async write(params) {
        this._object.write(Buffer.from(params.data, 'base64'));
    }
    async end() {
        this._object.end();
    }
}
exports.SocksSocketDispatcher = SocksSocketDispatcher;
//# sourceMappingURL=socksSocketDispatcher.js.map

/***/ }),

/***/ 5871:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamDispatcher = void 0;
const dispatcher_1 = __nccwpck_require__(5031);
const utils_1 = __nccwpck_require__(6416);
class StreamDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, stream) {
        super(scope, { guid: utils_1.createGuid(), stream }, 'Stream', {});
        this._ended = false;
        // In Node v12.9.0+ we can use readableEnded.
        stream.once('end', () => this._ended = true);
        stream.once('error', () => this._ended = true);
    }
    async read(params) {
        const stream = this._object.stream;
        if (this._ended)
            return { binary: '' };
        if (!stream.readableLength) {
            await new Promise((fulfill, reject) => {
                stream.once('readable', fulfill);
                stream.once('end', fulfill);
                stream.once('error', reject);
            });
        }
        const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
        return { binary: buffer ? buffer.toString('base64') : '' };
    }
    async close() {
        this._object.stream.destroy();
    }
}
exports.StreamDispatcher = StreamDispatcher;
//# sourceMappingURL=streamDispatcher.js.map

/***/ }),

/***/ 5698:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nccwpck_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nccwpck_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nccwpck_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nccwpck_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nccwpck_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nccwpck_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nccwpck_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nccwpck_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nccwpck_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nccwpck_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nccwpck_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nccwpck_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nccwpck_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(__nccwpck_require__.s = \"./src/server/supplements/injected/consoleApi.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/server/common/cssParser.ts\":\n/*!****************************************!*\\\n  !*** ./src/server/common/cssParser.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeSelector = exports.parseCSS = void 0;\nconst css = __importStar(__nccwpck_require__(/*! ./cssTokenizer */ \"./src/server/common/cssTokenizer.js\"));\nfunction parseCSS(selector, customNames) {\n    let tokens;\n    try {\n        tokens = css.tokenize(selector);\n        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))\n            tokens.push(new css.EOFToken());\n    }\n    catch (e) {\n        const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n        const index = (e.stack || '').indexOf(e.message);\n        if (index !== -1)\n            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n        e.message = newMessage;\n        throw e;\n    }\n    const unsupportedToken = tokens.find(token => {\n        return (token instanceof css.AtKeywordToken) ||\n            (token instanceof css.BadStringToken) ||\n            (token instanceof css.BadURLToken) ||\n            (token instanceof css.ColumnToken) ||\n            (token instanceof css.CDOToken) ||\n            (token instanceof css.CDCToken) ||\n            (token instanceof css.SemicolonToken) ||\n            // TODO: Consider using these for something, e.g. to escape complex strings.\n            // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n            // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n            (token instanceof css.OpenCurlyToken) ||\n            (token instanceof css.CloseCurlyToken) ||\n            // TODO: Consider treating these as strings?\n            (token instanceof css.URLToken) ||\n            (token instanceof css.PercentageToken);\n    });\n    if (unsupportedToken)\n        throw new Error(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n    let pos = 0;\n    const names = new Set();\n    function unexpected() {\n        return new Error(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n    }\n    function skipWhitespace() {\n        while (tokens[pos] instanceof css.WhitespaceToken)\n            pos++;\n    }\n    function isIdent(p = pos) {\n        return tokens[p] instanceof css.IdentToken;\n    }\n    function isString(p = pos) {\n        return tokens[p] instanceof css.StringToken;\n    }\n    function isNumber(p = pos) {\n        return tokens[p] instanceof css.NumberToken;\n    }\n    function isComma(p = pos) {\n        return tokens[p] instanceof css.CommaToken;\n    }\n    function isCloseParen(p = pos) {\n        return tokens[p] instanceof css.CloseParenToken;\n    }\n    function isStar(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';\n    }\n    function isEOF(p = pos) {\n        return tokens[p] instanceof css.EOFToken;\n    }\n    function isClauseCombinator(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));\n    }\n    function isSelectorClauseEnd(p = pos) {\n        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);\n    }\n    function consumeFunctionArguments() {\n        const result = [consumeArgument()];\n        while (true) {\n            skipWhitespace();\n            if (!isComma())\n                break;\n            pos++;\n            result.push(consumeArgument());\n        }\n        return result;\n    }\n    function consumeArgument() {\n        skipWhitespace();\n        if (isNumber())\n            return tokens[pos++].value;\n        if (isString())\n            return tokens[pos++].value;\n        return consumeComplexSelector();\n    }\n    function consumeComplexSelector() {\n        skipWhitespace();\n        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };\n        while (true) {\n            skipWhitespace();\n            if (isClauseCombinator()) {\n                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n                skipWhitespace();\n            }\n            else if (isSelectorClauseEnd()) {\n                break;\n            }\n            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });\n        }\n        return result;\n    }\n    function consumeSimpleSelector() {\n        let rawCSSString = '';\n        const functions = [];\n        while (!isSelectorClauseEnd()) {\n            if (isIdent() || isStar()) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if (tokens[pos] instanceof css.HashToken) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {\n                pos++;\n                if (isIdent())\n                    rawCSSString += '.' + tokens[pos++].toSource();\n                else\n                    throw unexpected();\n            }\n            else if (tokens[pos] instanceof css.ColonToken) {\n                pos++;\n                if (isIdent()) {\n                    if (!customNames.has(tokens[pos].value.toLowerCase())) {\n                        rawCSSString += ':' + tokens[pos++].toSource();\n                    }\n                    else {\n                        const name = tokens[pos++].value.toLowerCase();\n                        functions.push({ name, args: [] });\n                        names.add(name);\n                    }\n                }\n                else if (tokens[pos] instanceof css.FunctionToken) {\n                    const name = tokens[pos++].value.toLowerCase();\n                    if (!customNames.has(name)) {\n                        rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n                    }\n                    else {\n                        functions.push({ name, args: consumeFunctionArguments() });\n                        names.add(name);\n                    }\n                    skipWhitespace();\n                    if (!isCloseParen())\n                        throw unexpected();\n                    pos++;\n                }\n                else {\n                    throw unexpected();\n                }\n            }\n            else if (tokens[pos] instanceof css.OpenSquareToken) {\n                rawCSSString += '[';\n                pos++;\n                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())\n                    rawCSSString += tokens[pos++].toSource();\n                if (!(tokens[pos] instanceof css.CloseSquareToken))\n                    throw unexpected();\n                rawCSSString += ']';\n                pos++;\n            }\n            else {\n                throw unexpected();\n            }\n        }\n        if (!rawCSSString && !functions.length)\n            throw unexpected();\n        return { css: rawCSSString || undefined, functions };\n    }\n    function consumeBuiltinFunctionArguments() {\n        let s = '';\n        while (!isCloseParen() && !isEOF())\n            s += tokens[pos++].toSource();\n        return s;\n    }\n    const result = consumeFunctionArguments();\n    if (!isEOF())\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    return { selector: result, names: Array.from(names) };\n}\nexports.parseCSS = parseCSS;\nfunction serializeSelector(args) {\n    return args.map(arg => {\n        if (typeof arg === 'string')\n            return `\"${arg}\"`;\n        if (typeof arg === 'number')\n            return String(arg);\n        return arg.simples.map(({ selector, combinator }) => {\n            let s = selector.css || '';\n            s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n            if (combinator)\n                s += ' ' + combinator;\n            return s;\n        }).join(' ');\n    }).join(', ');\n}\nexports.serializeSelector = serializeSelector;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/cssTokenizer.js\":\n/*!*******************************************!*\\\n  !*** ./src/server/common/cssTokenizer.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n * Original at https://github.com/tabatkins/parse-css\n * licensed under http://creativecommons.org/publicdomain/zero/1.0/\n *\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Changes from https://github.com/tabatkins/parse-css\n//   - Tabs are replaced with two spaces.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n// @ts-nocheck\n(function (root, factory) {\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}(this, function (exports) {\n    var between = function (num, first, last) { return num >= first && num <= last; };\n    function digit(code) { return between(code, 0x30, 0x39); }\n    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }\n    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }\n    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }\n    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\n    function nonascii(code) { return code >= 0x80; }\n    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\n    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\n    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }\n    function newline(code) { return code == 0xa; }\n    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\n    function badescape(code) { return newline(code) || isNaN(code); }\n    var maximumallowedcodepoint = 0x10ffff;\n    var InvalidCharacterError = function (message) {\n        this.message = message;\n    };\n    InvalidCharacterError.prototype = new Error;\n    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n    function preprocess(str) {\n        // Turn a string into an array of code points,\n        // following the preprocessing cleanup rules.\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n            var code = str.charCodeAt(i);\n            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n                code = 0xa;\n                i++;\n            }\n            if (code == 0xd || code == 0xc)\n                code = 0xa;\n            if (code == 0x0)\n                code = 0xfffd;\n            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n                // Decode a surrogate pair into an astral codepoint.\n                var lead = code - 0xd800;\n                var trail = str.charCodeAt(i + 1) - 0xdc00;\n                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n                i++;\n            }\n            codepoints.push(code);\n        }\n        return codepoints;\n    }\n    function stringFromCode(code) {\n        if (code <= 0xffff)\n            return String.fromCharCode(code);\n        // Otherwise, encode astral char as surrogate pair.\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n        var trail = code % Math.pow(2, 10) + 0xdc00;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n    }\n    function tokenize(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        // Line number information.\n        var line = 0;\n        var column = 0;\n        // The only use of lastLineLength is in reconsume().\n        var lastLineLength = 0;\n        var incrLineno = function () {\n            line += 1;\n            lastLineLength = column;\n            column = 0;\n        };\n        var locStart = { line: line, column: column };\n        var codepoint = function (i) {\n            if (i >= str.length) {\n                return -1;\n            }\n            return str[i];\n        };\n        var next = function (num) {\n            if (num === undefined)\n                num = 1;\n            if (num > 3)\n                throw \"Spec Error: no more than three codepoints of lookahead.\";\n            return codepoint(i + num);\n        };\n        var consume = function (num) {\n            if (num === undefined)\n                num = 1;\n            i += num;\n            code = codepoint(i);\n            if (newline(code))\n                incrLineno();\n            else\n                column += num;\n            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n            return true;\n        };\n        var reconsume = function () {\n            i -= 1;\n            if (newline(code)) {\n                line -= 1;\n                column = lastLineLength;\n            }\n            else {\n                column -= 1;\n            }\n            locStart.line = line;\n            locStart.column = column;\n            return true;\n        };\n        var eof = function (codepoint) {\n            if (codepoint === undefined)\n                codepoint = code;\n            return codepoint == -1;\n        };\n        var donothing = function () { };\n        var parseerror = function () { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\"); return true; };\n        var consumeAToken = function () {\n            consumeComments();\n            consume();\n            if (whitespace(code)) {\n                while (whitespace(next()))\n                    consume();\n                return new WhitespaceToken;\n            }\n            else if (code == 0x22)\n                return consumeAStringToken();\n            else if (code == 0x23) {\n                if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n                    var token = new HashToken();\n                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                        token.type = \"id\";\n                    token.value = consumeAName();\n                    return token;\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x24) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SuffixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x27)\n                return consumeAStringToken();\n            else if (code == 0x28)\n                return new OpenParenToken();\n            else if (code == 0x29)\n                return new CloseParenToken();\n            else if (code == 0x2a) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SubstringMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2b) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2c)\n                return new CommaToken();\n            else if (code == 0x2d) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else if (next(1) == 0x2d && next(2) == 0x3e) {\n                    consume(2);\n                    return new CDCToken();\n                }\n                else if (startsWithAnIdentifier()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2e) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x3a)\n                return new ColonToken;\n            else if (code == 0x3b)\n                return new SemicolonToken;\n            else if (code == 0x3c) {\n                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n                    consume(3);\n                    return new CDOToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x40) {\n                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                    return new AtKeywordToken(consumeAName());\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5b)\n                return new OpenSquareToken();\n            else if (code == 0x5c) {\n                if (startsWithAValidEscape()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    parseerror();\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5d)\n                return new CloseSquareToken();\n            else if (code == 0x5e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new PrefixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7b)\n                return new OpenCurlyToken();\n            else if (code == 0x7c) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new DashMatchToken();\n                }\n                else if (next() == 0x7c) {\n                    consume();\n                    return new ColumnToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7d)\n                return new CloseCurlyToken();\n            else if (code == 0x7e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new IncludeMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (digit(code)) {\n                reconsume();\n                return consumeANumericToken();\n            }\n            else if (namestartchar(code)) {\n                reconsume();\n                return consumeAnIdentlikeToken();\n            }\n            else if (eof())\n                return new EOFToken();\n            else\n                return new DelimToken(code);\n        };\n        var consumeComments = function () {\n            while (next(1) == 0x2f && next(2) == 0x2a) {\n                consume(2);\n                while (true) {\n                    consume();\n                    if (code == 0x2a && next() == 0x2f) {\n                        consume();\n                        break;\n                    }\n                    else if (eof()) {\n                        parseerror();\n                        return;\n                    }\n                }\n            }\n        };\n        var consumeANumericToken = function () {\n            var num = consumeANumber();\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                var token = new DimensionToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                token.unit = consumeAName();\n                return token;\n            }\n            else if (next() == 0x25) {\n                consume();\n                var token = new PercentageToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                return token;\n            }\n            else {\n                var token = new NumberToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                return token;\n            }\n        };\n        var consumeAnIdentlikeToken = function () {\n            var str = consumeAName();\n            if (str.toLowerCase() == \"url\" && next() == 0x28) {\n                consume();\n                while (whitespace(next(1)) && whitespace(next(2)))\n                    consume();\n                if (next() == 0x22 || next() == 0x27) {\n                    return new FunctionToken(str);\n                }\n                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n                    return new FunctionToken(str);\n                }\n                else {\n                    return consumeAURLToken();\n                }\n            }\n            else if (next() == 0x28) {\n                consume();\n                return new FunctionToken(str);\n            }\n            else {\n                return new IdentToken(str);\n            }\n        };\n        var consumeAStringToken = function (endingCodePoint) {\n            if (endingCodePoint === undefined)\n                endingCodePoint = code;\n            var string = \"\";\n            while (consume()) {\n                if (code == endingCodePoint || eof()) {\n                    return new StringToken(string);\n                }\n                else if (newline(code)) {\n                    parseerror();\n                    reconsume();\n                    return new BadStringToken();\n                }\n                else if (code == 0x5c) {\n                    if (eof(next())) {\n                        donothing();\n                    }\n                    else if (newline(next())) {\n                        consume();\n                    }\n                    else {\n                        string += stringFromCode(consumeEscape());\n                    }\n                }\n                else {\n                    string += stringFromCode(code);\n                }\n            }\n        };\n        var consumeAURLToken = function () {\n            var token = new URLToken(\"\");\n            while (whitespace(next()))\n                consume();\n            if (eof(next()))\n                return token;\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return token;\n                }\n                else if (whitespace(code)) {\n                    while (whitespace(next()))\n                        consume();\n                    if (next() == 0x29 || eof(next())) {\n                        consume();\n                        return token;\n                    }\n                    else {\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n                    parseerror();\n                    consumeTheRemnantsOfABadURL();\n                    return new BadURLToken();\n                }\n                else if (code == 0x5c) {\n                    if (startsWithAValidEscape()) {\n                        token.value += stringFromCode(consumeEscape());\n                    }\n                    else {\n                        parseerror();\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else {\n                    token.value += stringFromCode(code);\n                }\n            }\n        };\n        var consumeEscape = function () {\n            // Assume the the current character is the \\\n            // and the next code point is not a newline.\n            consume();\n            if (hexdigit(code)) {\n                // Consume 1-6 hex digits\n                var digits = [code];\n                for (var total = 0; total < 5; total++) {\n                    if (hexdigit(next())) {\n                        consume();\n                        digits.push(code);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (whitespace(next()))\n                    consume();\n                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);\n                if (value > maximumallowedcodepoint)\n                    value = 0xfffd;\n                return value;\n            }\n            else if (eof()) {\n                return 0xfffd;\n            }\n            else {\n                return code;\n            }\n        };\n        var areAValidEscape = function (c1, c2) {\n            if (c1 != 0x5c)\n                return false;\n            if (newline(c2))\n                return false;\n            return true;\n        };\n        var startsWithAValidEscape = function () {\n            return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function (c1, c2, c3) {\n            if (c1 == 0x2d) {\n                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n            }\n            else if (namestartchar(c1)) {\n                return true;\n            }\n            else if (c1 == 0x5c) {\n                return areAValidEscape(c1, c2);\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithAnIdentifier = function () {\n            return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function (c1, c2, c3) {\n            if (c1 == 0x2b || c1 == 0x2d) {\n                if (digit(c2))\n                    return true;\n                if (c2 == 0x2e && digit(c3))\n                    return true;\n                return false;\n            }\n            else if (c1 == 0x2e) {\n                if (digit(c2))\n                    return true;\n                return false;\n            }\n            else if (digit(c1)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithANumber = function () {\n            return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function () {\n            var result = \"\";\n            while (consume()) {\n                if (namechar(code)) {\n                    result += stringFromCode(code);\n                }\n                else if (startsWithAValidEscape()) {\n                    result += stringFromCode(consumeEscape());\n                }\n                else {\n                    reconsume();\n                    return result;\n                }\n            }\n        };\n        var consumeANumber = function () {\n            var repr = [];\n            var type = \"integer\";\n            if (next() == 0x2b || next() == 0x2d) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            while (digit(next())) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            if (next(1) == 0x2e && digit(next(2))) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var c1 = next(1), c2 = next(2), c3 = next(3);\n            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var value = convertAStringToANumber(repr);\n            return { type: type, value: value, repr: repr };\n        };\n        var convertAStringToANumber = function (string) {\n            // CSS's number rules are identical to JS, afaik.\n            return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function () {\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return;\n                }\n                else if (startsWithAValidEscape()) {\n                    consumeEscape();\n                    donothing();\n                }\n                else {\n                    donothing();\n                }\n            }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n            tokens.push(consumeAToken());\n            iterationCount++;\n            if (iterationCount > str.length * 2)\n                return \"I'm infinite-looping!\";\n        }\n        return tokens;\n    }\n    function CSSParserToken() { throw \"Abstract Base Class\"; }\n    CSSParserToken.prototype.toJSON = function () {\n        return { token: this.tokenType };\n    };\n    CSSParserToken.prototype.toString = function () { return this.tokenType; };\n    CSSParserToken.prototype.toSource = function () { return '' + this; };\n    function BadStringToken() { return this; }\n    BadStringToken.prototype = Object.create(CSSParserToken.prototype);\n    BadStringToken.prototype.tokenType = \"BADSTRING\";\n    function BadURLToken() { return this; }\n    BadURLToken.prototype = Object.create(CSSParserToken.prototype);\n    BadURLToken.prototype.tokenType = \"BADURL\";\n    function WhitespaceToken() { return this; }\n    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);\n    WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\n    WhitespaceToken.prototype.toString = function () { return \"WS\"; };\n    WhitespaceToken.prototype.toSource = function () { return \" \"; };\n    function CDOToken() { return this; }\n    CDOToken.prototype = Object.create(CSSParserToken.prototype);\n    CDOToken.prototype.tokenType = \"CDO\";\n    CDOToken.prototype.toSource = function () { return \"<!--\"; };\n    function CDCToken() { return this; }\n    CDCToken.prototype = Object.create(CSSParserToken.prototype);\n    CDCToken.prototype.tokenType = \"CDC\";\n    CDCToken.prototype.toSource = function () { return \"-->\"; };\n    function ColonToken() { return this; }\n    ColonToken.prototype = Object.create(CSSParserToken.prototype);\n    ColonToken.prototype.tokenType = \":\";\n    function SemicolonToken() { return this; }\n    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);\n    SemicolonToken.prototype.tokenType = \";\";\n    function CommaToken() { return this; }\n    CommaToken.prototype = Object.create(CSSParserToken.prototype);\n    CommaToken.prototype.tokenType = \",\";\n    function GroupingToken() { throw \"Abstract Base Class\"; }\n    GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n    function OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\n    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    OpenCurlyToken.prototype.tokenType = \"{\";\n    function CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\n    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    CloseCurlyToken.prototype.tokenType = \"}\";\n    function OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\n    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);\n    OpenSquareToken.prototype.tokenType = \"[\";\n    function CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\n    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);\n    CloseSquareToken.prototype.tokenType = \"]\";\n    function OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\n    OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n    OpenParenToken.prototype.tokenType = \"(\";\n    function CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\n    CloseParenToken.prototype = Object.create(GroupingToken.prototype);\n    CloseParenToken.prototype.tokenType = \")\";\n    function IncludeMatchToken() { return this; }\n    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    IncludeMatchToken.prototype.tokenType = \"~=\";\n    function DashMatchToken() { return this; }\n    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    DashMatchToken.prototype.tokenType = \"|=\";\n    function PrefixMatchToken() { return this; }\n    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    PrefixMatchToken.prototype.tokenType = \"^=\";\n    function SuffixMatchToken() { return this; }\n    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SuffixMatchToken.prototype.tokenType = \"$=\";\n    function SubstringMatchToken() { return this; }\n    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SubstringMatchToken.prototype.tokenType = \"*=\";\n    function ColumnToken() { return this; }\n    ColumnToken.prototype = Object.create(CSSParserToken.prototype);\n    ColumnToken.prototype.tokenType = \"||\";\n    function EOFToken() { return this; }\n    EOFToken.prototype = Object.create(CSSParserToken.prototype);\n    EOFToken.prototype.tokenType = \"EOF\";\n    EOFToken.prototype.toSource = function () { return \"\"; };\n    function DelimToken(code) {\n        this.value = stringFromCode(code);\n        return this;\n    }\n    DelimToken.prototype = Object.create(CSSParserToken.prototype);\n    DelimToken.prototype.tokenType = \"DELIM\";\n    DelimToken.prototype.toString = function () { return \"DELIM(\" + this.value + \")\"; };\n    DelimToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    DelimToken.prototype.toSource = function () {\n        if (this.value == \"\\\\\")\n            return \"\\\\\\n\";\n        else\n            return this.value;\n    };\n    function StringValuedToken() { throw \"Abstract Base Class\"; }\n    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n    StringValuedToken.prototype.ASCIIMatch = function (str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n    };\n    StringValuedToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    function IdentToken(val) {\n        this.value = val;\n    }\n    IdentToken.prototype = Object.create(StringValuedToken.prototype);\n    IdentToken.prototype.tokenType = \"IDENT\";\n    IdentToken.prototype.toString = function () { return \"IDENT(\" + this.value + \")\"; };\n    IdentToken.prototype.toSource = function () {\n        return escapeIdent(this.value);\n    };\n    function FunctionToken(val) {\n        this.value = val;\n        this.mirror = \")\";\n    }\n    FunctionToken.prototype = Object.create(StringValuedToken.prototype);\n    FunctionToken.prototype.tokenType = \"FUNCTION\";\n    FunctionToken.prototype.toString = function () { return \"FUNCTION(\" + this.value + \")\"; };\n    FunctionToken.prototype.toSource = function () {\n        return escapeIdent(this.value) + \"(\";\n    };\n    function AtKeywordToken(val) {\n        this.value = val;\n    }\n    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);\n    AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\n    AtKeywordToken.prototype.toString = function () { return \"AT(\" + this.value + \")\"; };\n    AtKeywordToken.prototype.toSource = function () {\n        return \"@\" + escapeIdent(this.value);\n    };\n    function HashToken(val) {\n        this.value = val;\n        this.type = \"unrestricted\";\n    }\n    HashToken.prototype = Object.create(StringValuedToken.prototype);\n    HashToken.prototype.tokenType = \"HASH\";\n    HashToken.prototype.toString = function () { return \"HASH(\" + this.value + \")\"; };\n    HashToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n    };\n    HashToken.prototype.toSource = function () {\n        if (this.type == \"id\") {\n            return \"#\" + escapeIdent(this.value);\n        }\n        else {\n            return \"#\" + escapeHash(this.value);\n        }\n    };\n    function StringToken(val) {\n        this.value = val;\n    }\n    StringToken.prototype = Object.create(StringValuedToken.prototype);\n    StringToken.prototype.tokenType = \"STRING\";\n    StringToken.prototype.toString = function () {\n        return '\"' + escapeString(this.value) + '\"';\n    };\n    function URLToken(val) {\n        this.value = val;\n    }\n    URLToken.prototype = Object.create(StringValuedToken.prototype);\n    URLToken.prototype.tokenType = \"URL\";\n    URLToken.prototype.toString = function () { return \"URL(\" + this.value + \")\"; };\n    URLToken.prototype.toSource = function () {\n        return 'url(\"' + escapeString(this.value) + '\")';\n    };\n    function NumberToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n    }\n    NumberToken.prototype = Object.create(CSSParserToken.prototype);\n    NumberToken.prototype.tokenType = \"NUMBER\";\n    NumberToken.prototype.toString = function () {\n        if (this.type == \"integer\")\n            return \"INT(\" + this.value + \")\";\n        return \"NUMBER(\" + this.value + \")\";\n    };\n    NumberToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n    };\n    NumberToken.prototype.toSource = function () { return this.repr; };\n    function PercentageToken() {\n        this.value = null;\n        this.repr = \"\";\n    }\n    PercentageToken.prototype = Object.create(CSSParserToken.prototype);\n    PercentageToken.prototype.tokenType = \"PERCENTAGE\";\n    PercentageToken.prototype.toString = function () { return \"PERCENTAGE(\" + this.value + \")\"; };\n    PercentageToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n    };\n    PercentageToken.prototype.toSource = function () { return this.repr + \"%\"; };\n    function DimensionToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n        this.unit = \"\";\n    }\n    DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\n    DimensionToken.prototype.toString = function () { return \"DIM(\" + this.value + \",\" + this.unit + \")\"; };\n    DimensionToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n    };\n    DimensionToken.prototype.toSource = function () {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n            // Unit is ambiguous with scinot\n            // Remove the leading \"e\", replace with escape.\n            unit = \"\\\\65 \" + unit.slice(1, unit.length);\n        }\n        return source + unit;\n    };\n    function escapeIdent(string) {\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f ||\n                (i == 0 && between(code, 0x30, 0x39)) ||\n                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + string[i];\n            }\n        }\n        return result;\n    }\n    function escapeHash(string) {\n        // Escapes the contents of \"unrestricted\"-type hash tokens.\n        // Won't preserve the ID-ness of \"id\"-type hash tokens;\n        // use escapeIdent() for that.\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n        }\n        return result;\n    }\n    function escapeString(string) {\n        string = '' + string;\n        var result = '';\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code == 0x22 || code == 0x5c) {\n                result += '\\\\' + string[i];\n            }\n            else {\n                result += string[i];\n            }\n        }\n        return result;\n    }\n    // Exportation.\n    exports.tokenize = tokenize;\n    exports.IdentToken = IdentToken;\n    exports.FunctionToken = FunctionToken;\n    exports.AtKeywordToken = AtKeywordToken;\n    exports.HashToken = HashToken;\n    exports.StringToken = StringToken;\n    exports.BadStringToken = BadStringToken;\n    exports.URLToken = URLToken;\n    exports.BadURLToken = BadURLToken;\n    exports.DelimToken = DelimToken;\n    exports.NumberToken = NumberToken;\n    exports.PercentageToken = PercentageToken;\n    exports.DimensionToken = DimensionToken;\n    exports.IncludeMatchToken = IncludeMatchToken;\n    exports.DashMatchToken = DashMatchToken;\n    exports.PrefixMatchToken = PrefixMatchToken;\n    exports.SuffixMatchToken = SuffixMatchToken;\n    exports.SubstringMatchToken = SubstringMatchToken;\n    exports.ColumnToken = ColumnToken;\n    exports.WhitespaceToken = WhitespaceToken;\n    exports.CDOToken = CDOToken;\n    exports.CDCToken = CDCToken;\n    exports.ColonToken = ColonToken;\n    exports.SemicolonToken = SemicolonToken;\n    exports.CommaToken = CommaToken;\n    exports.OpenParenToken = OpenParenToken;\n    exports.CloseParenToken = CloseParenToken;\n    exports.OpenSquareToken = OpenSquareToken;\n    exports.CloseSquareToken = CloseSquareToken;\n    exports.OpenCurlyToken = OpenCurlyToken;\n    exports.CloseCurlyToken = CloseCurlyToken;\n    exports.EOFToken = EOFToken;\n    exports.CSSParserToken = CSSParserToken;\n    exports.GroupingToken = GroupingToken;\n}));\n\n\n/***/ }),\n\n/***/ \"./src/server/common/selectorParser.ts\":\n/*!*********************************************!*\\\n  !*** ./src/server/common/selectorParser.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseSelector = exports.customCSSNames = void 0;\nconst cssParser_1 = __nccwpck_require__(/*! ./cssParser */ \"./src/server/common/cssParser.ts\");\nexports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nfunction parseSelector(selector) {\n    const result = parseSelectorV1(selector);\n    result.parts = result.parts.map(part => {\n        if (Array.isArray(part))\n            return part;\n        if (part.name === 'css' || part.name === 'css:light') {\n            if (part.name === 'css:light')\n                part.body = ':light(' + part.body + ')';\n            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);\n            return parsedCSS.selector;\n        }\n        return part;\n    });\n    return {\n        parts: result.parts,\n        capture: result.capture,\n    };\n}\nexports.parseSelector = parseSelector;\nfunction parseSelectorV1(selector) {\n    let index = 0;\n    let quote;\n    let start = 0;\n    const result = { parts: [] };\n    const append = () => {\n        const part = selector.substring(start, index).trim();\n        const eqIndex = part.indexOf('=');\n        let name;\n        let body;\n        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n            name = part.substring(0, eqIndex).trim();\n            body = part.substring(eqIndex + 1);\n        }\n        else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n            name = 'text';\n            body = part;\n        }\n        else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n            name = 'text';\n            body = part;\n        }\n        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n            // If selector starts with '//' or '//' prefixed with multiple opening\n            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n            // If selector starts with '..', consider xpath as well.\n            name = 'xpath';\n            body = part;\n        }\n        else {\n            name = 'css';\n            body = part;\n        }\n        let capture = false;\n        if (name[0] === '*') {\n            capture = true;\n            name = name.substring(1);\n        }\n        result.parts.push({ name, body });\n        if (capture) {\n            if (result.capture !== undefined)\n                throw new Error(`Only one of the selectors can capture using * modifier`);\n            result.capture = result.parts.length - 1;\n        }\n    };\n    if (!selector.includes('>>')) {\n        index = selector.length;\n        append();\n        return result;\n    }\n    while (index < selector.length) {\n        const c = selector[index];\n        if (c === '\\\\' && index + 1 < selector.length) {\n            index += 2;\n        }\n        else if (c === quote) {\n            quote = undefined;\n            index++;\n        }\n        else if (!quote && (c === '\"' || c === '\\'' || c === '`')) {\n            quote = c;\n            index++;\n        }\n        else if (!quote && c === '>' && selector[index + 1] === '>') {\n            append();\n            index += 2;\n            start = index;\n        }\n        else {\n            index++;\n        }\n    }\n    append();\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/injected/selectorEvaluator.ts\":\n/*!**************************************************!*\\\n  !*** ./src/server/injected/selectorEvaluator.ts ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;\nconst selectorParser_1 = __nccwpck_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\nclass SelectorEvaluatorImpl {\n    constructor(extraEngines) {\n        this._engines = new Map();\n        this._cacheQueryCSS = new Map();\n        this._cacheMatches = new Map();\n        this._cacheQuery = new Map();\n        this._cacheMatchesSimple = new Map();\n        this._cacheMatchesParents = new Map();\n        this._cacheCallMatches = new Map();\n        this._cacheCallQuery = new Map();\n        this._cacheQuerySimple = new Map();\n        this._cacheText = new Map();\n        this._retainCacheCounter = 0;\n        for (const [name, engine] of extraEngines)\n            this._engines.set(name, engine);\n        this._engines.set('not', notEngine);\n        this._engines.set('is', isEngine);\n        this._engines.set('where', isEngine);\n        this._engines.set('has', hasEngine);\n        this._engines.set('scope', scopeEngine);\n        this._engines.set('light', lightEngine);\n        this._engines.set('visible', visibleEngine);\n        this._engines.set('text', textEngine);\n        this._engines.set('text-is', textIsEngine);\n        this._engines.set('text-matches', textMatchesEngine);\n        this._engines.set('has-text', hasTextEngine);\n        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));\n        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));\n        this._engines.set('above', createPositionEngine('above', boxAbove));\n        this._engines.set('below', createPositionEngine('below', boxBelow));\n        this._engines.set('near', createPositionEngine('near', boxNear));\n        this._engines.set('nth-match', nthMatchEngine);\n        const allNames = [...this._engines.keys()];\n        allNames.sort();\n        const parserNames = [...selectorParser_1.customCSSNames];\n        parserNames.sort();\n        if (allNames.join('|') !== parserNames.join('|'))\n            throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join('|')} vs ${parserNames.join('|')}`);\n    }\n    begin() {\n        ++this._retainCacheCounter;\n    }\n    end() {\n        --this._retainCacheCounter;\n        if (!this._retainCacheCounter) {\n            this._cacheQueryCSS.clear();\n            this._cacheMatches.clear();\n            this._cacheQuery.clear();\n            this._cacheMatchesSimple.clear();\n            this._cacheMatchesParents.clear();\n            this._cacheCallMatches.clear();\n            this._cacheCallQuery.clear();\n            this._cacheQuerySimple.clear();\n            this._cacheText.clear();\n        }\n    }\n    _cached(cache, main, rest, cb) {\n        if (!cache.has(main))\n            cache.set(main, []);\n        const entries = cache.get(main);\n        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));\n        if (entry)\n            return entry.result;\n        const result = cb();\n        entries.push({ rest, result });\n        return result;\n    }\n    _checkSelector(s) {\n        const wellFormed = typeof s === 'object' && s &&\n            (Array.isArray(s) || ('simples' in s) && (s.simples.length));\n        if (!wellFormed)\n            throw new Error(`Malformed selector \"${s}\"`);\n        return s;\n    }\n    matches(element, s, context) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._matchesEngine(isEngine, element, selector, context);\n                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n                    return false;\n                return this._matchesParents(element, selector, selector.simples.length - 2, context);\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    query(context, s) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._queryEngine(isEngine, context, selector);\n                // query() recursively calls itself, so we set up a new map for this particular query() call.\n                const previousScoreMap = this._scoreMap;\n                this._scoreMap = new Map();\n                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));\n                if (this._scoreMap.size) {\n                    elements.sort((a, b) => {\n                        const aScore = this._scoreMap.get(a);\n                        const bScore = this._scoreMap.get(b);\n                        if (aScore === bScore)\n                            return 0;\n                        if (aScore === undefined)\n                            return 1;\n                        if (bScore === undefined)\n                            return -1;\n                        return aScore - bScore;\n                    });\n                }\n                this._scoreMap = previousScoreMap;\n                return elements;\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    _markScore(element, score) {\n        // HACK ALERT: temporary marks an element with a score, to be used\n        // for sorting at the end of the query().\n        if (this._scoreMap)\n            this._scoreMap.set(element, score);\n    }\n    _matchesSimple(element, simple, context) {\n        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');\n            if (!isPossiblyScopeClause && element === context.scope)\n                return false;\n            if (simple.css && !this._matchesCSS(element, simple.css))\n                return false;\n            for (const func of simple.functions) {\n                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n                    return false;\n            }\n            return true;\n        });\n    }\n    _querySimple(context, simple) {\n        if (!simple.functions.length)\n            return this._queryCSS(context, simple.css || '*');\n        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n            let css = simple.css;\n            const funcs = simple.functions;\n            if (css === '*' && funcs.length)\n                css = undefined;\n            let elements;\n            let firstIndex = -1;\n            if (css !== undefined) {\n                elements = this._queryCSS(context, css);\n            }\n            else {\n                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);\n                if (firstIndex === -1)\n                    firstIndex = 0;\n                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches !== undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches === undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            return elements;\n        });\n    }\n    _matchesParents(element, complex, index, context) {\n        if (index < 0)\n            return true;\n        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n            const { selector: simple, combinator } = complex.simples[index];\n            if (combinator === '>') {\n                const parent = parentElementOrShadowHostInContext(element, context);\n                if (!parent || !this._matchesSimple(parent, simple, context))\n                    return false;\n                return this._matchesParents(parent, complex, index - 1, context);\n            }\n            if (combinator === '+') {\n                const previousSibling = previousSiblingInContext(element, context);\n                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n                    return false;\n                return this._matchesParents(previousSibling, complex, index - 1, context);\n            }\n            if (combinator === '') {\n                let parent = parentElementOrShadowHostInContext(element, context);\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            if (combinator === '~') {\n                let previousSibling = previousSiblingInContext(element, context);\n                while (previousSibling) {\n                    if (this._matchesSimple(previousSibling, simple, context)) {\n                        if (this._matchesParents(previousSibling, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '~')\n                            break;\n                    }\n                    previousSibling = previousSiblingInContext(previousSibling, context);\n                }\n                return false;\n            }\n            if (combinator === '>=') {\n                let parent = element;\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            throw new Error(`Unsupported combinator \"${combinator}\"`);\n        });\n    }\n    _matchesEngine(engine, element, args, context) {\n        if (engine.matches)\n            return this._callMatches(engine, element, args, context);\n        if (engine.query)\n            return this._callQuery(engine, args, context).includes(element);\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _queryEngine(engine, context, args) {\n        if (engine.query)\n            return this._callQuery(engine, args, context);\n        if (engine.matches)\n            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _callMatches(engine, element, args, context) {\n        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n            return engine.matches(element, args, context, this);\n        });\n    }\n    _callQuery(engine, args, context) {\n        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n            return engine.query(context, args, this);\n        });\n    }\n    _matchesCSS(element, css) {\n        return element.matches(css);\n    }\n    _queryCSS(context, css) {\n        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\n            let result = [];\n            function query(root) {\n                result = result.concat([...root.querySelectorAll(css)]);\n                if (!context.pierceShadow)\n                    return;\n                if (root.shadowRoot)\n                    query(root.shadowRoot);\n                for (const element of root.querySelectorAll('*')) {\n                    if (element.shadowRoot)\n                        query(element.shadowRoot);\n                }\n            }\n            query(context.scope);\n            return result;\n        });\n    }\n    _getEngine(name) {\n        const engine = this._engines.get(name);\n        if (!engine)\n            throw new Error(`Unknown selector engine \"${name}\"`);\n        return engine;\n    }\n}\nexports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;\nconst isEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        return args.some(selector => evaluator.matches(element, selector, context));\n    },\n    query(context, args, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        let elements = [];\n        for (const arg of args)\n            elements = elements.concat(evaluator.query(context, arg));\n        return args.length === 1 ? elements : sortInDOMOrder(elements);\n    },\n};\nconst hasEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"has\" engine expects non-empty selector list`);\n        return evaluator.query({ ...context, scope: element }, args).length > 0;\n    },\n    // TODO: we do not implement \"relative selectors\", as in \"div:has(> span)\" or \"div:has(+ span)\".\n    // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n    // all parents/descendants, just have to be careful with the \":scope\" matching.\n};\nconst scopeEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)\n            return element === context.scope.documentElement;\n        return element === context.scope;\n    },\n    query(context, args, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {\n            const root = context.scope.documentElement;\n            return root ? [root] : [];\n        }\n        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)\n            return [context.scope];\n        return [];\n    },\n};\nconst notEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"not\" engine expects non-empty selector list`);\n        return !evaluator.matches(element, args, context);\n    },\n};\nconst lightEngine = {\n    query(context, args, evaluator) {\n        return evaluator.query({ ...context, pierceShadow: false }, args);\n    },\n    matches(element, args, context, evaluator) {\n        return evaluator.matches(element, args, { ...context, pierceShadow: false });\n    }\n};\nconst visibleEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length)\n            throw new Error(`\"visible\" engine expects no arguments`);\n        return isVisible(element);\n    }\n};\nconst textEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text\" engine expects a single string`);\n        const matcher = createLaxTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst textIsEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text-is\" engine expects a single string`);\n        const matcher = createStrictTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) !== 'none';\n    },\n};\nconst textMatchesEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))\n            throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst hasTextEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"has-text\" engine expects a single string`);\n        if (shouldSkipForTextMatching(element))\n            return false;\n        const matcher = createLaxTextMatcher(args[0]);\n        return matcher(elementText(evaluator, element));\n    },\n};\nfunction createLaxTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();\n    return (elementText) => {\n        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();\n        return s.includes(text);\n    };\n}\nexports.createLaxTextMatcher = createLaxTextMatcher;\nfunction createStrictTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ');\n    return (elementText) => {\n        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);\n    };\n}\nexports.createStrictTextMatcher = createStrictTextMatcher;\nfunction createRegexTextMatcher(source, flags) {\n    const re = new RegExp(source, flags);\n    return (elementText) => {\n        return re.test(elementText.full);\n    };\n}\nexports.createRegexTextMatcher = createRegexTextMatcher;\nfunction shouldSkipForTextMatching(element) {\n    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n    let value = evaluator._cacheText.get(root);\n    if (value === undefined) {\n        value = { full: '', immediate: [] };\n        if (!shouldSkipForTextMatching(root)) {\n            let currentImmediate = '';\n            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {\n                value = { full: root.value, immediate: [root.value] };\n            }\n            else {\n                for (let child = root.firstChild; child; child = child.nextSibling) {\n                    if (child.nodeType === Node.TEXT_NODE) {\n                        value.full += child.nodeValue || '';\n                        currentImmediate += child.nodeValue || '';\n                    }\n                    else {\n                        if (currentImmediate)\n                            value.immediate.push(currentImmediate);\n                        currentImmediate = '';\n                        if (child.nodeType === Node.ELEMENT_NODE)\n                            value.full += elementText(evaluator, child).full;\n                    }\n                }\n                if (currentImmediate)\n                    value.immediate.push(currentImmediate);\n                if (root.shadowRoot)\n                    value.full += elementText(evaluator, root.shadowRoot).full;\n            }\n        }\n        evaluator._cacheText.set(root, value);\n    }\n    return value;\n}\nexports.elementText = elementText;\nfunction elementMatchesText(evaluator, element, matcher) {\n    if (shouldSkipForTextMatching(element))\n        return 'none';\n    if (!matcher(elementText(evaluator, element)))\n        return 'none';\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))\n            return 'selfAndChildren';\n    }\n    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))\n        return 'selfAndChildren';\n    return 'self';\n}\nexports.elementMatchesText = elementMatchesText;\nfunction boxRightOf(box1, box2, maxDistance) {\n    const distance = box1.left - box2.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n    const distance = box2.left - box1.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n    const distance = box2.top - box1.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n    const distance = box1.top - box2.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n    const kThreshold = maxDistance === undefined ? 50 : maxDistance;\n    let score = 0;\n    if (box1.left - box2.right >= 0)\n        score += box1.left - box2.right;\n    if (box2.left - box1.right >= 0)\n        score += box2.left - box1.right;\n    if (box2.top - box1.bottom >= 0)\n        score += box2.top - box1.bottom;\n    if (box1.top - box2.bottom >= 0)\n        score += box1.top - box2.bottom;\n    return score > kThreshold ? undefined : score;\n}\nfunction createPositionEngine(name, scorer) {\n    return {\n        matches(element, args, context, evaluator) {\n            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;\n            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);\n            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))\n                throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n            const box = element.getBoundingClientRect();\n            let bestScore;\n            for (const e of evaluator.query(context, queryArgs)) {\n                if (e === element)\n                    continue;\n                const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n                if (score === undefined)\n                    continue;\n                if (bestScore === undefined || score < bestScore)\n                    bestScore = score;\n            }\n            if (bestScore === undefined)\n                return false;\n            evaluator._markScore(element, bestScore);\n            return true;\n        }\n    };\n}\nconst nthMatchEngine = {\n    query(context, args, evaluator) {\n        let index = args[args.length - 1];\n        if (args.length < 2)\n            throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n        if (typeof index !== 'number' || index < 1)\n            throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n        index--; // one-based\n        return index < elements.length ? [elements[index]] : [];\n    },\n};\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n}\nexports.parentElementOrShadowHost = parentElementOrShadowHost;\nfunction parentElementOrShadowHostInContext(element, context) {\n    if (element === context.scope)\n        return;\n    if (!context.pierceShadow)\n        return element.parentElement || undefined;\n    return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n    if (element === context.scope)\n        return;\n    return element.previousElementSibling || undefined;\n}\nfunction isVisible(element) {\n    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.\n    if (!element.ownerDocument || !element.ownerDocument.defaultView)\n        return true;\n    const style = element.ownerDocument.defaultView.getComputedStyle(element);\n    if (!style || style.visibility === 'hidden')\n        return false;\n    const rect = element.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n}\nexports.isVisible = isVisible;\nfunction sortInDOMOrder(elements) {\n    const elementToEntry = new Map();\n    const roots = [];\n    const result = [];\n    function append(element) {\n        let entry = elementToEntry.get(element);\n        if (entry)\n            return entry;\n        const parent = parentElementOrShadowHost(element);\n        if (parent) {\n            const parentEntry = append(parent);\n            parentEntry.children.push(element);\n        }\n        else {\n            roots.push(element);\n        }\n        entry = { children: [], taken: false };\n        elementToEntry.set(element, entry);\n        return entry;\n    }\n    elements.forEach(e => append(e).taken = true);\n    function visit(element) {\n        const entry = elementToEntry.get(element);\n        if (entry.taken)\n            result.push(element);\n        if (entry.children.length > 1) {\n            const set = new Set(entry.children);\n            entry.children = [];\n            let child = element.firstElementChild;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n        }\n        entry.children.forEach(visit);\n    }\n    roots.forEach(visit);\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/consoleApi.ts\":\n/*!*******************************************************!*\\\n  !*** ./src/server/supplements/injected/consoleApi.ts ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConsoleAPI = void 0;\nconst selectorGenerator_1 = __nccwpck_require__(/*! ./selectorGenerator */ \"./src/server/supplements/injected/selectorGenerator.ts\");\nclass ConsoleAPI {\n    constructor(injectedScript) {\n        this._injectedScript = injectedScript;\n        if (window.playwright)\n            return;\n        window.playwright = {\n            $: (selector) => this._querySelector(selector),\n            $$: (selector) => this._querySelectorAll(selector),\n            inspect: (selector) => this._inspect(selector),\n            selector: (element) => this._selector(element),\n            resume: () => this._resume(),\n        };\n    }\n    _querySelector(selector) {\n        if (typeof selector !== 'string')\n            throw new Error(`Usage: playwright.query('Playwright >> selector').`);\n        const parsed = this._injectedScript.parseSelector(selector);\n        return this._injectedScript.querySelector(parsed, document);\n    }\n    _querySelectorAll(selector) {\n        if (typeof selector !== 'string')\n            throw new Error(`Usage: playwright.$$('Playwright >> selector').`);\n        const parsed = this._injectedScript.parseSelector(selector);\n        return this._injectedScript.querySelectorAll(parsed, document);\n    }\n    _inspect(selector) {\n        if (typeof selector !== 'string')\n            throw new Error(`Usage: playwright.inspect('Playwright >> selector').`);\n        window.inspect(this._querySelector(selector));\n    }\n    _selector(element) {\n        if (!(element instanceof Element))\n            throw new Error(`Usage: playwright.selector(element).`);\n        return selectorGenerator_1.generateSelector(this._injectedScript, element).selector;\n    }\n    _resume() {\n        window._playwrightResume().catch(() => { });\n    }\n}\nexports.ConsoleAPI = ConsoleAPI;\nexports.default = ConsoleAPI;\n\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/selectorGenerator.ts\":\n/*!**************************************************************!*\\\n  !*** ./src/server/supplements/injected/selectorGenerator.ts ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSelector = exports.querySelector = void 0;\nconst selectorEvaluator_1 = __nccwpck_require__(/*! ../../injected/selectorEvaluator */ \"./src/server/injected/selectorEvaluator.ts\");\nconst cacheAllowText = new Map();\nconst cacheDisallowText = new Map();\nfunction querySelector(injectedScript, selector, ownerDocument) {\n    try {\n        const parsedSelector = injectedScript.parseSelector(selector);\n        return {\n            selector,\n            elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n        };\n    }\n    catch (e) {\n        return {\n            selector,\n            elements: [],\n        };\n    }\n}\nexports.querySelector = querySelector;\nfunction generateSelector(injectedScript, targetElement) {\n    injectedScript._evaluator.begin();\n    try {\n        targetElement = targetElement.closest('button,select,input,[role=button],[role=checkbox],[role=radio]') || targetElement;\n        const targetTokens = generateSelectorFor(injectedScript, targetElement);\n        const bestTokens = targetTokens || [cssFallback(injectedScript, targetElement)];\n        const selector = joinTokens(bestTokens);\n        const parsedSelector = injectedScript.parseSelector(selector);\n        return {\n            selector,\n            elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n        };\n    }\n    finally {\n        cacheAllowText.clear();\n        cacheDisallowText.clear();\n        injectedScript._evaluator.end();\n    }\n}\nexports.generateSelector = generateSelector;\nfunction filterRegexTokens(textCandidates) {\n    // Filter out regex-based selectors for better performance.\n    return textCandidates.filter(c => c[0].selector[0] !== '/');\n}\nfunction generateSelectorFor(injectedScript, targetElement) {\n    if (targetElement.ownerDocument.documentElement === targetElement)\n        return [{ engine: 'css', selector: 'html', score: 1 }];\n    const calculate = (element, allowText) => {\n        const allowNthMatch = element === targetElement;\n        let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map(token => [token]) : [];\n        if (element !== targetElement) {\n            // Do not use regex for parent elements (for performance).\n            textCandidates = filterRegexTokens(textCandidates);\n        }\n        const noTextCandidates = buildCandidates(injectedScript, element).map(token => [token]);\n        // First check all text and non-text candidates for the element.\n        let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n        // Do not use regex for chained selectors (for performance).\n        textCandidates = filterRegexTokens(textCandidates);\n        const checkWithText = (textCandidatesToUse) => {\n            // Use the deepest possible text selector - works pretty good and saves on compute time.\n            const allowParentText = allowText && !textCandidatesToUse.length;\n            const candidates = [...textCandidatesToUse, ...noTextCandidates].filter(c => {\n                if (!result)\n                    return true;\n                return combineScores(c) < combineScores(result);\n            });\n            // This is best theoretically possible candidate from the current parent.\n            // We use the fact that widening the scope to grand-parent makes any selector\n            // even less likely to match.\n            let bestPossibleInParent = candidates[0];\n            if (!bestPossibleInParent)\n                return;\n            for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n                const parentTokens = calculateCached(parent, allowParentText);\n                if (!parentTokens)\n                    continue;\n                // Even the best selector won't be too good - skip this parent.\n                if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n                    continue;\n                // Update the best candidate that finds \"element\" in the \"parent\".\n                bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n                if (!bestPossibleInParent)\n                    return;\n                const combined = [...parentTokens, ...bestPossibleInParent];\n                if (!result || combineScores(combined) < combineScores(result))\n                    result = combined;\n            }\n        };\n        checkWithText(textCandidates);\n        // Allow skipping text on the target element, and using text on one of the parents.\n        if (element === targetElement && textCandidates.length)\n            checkWithText([]);\n        return result;\n    };\n    const calculateCached = (element, allowText) => {\n        const cache = allowText ? cacheAllowText : cacheDisallowText;\n        let value = cache.get(element);\n        if (value === undefined) {\n            value = calculate(element, allowText);\n            cache.set(element, value);\n        }\n        return value;\n    };\n    return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n    const candidates = [];\n    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {\n        if (element.hasAttribute(attribute))\n            candidates.push({ engine: 'css', selector: `[${attribute}=${quoteString(element.getAttribute(attribute))}]`, score: 1 });\n    }\n    if (element.nodeName === 'INPUT') {\n        const input = element;\n        if (input.placeholder)\n            candidates.push({ engine: 'css', selector: `[placeholder=${quoteString(input.placeholder)}]`, score: 10 });\n    }\n    if (element.hasAttribute('aria-label'))\n        candidates.push({ engine: 'css', selector: `[aria-label=${quoteString(element.getAttribute('aria-label'))}]`, score: 10 });\n    if (element.getAttribute('alt') && ['APPLET', 'AREA', 'IMG', 'INPUT'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[alt=${quoteString(element.getAttribute('alt'))}]`, score: 10 });\n    if (element.hasAttribute('role'))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLocaleLowerCase()}[role=${quoteString(element.getAttribute('role'))}]`, score: 50 });\n    if (element.getAttribute('name') && ['BUTTON', 'FORM', 'FIELDSET', 'IFRAME', 'INPUT', 'KEYGEN', 'OBJECT', 'OUTPUT', 'SELECT', 'TEXTAREA', 'MAP', 'META', 'PARAM'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[name=${quoteString(element.getAttribute('name'))}]`, score: 50 });\n    if (['INPUT', 'TEXTAREA'].includes(element.nodeName) && element.getAttribute('type') !== 'hidden') {\n        if (element.getAttribute('type'))\n            candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[type=${quoteString(element.getAttribute('type'))}]`, score: 50 });\n    }\n    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: element.nodeName.toLowerCase(), score: 50 });\n    const idAttr = element.getAttribute('id');\n    if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: 'css', selector: makeSelectorForId(idAttr), score: 100 });\n    candidates.push({ engine: 'css', selector: element.nodeName.toLocaleLowerCase(), score: 200 });\n    return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n    if (element.nodeName === 'SELECT')\n        return [];\n    const text = selectorEvaluator_1.elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, ' ').substring(0, 80);\n    if (!text)\n        return [];\n    const candidates = [];\n    let escaped = text;\n    if (text.includes('\"') || text.includes('>>') || text[0] === '/')\n        escaped = `/.*${escapeForRegex(text)}.*/`;\n    candidates.push({ engine: 'text', selector: escaped, score: 10 });\n    if (allowHasText && escaped === text) {\n        let prefix = element.nodeName.toLocaleLowerCase();\n        if (element.hasAttribute('role'))\n            prefix += `[role=${quoteString(element.getAttribute('role'))}]`;\n        candidates.push({ engine: 'css', selector: `${prefix}:has-text(\"${text}\")`, score: 30 });\n    }\n    return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return null;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n    return null;\n}\nfunction makeSelectorForId(id) {\n    return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? '#' + id : `[id=\"${id}\"]`;\n}\nfunction cssFallback(injectedScript, targetElement) {\n    const kFallbackScore = 10000000;\n    const root = targetElement.ownerDocument;\n    const tokens = [];\n    function uniqueCSSSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        const selector = path.join(' ');\n        const parsedSelector = injectedScript.parseSelector(selector);\n        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);\n        return node === targetElement ? selector : undefined;\n    }\n    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n        const nodeName = element.nodeName.toLowerCase();\n        // Element ID is the strongest signal, use it.\n        let bestTokenForLevel = '';\n        if (element.id) {\n            const token = makeSelectorForId(element.id);\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            bestTokenForLevel = token;\n        }\n        const parent = element.parentNode;\n        // Combine class names until unique.\n        const classes = [...element.classList];\n        for (let i = 0; i < classes.length; ++i) {\n            const token = '.' + classes.slice(0, i + 1).join('.');\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            // Even if not unique, does this subset of classes uniquely identify node as a child?\n            if (!bestTokenForLevel && parent) {\n                const sameClassSiblings = parent.querySelectorAll(token);\n                if (sameClassSiblings.length === 1)\n                    bestTokenForLevel = token;\n            }\n        }\n        // Ordinal is the weakest signal.\n        if (parent) {\n            const siblings = [...parent.children];\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            if (!bestTokenForLevel)\n                bestTokenForLevel = token;\n        }\n        else if (!bestTokenForLevel) {\n            bestTokenForLevel = nodeName;\n        }\n        tokens.unshift(bestTokenForLevel);\n    }\n    return { engine: 'css', selector: uniqueCSSSelector(), score: kFallbackScore };\n}\nfunction escapeForRegex(text) {\n    return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction quoteString(text) {\n    return `\"${text.replaceAll(/\"/g, '\\\\\"').replaceAll(/\\n/g, '\\\\n')}\"`;\n}\nfunction joinTokens(tokens) {\n    const parts = [];\n    let lastEngine = '';\n    for (const { engine, selector } of tokens) {\n        if (parts.length && (lastEngine !== 'css' || engine !== 'css' || selector.startsWith(':nth-match(')))\n            parts.push('>>');\n        lastEngine = engine;\n        if (engine === 'css')\n            parts.push(selector);\n        else\n            parts.push(`${engine}=${selector}`);\n    }\n    return parts.join(' ');\n}\nfunction combineScores(tokens) {\n    let score = 0;\n    for (let i = 0; i < tokens.length; i++)\n        score += tokens[i].score * (tokens.length - i);\n    return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n    const joined = selectors.map(tokens => ({ tokens, score: combineScores(tokens) }));\n    joined.sort((a, b) => a.score - b.score);\n    let bestWithIndex = null;\n    for (const { tokens } of joined) {\n        const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n        const result = injectedScript.querySelectorAll(parsedSelector, scope);\n        const index = result.indexOf(targetElement);\n        if (index === 0) {\n            // We are the first match - found the best selector.\n            return tokens;\n        }\n        // Otherwise, perhaps we can get nth-match?\n        if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n            continue;\n        // To use nth-match, we must convert everything to css.\n        const allCss = tokens.map(token => {\n            if (token.engine !== 'text')\n                return token;\n            if (token.selector.startsWith('/') && token.selector.endsWith('/'))\n                return { engine: 'css', selector: `:text-matches(\"${token.selector.substring(1, token.selector.length - 1)}\")`, score: token.score };\n            return { engine: 'css', selector: `:text(\"${token.selector}\")`, score: token.score };\n        });\n        const combined = joinTokens(allCss);\n        bestWithIndex = [{ engine: 'css', selector: `:nth-match(${combined}, ${index + 1})`, score: combineScores(allCss) + 1000 }];\n    }\n    return bestWithIndex;\n}\nfunction isGuidLike(id) {\n    let lastCharacterType;\n    let transitionCount = 0;\n    for (let i = 0; i < id.length; ++i) {\n        const c = id[i];\n        let characterType;\n        if (c === '-' || c === '_')\n            continue;\n        if (c >= 'a' && c <= 'z')\n            characterType = 'lower';\n        else if (c >= 'A' && c <= 'Z')\n            characterType = 'upper';\n        else if (c >= '0' && c <= '9')\n            characterType = 'digit';\n        else\n            characterType = 'other';\n        if (characterType === 'lower' && lastCharacterType === 'upper') {\n            lastCharacterType = characterType;\n            continue;\n        }\n        if (lastCharacterType && lastCharacterType !== characterType)\n            ++transitionCount;\n        lastCharacterType = characterType;\n    }\n    return transitionCount >= id.length / 4;\n}\n\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=consoleApiSource.js.map

/***/ }),

/***/ 7788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nccwpck_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nccwpck_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nccwpck_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nccwpck_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nccwpck_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nccwpck_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nccwpck_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nccwpck_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nccwpck_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nccwpck_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nccwpck_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nccwpck_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nccwpck_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(__nccwpck_require__.s = \"./src/server/injected/injectedScript.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/cssParser.ts\":\n/*!****************************************!*\\\n  !*** ./src/server/common/cssParser.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeSelector = exports.parseCSS = void 0;\nconst css = __importStar(__nccwpck_require__(/*! ./cssTokenizer */ \"./src/server/common/cssTokenizer.js\"));\nfunction parseCSS(selector, customNames) {\n    let tokens;\n    try {\n        tokens = css.tokenize(selector);\n        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))\n            tokens.push(new css.EOFToken());\n    }\n    catch (e) {\n        const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n        const index = (e.stack || '').indexOf(e.message);\n        if (index !== -1)\n            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n        e.message = newMessage;\n        throw e;\n    }\n    const unsupportedToken = tokens.find(token => {\n        return (token instanceof css.AtKeywordToken) ||\n            (token instanceof css.BadStringToken) ||\n            (token instanceof css.BadURLToken) ||\n            (token instanceof css.ColumnToken) ||\n            (token instanceof css.CDOToken) ||\n            (token instanceof css.CDCToken) ||\n            (token instanceof css.SemicolonToken) ||\n            // TODO: Consider using these for something, e.g. to escape complex strings.\n            // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n            // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n            (token instanceof css.OpenCurlyToken) ||\n            (token instanceof css.CloseCurlyToken) ||\n            // TODO: Consider treating these as strings?\n            (token instanceof css.URLToken) ||\n            (token instanceof css.PercentageToken);\n    });\n    if (unsupportedToken)\n        throw new Error(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n    let pos = 0;\n    const names = new Set();\n    function unexpected() {\n        return new Error(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n    }\n    function skipWhitespace() {\n        while (tokens[pos] instanceof css.WhitespaceToken)\n            pos++;\n    }\n    function isIdent(p = pos) {\n        return tokens[p] instanceof css.IdentToken;\n    }\n    function isString(p = pos) {\n        return tokens[p] instanceof css.StringToken;\n    }\n    function isNumber(p = pos) {\n        return tokens[p] instanceof css.NumberToken;\n    }\n    function isComma(p = pos) {\n        return tokens[p] instanceof css.CommaToken;\n    }\n    function isCloseParen(p = pos) {\n        return tokens[p] instanceof css.CloseParenToken;\n    }\n    function isStar(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';\n    }\n    function isEOF(p = pos) {\n        return tokens[p] instanceof css.EOFToken;\n    }\n    function isClauseCombinator(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));\n    }\n    function isSelectorClauseEnd(p = pos) {\n        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);\n    }\n    function consumeFunctionArguments() {\n        const result = [consumeArgument()];\n        while (true) {\n            skipWhitespace();\n            if (!isComma())\n                break;\n            pos++;\n            result.push(consumeArgument());\n        }\n        return result;\n    }\n    function consumeArgument() {\n        skipWhitespace();\n        if (isNumber())\n            return tokens[pos++].value;\n        if (isString())\n            return tokens[pos++].value;\n        return consumeComplexSelector();\n    }\n    function consumeComplexSelector() {\n        skipWhitespace();\n        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };\n        while (true) {\n            skipWhitespace();\n            if (isClauseCombinator()) {\n                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n                skipWhitespace();\n            }\n            else if (isSelectorClauseEnd()) {\n                break;\n            }\n            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });\n        }\n        return result;\n    }\n    function consumeSimpleSelector() {\n        let rawCSSString = '';\n        const functions = [];\n        while (!isSelectorClauseEnd()) {\n            if (isIdent() || isStar()) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if (tokens[pos] instanceof css.HashToken) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {\n                pos++;\n                if (isIdent())\n                    rawCSSString += '.' + tokens[pos++].toSource();\n                else\n                    throw unexpected();\n            }\n            else if (tokens[pos] instanceof css.ColonToken) {\n                pos++;\n                if (isIdent()) {\n                    if (!customNames.has(tokens[pos].value.toLowerCase())) {\n                        rawCSSString += ':' + tokens[pos++].toSource();\n                    }\n                    else {\n                        const name = tokens[pos++].value.toLowerCase();\n                        functions.push({ name, args: [] });\n                        names.add(name);\n                    }\n                }\n                else if (tokens[pos] instanceof css.FunctionToken) {\n                    const name = tokens[pos++].value.toLowerCase();\n                    if (!customNames.has(name)) {\n                        rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n                    }\n                    else {\n                        functions.push({ name, args: consumeFunctionArguments() });\n                        names.add(name);\n                    }\n                    skipWhitespace();\n                    if (!isCloseParen())\n                        throw unexpected();\n                    pos++;\n                }\n                else {\n                    throw unexpected();\n                }\n            }\n            else if (tokens[pos] instanceof css.OpenSquareToken) {\n                rawCSSString += '[';\n                pos++;\n                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())\n                    rawCSSString += tokens[pos++].toSource();\n                if (!(tokens[pos] instanceof css.CloseSquareToken))\n                    throw unexpected();\n                rawCSSString += ']';\n                pos++;\n            }\n            else {\n                throw unexpected();\n            }\n        }\n        if (!rawCSSString && !functions.length)\n            throw unexpected();\n        return { css: rawCSSString || undefined, functions };\n    }\n    function consumeBuiltinFunctionArguments() {\n        let s = '';\n        while (!isCloseParen() && !isEOF())\n            s += tokens[pos++].toSource();\n        return s;\n    }\n    const result = consumeFunctionArguments();\n    if (!isEOF())\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    return { selector: result, names: Array.from(names) };\n}\nexports.parseCSS = parseCSS;\nfunction serializeSelector(args) {\n    return args.map(arg => {\n        if (typeof arg === 'string')\n            return `\"${arg}\"`;\n        if (typeof arg === 'number')\n            return String(arg);\n        return arg.simples.map(({ selector, combinator }) => {\n            let s = selector.css || '';\n            s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n            if (combinator)\n                s += ' ' + combinator;\n            return s;\n        }).join(' ');\n    }).join(', ');\n}\nexports.serializeSelector = serializeSelector;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/cssTokenizer.js\":\n/*!*******************************************!*\\\n  !*** ./src/server/common/cssTokenizer.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n * Original at https://github.com/tabatkins/parse-css\n * licensed under http://creativecommons.org/publicdomain/zero/1.0/\n *\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Changes from https://github.com/tabatkins/parse-css\n//   - Tabs are replaced with two spaces.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n// @ts-nocheck\n(function (root, factory) {\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}(this, function (exports) {\n    var between = function (num, first, last) { return num >= first && num <= last; };\n    function digit(code) { return between(code, 0x30, 0x39); }\n    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }\n    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }\n    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }\n    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\n    function nonascii(code) { return code >= 0x80; }\n    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\n    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\n    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }\n    function newline(code) { return code == 0xa; }\n    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\n    function badescape(code) { return newline(code) || isNaN(code); }\n    var maximumallowedcodepoint = 0x10ffff;\n    var InvalidCharacterError = function (message) {\n        this.message = message;\n    };\n    InvalidCharacterError.prototype = new Error;\n    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n    function preprocess(str) {\n        // Turn a string into an array of code points,\n        // following the preprocessing cleanup rules.\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n            var code = str.charCodeAt(i);\n            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n                code = 0xa;\n                i++;\n            }\n            if (code == 0xd || code == 0xc)\n                code = 0xa;\n            if (code == 0x0)\n                code = 0xfffd;\n            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n                // Decode a surrogate pair into an astral codepoint.\n                var lead = code - 0xd800;\n                var trail = str.charCodeAt(i + 1) - 0xdc00;\n                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n                i++;\n            }\n            codepoints.push(code);\n        }\n        return codepoints;\n    }\n    function stringFromCode(code) {\n        if (code <= 0xffff)\n            return String.fromCharCode(code);\n        // Otherwise, encode astral char as surrogate pair.\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n        var trail = code % Math.pow(2, 10) + 0xdc00;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n    }\n    function tokenize(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        // Line number information.\n        var line = 0;\n        var column = 0;\n        // The only use of lastLineLength is in reconsume().\n        var lastLineLength = 0;\n        var incrLineno = function () {\n            line += 1;\n            lastLineLength = column;\n            column = 0;\n        };\n        var locStart = { line: line, column: column };\n        var codepoint = function (i) {\n            if (i >= str.length) {\n                return -1;\n            }\n            return str[i];\n        };\n        var next = function (num) {\n            if (num === undefined)\n                num = 1;\n            if (num > 3)\n                throw \"Spec Error: no more than three codepoints of lookahead.\";\n            return codepoint(i + num);\n        };\n        var consume = function (num) {\n            if (num === undefined)\n                num = 1;\n            i += num;\n            code = codepoint(i);\n            if (newline(code))\n                incrLineno();\n            else\n                column += num;\n            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n            return true;\n        };\n        var reconsume = function () {\n            i -= 1;\n            if (newline(code)) {\n                line -= 1;\n                column = lastLineLength;\n            }\n            else {\n                column -= 1;\n            }\n            locStart.line = line;\n            locStart.column = column;\n            return true;\n        };\n        var eof = function (codepoint) {\n            if (codepoint === undefined)\n                codepoint = code;\n            return codepoint == -1;\n        };\n        var donothing = function () { };\n        var parseerror = function () { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\"); return true; };\n        var consumeAToken = function () {\n            consumeComments();\n            consume();\n            if (whitespace(code)) {\n                while (whitespace(next()))\n                    consume();\n                return new WhitespaceToken;\n            }\n            else if (code == 0x22)\n                return consumeAStringToken();\n            else if (code == 0x23) {\n                if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n                    var token = new HashToken();\n                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                        token.type = \"id\";\n                    token.value = consumeAName();\n                    return token;\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x24) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SuffixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x27)\n                return consumeAStringToken();\n            else if (code == 0x28)\n                return new OpenParenToken();\n            else if (code == 0x29)\n                return new CloseParenToken();\n            else if (code == 0x2a) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SubstringMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2b) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2c)\n                return new CommaToken();\n            else if (code == 0x2d) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else if (next(1) == 0x2d && next(2) == 0x3e) {\n                    consume(2);\n                    return new CDCToken();\n                }\n                else if (startsWithAnIdentifier()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2e) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x3a)\n                return new ColonToken;\n            else if (code == 0x3b)\n                return new SemicolonToken;\n            else if (code == 0x3c) {\n                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n                    consume(3);\n                    return new CDOToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x40) {\n                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                    return new AtKeywordToken(consumeAName());\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5b)\n                return new OpenSquareToken();\n            else if (code == 0x5c) {\n                if (startsWithAValidEscape()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    parseerror();\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5d)\n                return new CloseSquareToken();\n            else if (code == 0x5e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new PrefixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7b)\n                return new OpenCurlyToken();\n            else if (code == 0x7c) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new DashMatchToken();\n                }\n                else if (next() == 0x7c) {\n                    consume();\n                    return new ColumnToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7d)\n                return new CloseCurlyToken();\n            else if (code == 0x7e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new IncludeMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (digit(code)) {\n                reconsume();\n                return consumeANumericToken();\n            }\n            else if (namestartchar(code)) {\n                reconsume();\n                return consumeAnIdentlikeToken();\n            }\n            else if (eof())\n                return new EOFToken();\n            else\n                return new DelimToken(code);\n        };\n        var consumeComments = function () {\n            while (next(1) == 0x2f && next(2) == 0x2a) {\n                consume(2);\n                while (true) {\n                    consume();\n                    if (code == 0x2a && next() == 0x2f) {\n                        consume();\n                        break;\n                    }\n                    else if (eof()) {\n                        parseerror();\n                        return;\n                    }\n                }\n            }\n        };\n        var consumeANumericToken = function () {\n            var num = consumeANumber();\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                var token = new DimensionToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                token.unit = consumeAName();\n                return token;\n            }\n            else if (next() == 0x25) {\n                consume();\n                var token = new PercentageToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                return token;\n            }\n            else {\n                var token = new NumberToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                return token;\n            }\n        };\n        var consumeAnIdentlikeToken = function () {\n            var str = consumeAName();\n            if (str.toLowerCase() == \"url\" && next() == 0x28) {\n                consume();\n                while (whitespace(next(1)) && whitespace(next(2)))\n                    consume();\n                if (next() == 0x22 || next() == 0x27) {\n                    return new FunctionToken(str);\n                }\n                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n                    return new FunctionToken(str);\n                }\n                else {\n                    return consumeAURLToken();\n                }\n            }\n            else if (next() == 0x28) {\n                consume();\n                return new FunctionToken(str);\n            }\n            else {\n                return new IdentToken(str);\n            }\n        };\n        var consumeAStringToken = function (endingCodePoint) {\n            if (endingCodePoint === undefined)\n                endingCodePoint = code;\n            var string = \"\";\n            while (consume()) {\n                if (code == endingCodePoint || eof()) {\n                    return new StringToken(string);\n                }\n                else if (newline(code)) {\n                    parseerror();\n                    reconsume();\n                    return new BadStringToken();\n                }\n                else if (code == 0x5c) {\n                    if (eof(next())) {\n                        donothing();\n                    }\n                    else if (newline(next())) {\n                        consume();\n                    }\n                    else {\n                        string += stringFromCode(consumeEscape());\n                    }\n                }\n                else {\n                    string += stringFromCode(code);\n                }\n            }\n        };\n        var consumeAURLToken = function () {\n            var token = new URLToken(\"\");\n            while (whitespace(next()))\n                consume();\n            if (eof(next()))\n                return token;\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return token;\n                }\n                else if (whitespace(code)) {\n                    while (whitespace(next()))\n                        consume();\n                    if (next() == 0x29 || eof(next())) {\n                        consume();\n                        return token;\n                    }\n                    else {\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n                    parseerror();\n                    consumeTheRemnantsOfABadURL();\n                    return new BadURLToken();\n                }\n                else if (code == 0x5c) {\n                    if (startsWithAValidEscape()) {\n                        token.value += stringFromCode(consumeEscape());\n                    }\n                    else {\n                        parseerror();\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else {\n                    token.value += stringFromCode(code);\n                }\n            }\n        };\n        var consumeEscape = function () {\n            // Assume the the current character is the \\\n            // and the next code point is not a newline.\n            consume();\n            if (hexdigit(code)) {\n                // Consume 1-6 hex digits\n                var digits = [code];\n                for (var total = 0; total < 5; total++) {\n                    if (hexdigit(next())) {\n                        consume();\n                        digits.push(code);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (whitespace(next()))\n                    consume();\n                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);\n                if (value > maximumallowedcodepoint)\n                    value = 0xfffd;\n                return value;\n            }\n            else if (eof()) {\n                return 0xfffd;\n            }\n            else {\n                return code;\n            }\n        };\n        var areAValidEscape = function (c1, c2) {\n            if (c1 != 0x5c)\n                return false;\n            if (newline(c2))\n                return false;\n            return true;\n        };\n        var startsWithAValidEscape = function () {\n            return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function (c1, c2, c3) {\n            if (c1 == 0x2d) {\n                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n            }\n            else if (namestartchar(c1)) {\n                return true;\n            }\n            else if (c1 == 0x5c) {\n                return areAValidEscape(c1, c2);\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithAnIdentifier = function () {\n            return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function (c1, c2, c3) {\n            if (c1 == 0x2b || c1 == 0x2d) {\n                if (digit(c2))\n                    return true;\n                if (c2 == 0x2e && digit(c3))\n                    return true;\n                return false;\n            }\n            else if (c1 == 0x2e) {\n                if (digit(c2))\n                    return true;\n                return false;\n            }\n            else if (digit(c1)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithANumber = function () {\n            return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function () {\n            var result = \"\";\n            while (consume()) {\n                if (namechar(code)) {\n                    result += stringFromCode(code);\n                }\n                else if (startsWithAValidEscape()) {\n                    result += stringFromCode(consumeEscape());\n                }\n                else {\n                    reconsume();\n                    return result;\n                }\n            }\n        };\n        var consumeANumber = function () {\n            var repr = [];\n            var type = \"integer\";\n            if (next() == 0x2b || next() == 0x2d) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            while (digit(next())) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            if (next(1) == 0x2e && digit(next(2))) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var c1 = next(1), c2 = next(2), c3 = next(3);\n            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var value = convertAStringToANumber(repr);\n            return { type: type, value: value, repr: repr };\n        };\n        var convertAStringToANumber = function (string) {\n            // CSS's number rules are identical to JS, afaik.\n            return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function () {\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return;\n                }\n                else if (startsWithAValidEscape()) {\n                    consumeEscape();\n                    donothing();\n                }\n                else {\n                    donothing();\n                }\n            }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n            tokens.push(consumeAToken());\n            iterationCount++;\n            if (iterationCount > str.length * 2)\n                return \"I'm infinite-looping!\";\n        }\n        return tokens;\n    }\n    function CSSParserToken() { throw \"Abstract Base Class\"; }\n    CSSParserToken.prototype.toJSON = function () {\n        return { token: this.tokenType };\n    };\n    CSSParserToken.prototype.toString = function () { return this.tokenType; };\n    CSSParserToken.prototype.toSource = function () { return '' + this; };\n    function BadStringToken() { return this; }\n    BadStringToken.prototype = Object.create(CSSParserToken.prototype);\n    BadStringToken.prototype.tokenType = \"BADSTRING\";\n    function BadURLToken() { return this; }\n    BadURLToken.prototype = Object.create(CSSParserToken.prototype);\n    BadURLToken.prototype.tokenType = \"BADURL\";\n    function WhitespaceToken() { return this; }\n    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);\n    WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\n    WhitespaceToken.prototype.toString = function () { return \"WS\"; };\n    WhitespaceToken.prototype.toSource = function () { return \" \"; };\n    function CDOToken() { return this; }\n    CDOToken.prototype = Object.create(CSSParserToken.prototype);\n    CDOToken.prototype.tokenType = \"CDO\";\n    CDOToken.prototype.toSource = function () { return \"<!--\"; };\n    function CDCToken() { return this; }\n    CDCToken.prototype = Object.create(CSSParserToken.prototype);\n    CDCToken.prototype.tokenType = \"CDC\";\n    CDCToken.prototype.toSource = function () { return \"-->\"; };\n    function ColonToken() { return this; }\n    ColonToken.prototype = Object.create(CSSParserToken.prototype);\n    ColonToken.prototype.tokenType = \":\";\n    function SemicolonToken() { return this; }\n    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);\n    SemicolonToken.prototype.tokenType = \";\";\n    function CommaToken() { return this; }\n    CommaToken.prototype = Object.create(CSSParserToken.prototype);\n    CommaToken.prototype.tokenType = \",\";\n    function GroupingToken() { throw \"Abstract Base Class\"; }\n    GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n    function OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\n    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    OpenCurlyToken.prototype.tokenType = \"{\";\n    function CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\n    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    CloseCurlyToken.prototype.tokenType = \"}\";\n    function OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\n    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);\n    OpenSquareToken.prototype.tokenType = \"[\";\n    function CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\n    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);\n    CloseSquareToken.prototype.tokenType = \"]\";\n    function OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\n    OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n    OpenParenToken.prototype.tokenType = \"(\";\n    function CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\n    CloseParenToken.prototype = Object.create(GroupingToken.prototype);\n    CloseParenToken.prototype.tokenType = \")\";\n    function IncludeMatchToken() { return this; }\n    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    IncludeMatchToken.prototype.tokenType = \"~=\";\n    function DashMatchToken() { return this; }\n    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    DashMatchToken.prototype.tokenType = \"|=\";\n    function PrefixMatchToken() { return this; }\n    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    PrefixMatchToken.prototype.tokenType = \"^=\";\n    function SuffixMatchToken() { return this; }\n    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SuffixMatchToken.prototype.tokenType = \"$=\";\n    function SubstringMatchToken() { return this; }\n    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SubstringMatchToken.prototype.tokenType = \"*=\";\n    function ColumnToken() { return this; }\n    ColumnToken.prototype = Object.create(CSSParserToken.prototype);\n    ColumnToken.prototype.tokenType = \"||\";\n    function EOFToken() { return this; }\n    EOFToken.prototype = Object.create(CSSParserToken.prototype);\n    EOFToken.prototype.tokenType = \"EOF\";\n    EOFToken.prototype.toSource = function () { return \"\"; };\n    function DelimToken(code) {\n        this.value = stringFromCode(code);\n        return this;\n    }\n    DelimToken.prototype = Object.create(CSSParserToken.prototype);\n    DelimToken.prototype.tokenType = \"DELIM\";\n    DelimToken.prototype.toString = function () { return \"DELIM(\" + this.value + \")\"; };\n    DelimToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    DelimToken.prototype.toSource = function () {\n        if (this.value == \"\\\\\")\n            return \"\\\\\\n\";\n        else\n            return this.value;\n    };\n    function StringValuedToken() { throw \"Abstract Base Class\"; }\n    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n    StringValuedToken.prototype.ASCIIMatch = function (str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n    };\n    StringValuedToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    function IdentToken(val) {\n        this.value = val;\n    }\n    IdentToken.prototype = Object.create(StringValuedToken.prototype);\n    IdentToken.prototype.tokenType = \"IDENT\";\n    IdentToken.prototype.toString = function () { return \"IDENT(\" + this.value + \")\"; };\n    IdentToken.prototype.toSource = function () {\n        return escapeIdent(this.value);\n    };\n    function FunctionToken(val) {\n        this.value = val;\n        this.mirror = \")\";\n    }\n    FunctionToken.prototype = Object.create(StringValuedToken.prototype);\n    FunctionToken.prototype.tokenType = \"FUNCTION\";\n    FunctionToken.prototype.toString = function () { return \"FUNCTION(\" + this.value + \")\"; };\n    FunctionToken.prototype.toSource = function () {\n        return escapeIdent(this.value) + \"(\";\n    };\n    function AtKeywordToken(val) {\n        this.value = val;\n    }\n    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);\n    AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\n    AtKeywordToken.prototype.toString = function () { return \"AT(\" + this.value + \")\"; };\n    AtKeywordToken.prototype.toSource = function () {\n        return \"@\" + escapeIdent(this.value);\n    };\n    function HashToken(val) {\n        this.value = val;\n        this.type = \"unrestricted\";\n    }\n    HashToken.prototype = Object.create(StringValuedToken.prototype);\n    HashToken.prototype.tokenType = \"HASH\";\n    HashToken.prototype.toString = function () { return \"HASH(\" + this.value + \")\"; };\n    HashToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n    };\n    HashToken.prototype.toSource = function () {\n        if (this.type == \"id\") {\n            return \"#\" + escapeIdent(this.value);\n        }\n        else {\n            return \"#\" + escapeHash(this.value);\n        }\n    };\n    function StringToken(val) {\n        this.value = val;\n    }\n    StringToken.prototype = Object.create(StringValuedToken.prototype);\n    StringToken.prototype.tokenType = \"STRING\";\n    StringToken.prototype.toString = function () {\n        return '\"' + escapeString(this.value) + '\"';\n    };\n    function URLToken(val) {\n        this.value = val;\n    }\n    URLToken.prototype = Object.create(StringValuedToken.prototype);\n    URLToken.prototype.tokenType = \"URL\";\n    URLToken.prototype.toString = function () { return \"URL(\" + this.value + \")\"; };\n    URLToken.prototype.toSource = function () {\n        return 'url(\"' + escapeString(this.value) + '\")';\n    };\n    function NumberToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n    }\n    NumberToken.prototype = Object.create(CSSParserToken.prototype);\n    NumberToken.prototype.tokenType = \"NUMBER\";\n    NumberToken.prototype.toString = function () {\n        if (this.type == \"integer\")\n            return \"INT(\" + this.value + \")\";\n        return \"NUMBER(\" + this.value + \")\";\n    };\n    NumberToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n    };\n    NumberToken.prototype.toSource = function () { return this.repr; };\n    function PercentageToken() {\n        this.value = null;\n        this.repr = \"\";\n    }\n    PercentageToken.prototype = Object.create(CSSParserToken.prototype);\n    PercentageToken.prototype.tokenType = \"PERCENTAGE\";\n    PercentageToken.prototype.toString = function () { return \"PERCENTAGE(\" + this.value + \")\"; };\n    PercentageToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n    };\n    PercentageToken.prototype.toSource = function () { return this.repr + \"%\"; };\n    function DimensionToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n        this.unit = \"\";\n    }\n    DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\n    DimensionToken.prototype.toString = function () { return \"DIM(\" + this.value + \",\" + this.unit + \")\"; };\n    DimensionToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n    };\n    DimensionToken.prototype.toSource = function () {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n            // Unit is ambiguous with scinot\n            // Remove the leading \"e\", replace with escape.\n            unit = \"\\\\65 \" + unit.slice(1, unit.length);\n        }\n        return source + unit;\n    };\n    function escapeIdent(string) {\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f ||\n                (i == 0 && between(code, 0x30, 0x39)) ||\n                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + string[i];\n            }\n        }\n        return result;\n    }\n    function escapeHash(string) {\n        // Escapes the contents of \"unrestricted\"-type hash tokens.\n        // Won't preserve the ID-ness of \"id\"-type hash tokens;\n        // use escapeIdent() for that.\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n        }\n        return result;\n    }\n    function escapeString(string) {\n        string = '' + string;\n        var result = '';\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code == 0x22 || code == 0x5c) {\n                result += '\\\\' + string[i];\n            }\n            else {\n                result += string[i];\n            }\n        }\n        return result;\n    }\n    // Exportation.\n    exports.tokenize = tokenize;\n    exports.IdentToken = IdentToken;\n    exports.FunctionToken = FunctionToken;\n    exports.AtKeywordToken = AtKeywordToken;\n    exports.HashToken = HashToken;\n    exports.StringToken = StringToken;\n    exports.BadStringToken = BadStringToken;\n    exports.URLToken = URLToken;\n    exports.BadURLToken = BadURLToken;\n    exports.DelimToken = DelimToken;\n    exports.NumberToken = NumberToken;\n    exports.PercentageToken = PercentageToken;\n    exports.DimensionToken = DimensionToken;\n    exports.IncludeMatchToken = IncludeMatchToken;\n    exports.DashMatchToken = DashMatchToken;\n    exports.PrefixMatchToken = PrefixMatchToken;\n    exports.SuffixMatchToken = SuffixMatchToken;\n    exports.SubstringMatchToken = SubstringMatchToken;\n    exports.ColumnToken = ColumnToken;\n    exports.WhitespaceToken = WhitespaceToken;\n    exports.CDOToken = CDOToken;\n    exports.CDCToken = CDCToken;\n    exports.ColonToken = ColonToken;\n    exports.SemicolonToken = SemicolonToken;\n    exports.CommaToken = CommaToken;\n    exports.OpenParenToken = OpenParenToken;\n    exports.CloseParenToken = CloseParenToken;\n    exports.OpenSquareToken = OpenSquareToken;\n    exports.CloseSquareToken = CloseSquareToken;\n    exports.OpenCurlyToken = OpenCurlyToken;\n    exports.CloseCurlyToken = CloseCurlyToken;\n    exports.EOFToken = EOFToken;\n    exports.CSSParserToken = CSSParserToken;\n    exports.GroupingToken = GroupingToken;\n}));\n\n\n/***/ }),\n\n/***/ \"./src/server/common/selectorParser.ts\":\n/*!*********************************************!*\\\n  !*** ./src/server/common/selectorParser.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseSelector = exports.customCSSNames = void 0;\nconst cssParser_1 = __nccwpck_require__(/*! ./cssParser */ \"./src/server/common/cssParser.ts\");\nexports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nfunction parseSelector(selector) {\n    const result = parseSelectorV1(selector);\n    result.parts = result.parts.map(part => {\n        if (Array.isArray(part))\n            return part;\n        if (part.name === 'css' || part.name === 'css:light') {\n            if (part.name === 'css:light')\n                part.body = ':light(' + part.body + ')';\n            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);\n            return parsedCSS.selector;\n        }\n        return part;\n    });\n    return {\n        parts: result.parts,\n        capture: result.capture,\n    };\n}\nexports.parseSelector = parseSelector;\nfunction parseSelectorV1(selector) {\n    let index = 0;\n    let quote;\n    let start = 0;\n    const result = { parts: [] };\n    const append = () => {\n        const part = selector.substring(start, index).trim();\n        const eqIndex = part.indexOf('=');\n        let name;\n        let body;\n        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n            name = part.substring(0, eqIndex).trim();\n            body = part.substring(eqIndex + 1);\n        }\n        else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n            name = 'text';\n            body = part;\n        }\n        else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n            name = 'text';\n            body = part;\n        }\n        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n            // If selector starts with '//' or '//' prefixed with multiple opening\n            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n            // If selector starts with '..', consider xpath as well.\n            name = 'xpath';\n            body = part;\n        }\n        else {\n            name = 'css';\n            body = part;\n        }\n        let capture = false;\n        if (name[0] === '*') {\n            capture = true;\n            name = name.substring(1);\n        }\n        result.parts.push({ name, body });\n        if (capture) {\n            if (result.capture !== undefined)\n                throw new Error(`Only one of the selectors can capture using * modifier`);\n            result.capture = result.parts.length - 1;\n        }\n    };\n    if (!selector.includes('>>')) {\n        index = selector.length;\n        append();\n        return result;\n    }\n    while (index < selector.length) {\n        const c = selector[index];\n        if (c === '\\\\' && index + 1 < selector.length) {\n            index += 2;\n        }\n        else if (c === quote) {\n            quote = undefined;\n            index++;\n        }\n        else if (!quote && (c === '\"' || c === '\\'' || c === '`')) {\n            quote = c;\n            index++;\n        }\n        else if (!quote && c === '>' && selector[index + 1] === '>') {\n            append();\n            index += 2;\n            start = index;\n        }\n        else {\n            index++;\n        }\n    }\n    append();\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/injected/injectedScript.ts\":\n/*!***********************************************!*\\\n  !*** ./src/server/injected/injectedScript.ts ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InjectedScript = void 0;\nconst xpathSelectorEngine_1 = __nccwpck_require__(/*! ./xpathSelectorEngine */ \"./src/server/injected/xpathSelectorEngine.ts\");\nconst selectorParser_1 = __nccwpck_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\nconst selectorEvaluator_1 = __nccwpck_require__(/*! ./selectorEvaluator */ \"./src/server/injected/selectorEvaluator.ts\");\nclass InjectedScript {\n    constructor(stableRafCount, replaceRafWithTimeout, customEngines) {\n        this._enginesV1 = new Map();\n        this._enginesV1.set('xpath', xpathSelectorEngine_1.XPathEngine);\n        this._enginesV1.set('xpath:light', xpathSelectorEngine_1.XPathEngine);\n        this._enginesV1.set('text', this._createTextEngine(true));\n        this._enginesV1.set('text:light', this._createTextEngine(false));\n        this._enginesV1.set('id', this._createAttributeEngine('id', true));\n        this._enginesV1.set('id:light', this._createAttributeEngine('id', false));\n        this._enginesV1.set('data-testid', this._createAttributeEngine('data-testid', true));\n        this._enginesV1.set('data-testid:light', this._createAttributeEngine('data-testid', false));\n        this._enginesV1.set('data-test-id', this._createAttributeEngine('data-test-id', true));\n        this._enginesV1.set('data-test-id:light', this._createAttributeEngine('data-test-id', false));\n        this._enginesV1.set('data-test', this._createAttributeEngine('data-test', true));\n        this._enginesV1.set('data-test:light', this._createAttributeEngine('data-test', false));\n        for (const { name, engine } of customEngines)\n            this._enginesV1.set(name, engine);\n        // No custom engines in V2 for now.\n        this._evaluator = new selectorEvaluator_1.SelectorEvaluatorImpl(new Map());\n        this._stableRafCount = stableRafCount;\n        this._replaceRafWithTimeout = replaceRafWithTimeout;\n    }\n    parseSelector(selector) {\n        const result = selectorParser_1.parseSelector(selector);\n        for (const part of result.parts) {\n            if (!Array.isArray(part) && !this._enginesV1.has(part.name))\n                throw new Error(`Unknown engine \"${part.name}\" while parsing selector ${selector}`);\n        }\n        return result;\n    }\n    querySelector(selector, root) {\n        if (!root['querySelector'])\n            throw new Error('Node is not queryable.');\n        this._evaluator.begin();\n        try {\n            return this._querySelectorRecursively(root, selector, 0);\n        }\n        finally {\n            this._evaluator.end();\n        }\n    }\n    _querySelectorRecursively(root, selector, index) {\n        const current = selector.parts[index];\n        if (index === selector.parts.length - 1)\n            return this._queryEngine(current, root);\n        const all = this._queryEngineAll(current, root);\n        for (const next of all) {\n            const result = this._querySelectorRecursively(next, selector, index + 1);\n            if (result)\n                return selector.capture === index ? next : result;\n        }\n    }\n    querySelectorAll(selector, root) {\n        if (!root['querySelectorAll'])\n            throw new Error('Node is not queryable.');\n        this._evaluator.begin();\n        try {\n            const capture = selector.capture === undefined ? selector.parts.length - 1 : selector.capture;\n            // Query all elements up to the capture.\n            const partsToQueryAll = selector.parts.slice(0, capture + 1);\n            // Check they have a descendant matching everything after the capture.\n            const partsToCheckOne = selector.parts.slice(capture + 1);\n            let set = new Set([root]);\n            for (const part of partsToQueryAll) {\n                const newSet = new Set();\n                for (const prev of set) {\n                    for (const next of this._queryEngineAll(part, prev)) {\n                        if (newSet.has(next))\n                            continue;\n                        newSet.add(next);\n                    }\n                }\n                set = newSet;\n            }\n            let result = [...set];\n            if (partsToCheckOne.length) {\n                const partial = { parts: partsToCheckOne };\n                result = result.filter(e => !!this._querySelectorRecursively(e, partial, 0));\n            }\n            return result;\n        }\n        finally {\n            this._evaluator.end();\n        }\n    }\n    _queryEngine(part, root) {\n        if (Array.isArray(part))\n            return this._evaluator.query({ scope: root, pierceShadow: true }, part)[0];\n        return this._enginesV1.get(part.name).query(root, part.body);\n    }\n    _queryEngineAll(part, root) {\n        if (Array.isArray(part))\n            return this._evaluator.query({ scope: root, pierceShadow: true }, part);\n        return this._enginesV1.get(part.name).queryAll(root, part.body);\n    }\n    _createAttributeEngine(attribute, shadow) {\n        const toCSS = (selector) => {\n            const css = `[${attribute}=${JSON.stringify(selector)}]`;\n            return [{ simples: [{ selector: { css, functions: [] }, combinator: '' }] }];\n        };\n        return {\n            query: (root, selector) => {\n                return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector))[0];\n            },\n            queryAll: (root, selector) => {\n                return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n            }\n        };\n    }\n    _createTextEngine(shadow) {\n        const queryList = (root, selector, single) => {\n            const { matcher, kind } = createTextMatcher(selector);\n            const result = [];\n            let lastDidNotMatchSelf = null;\n            const checkElement = (element) => {\n                // TODO: replace contains() with something shadow-dom-aware?\n                if (kind === 'lax' && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n                    return false;\n                const matches = selectorEvaluator_1.elementMatchesText(this._evaluator, element, matcher);\n                if (matches === 'none')\n                    lastDidNotMatchSelf = element;\n                if (matches === 'self' || (matches === 'selfAndChildren' && kind === 'strict'))\n                    result.push(element);\n                return single && result.length > 0;\n            };\n            if (root.nodeType === Node.ELEMENT_NODE && checkElement(root))\n                return result;\n            const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, '*');\n            for (const element of elements) {\n                if (checkElement(element))\n                    return result;\n            }\n            return result;\n        };\n        return {\n            query: (root, selector) => {\n                return queryList(root, selector, true)[0];\n            },\n            queryAll: (root, selector) => {\n                return queryList(root, selector, false);\n            }\n        };\n    }\n    extend(source, params) {\n        const constrFunction = global.eval(`\n    (() => {\n      ${source}\n      return pwExport;\n    })()`);\n        return new constrFunction(this, params);\n    }\n    isVisible(element) {\n        return selectorEvaluator_1.isVisible(element);\n    }\n    pollRaf(predicate) {\n        return this._runAbortableTask(progress => {\n            let fulfill;\n            let reject;\n            const result = new Promise((f, r) => { fulfill = f; reject = r; });\n            const onRaf = () => {\n                if (progress.aborted)\n                    return;\n                try {\n                    const continuePolling = Symbol('continuePolling');\n                    const success = predicate(progress, continuePolling);\n                    if (success !== continuePolling)\n                        fulfill(success);\n                    else\n                        requestAnimationFrame(onRaf);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            };\n            onRaf();\n            return result;\n        });\n    }\n    pollInterval(pollInterval, predicate) {\n        return this._runAbortableTask(progress => {\n            let fulfill;\n            let reject;\n            const result = new Promise((f, r) => { fulfill = f; reject = r; });\n            const onTimeout = () => {\n                if (progress.aborted)\n                    return;\n                try {\n                    const continuePolling = Symbol('continuePolling');\n                    const success = predicate(progress, continuePolling);\n                    if (success !== continuePolling)\n                        fulfill(success);\n                    else\n                        setTimeout(onTimeout, pollInterval);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            };\n            onTimeout();\n            return result;\n        });\n    }\n    _runAbortableTask(task) {\n        let unsentLogs = [];\n        let takeNextLogsCallback;\n        let taskFinished = false;\n        const logReady = () => {\n            if (!takeNextLogsCallback)\n                return;\n            takeNextLogsCallback(unsentLogs);\n            unsentLogs = [];\n            takeNextLogsCallback = undefined;\n        };\n        const takeNextLogs = () => new Promise(fulfill => {\n            takeNextLogsCallback = fulfill;\n            if (unsentLogs.length || taskFinished)\n                logReady();\n        });\n        let lastLog = '';\n        const progress = {\n            aborted: false,\n            log: (message) => {\n                lastLog = message;\n                unsentLogs.push(message);\n                logReady();\n            },\n            logRepeating: (message) => {\n                if (message !== lastLog)\n                    progress.log(message);\n            },\n        };\n        const run = () => {\n            const result = task(progress);\n            // After the task has finished, there should be no more logs.\n            // Release any pending `takeNextLogs` call, and do not block any future ones.\n            // This prevents non-finished protocol evaluation calls and memory leaks.\n            result.finally(() => {\n                taskFinished = true;\n                logReady();\n            });\n            return result;\n        };\n        return {\n            takeNextLogs,\n            run,\n            cancel: () => { progress.aborted = true; },\n            takeLastLogs: () => unsentLogs,\n        };\n    }\n    getElementBorderWidth(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n            return { left: 0, top: 0 };\n        const style = node.ownerDocument.defaultView.getComputedStyle(node);\n        return { left: parseInt(style.borderLeftWidth || '', 10), top: parseInt(style.borderTopWidth || '', 10) };\n    }\n    _retarget(node, behavior) {\n        let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n        if (!element)\n            return null;\n        if (!element.matches('input, textarea, select'))\n            element = element.closest('button, [role=button], [role=checkbox], [role=radio]') || element;\n        if (behavior === 'follow-label') {\n            if (!element.matches('input, textarea, button, select, [role=button], [role=checkbox], [role=radio]') &&\n                !element.isContentEditable) {\n                // Go up to the label that might be connected to the input/textarea.\n                element = element.closest('label') || element;\n            }\n            if (element.nodeName === 'LABEL')\n                element = element.control || element;\n        }\n        return element;\n    }\n    waitForElementStatesAndPerformAction(node, states, callback) {\n        let lastRect;\n        let counter = 0;\n        let samePositionCounter = 0;\n        let lastTime = 0;\n        const predicate = (progress, continuePolling) => {\n            for (const state of states) {\n                if (state !== 'stable') {\n                    const result = this.checkElementState(node, state);\n                    if (typeof result !== 'boolean')\n                        return result;\n                    if (!result) {\n                        progress.logRepeating(`    element is not ${state} - waiting...`);\n                        return continuePolling;\n                    }\n                    continue;\n                }\n                const element = this._retarget(node, 'no-follow-label');\n                if (!element)\n                    return 'error:notconnected';\n                // First raf happens in the same animation frame as evaluation, so it does not produce\n                // any client rect difference compared to synchronous call. We skip the synchronous call\n                // and only force layout during actual rafs as a small optimisation.\n                if (++counter === 1)\n                    return continuePolling;\n                // Drop frames that are shorter than 16ms - WebKit Win bug.\n                const time = performance.now();\n                if (this._stableRafCount > 1 && time - lastTime < 15)\n                    return continuePolling;\n                lastTime = time;\n                const clientRect = element.getBoundingClientRect();\n                const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n                const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n                if (samePosition)\n                    ++samePositionCounter;\n                else\n                    samePositionCounter = 0;\n                const isStable = samePositionCounter >= this._stableRafCount;\n                const isStableForLogs = isStable || !lastRect;\n                lastRect = rect;\n                if (!isStableForLogs)\n                    progress.logRepeating(`    element is not stable - waiting...`);\n                if (!isStable)\n                    return continuePolling;\n            }\n            return callback(node, progress, continuePolling);\n        };\n        if (this._replaceRafWithTimeout)\n            return this.pollInterval(16, predicate);\n        else\n            return this.pollRaf(predicate);\n    }\n    checkElementState(node, state) {\n        const element = this._retarget(node, ['stable', 'visible', 'hidden'].includes(state) ? 'no-follow-label' : 'follow-label');\n        if (!element || !element.isConnected) {\n            if (state === 'hidden')\n                return true;\n            return 'error:notconnected';\n        }\n        if (state === 'visible')\n            return this.isVisible(element);\n        if (state === 'hidden')\n            return !this.isVisible(element);\n        const disabled = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(element.nodeName) && element.hasAttribute('disabled');\n        if (state === 'disabled')\n            return disabled;\n        if (state === 'enabled')\n            return !disabled;\n        const editable = !(['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName) && element.hasAttribute('readonly'));\n        if (state === 'editable')\n            return !disabled && editable;\n        if (state === 'checked') {\n            if (element.getAttribute('role') === 'checkbox')\n                return element.getAttribute('aria-checked') === 'true';\n            if (element.nodeName !== 'INPUT')\n                return 'error:notcheckbox';\n            if (!['radio', 'checkbox'].includes(element.type.toLowerCase()))\n                return 'error:notcheckbox';\n            return element.checked;\n        }\n        throw new Error(`Unexpected element state \"${state}\"`);\n    }\n    selectOptions(optionsToSelect, node, progress, continuePolling) {\n        const element = this._retarget(node, 'follow-label');\n        if (!element)\n            return 'error:notconnected';\n        if (element.nodeName.toLowerCase() !== 'select')\n            return 'error:notselect';\n        const select = element;\n        const options = [...select.options];\n        const selectedOptions = [];\n        let remainingOptionsToSelect = optionsToSelect.slice();\n        for (let index = 0; index < options.length; index++) {\n            const option = options[index];\n            const filter = (optionToSelect) => {\n                if (optionToSelect instanceof Node)\n                    return option === optionToSelect;\n                let matches = true;\n                if (optionToSelect.value !== undefined)\n                    matches = matches && optionToSelect.value === option.value;\n                if (optionToSelect.label !== undefined)\n                    matches = matches && optionToSelect.label === option.label;\n                if (optionToSelect.index !== undefined)\n                    matches = matches && optionToSelect.index === index;\n                return matches;\n            };\n            if (!remainingOptionsToSelect.some(filter))\n                continue;\n            selectedOptions.push(option);\n            if (select.multiple) {\n                remainingOptionsToSelect = remainingOptionsToSelect.filter(o => !filter(o));\n            }\n            else {\n                remainingOptionsToSelect = [];\n                break;\n            }\n        }\n        if (remainingOptionsToSelect.length) {\n            progress.logRepeating('    did not find some options - waiting... ');\n            return continuePolling;\n        }\n        select.value = undefined;\n        selectedOptions.forEach(option => option.selected = true);\n        progress.log('    selected specified option(s)');\n        select.dispatchEvent(new Event('input', { 'bubbles': true }));\n        select.dispatchEvent(new Event('change', { 'bubbles': true }));\n        return selectedOptions.map(option => option.value);\n    }\n    fill(value, node, progress) {\n        const element = this._retarget(node, 'follow-label');\n        if (!element)\n            return 'error:notconnected';\n        if (element.nodeName.toLowerCase() === 'input') {\n            const input = element;\n            const type = input.type.toLowerCase();\n            const kDateTypes = new Set(['date', 'time', 'datetime', 'datetime-local', 'month', 'week']);\n            const kTextInputTypes = new Set(['', 'email', 'number', 'password', 'search', 'tel', 'text', 'url']);\n            if (!kTextInputTypes.has(type) && !kDateTypes.has(type)) {\n                progress.log(`    input of type \"${type}\" cannot be filled`);\n                return 'error:notfillableinputtype';\n            }\n            if (type === 'number') {\n                value = value.trim();\n                if (isNaN(Number(value)))\n                    return 'error:notfillablenumberinput';\n            }\n            if (kDateTypes.has(type)) {\n                value = value.trim();\n                input.focus();\n                input.value = value;\n                if (input.value !== value)\n                    return 'error:notvaliddate';\n                element.dispatchEvent(new Event('input', { 'bubbles': true }));\n                element.dispatchEvent(new Event('change', { 'bubbles': true }));\n                return 'done'; // We have already changed the value, no need to input it.\n            }\n        }\n        else if (element.nodeName.toLowerCase() === 'textarea') {\n            // Nothing to check here.\n        }\n        else if (!element.isContentEditable) {\n            return 'error:notfillableelement';\n        }\n        this.selectText(element);\n        return 'needsinput'; // Still need to input the value.\n    }\n    selectText(node) {\n        const element = this._retarget(node, 'follow-label');\n        if (!element)\n            return 'error:notconnected';\n        if (element.nodeName.toLowerCase() === 'input') {\n            const input = element;\n            input.select();\n            input.focus();\n            return 'done';\n        }\n        if (element.nodeName.toLowerCase() === 'textarea') {\n            const textarea = element;\n            textarea.selectionStart = 0;\n            textarea.selectionEnd = textarea.value.length;\n            textarea.focus();\n            return 'done';\n        }\n        const range = element.ownerDocument.createRange();\n        range.selectNodeContents(element);\n        const selection = element.ownerDocument.defaultView.getSelection();\n        if (selection) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        element.focus();\n        return 'done';\n    }\n    focusNode(node, resetSelectionIfNotFocused) {\n        if (!node.isConnected)\n            return 'error:notconnected';\n        if (node.nodeType !== Node.ELEMENT_NODE)\n            return 'error:notelement';\n        const wasFocused = node.getRootNode().activeElement === node && node.ownerDocument && node.ownerDocument.hasFocus();\n        node.focus();\n        if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === 'input') {\n            try {\n                const input = node;\n                input.setSelectionRange(0, 0);\n            }\n            catch (e) {\n                // Some inputs do not allow selection.\n            }\n        }\n        return 'done';\n    }\n    setInputFiles(node, payloads) {\n        if (node.nodeType !== Node.ELEMENT_NODE)\n            return 'Node is not of type HTMLElement';\n        const element = node;\n        if (element.nodeName !== 'INPUT')\n            return 'Not an <input> element';\n        const input = element;\n        const type = (input.getAttribute('type') || '').toLowerCase();\n        if (type !== 'file')\n            return 'Not an input[type=file] element';\n        const files = payloads.map(file => {\n            const bytes = Uint8Array.from(atob(file.buffer), c => c.charCodeAt(0));\n            return new File([bytes], file.name, { type: file.mimeType });\n        });\n        const dt = new DataTransfer();\n        for (const file of files)\n            dt.items.add(file);\n        input.files = dt.files;\n        input.dispatchEvent(new Event('input', { 'bubbles': true }));\n        input.dispatchEvent(new Event('change', { 'bubbles': true }));\n    }\n    checkHitTargetAt(node, point) {\n        let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n        if (!element || !element.isConnected)\n            return 'error:notconnected';\n        element = element.closest('button, [role=button]') || element;\n        let hitElement = this.deepElementFromPoint(document, point.x, point.y);\n        const hitParents = [];\n        while (hitElement && hitElement !== element) {\n            hitParents.push(hitElement);\n            hitElement = selectorEvaluator_1.parentElementOrShadowHost(hitElement);\n        }\n        if (hitElement === element)\n            return 'done';\n        const hitTargetDescription = this.previewNode(hitParents[0]);\n        // Root is the topmost element in the hitTarget's chain that is not in the\n        // element's chain. For example, it might be a dialog element that overlays\n        // the target.\n        let rootHitTargetDescription;\n        while (element) {\n            const index = hitParents.indexOf(element);\n            if (index !== -1) {\n                if (index > 1)\n                    rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n                break;\n            }\n            element = selectorEvaluator_1.parentElementOrShadowHost(element);\n        }\n        if (rootHitTargetDescription)\n            return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n        return { hitTargetDescription };\n    }\n    dispatchEvent(node, type, eventInit) {\n        let event;\n        eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInit };\n        switch (eventType.get(type)) {\n            case 'mouse':\n                event = new MouseEvent(type, eventInit);\n                break;\n            case 'keyboard':\n                event = new KeyboardEvent(type, eventInit);\n                break;\n            case 'touch':\n                event = new TouchEvent(type, eventInit);\n                break;\n            case 'pointer':\n                event = new PointerEvent(type, eventInit);\n                break;\n            case 'focus':\n                event = new FocusEvent(type, eventInit);\n                break;\n            case 'drag':\n                event = new DragEvent(type, eventInit);\n                break;\n            default:\n                event = new Event(type, eventInit);\n                break;\n        }\n        node.dispatchEvent(event);\n    }\n    deepElementFromPoint(document, x, y) {\n        let container = document;\n        let element;\n        while (container) {\n            // elementFromPoint works incorrectly in Chromium (http://crbug.com/1188919),\n            // so we use elementsFromPoint instead.\n            const elements = container.elementsFromPoint(x, y);\n            const innerElement = elements[0];\n            if (!innerElement || element === innerElement)\n                break;\n            element = innerElement;\n            container = element.shadowRoot;\n        }\n        return element;\n    }\n    previewNode(node) {\n        if (node.nodeType === Node.TEXT_NODE)\n            return oneLine(`#text=${node.nodeValue || ''}`);\n        if (node.nodeType !== Node.ELEMENT_NODE)\n            return oneLine(`<${node.nodeName.toLowerCase()} />`);\n        const element = node;\n        const attrs = [];\n        for (let i = 0; i < element.attributes.length; i++) {\n            const { name, value } = element.attributes[i];\n            if (name === 'style')\n                continue;\n            if (!value && booleanAttributes.has(name))\n                attrs.push(` ${name}`);\n            else\n                attrs.push(` ${name}=\"${value}\"`);\n        }\n        attrs.sort((a, b) => a.length - b.length);\n        let attrText = attrs.join('');\n        if (attrText.length > 50)\n            attrText = attrText.substring(0, 49) + '\\u2026';\n        if (autoClosingTags.has(element.nodeName))\n            return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n        const children = element.childNodes;\n        let onlyText = false;\n        if (children.length <= 5) {\n            onlyText = true;\n            for (let i = 0; i < children.length; i++)\n                onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n        }\n        let text = onlyText ? (element.textContent || '') : (children.length ? '\\u2026' : '');\n        if (text.length > 50)\n            text = text.substring(0, 49) + '\\u2026';\n        return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`);\n    }\n}\nexports.InjectedScript = InjectedScript;\nconst autoClosingTags = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'MENUITEM', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);\nconst booleanAttributes = new Set(['checked', 'selected', 'disabled', 'readonly', 'multiple']);\nfunction oneLine(s) {\n    return s.replace(/\\n/g, '↵').replace(/\\t/g, '⇆');\n}\nconst eventType = new Map([\n    ['auxclick', 'mouse'],\n    ['click', 'mouse'],\n    ['dblclick', 'mouse'],\n    ['mousedown', 'mouse'],\n    ['mouseeenter', 'mouse'],\n    ['mouseleave', 'mouse'],\n    ['mousemove', 'mouse'],\n    ['mouseout', 'mouse'],\n    ['mouseover', 'mouse'],\n    ['mouseup', 'mouse'],\n    ['mouseleave', 'mouse'],\n    ['mousewheel', 'mouse'],\n    ['keydown', 'keyboard'],\n    ['keyup', 'keyboard'],\n    ['keypress', 'keyboard'],\n    ['textInput', 'keyboard'],\n    ['touchstart', 'touch'],\n    ['touchmove', 'touch'],\n    ['touchend', 'touch'],\n    ['touchcancel', 'touch'],\n    ['pointerover', 'pointer'],\n    ['pointerout', 'pointer'],\n    ['pointerenter', 'pointer'],\n    ['pointerleave', 'pointer'],\n    ['pointerdown', 'pointer'],\n    ['pointerup', 'pointer'],\n    ['pointermove', 'pointer'],\n    ['pointercancel', 'pointer'],\n    ['gotpointercapture', 'pointer'],\n    ['lostpointercapture', 'pointer'],\n    ['focus', 'focus'],\n    ['blur', 'focus'],\n    ['drag', 'drag'],\n    ['dragstart', 'drag'],\n    ['dragend', 'drag'],\n    ['dragover', 'drag'],\n    ['dragenter', 'drag'],\n    ['dragleave', 'drag'],\n    ['dragexit', 'drag'],\n    ['drop', 'drag'],\n]);\nfunction unescape(s) {\n    if (!s.includes('\\\\'))\n        return s;\n    const r = [];\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] === '\\\\' && i + 1 < s.length)\n            i++;\n        r.push(s[i++]);\n    }\n    return r.join('');\n}\nfunction createTextMatcher(selector) {\n    if (selector[0] === '/' && selector.lastIndexOf('/') > 0) {\n        const lastSlash = selector.lastIndexOf('/');\n        const matcher = selectorEvaluator_1.createRegexTextMatcher(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n        return { matcher, kind: 'regex' };\n    }\n    let strict = false;\n    if (selector.length > 1 && selector[0] === '\"' && selector[selector.length - 1] === '\"') {\n        selector = unescape(selector.substring(1, selector.length - 1));\n        strict = true;\n    }\n    if (selector.length > 1 && selector[0] === \"'\" && selector[selector.length - 1] === \"'\") {\n        selector = unescape(selector.substring(1, selector.length - 1));\n        strict = true;\n    }\n    const matcher = strict ? selectorEvaluator_1.createStrictTextMatcher(selector) : selectorEvaluator_1.createLaxTextMatcher(selector);\n    return { matcher, kind: strict ? 'strict' : 'lax' };\n}\nexports.default = InjectedScript;\n\n/* WEBPACK VAR INJECTION */}.call(this, __nccwpck_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./src/server/injected/selectorEvaluator.ts\":\n/*!**************************************************!*\\\n  !*** ./src/server/injected/selectorEvaluator.ts ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;\nconst selectorParser_1 = __nccwpck_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\nclass SelectorEvaluatorImpl {\n    constructor(extraEngines) {\n        this._engines = new Map();\n        this._cacheQueryCSS = new Map();\n        this._cacheMatches = new Map();\n        this._cacheQuery = new Map();\n        this._cacheMatchesSimple = new Map();\n        this._cacheMatchesParents = new Map();\n        this._cacheCallMatches = new Map();\n        this._cacheCallQuery = new Map();\n        this._cacheQuerySimple = new Map();\n        this._cacheText = new Map();\n        this._retainCacheCounter = 0;\n        for (const [name, engine] of extraEngines)\n            this._engines.set(name, engine);\n        this._engines.set('not', notEngine);\n        this._engines.set('is', isEngine);\n        this._engines.set('where', isEngine);\n        this._engines.set('has', hasEngine);\n        this._engines.set('scope', scopeEngine);\n        this._engines.set('light', lightEngine);\n        this._engines.set('visible', visibleEngine);\n        this._engines.set('text', textEngine);\n        this._engines.set('text-is', textIsEngine);\n        this._engines.set('text-matches', textMatchesEngine);\n        this._engines.set('has-text', hasTextEngine);\n        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));\n        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));\n        this._engines.set('above', createPositionEngine('above', boxAbove));\n        this._engines.set('below', createPositionEngine('below', boxBelow));\n        this._engines.set('near', createPositionEngine('near', boxNear));\n        this._engines.set('nth-match', nthMatchEngine);\n        const allNames = [...this._engines.keys()];\n        allNames.sort();\n        const parserNames = [...selectorParser_1.customCSSNames];\n        parserNames.sort();\n        if (allNames.join('|') !== parserNames.join('|'))\n            throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join('|')} vs ${parserNames.join('|')}`);\n    }\n    begin() {\n        ++this._retainCacheCounter;\n    }\n    end() {\n        --this._retainCacheCounter;\n        if (!this._retainCacheCounter) {\n            this._cacheQueryCSS.clear();\n            this._cacheMatches.clear();\n            this._cacheQuery.clear();\n            this._cacheMatchesSimple.clear();\n            this._cacheMatchesParents.clear();\n            this._cacheCallMatches.clear();\n            this._cacheCallQuery.clear();\n            this._cacheQuerySimple.clear();\n            this._cacheText.clear();\n        }\n    }\n    _cached(cache, main, rest, cb) {\n        if (!cache.has(main))\n            cache.set(main, []);\n        const entries = cache.get(main);\n        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));\n        if (entry)\n            return entry.result;\n        const result = cb();\n        entries.push({ rest, result });\n        return result;\n    }\n    _checkSelector(s) {\n        const wellFormed = typeof s === 'object' && s &&\n            (Array.isArray(s) || ('simples' in s) && (s.simples.length));\n        if (!wellFormed)\n            throw new Error(`Malformed selector \"${s}\"`);\n        return s;\n    }\n    matches(element, s, context) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._matchesEngine(isEngine, element, selector, context);\n                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n                    return false;\n                return this._matchesParents(element, selector, selector.simples.length - 2, context);\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    query(context, s) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._queryEngine(isEngine, context, selector);\n                // query() recursively calls itself, so we set up a new map for this particular query() call.\n                const previousScoreMap = this._scoreMap;\n                this._scoreMap = new Map();\n                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));\n                if (this._scoreMap.size) {\n                    elements.sort((a, b) => {\n                        const aScore = this._scoreMap.get(a);\n                        const bScore = this._scoreMap.get(b);\n                        if (aScore === bScore)\n                            return 0;\n                        if (aScore === undefined)\n                            return 1;\n                        if (bScore === undefined)\n                            return -1;\n                        return aScore - bScore;\n                    });\n                }\n                this._scoreMap = previousScoreMap;\n                return elements;\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    _markScore(element, score) {\n        // HACK ALERT: temporary marks an element with a score, to be used\n        // for sorting at the end of the query().\n        if (this._scoreMap)\n            this._scoreMap.set(element, score);\n    }\n    _matchesSimple(element, simple, context) {\n        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');\n            if (!isPossiblyScopeClause && element === context.scope)\n                return false;\n            if (simple.css && !this._matchesCSS(element, simple.css))\n                return false;\n            for (const func of simple.functions) {\n                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n                    return false;\n            }\n            return true;\n        });\n    }\n    _querySimple(context, simple) {\n        if (!simple.functions.length)\n            return this._queryCSS(context, simple.css || '*');\n        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n            let css = simple.css;\n            const funcs = simple.functions;\n            if (css === '*' && funcs.length)\n                css = undefined;\n            let elements;\n            let firstIndex = -1;\n            if (css !== undefined) {\n                elements = this._queryCSS(context, css);\n            }\n            else {\n                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);\n                if (firstIndex === -1)\n                    firstIndex = 0;\n                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches !== undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches === undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            return elements;\n        });\n    }\n    _matchesParents(element, complex, index, context) {\n        if (index < 0)\n            return true;\n        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n            const { selector: simple, combinator } = complex.simples[index];\n            if (combinator === '>') {\n                const parent = parentElementOrShadowHostInContext(element, context);\n                if (!parent || !this._matchesSimple(parent, simple, context))\n                    return false;\n                return this._matchesParents(parent, complex, index - 1, context);\n            }\n            if (combinator === '+') {\n                const previousSibling = previousSiblingInContext(element, context);\n                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n                    return false;\n                return this._matchesParents(previousSibling, complex, index - 1, context);\n            }\n            if (combinator === '') {\n                let parent = parentElementOrShadowHostInContext(element, context);\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            if (combinator === '~') {\n                let previousSibling = previousSiblingInContext(element, context);\n                while (previousSibling) {\n                    if (this._matchesSimple(previousSibling, simple, context)) {\n                        if (this._matchesParents(previousSibling, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '~')\n                            break;\n                    }\n                    previousSibling = previousSiblingInContext(previousSibling, context);\n                }\n                return false;\n            }\n            if (combinator === '>=') {\n                let parent = element;\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            throw new Error(`Unsupported combinator \"${combinator}\"`);\n        });\n    }\n    _matchesEngine(engine, element, args, context) {\n        if (engine.matches)\n            return this._callMatches(engine, element, args, context);\n        if (engine.query)\n            return this._callQuery(engine, args, context).includes(element);\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _queryEngine(engine, context, args) {\n        if (engine.query)\n            return this._callQuery(engine, args, context);\n        if (engine.matches)\n            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _callMatches(engine, element, args, context) {\n        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n            return engine.matches(element, args, context, this);\n        });\n    }\n    _callQuery(engine, args, context) {\n        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n            return engine.query(context, args, this);\n        });\n    }\n    _matchesCSS(element, css) {\n        return element.matches(css);\n    }\n    _queryCSS(context, css) {\n        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\n            let result = [];\n            function query(root) {\n                result = result.concat([...root.querySelectorAll(css)]);\n                if (!context.pierceShadow)\n                    return;\n                if (root.shadowRoot)\n                    query(root.shadowRoot);\n                for (const element of root.querySelectorAll('*')) {\n                    if (element.shadowRoot)\n                        query(element.shadowRoot);\n                }\n            }\n            query(context.scope);\n            return result;\n        });\n    }\n    _getEngine(name) {\n        const engine = this._engines.get(name);\n        if (!engine)\n            throw new Error(`Unknown selector engine \"${name}\"`);\n        return engine;\n    }\n}\nexports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;\nconst isEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        return args.some(selector => evaluator.matches(element, selector, context));\n    },\n    query(context, args, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        let elements = [];\n        for (const arg of args)\n            elements = elements.concat(evaluator.query(context, arg));\n        return args.length === 1 ? elements : sortInDOMOrder(elements);\n    },\n};\nconst hasEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"has\" engine expects non-empty selector list`);\n        return evaluator.query({ ...context, scope: element }, args).length > 0;\n    },\n    // TODO: we do not implement \"relative selectors\", as in \"div:has(> span)\" or \"div:has(+ span)\".\n    // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n    // all parents/descendants, just have to be careful with the \":scope\" matching.\n};\nconst scopeEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)\n            return element === context.scope.documentElement;\n        return element === context.scope;\n    },\n    query(context, args, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {\n            const root = context.scope.documentElement;\n            return root ? [root] : [];\n        }\n        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)\n            return [context.scope];\n        return [];\n    },\n};\nconst notEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"not\" engine expects non-empty selector list`);\n        return !evaluator.matches(element, args, context);\n    },\n};\nconst lightEngine = {\n    query(context, args, evaluator) {\n        return evaluator.query({ ...context, pierceShadow: false }, args);\n    },\n    matches(element, args, context, evaluator) {\n        return evaluator.matches(element, args, { ...context, pierceShadow: false });\n    }\n};\nconst visibleEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length)\n            throw new Error(`\"visible\" engine expects no arguments`);\n        return isVisible(element);\n    }\n};\nconst textEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text\" engine expects a single string`);\n        const matcher = createLaxTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst textIsEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text-is\" engine expects a single string`);\n        const matcher = createStrictTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) !== 'none';\n    },\n};\nconst textMatchesEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))\n            throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst hasTextEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"has-text\" engine expects a single string`);\n        if (shouldSkipForTextMatching(element))\n            return false;\n        const matcher = createLaxTextMatcher(args[0]);\n        return matcher(elementText(evaluator, element));\n    },\n};\nfunction createLaxTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();\n    return (elementText) => {\n        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();\n        return s.includes(text);\n    };\n}\nexports.createLaxTextMatcher = createLaxTextMatcher;\nfunction createStrictTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ');\n    return (elementText) => {\n        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);\n    };\n}\nexports.createStrictTextMatcher = createStrictTextMatcher;\nfunction createRegexTextMatcher(source, flags) {\n    const re = new RegExp(source, flags);\n    return (elementText) => {\n        return re.test(elementText.full);\n    };\n}\nexports.createRegexTextMatcher = createRegexTextMatcher;\nfunction shouldSkipForTextMatching(element) {\n    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n    let value = evaluator._cacheText.get(root);\n    if (value === undefined) {\n        value = { full: '', immediate: [] };\n        if (!shouldSkipForTextMatching(root)) {\n            let currentImmediate = '';\n            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {\n                value = { full: root.value, immediate: [root.value] };\n            }\n            else {\n                for (let child = root.firstChild; child; child = child.nextSibling) {\n                    if (child.nodeType === Node.TEXT_NODE) {\n                        value.full += child.nodeValue || '';\n                        currentImmediate += child.nodeValue || '';\n                    }\n                    else {\n                        if (currentImmediate)\n                            value.immediate.push(currentImmediate);\n                        currentImmediate = '';\n                        if (child.nodeType === Node.ELEMENT_NODE)\n                            value.full += elementText(evaluator, child).full;\n                    }\n                }\n                if (currentImmediate)\n                    value.immediate.push(currentImmediate);\n                if (root.shadowRoot)\n                    value.full += elementText(evaluator, root.shadowRoot).full;\n            }\n        }\n        evaluator._cacheText.set(root, value);\n    }\n    return value;\n}\nexports.elementText = elementText;\nfunction elementMatchesText(evaluator, element, matcher) {\n    if (shouldSkipForTextMatching(element))\n        return 'none';\n    if (!matcher(elementText(evaluator, element)))\n        return 'none';\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))\n            return 'selfAndChildren';\n    }\n    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))\n        return 'selfAndChildren';\n    return 'self';\n}\nexports.elementMatchesText = elementMatchesText;\nfunction boxRightOf(box1, box2, maxDistance) {\n    const distance = box1.left - box2.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n    const distance = box2.left - box1.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n    const distance = box2.top - box1.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n    const distance = box1.top - box2.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n    const kThreshold = maxDistance === undefined ? 50 : maxDistance;\n    let score = 0;\n    if (box1.left - box2.right >= 0)\n        score += box1.left - box2.right;\n    if (box2.left - box1.right >= 0)\n        score += box2.left - box1.right;\n    if (box2.top - box1.bottom >= 0)\n        score += box2.top - box1.bottom;\n    if (box1.top - box2.bottom >= 0)\n        score += box1.top - box2.bottom;\n    return score > kThreshold ? undefined : score;\n}\nfunction createPositionEngine(name, scorer) {\n    return {\n        matches(element, args, context, evaluator) {\n            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;\n            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);\n            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))\n                throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n            const box = element.getBoundingClientRect();\n            let bestScore;\n            for (const e of evaluator.query(context, queryArgs)) {\n                if (e === element)\n                    continue;\n                const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n                if (score === undefined)\n                    continue;\n                if (bestScore === undefined || score < bestScore)\n                    bestScore = score;\n            }\n            if (bestScore === undefined)\n                return false;\n            evaluator._markScore(element, bestScore);\n            return true;\n        }\n    };\n}\nconst nthMatchEngine = {\n    query(context, args, evaluator) {\n        let index = args[args.length - 1];\n        if (args.length < 2)\n            throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n        if (typeof index !== 'number' || index < 1)\n            throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n        index--; // one-based\n        return index < elements.length ? [elements[index]] : [];\n    },\n};\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n}\nexports.parentElementOrShadowHost = parentElementOrShadowHost;\nfunction parentElementOrShadowHostInContext(element, context) {\n    if (element === context.scope)\n        return;\n    if (!context.pierceShadow)\n        return element.parentElement || undefined;\n    return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n    if (element === context.scope)\n        return;\n    return element.previousElementSibling || undefined;\n}\nfunction isVisible(element) {\n    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.\n    if (!element.ownerDocument || !element.ownerDocument.defaultView)\n        return true;\n    const style = element.ownerDocument.defaultView.getComputedStyle(element);\n    if (!style || style.visibility === 'hidden')\n        return false;\n    const rect = element.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n}\nexports.isVisible = isVisible;\nfunction sortInDOMOrder(elements) {\n    const elementToEntry = new Map();\n    const roots = [];\n    const result = [];\n    function append(element) {\n        let entry = elementToEntry.get(element);\n        if (entry)\n            return entry;\n        const parent = parentElementOrShadowHost(element);\n        if (parent) {\n            const parentEntry = append(parent);\n            parentEntry.children.push(element);\n        }\n        else {\n            roots.push(element);\n        }\n        entry = { children: [], taken: false };\n        elementToEntry.set(element, entry);\n        return entry;\n    }\n    elements.forEach(e => append(e).taken = true);\n    function visit(element) {\n        const entry = elementToEntry.get(element);\n        if (entry.taken)\n            result.push(element);\n        if (entry.children.length > 1) {\n            const set = new Set(entry.children);\n            entry.children = [];\n            let child = element.firstElementChild;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n        }\n        entry.children.forEach(visit);\n    }\n    roots.forEach(visit);\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/injected/xpathSelectorEngine.ts\":\n/*!****************************************************!*\\\n  !*** ./src/server/injected/xpathSelectorEngine.ts ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XPathEngine = void 0;\nexports.XPathEngine = {\n    query(root, selector) {\n        if (selector.startsWith('/'))\n            selector = '.' + selector;\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n        for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n            if (node.nodeType === Node.ELEMENT_NODE)\n                return node;\n        }\n    },\n    queryAll(root, selector) {\n        if (selector.startsWith('/'))\n            selector = '.' + selector;\n        const result = [];\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return result;\n        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n        for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n            if (node.nodeType === Node.ELEMENT_NODE)\n                result.push(node);\n        }\n        return result;\n    }\n};\n\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=injectedScriptSource.js.map

/***/ }),

/***/ 2476:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nccwpck_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nccwpck_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nccwpck_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nccwpck_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nccwpck_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nccwpck_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nccwpck_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nccwpck_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nccwpck_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nccwpck_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nccwpck_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nccwpck_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nccwpck_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(__nccwpck_require__.s = \"./src/server/supplements/injected/recorder.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/server/common/cssParser.ts\":\n/*!****************************************!*\\\n  !*** ./src/server/common/cssParser.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeSelector = exports.parseCSS = void 0;\nconst css = __importStar(__nccwpck_require__(/*! ./cssTokenizer */ \"./src/server/common/cssTokenizer.js\"));\nfunction parseCSS(selector, customNames) {\n    let tokens;\n    try {\n        tokens = css.tokenize(selector);\n        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))\n            tokens.push(new css.EOFToken());\n    }\n    catch (e) {\n        const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n        const index = (e.stack || '').indexOf(e.message);\n        if (index !== -1)\n            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n        e.message = newMessage;\n        throw e;\n    }\n    const unsupportedToken = tokens.find(token => {\n        return (token instanceof css.AtKeywordToken) ||\n            (token instanceof css.BadStringToken) ||\n            (token instanceof css.BadURLToken) ||\n            (token instanceof css.ColumnToken) ||\n            (token instanceof css.CDOToken) ||\n            (token instanceof css.CDCToken) ||\n            (token instanceof css.SemicolonToken) ||\n            // TODO: Consider using these for something, e.g. to escape complex strings.\n            // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n            // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n            (token instanceof css.OpenCurlyToken) ||\n            (token instanceof css.CloseCurlyToken) ||\n            // TODO: Consider treating these as strings?\n            (token instanceof css.URLToken) ||\n            (token instanceof css.PercentageToken);\n    });\n    if (unsupportedToken)\n        throw new Error(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n    let pos = 0;\n    const names = new Set();\n    function unexpected() {\n        return new Error(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n    }\n    function skipWhitespace() {\n        while (tokens[pos] instanceof css.WhitespaceToken)\n            pos++;\n    }\n    function isIdent(p = pos) {\n        return tokens[p] instanceof css.IdentToken;\n    }\n    function isString(p = pos) {\n        return tokens[p] instanceof css.StringToken;\n    }\n    function isNumber(p = pos) {\n        return tokens[p] instanceof css.NumberToken;\n    }\n    function isComma(p = pos) {\n        return tokens[p] instanceof css.CommaToken;\n    }\n    function isCloseParen(p = pos) {\n        return tokens[p] instanceof css.CloseParenToken;\n    }\n    function isStar(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';\n    }\n    function isEOF(p = pos) {\n        return tokens[p] instanceof css.EOFToken;\n    }\n    function isClauseCombinator(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));\n    }\n    function isSelectorClauseEnd(p = pos) {\n        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);\n    }\n    function consumeFunctionArguments() {\n        const result = [consumeArgument()];\n        while (true) {\n            skipWhitespace();\n            if (!isComma())\n                break;\n            pos++;\n            result.push(consumeArgument());\n        }\n        return result;\n    }\n    function consumeArgument() {\n        skipWhitespace();\n        if (isNumber())\n            return tokens[pos++].value;\n        if (isString())\n            return tokens[pos++].value;\n        return consumeComplexSelector();\n    }\n    function consumeComplexSelector() {\n        skipWhitespace();\n        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };\n        while (true) {\n            skipWhitespace();\n            if (isClauseCombinator()) {\n                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n                skipWhitespace();\n            }\n            else if (isSelectorClauseEnd()) {\n                break;\n            }\n            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });\n        }\n        return result;\n    }\n    function consumeSimpleSelector() {\n        let rawCSSString = '';\n        const functions = [];\n        while (!isSelectorClauseEnd()) {\n            if (isIdent() || isStar()) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if (tokens[pos] instanceof css.HashToken) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {\n                pos++;\n                if (isIdent())\n                    rawCSSString += '.' + tokens[pos++].toSource();\n                else\n                    throw unexpected();\n            }\n            else if (tokens[pos] instanceof css.ColonToken) {\n                pos++;\n                if (isIdent()) {\n                    if (!customNames.has(tokens[pos].value.toLowerCase())) {\n                        rawCSSString += ':' + tokens[pos++].toSource();\n                    }\n                    else {\n                        const name = tokens[pos++].value.toLowerCase();\n                        functions.push({ name, args: [] });\n                        names.add(name);\n                    }\n                }\n                else if (tokens[pos] instanceof css.FunctionToken) {\n                    const name = tokens[pos++].value.toLowerCase();\n                    if (!customNames.has(name)) {\n                        rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n                    }\n                    else {\n                        functions.push({ name, args: consumeFunctionArguments() });\n                        names.add(name);\n                    }\n                    skipWhitespace();\n                    if (!isCloseParen())\n                        throw unexpected();\n                    pos++;\n                }\n                else {\n                    throw unexpected();\n                }\n            }\n            else if (tokens[pos] instanceof css.OpenSquareToken) {\n                rawCSSString += '[';\n                pos++;\n                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())\n                    rawCSSString += tokens[pos++].toSource();\n                if (!(tokens[pos] instanceof css.CloseSquareToken))\n                    throw unexpected();\n                rawCSSString += ']';\n                pos++;\n            }\n            else {\n                throw unexpected();\n            }\n        }\n        if (!rawCSSString && !functions.length)\n            throw unexpected();\n        return { css: rawCSSString || undefined, functions };\n    }\n    function consumeBuiltinFunctionArguments() {\n        let s = '';\n        while (!isCloseParen() && !isEOF())\n            s += tokens[pos++].toSource();\n        return s;\n    }\n    const result = consumeFunctionArguments();\n    if (!isEOF())\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    return { selector: result, names: Array.from(names) };\n}\nexports.parseCSS = parseCSS;\nfunction serializeSelector(args) {\n    return args.map(arg => {\n        if (typeof arg === 'string')\n            return `\"${arg}\"`;\n        if (typeof arg === 'number')\n            return String(arg);\n        return arg.simples.map(({ selector, combinator }) => {\n            let s = selector.css || '';\n            s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n            if (combinator)\n                s += ' ' + combinator;\n            return s;\n        }).join(' ');\n    }).join(', ');\n}\nexports.serializeSelector = serializeSelector;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/cssTokenizer.js\":\n/*!*******************************************!*\\\n  !*** ./src/server/common/cssTokenizer.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n * Original at https://github.com/tabatkins/parse-css\n * licensed under http://creativecommons.org/publicdomain/zero/1.0/\n *\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Changes from https://github.com/tabatkins/parse-css\n//   - Tabs are replaced with two spaces.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n// @ts-nocheck\n(function (root, factory) {\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}(this, function (exports) {\n    var between = function (num, first, last) { return num >= first && num <= last; };\n    function digit(code) { return between(code, 0x30, 0x39); }\n    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }\n    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }\n    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }\n    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\n    function nonascii(code) { return code >= 0x80; }\n    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\n    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\n    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }\n    function newline(code) { return code == 0xa; }\n    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\n    function badescape(code) { return newline(code) || isNaN(code); }\n    var maximumallowedcodepoint = 0x10ffff;\n    var InvalidCharacterError = function (message) {\n        this.message = message;\n    };\n    InvalidCharacterError.prototype = new Error;\n    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n    function preprocess(str) {\n        // Turn a string into an array of code points,\n        // following the preprocessing cleanup rules.\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n            var code = str.charCodeAt(i);\n            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n                code = 0xa;\n                i++;\n            }\n            if (code == 0xd || code == 0xc)\n                code = 0xa;\n            if (code == 0x0)\n                code = 0xfffd;\n            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n                // Decode a surrogate pair into an astral codepoint.\n                var lead = code - 0xd800;\n                var trail = str.charCodeAt(i + 1) - 0xdc00;\n                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n                i++;\n            }\n            codepoints.push(code);\n        }\n        return codepoints;\n    }\n    function stringFromCode(code) {\n        if (code <= 0xffff)\n            return String.fromCharCode(code);\n        // Otherwise, encode astral char as surrogate pair.\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n        var trail = code % Math.pow(2, 10) + 0xdc00;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n    }\n    function tokenize(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        // Line number information.\n        var line = 0;\n        var column = 0;\n        // The only use of lastLineLength is in reconsume().\n        var lastLineLength = 0;\n        var incrLineno = function () {\n            line += 1;\n            lastLineLength = column;\n            column = 0;\n        };\n        var locStart = { line: line, column: column };\n        var codepoint = function (i) {\n            if (i >= str.length) {\n                return -1;\n            }\n            return str[i];\n        };\n        var next = function (num) {\n            if (num === undefined)\n                num = 1;\n            if (num > 3)\n                throw \"Spec Error: no more than three codepoints of lookahead.\";\n            return codepoint(i + num);\n        };\n        var consume = function (num) {\n            if (num === undefined)\n                num = 1;\n            i += num;\n            code = codepoint(i);\n            if (newline(code))\n                incrLineno();\n            else\n                column += num;\n            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n            return true;\n        };\n        var reconsume = function () {\n            i -= 1;\n            if (newline(code)) {\n                line -= 1;\n                column = lastLineLength;\n            }\n            else {\n                column -= 1;\n            }\n            locStart.line = line;\n            locStart.column = column;\n            return true;\n        };\n        var eof = function (codepoint) {\n            if (codepoint === undefined)\n                codepoint = code;\n            return codepoint == -1;\n        };\n        var donothing = function () { };\n        var parseerror = function () { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\"); return true; };\n        var consumeAToken = function () {\n            consumeComments();\n            consume();\n            if (whitespace(code)) {\n                while (whitespace(next()))\n                    consume();\n                return new WhitespaceToken;\n            }\n            else if (code == 0x22)\n                return consumeAStringToken();\n            else if (code == 0x23) {\n                if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n                    var token = new HashToken();\n                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                        token.type = \"id\";\n                    token.value = consumeAName();\n                    return token;\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x24) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SuffixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x27)\n                return consumeAStringToken();\n            else if (code == 0x28)\n                return new OpenParenToken();\n            else if (code == 0x29)\n                return new CloseParenToken();\n            else if (code == 0x2a) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SubstringMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2b) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2c)\n                return new CommaToken();\n            else if (code == 0x2d) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else if (next(1) == 0x2d && next(2) == 0x3e) {\n                    consume(2);\n                    return new CDCToken();\n                }\n                else if (startsWithAnIdentifier()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2e) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x3a)\n                return new ColonToken;\n            else if (code == 0x3b)\n                return new SemicolonToken;\n            else if (code == 0x3c) {\n                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n                    consume(3);\n                    return new CDOToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x40) {\n                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                    return new AtKeywordToken(consumeAName());\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5b)\n                return new OpenSquareToken();\n            else if (code == 0x5c) {\n                if (startsWithAValidEscape()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    parseerror();\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5d)\n                return new CloseSquareToken();\n            else if (code == 0x5e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new PrefixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7b)\n                return new OpenCurlyToken();\n            else if (code == 0x7c) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new DashMatchToken();\n                }\n                else if (next() == 0x7c) {\n                    consume();\n                    return new ColumnToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7d)\n                return new CloseCurlyToken();\n            else if (code == 0x7e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new IncludeMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (digit(code)) {\n                reconsume();\n                return consumeANumericToken();\n            }\n            else if (namestartchar(code)) {\n                reconsume();\n                return consumeAnIdentlikeToken();\n            }\n            else if (eof())\n                return new EOFToken();\n            else\n                return new DelimToken(code);\n        };\n        var consumeComments = function () {\n            while (next(1) == 0x2f && next(2) == 0x2a) {\n                consume(2);\n                while (true) {\n                    consume();\n                    if (code == 0x2a && next() == 0x2f) {\n                        consume();\n                        break;\n                    }\n                    else if (eof()) {\n                        parseerror();\n                        return;\n                    }\n                }\n            }\n        };\n        var consumeANumericToken = function () {\n            var num = consumeANumber();\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                var token = new DimensionToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                token.unit = consumeAName();\n                return token;\n            }\n            else if (next() == 0x25) {\n                consume();\n                var token = new PercentageToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                return token;\n            }\n            else {\n                var token = new NumberToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                return token;\n            }\n        };\n        var consumeAnIdentlikeToken = function () {\n            var str = consumeAName();\n            if (str.toLowerCase() == \"url\" && next() == 0x28) {\n                consume();\n                while (whitespace(next(1)) && whitespace(next(2)))\n                    consume();\n                if (next() == 0x22 || next() == 0x27) {\n                    return new FunctionToken(str);\n                }\n                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n                    return new FunctionToken(str);\n                }\n                else {\n                    return consumeAURLToken();\n                }\n            }\n            else if (next() == 0x28) {\n                consume();\n                return new FunctionToken(str);\n            }\n            else {\n                return new IdentToken(str);\n            }\n        };\n        var consumeAStringToken = function (endingCodePoint) {\n            if (endingCodePoint === undefined)\n                endingCodePoint = code;\n            var string = \"\";\n            while (consume()) {\n                if (code == endingCodePoint || eof()) {\n                    return new StringToken(string);\n                }\n                else if (newline(code)) {\n                    parseerror();\n                    reconsume();\n                    return new BadStringToken();\n                }\n                else if (code == 0x5c) {\n                    if (eof(next())) {\n                        donothing();\n                    }\n                    else if (newline(next())) {\n                        consume();\n                    }\n                    else {\n                        string += stringFromCode(consumeEscape());\n                    }\n                }\n                else {\n                    string += stringFromCode(code);\n                }\n            }\n        };\n        var consumeAURLToken = function () {\n            var token = new URLToken(\"\");\n            while (whitespace(next()))\n                consume();\n            if (eof(next()))\n                return token;\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return token;\n                }\n                else if (whitespace(code)) {\n                    while (whitespace(next()))\n                        consume();\n                    if (next() == 0x29 || eof(next())) {\n                        consume();\n                        return token;\n                    }\n                    else {\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n                    parseerror();\n                    consumeTheRemnantsOfABadURL();\n                    return new BadURLToken();\n                }\n                else if (code == 0x5c) {\n                    if (startsWithAValidEscape()) {\n                        token.value += stringFromCode(consumeEscape());\n                    }\n                    else {\n                        parseerror();\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else {\n                    token.value += stringFromCode(code);\n                }\n            }\n        };\n        var consumeEscape = function () {\n            // Assume the the current character is the \\\n            // and the next code point is not a newline.\n            consume();\n            if (hexdigit(code)) {\n                // Consume 1-6 hex digits\n                var digits = [code];\n                for (var total = 0; total < 5; total++) {\n                    if (hexdigit(next())) {\n                        consume();\n                        digits.push(code);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (whitespace(next()))\n                    consume();\n                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);\n                if (value > maximumallowedcodepoint)\n                    value = 0xfffd;\n                return value;\n            }\n            else if (eof()) {\n                return 0xfffd;\n            }\n            else {\n                return code;\n            }\n        };\n        var areAValidEscape = function (c1, c2) {\n            if (c1 != 0x5c)\n                return false;\n            if (newline(c2))\n                return false;\n            return true;\n        };\n        var startsWithAValidEscape = function () {\n            return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function (c1, c2, c3) {\n            if (c1 == 0x2d) {\n                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n            }\n            else if (namestartchar(c1)) {\n                return true;\n            }\n            else if (c1 == 0x5c) {\n                return areAValidEscape(c1, c2);\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithAnIdentifier = function () {\n            return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function (c1, c2, c3) {\n            if (c1 == 0x2b || c1 == 0x2d) {\n                if (digit(c2))\n                    return true;\n                if (c2 == 0x2e && digit(c3))\n                    return true;\n                return false;\n            }\n            else if (c1 == 0x2e) {\n                if (digit(c2))\n                    return true;\n                return false;\n            }\n            else if (digit(c1)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithANumber = function () {\n            return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function () {\n            var result = \"\";\n            while (consume()) {\n                if (namechar(code)) {\n                    result += stringFromCode(code);\n                }\n                else if (startsWithAValidEscape()) {\n                    result += stringFromCode(consumeEscape());\n                }\n                else {\n                    reconsume();\n                    return result;\n                }\n            }\n        };\n        var consumeANumber = function () {\n            var repr = [];\n            var type = \"integer\";\n            if (next() == 0x2b || next() == 0x2d) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            while (digit(next())) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            if (next(1) == 0x2e && digit(next(2))) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var c1 = next(1), c2 = next(2), c3 = next(3);\n            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var value = convertAStringToANumber(repr);\n            return { type: type, value: value, repr: repr };\n        };\n        var convertAStringToANumber = function (string) {\n            // CSS's number rules are identical to JS, afaik.\n            return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function () {\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return;\n                }\n                else if (startsWithAValidEscape()) {\n                    consumeEscape();\n                    donothing();\n                }\n                else {\n                    donothing();\n                }\n            }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n            tokens.push(consumeAToken());\n            iterationCount++;\n            if (iterationCount > str.length * 2)\n                return \"I'm infinite-looping!\";\n        }\n        return tokens;\n    }\n    function CSSParserToken() { throw \"Abstract Base Class\"; }\n    CSSParserToken.prototype.toJSON = function () {\n        return { token: this.tokenType };\n    };\n    CSSParserToken.prototype.toString = function () { return this.tokenType; };\n    CSSParserToken.prototype.toSource = function () { return '' + this; };\n    function BadStringToken() { return this; }\n    BadStringToken.prototype = Object.create(CSSParserToken.prototype);\n    BadStringToken.prototype.tokenType = \"BADSTRING\";\n    function BadURLToken() { return this; }\n    BadURLToken.prototype = Object.create(CSSParserToken.prototype);\n    BadURLToken.prototype.tokenType = \"BADURL\";\n    function WhitespaceToken() { return this; }\n    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);\n    WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\n    WhitespaceToken.prototype.toString = function () { return \"WS\"; };\n    WhitespaceToken.prototype.toSource = function () { return \" \"; };\n    function CDOToken() { return this; }\n    CDOToken.prototype = Object.create(CSSParserToken.prototype);\n    CDOToken.prototype.tokenType = \"CDO\";\n    CDOToken.prototype.toSource = function () { return \"<!--\"; };\n    function CDCToken() { return this; }\n    CDCToken.prototype = Object.create(CSSParserToken.prototype);\n    CDCToken.prototype.tokenType = \"CDC\";\n    CDCToken.prototype.toSource = function () { return \"-->\"; };\n    function ColonToken() { return this; }\n    ColonToken.prototype = Object.create(CSSParserToken.prototype);\n    ColonToken.prototype.tokenType = \":\";\n    function SemicolonToken() { return this; }\n    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);\n    SemicolonToken.prototype.tokenType = \";\";\n    function CommaToken() { return this; }\n    CommaToken.prototype = Object.create(CSSParserToken.prototype);\n    CommaToken.prototype.tokenType = \",\";\n    function GroupingToken() { throw \"Abstract Base Class\"; }\n    GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n    function OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\n    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    OpenCurlyToken.prototype.tokenType = \"{\";\n    function CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\n    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    CloseCurlyToken.prototype.tokenType = \"}\";\n    function OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\n    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);\n    OpenSquareToken.prototype.tokenType = \"[\";\n    function CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\n    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);\n    CloseSquareToken.prototype.tokenType = \"]\";\n    function OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\n    OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n    OpenParenToken.prototype.tokenType = \"(\";\n    function CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\n    CloseParenToken.prototype = Object.create(GroupingToken.prototype);\n    CloseParenToken.prototype.tokenType = \")\";\n    function IncludeMatchToken() { return this; }\n    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    IncludeMatchToken.prototype.tokenType = \"~=\";\n    function DashMatchToken() { return this; }\n    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    DashMatchToken.prototype.tokenType = \"|=\";\n    function PrefixMatchToken() { return this; }\n    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    PrefixMatchToken.prototype.tokenType = \"^=\";\n    function SuffixMatchToken() { return this; }\n    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SuffixMatchToken.prototype.tokenType = \"$=\";\n    function SubstringMatchToken() { return this; }\n    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SubstringMatchToken.prototype.tokenType = \"*=\";\n    function ColumnToken() { return this; }\n    ColumnToken.prototype = Object.create(CSSParserToken.prototype);\n    ColumnToken.prototype.tokenType = \"||\";\n    function EOFToken() { return this; }\n    EOFToken.prototype = Object.create(CSSParserToken.prototype);\n    EOFToken.prototype.tokenType = \"EOF\";\n    EOFToken.prototype.toSource = function () { return \"\"; };\n    function DelimToken(code) {\n        this.value = stringFromCode(code);\n        return this;\n    }\n    DelimToken.prototype = Object.create(CSSParserToken.prototype);\n    DelimToken.prototype.tokenType = \"DELIM\";\n    DelimToken.prototype.toString = function () { return \"DELIM(\" + this.value + \")\"; };\n    DelimToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    DelimToken.prototype.toSource = function () {\n        if (this.value == \"\\\\\")\n            return \"\\\\\\n\";\n        else\n            return this.value;\n    };\n    function StringValuedToken() { throw \"Abstract Base Class\"; }\n    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n    StringValuedToken.prototype.ASCIIMatch = function (str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n    };\n    StringValuedToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    function IdentToken(val) {\n        this.value = val;\n    }\n    IdentToken.prototype = Object.create(StringValuedToken.prototype);\n    IdentToken.prototype.tokenType = \"IDENT\";\n    IdentToken.prototype.toString = function () { return \"IDENT(\" + this.value + \")\"; };\n    IdentToken.prototype.toSource = function () {\n        return escapeIdent(this.value);\n    };\n    function FunctionToken(val) {\n        this.value = val;\n        this.mirror = \")\";\n    }\n    FunctionToken.prototype = Object.create(StringValuedToken.prototype);\n    FunctionToken.prototype.tokenType = \"FUNCTION\";\n    FunctionToken.prototype.toString = function () { return \"FUNCTION(\" + this.value + \")\"; };\n    FunctionToken.prototype.toSource = function () {\n        return escapeIdent(this.value) + \"(\";\n    };\n    function AtKeywordToken(val) {\n        this.value = val;\n    }\n    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);\n    AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\n    AtKeywordToken.prototype.toString = function () { return \"AT(\" + this.value + \")\"; };\n    AtKeywordToken.prototype.toSource = function () {\n        return \"@\" + escapeIdent(this.value);\n    };\n    function HashToken(val) {\n        this.value = val;\n        this.type = \"unrestricted\";\n    }\n    HashToken.prototype = Object.create(StringValuedToken.prototype);\n    HashToken.prototype.tokenType = \"HASH\";\n    HashToken.prototype.toString = function () { return \"HASH(\" + this.value + \")\"; };\n    HashToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n    };\n    HashToken.prototype.toSource = function () {\n        if (this.type == \"id\") {\n            return \"#\" + escapeIdent(this.value);\n        }\n        else {\n            return \"#\" + escapeHash(this.value);\n        }\n    };\n    function StringToken(val) {\n        this.value = val;\n    }\n    StringToken.prototype = Object.create(StringValuedToken.prototype);\n    StringToken.prototype.tokenType = \"STRING\";\n    StringToken.prototype.toString = function () {\n        return '\"' + escapeString(this.value) + '\"';\n    };\n    function URLToken(val) {\n        this.value = val;\n    }\n    URLToken.prototype = Object.create(StringValuedToken.prototype);\n    URLToken.prototype.tokenType = \"URL\";\n    URLToken.prototype.toString = function () { return \"URL(\" + this.value + \")\"; };\n    URLToken.prototype.toSource = function () {\n        return 'url(\"' + escapeString(this.value) + '\")';\n    };\n    function NumberToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n    }\n    NumberToken.prototype = Object.create(CSSParserToken.prototype);\n    NumberToken.prototype.tokenType = \"NUMBER\";\n    NumberToken.prototype.toString = function () {\n        if (this.type == \"integer\")\n            return \"INT(\" + this.value + \")\";\n        return \"NUMBER(\" + this.value + \")\";\n    };\n    NumberToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n    };\n    NumberToken.prototype.toSource = function () { return this.repr; };\n    function PercentageToken() {\n        this.value = null;\n        this.repr = \"\";\n    }\n    PercentageToken.prototype = Object.create(CSSParserToken.prototype);\n    PercentageToken.prototype.tokenType = \"PERCENTAGE\";\n    PercentageToken.prototype.toString = function () { return \"PERCENTAGE(\" + this.value + \")\"; };\n    PercentageToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n    };\n    PercentageToken.prototype.toSource = function () { return this.repr + \"%\"; };\n    function DimensionToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n        this.unit = \"\";\n    }\n    DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\n    DimensionToken.prototype.toString = function () { return \"DIM(\" + this.value + \",\" + this.unit + \")\"; };\n    DimensionToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n    };\n    DimensionToken.prototype.toSource = function () {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n            // Unit is ambiguous with scinot\n            // Remove the leading \"e\", replace with escape.\n            unit = \"\\\\65 \" + unit.slice(1, unit.length);\n        }\n        return source + unit;\n    };\n    function escapeIdent(string) {\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f ||\n                (i == 0 && between(code, 0x30, 0x39)) ||\n                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + string[i];\n            }\n        }\n        return result;\n    }\n    function escapeHash(string) {\n        // Escapes the contents of \"unrestricted\"-type hash tokens.\n        // Won't preserve the ID-ness of \"id\"-type hash tokens;\n        // use escapeIdent() for that.\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n        }\n        return result;\n    }\n    function escapeString(string) {\n        string = '' + string;\n        var result = '';\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code == 0x22 || code == 0x5c) {\n                result += '\\\\' + string[i];\n            }\n            else {\n                result += string[i];\n            }\n        }\n        return result;\n    }\n    // Exportation.\n    exports.tokenize = tokenize;\n    exports.IdentToken = IdentToken;\n    exports.FunctionToken = FunctionToken;\n    exports.AtKeywordToken = AtKeywordToken;\n    exports.HashToken = HashToken;\n    exports.StringToken = StringToken;\n    exports.BadStringToken = BadStringToken;\n    exports.URLToken = URLToken;\n    exports.BadURLToken = BadURLToken;\n    exports.DelimToken = DelimToken;\n    exports.NumberToken = NumberToken;\n    exports.PercentageToken = PercentageToken;\n    exports.DimensionToken = DimensionToken;\n    exports.IncludeMatchToken = IncludeMatchToken;\n    exports.DashMatchToken = DashMatchToken;\n    exports.PrefixMatchToken = PrefixMatchToken;\n    exports.SuffixMatchToken = SuffixMatchToken;\n    exports.SubstringMatchToken = SubstringMatchToken;\n    exports.ColumnToken = ColumnToken;\n    exports.WhitespaceToken = WhitespaceToken;\n    exports.CDOToken = CDOToken;\n    exports.CDCToken = CDCToken;\n    exports.ColonToken = ColonToken;\n    exports.SemicolonToken = SemicolonToken;\n    exports.CommaToken = CommaToken;\n    exports.OpenParenToken = OpenParenToken;\n    exports.CloseParenToken = CloseParenToken;\n    exports.OpenSquareToken = OpenSquareToken;\n    exports.CloseSquareToken = CloseSquareToken;\n    exports.OpenCurlyToken = OpenCurlyToken;\n    exports.CloseCurlyToken = CloseCurlyToken;\n    exports.EOFToken = EOFToken;\n    exports.CSSParserToken = CSSParserToken;\n    exports.GroupingToken = GroupingToken;\n}));\n\n\n/***/ }),\n\n/***/ \"./src/server/common/selectorParser.ts\":\n/*!*********************************************!*\\\n  !*** ./src/server/common/selectorParser.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseSelector = exports.customCSSNames = void 0;\nconst cssParser_1 = __nccwpck_require__(/*! ./cssParser */ \"./src/server/common/cssParser.ts\");\nexports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nfunction parseSelector(selector) {\n    const result = parseSelectorV1(selector);\n    result.parts = result.parts.map(part => {\n        if (Array.isArray(part))\n            return part;\n        if (part.name === 'css' || part.name === 'css:light') {\n            if (part.name === 'css:light')\n                part.body = ':light(' + part.body + ')';\n            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);\n            return parsedCSS.selector;\n        }\n        return part;\n    });\n    return {\n        parts: result.parts,\n        capture: result.capture,\n    };\n}\nexports.parseSelector = parseSelector;\nfunction parseSelectorV1(selector) {\n    let index = 0;\n    let quote;\n    let start = 0;\n    const result = { parts: [] };\n    const append = () => {\n        const part = selector.substring(start, index).trim();\n        const eqIndex = part.indexOf('=');\n        let name;\n        let body;\n        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n            name = part.substring(0, eqIndex).trim();\n            body = part.substring(eqIndex + 1);\n        }\n        else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n            name = 'text';\n            body = part;\n        }\n        else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n            name = 'text';\n            body = part;\n        }\n        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n            // If selector starts with '//' or '//' prefixed with multiple opening\n            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n            // If selector starts with '..', consider xpath as well.\n            name = 'xpath';\n            body = part;\n        }\n        else {\n            name = 'css';\n            body = part;\n        }\n        let capture = false;\n        if (name[0] === '*') {\n            capture = true;\n            name = name.substring(1);\n        }\n        result.parts.push({ name, body });\n        if (capture) {\n            if (result.capture !== undefined)\n                throw new Error(`Only one of the selectors can capture using * modifier`);\n            result.capture = result.parts.length - 1;\n        }\n    };\n    if (!selector.includes('>>')) {\n        index = selector.length;\n        append();\n        return result;\n    }\n    while (index < selector.length) {\n        const c = selector[index];\n        if (c === '\\\\' && index + 1 < selector.length) {\n            index += 2;\n        }\n        else if (c === quote) {\n            quote = undefined;\n            index++;\n        }\n        else if (!quote && (c === '\"' || c === '\\'' || c === '`')) {\n            quote = c;\n            index++;\n        }\n        else if (!quote && c === '>' && selector[index + 1] === '>') {\n            append();\n            index += 2;\n            start = index;\n        }\n        else {\n            index++;\n        }\n    }\n    append();\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/injected/selectorEvaluator.ts\":\n/*!**************************************************!*\\\n  !*** ./src/server/injected/selectorEvaluator.ts ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;\nconst selectorParser_1 = __nccwpck_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\nclass SelectorEvaluatorImpl {\n    constructor(extraEngines) {\n        this._engines = new Map();\n        this._cacheQueryCSS = new Map();\n        this._cacheMatches = new Map();\n        this._cacheQuery = new Map();\n        this._cacheMatchesSimple = new Map();\n        this._cacheMatchesParents = new Map();\n        this._cacheCallMatches = new Map();\n        this._cacheCallQuery = new Map();\n        this._cacheQuerySimple = new Map();\n        this._cacheText = new Map();\n        this._retainCacheCounter = 0;\n        for (const [name, engine] of extraEngines)\n            this._engines.set(name, engine);\n        this._engines.set('not', notEngine);\n        this._engines.set('is', isEngine);\n        this._engines.set('where', isEngine);\n        this._engines.set('has', hasEngine);\n        this._engines.set('scope', scopeEngine);\n        this._engines.set('light', lightEngine);\n        this._engines.set('visible', visibleEngine);\n        this._engines.set('text', textEngine);\n        this._engines.set('text-is', textIsEngine);\n        this._engines.set('text-matches', textMatchesEngine);\n        this._engines.set('has-text', hasTextEngine);\n        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));\n        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));\n        this._engines.set('above', createPositionEngine('above', boxAbove));\n        this._engines.set('below', createPositionEngine('below', boxBelow));\n        this._engines.set('near', createPositionEngine('near', boxNear));\n        this._engines.set('nth-match', nthMatchEngine);\n        const allNames = [...this._engines.keys()];\n        allNames.sort();\n        const parserNames = [...selectorParser_1.customCSSNames];\n        parserNames.sort();\n        if (allNames.join('|') !== parserNames.join('|'))\n            throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join('|')} vs ${parserNames.join('|')}`);\n    }\n    begin() {\n        ++this._retainCacheCounter;\n    }\n    end() {\n        --this._retainCacheCounter;\n        if (!this._retainCacheCounter) {\n            this._cacheQueryCSS.clear();\n            this._cacheMatches.clear();\n            this._cacheQuery.clear();\n            this._cacheMatchesSimple.clear();\n            this._cacheMatchesParents.clear();\n            this._cacheCallMatches.clear();\n            this._cacheCallQuery.clear();\n            this._cacheQuerySimple.clear();\n            this._cacheText.clear();\n        }\n    }\n    _cached(cache, main, rest, cb) {\n        if (!cache.has(main))\n            cache.set(main, []);\n        const entries = cache.get(main);\n        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));\n        if (entry)\n            return entry.result;\n        const result = cb();\n        entries.push({ rest, result });\n        return result;\n    }\n    _checkSelector(s) {\n        const wellFormed = typeof s === 'object' && s &&\n            (Array.isArray(s) || ('simples' in s) && (s.simples.length));\n        if (!wellFormed)\n            throw new Error(`Malformed selector \"${s}\"`);\n        return s;\n    }\n    matches(element, s, context) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._matchesEngine(isEngine, element, selector, context);\n                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n                    return false;\n                return this._matchesParents(element, selector, selector.simples.length - 2, context);\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    query(context, s) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._queryEngine(isEngine, context, selector);\n                // query() recursively calls itself, so we set up a new map for this particular query() call.\n                const previousScoreMap = this._scoreMap;\n                this._scoreMap = new Map();\n                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));\n                if (this._scoreMap.size) {\n                    elements.sort((a, b) => {\n                        const aScore = this._scoreMap.get(a);\n                        const bScore = this._scoreMap.get(b);\n                        if (aScore === bScore)\n                            return 0;\n                        if (aScore === undefined)\n                            return 1;\n                        if (bScore === undefined)\n                            return -1;\n                        return aScore - bScore;\n                    });\n                }\n                this._scoreMap = previousScoreMap;\n                return elements;\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    _markScore(element, score) {\n        // HACK ALERT: temporary marks an element with a score, to be used\n        // for sorting at the end of the query().\n        if (this._scoreMap)\n            this._scoreMap.set(element, score);\n    }\n    _matchesSimple(element, simple, context) {\n        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');\n            if (!isPossiblyScopeClause && element === context.scope)\n                return false;\n            if (simple.css && !this._matchesCSS(element, simple.css))\n                return false;\n            for (const func of simple.functions) {\n                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n                    return false;\n            }\n            return true;\n        });\n    }\n    _querySimple(context, simple) {\n        if (!simple.functions.length)\n            return this._queryCSS(context, simple.css || '*');\n        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n            let css = simple.css;\n            const funcs = simple.functions;\n            if (css === '*' && funcs.length)\n                css = undefined;\n            let elements;\n            let firstIndex = -1;\n            if (css !== undefined) {\n                elements = this._queryCSS(context, css);\n            }\n            else {\n                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);\n                if (firstIndex === -1)\n                    firstIndex = 0;\n                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches !== undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches === undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            return elements;\n        });\n    }\n    _matchesParents(element, complex, index, context) {\n        if (index < 0)\n            return true;\n        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n            const { selector: simple, combinator } = complex.simples[index];\n            if (combinator === '>') {\n                const parent = parentElementOrShadowHostInContext(element, context);\n                if (!parent || !this._matchesSimple(parent, simple, context))\n                    return false;\n                return this._matchesParents(parent, complex, index - 1, context);\n            }\n            if (combinator === '+') {\n                const previousSibling = previousSiblingInContext(element, context);\n                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n                    return false;\n                return this._matchesParents(previousSibling, complex, index - 1, context);\n            }\n            if (combinator === '') {\n                let parent = parentElementOrShadowHostInContext(element, context);\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            if (combinator === '~') {\n                let previousSibling = previousSiblingInContext(element, context);\n                while (previousSibling) {\n                    if (this._matchesSimple(previousSibling, simple, context)) {\n                        if (this._matchesParents(previousSibling, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '~')\n                            break;\n                    }\n                    previousSibling = previousSiblingInContext(previousSibling, context);\n                }\n                return false;\n            }\n            if (combinator === '>=') {\n                let parent = element;\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            throw new Error(`Unsupported combinator \"${combinator}\"`);\n        });\n    }\n    _matchesEngine(engine, element, args, context) {\n        if (engine.matches)\n            return this._callMatches(engine, element, args, context);\n        if (engine.query)\n            return this._callQuery(engine, args, context).includes(element);\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _queryEngine(engine, context, args) {\n        if (engine.query)\n            return this._callQuery(engine, args, context);\n        if (engine.matches)\n            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _callMatches(engine, element, args, context) {\n        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n            return engine.matches(element, args, context, this);\n        });\n    }\n    _callQuery(engine, args, context) {\n        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n            return engine.query(context, args, this);\n        });\n    }\n    _matchesCSS(element, css) {\n        return element.matches(css);\n    }\n    _queryCSS(context, css) {\n        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\n            let result = [];\n            function query(root) {\n                result = result.concat([...root.querySelectorAll(css)]);\n                if (!context.pierceShadow)\n                    return;\n                if (root.shadowRoot)\n                    query(root.shadowRoot);\n                for (const element of root.querySelectorAll('*')) {\n                    if (element.shadowRoot)\n                        query(element.shadowRoot);\n                }\n            }\n            query(context.scope);\n            return result;\n        });\n    }\n    _getEngine(name) {\n        const engine = this._engines.get(name);\n        if (!engine)\n            throw new Error(`Unknown selector engine \"${name}\"`);\n        return engine;\n    }\n}\nexports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;\nconst isEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        return args.some(selector => evaluator.matches(element, selector, context));\n    },\n    query(context, args, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        let elements = [];\n        for (const arg of args)\n            elements = elements.concat(evaluator.query(context, arg));\n        return args.length === 1 ? elements : sortInDOMOrder(elements);\n    },\n};\nconst hasEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"has\" engine expects non-empty selector list`);\n        return evaluator.query({ ...context, scope: element }, args).length > 0;\n    },\n    // TODO: we do not implement \"relative selectors\", as in \"div:has(> span)\" or \"div:has(+ span)\".\n    // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n    // all parents/descendants, just have to be careful with the \":scope\" matching.\n};\nconst scopeEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)\n            return element === context.scope.documentElement;\n        return element === context.scope;\n    },\n    query(context, args, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {\n            const root = context.scope.documentElement;\n            return root ? [root] : [];\n        }\n        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)\n            return [context.scope];\n        return [];\n    },\n};\nconst notEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"not\" engine expects non-empty selector list`);\n        return !evaluator.matches(element, args, context);\n    },\n};\nconst lightEngine = {\n    query(context, args, evaluator) {\n        return evaluator.query({ ...context, pierceShadow: false }, args);\n    },\n    matches(element, args, context, evaluator) {\n        return evaluator.matches(element, args, { ...context, pierceShadow: false });\n    }\n};\nconst visibleEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length)\n            throw new Error(`\"visible\" engine expects no arguments`);\n        return isVisible(element);\n    }\n};\nconst textEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text\" engine expects a single string`);\n        const matcher = createLaxTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst textIsEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text-is\" engine expects a single string`);\n        const matcher = createStrictTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) !== 'none';\n    },\n};\nconst textMatchesEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))\n            throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst hasTextEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"has-text\" engine expects a single string`);\n        if (shouldSkipForTextMatching(element))\n            return false;\n        const matcher = createLaxTextMatcher(args[0]);\n        return matcher(elementText(evaluator, element));\n    },\n};\nfunction createLaxTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();\n    return (elementText) => {\n        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();\n        return s.includes(text);\n    };\n}\nexports.createLaxTextMatcher = createLaxTextMatcher;\nfunction createStrictTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ');\n    return (elementText) => {\n        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);\n    };\n}\nexports.createStrictTextMatcher = createStrictTextMatcher;\nfunction createRegexTextMatcher(source, flags) {\n    const re = new RegExp(source, flags);\n    return (elementText) => {\n        return re.test(elementText.full);\n    };\n}\nexports.createRegexTextMatcher = createRegexTextMatcher;\nfunction shouldSkipForTextMatching(element) {\n    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n    let value = evaluator._cacheText.get(root);\n    if (value === undefined) {\n        value = { full: '', immediate: [] };\n        if (!shouldSkipForTextMatching(root)) {\n            let currentImmediate = '';\n            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {\n                value = { full: root.value, immediate: [root.value] };\n            }\n            else {\n                for (let child = root.firstChild; child; child = child.nextSibling) {\n                    if (child.nodeType === Node.TEXT_NODE) {\n                        value.full += child.nodeValue || '';\n                        currentImmediate += child.nodeValue || '';\n                    }\n                    else {\n                        if (currentImmediate)\n                            value.immediate.push(currentImmediate);\n                        currentImmediate = '';\n                        if (child.nodeType === Node.ELEMENT_NODE)\n                            value.full += elementText(evaluator, child).full;\n                    }\n                }\n                if (currentImmediate)\n                    value.immediate.push(currentImmediate);\n                if (root.shadowRoot)\n                    value.full += elementText(evaluator, root.shadowRoot).full;\n            }\n        }\n        evaluator._cacheText.set(root, value);\n    }\n    return value;\n}\nexports.elementText = elementText;\nfunction elementMatchesText(evaluator, element, matcher) {\n    if (shouldSkipForTextMatching(element))\n        return 'none';\n    if (!matcher(elementText(evaluator, element)))\n        return 'none';\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))\n            return 'selfAndChildren';\n    }\n    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))\n        return 'selfAndChildren';\n    return 'self';\n}\nexports.elementMatchesText = elementMatchesText;\nfunction boxRightOf(box1, box2, maxDistance) {\n    const distance = box1.left - box2.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n    const distance = box2.left - box1.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n    const distance = box2.top - box1.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n    const distance = box1.top - box2.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n    const kThreshold = maxDistance === undefined ? 50 : maxDistance;\n    let score = 0;\n    if (box1.left - box2.right >= 0)\n        score += box1.left - box2.right;\n    if (box2.left - box1.right >= 0)\n        score += box2.left - box1.right;\n    if (box2.top - box1.bottom >= 0)\n        score += box2.top - box1.bottom;\n    if (box1.top - box2.bottom >= 0)\n        score += box1.top - box2.bottom;\n    return score > kThreshold ? undefined : score;\n}\nfunction createPositionEngine(name, scorer) {\n    return {\n        matches(element, args, context, evaluator) {\n            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;\n            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);\n            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))\n                throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n            const box = element.getBoundingClientRect();\n            let bestScore;\n            for (const e of evaluator.query(context, queryArgs)) {\n                if (e === element)\n                    continue;\n                const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n                if (score === undefined)\n                    continue;\n                if (bestScore === undefined || score < bestScore)\n                    bestScore = score;\n            }\n            if (bestScore === undefined)\n                return false;\n            evaluator._markScore(element, bestScore);\n            return true;\n        }\n    };\n}\nconst nthMatchEngine = {\n    query(context, args, evaluator) {\n        let index = args[args.length - 1];\n        if (args.length < 2)\n            throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n        if (typeof index !== 'number' || index < 1)\n            throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n        index--; // one-based\n        return index < elements.length ? [elements[index]] : [];\n    },\n};\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n}\nexports.parentElementOrShadowHost = parentElementOrShadowHost;\nfunction parentElementOrShadowHostInContext(element, context) {\n    if (element === context.scope)\n        return;\n    if (!context.pierceShadow)\n        return element.parentElement || undefined;\n    return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n    if (element === context.scope)\n        return;\n    return element.previousElementSibling || undefined;\n}\nfunction isVisible(element) {\n    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.\n    if (!element.ownerDocument || !element.ownerDocument.defaultView)\n        return true;\n    const style = element.ownerDocument.defaultView.getComputedStyle(element);\n    if (!style || style.visibility === 'hidden')\n        return false;\n    const rect = element.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n}\nexports.isVisible = isVisible;\nfunction sortInDOMOrder(elements) {\n    const elementToEntry = new Map();\n    const roots = [];\n    const result = [];\n    function append(element) {\n        let entry = elementToEntry.get(element);\n        if (entry)\n            return entry;\n        const parent = parentElementOrShadowHost(element);\n        if (parent) {\n            const parentEntry = append(parent);\n            parentEntry.children.push(element);\n        }\n        else {\n            roots.push(element);\n        }\n        entry = { children: [], taken: false };\n        elementToEntry.set(element, entry);\n        return entry;\n    }\n    elements.forEach(e => append(e).taken = true);\n    function visit(element) {\n        const entry = elementToEntry.get(element);\n        if (entry.taken)\n            result.push(element);\n        if (entry.children.length > 1) {\n            const set = new Set(entry.children);\n            entry.children = [];\n            let child = element.firstElementChild;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n        }\n        entry.children.forEach(visit);\n    }\n    roots.forEach(visit);\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/recorder.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/server/supplements/injected/recorder.ts ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Recorder = void 0;\nconst selectorGenerator_1 = __nccwpck_require__(/*! ./selectorGenerator */ \"./src/server/supplements/injected/selectorGenerator.ts\");\nconst scriptSymbol = Symbol('scriptSymbol');\nclass Recorder {\n    constructor(injectedScript, params) {\n        this._performingAction = false;\n        this._highlightElements = [];\n        this._listeners = [];\n        this._hoveredModel = null;\n        this._hoveredElement = null;\n        this._activeModel = null;\n        this._expectProgrammaticKeyUp = false;\n        this._mode = 'none';\n        this._params = params;\n        this._injectedScript = injectedScript;\n        this._outerGlassPaneElement = document.createElement('x-pw-glass');\n        this._outerGlassPaneElement.style.position = 'fixed';\n        this._outerGlassPaneElement.style.top = '0';\n        this._outerGlassPaneElement.style.right = '0';\n        this._outerGlassPaneElement.style.bottom = '0';\n        this._outerGlassPaneElement.style.left = '0';\n        this._outerGlassPaneElement.style.zIndex = '2147483647';\n        this._outerGlassPaneElement.style.pointerEvents = 'none';\n        this._outerGlassPaneElement.style.display = 'flex';\n        this._tooltipElement = document.createElement('x-pw-tooltip');\n        this._actionPointElement = document.createElement('x-pw-action-point');\n        this._actionPointElement.setAttribute('hidden', 'true');\n        this._innerGlassPaneElement = document.createElement('x-pw-glass-inner');\n        this._innerGlassPaneElement.style.flex = 'auto';\n        this._innerGlassPaneElement.appendChild(this._tooltipElement);\n        // Use a closed shadow root to prevent selectors matching our internal previews.\n        this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: this._params.isUnderTest ? 'open' : 'closed' });\n        this._glassPaneShadow.appendChild(this._innerGlassPaneElement);\n        this._glassPaneShadow.appendChild(this._actionPointElement);\n        const styleElement = document.createElement('style');\n        styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\n                       'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n        this._glassPaneShadow.appendChild(styleElement);\n        this._refreshListenersIfNeeded();\n        setInterval(() => {\n            this._refreshListenersIfNeeded();\n            if (params.isUnderTest && !this._reportedReadyForTest) {\n                this._reportedReadyForTest = true;\n                console.error('Recorder script ready for test');\n            }\n        }, 500);\n        globalThis._playwrightRefreshOverlay = () => {\n            this._pollRecorderMode().catch(e => console.log(e)); // eslint-disable-line no-console\n        };\n        globalThis._playwrightRefreshOverlay();\n    }\n    _refreshListenersIfNeeded() {\n        if (document.documentElement[scriptSymbol])\n            return;\n        document.documentElement[scriptSymbol] = true;\n        removeEventListeners(this._listeners);\n        this._listeners = [\n            addEventListener(document, 'click', event => this._onClick(event), true),\n            addEventListener(document, 'auxclick', event => this._onClick(event), true),\n            addEventListener(document, 'input', event => this._onInput(event), true),\n            addEventListener(document, 'keydown', event => this._onKeyDown(event), true),\n            addEventListener(document, 'keyup', event => this._onKeyUp(event), true),\n            addEventListener(document, 'mousedown', event => this._onMouseDown(event), true),\n            addEventListener(document, 'mouseup', event => this._onMouseUp(event), true),\n            addEventListener(document, 'mousemove', event => this._onMouseMove(event), true),\n            addEventListener(document, 'mouseleave', event => this._onMouseLeave(event), true),\n            addEventListener(document, 'focus', () => this._onFocus(), true),\n            addEventListener(document, 'scroll', () => {\n                this._hoveredModel = null;\n                this._actionPointElement.hidden = true;\n                this._updateHighlight();\n            }, true),\n        ];\n        document.documentElement.appendChild(this._outerGlassPaneElement);\n    }\n    async _pollRecorderMode() {\n        var _a;\n        const pollPeriod = 1000;\n        if (this._pollRecorderModeTimer)\n            clearTimeout(this._pollRecorderModeTimer);\n        const state = await globalThis._playwrightRecorderState().catch(e => null);\n        if (!state) {\n            this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n            return;\n        }\n        const { mode, actionPoint, actionSelector } = state;\n        if (mode !== this._mode) {\n            this._mode = mode;\n            this._clearHighlight();\n        }\n        if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {\n            // All good.\n        }\n        else if (!actionPoint && !this._actionPoint) {\n            // All good.\n        }\n        else {\n            if (actionPoint) {\n                this._actionPointElement.style.top = actionPoint.y + 'px';\n                this._actionPointElement.style.left = actionPoint.x + 'px';\n                this._actionPointElement.hidden = false;\n            }\n            else {\n                this._actionPointElement.hidden = true;\n            }\n            this._actionPoint = actionPoint;\n        }\n        // Race or scroll.\n        if (this._actionSelector && !((_a = this._hoveredModel) === null || _a === void 0 ? void 0 : _a.elements.length))\n            this._actionSelector = undefined;\n        if (actionSelector !== this._actionSelector) {\n            this._hoveredModel = actionSelector ? selectorGenerator_1.querySelector(this._injectedScript, actionSelector, document) : null;\n            this._updateHighlight();\n            this._actionSelector = actionSelector;\n        }\n        this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n    }\n    _clearHighlight() {\n        this._hoveredModel = null;\n        this._activeModel = null;\n        this._updateHighlight();\n    }\n    _actionInProgress(event) {\n        // If Playwright is performing action for us, bail.\n        if (this._performingAction)\n            return true;\n        // Consume as the first thing.\n        consumeEvent(event);\n        return false;\n    }\n    _consumedDueToNoModel(event, model) {\n        if (model)\n            return false;\n        consumeEvent(event);\n        return true;\n    }\n    _consumedDueWrongTarget(event) {\n        if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))\n            return false;\n        consumeEvent(event);\n        return true;\n    }\n    _onClick(event) {\n        if (this._mode === 'inspecting')\n            globalThis._playwrightRecorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : '');\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (this._actionInProgress(event))\n            return;\n        if (this._consumedDueToNoModel(event, this._hoveredModel))\n            return;\n        const checkbox = asCheckbox(this._deepEventTarget(event));\n        if (checkbox) {\n            // Interestingly, inputElement.checked is reversed inside this event handler.\n            this._performAction({\n                name: checkbox.checked ? 'check' : 'uncheck',\n                selector: this._hoveredModel.selector,\n                signals: [],\n            });\n            return;\n        }\n        this._performAction({\n            name: 'click',\n            selector: this._hoveredModel.selector,\n            signals: [],\n            button: buttonForEvent(event),\n            modifiers: modifiersForEvent(event),\n            clickCount: event.detail\n        });\n    }\n    _shouldIgnoreMouseEvent(event) {\n        const target = this._deepEventTarget(event);\n        if (this._mode === 'none')\n            return true;\n        if (this._mode === 'inspecting') {\n            consumeEvent(event);\n            return true;\n        }\n        const nodeName = target.nodeName;\n        if (nodeName === 'SELECT')\n            return true;\n        if (nodeName === 'INPUT' && ['date'].includes(target.type))\n            return true;\n        return false;\n    }\n    _onMouseDown(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (!this._performingAction)\n            consumeEvent(event);\n        this._activeModel = this._hoveredModel;\n    }\n    _onMouseUp(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (!this._performingAction)\n            consumeEvent(event);\n    }\n    _onMouseMove(event) {\n        if (this._mode === 'none')\n            return;\n        const target = this._deepEventTarget(event);\n        if (this._hoveredElement === target)\n            return;\n        this._hoveredElement = target;\n        this._updateModelForHoveredElement();\n    }\n    _onMouseLeave(event) {\n        // Leaving iframe.\n        if (this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n            this._hoveredElement = null;\n            this._updateModelForHoveredElement();\n        }\n    }\n    _onFocus() {\n        const activeElement = this._deepActiveElement(document);\n        const result = activeElement ? selectorGenerator_1.generateSelector(this._injectedScript, activeElement) : null;\n        this._activeModel = result && result.selector ? result : null;\n        if (this._params.isUnderTest)\n            console.error('Highlight updated for test: ' + (result ? result.selector : null));\n    }\n    _updateModelForHoveredElement() {\n        if (!this._hoveredElement) {\n            this._hoveredModel = null;\n            this._updateHighlight();\n            return;\n        }\n        const hoveredElement = this._hoveredElement;\n        const { selector, elements } = selectorGenerator_1.generateSelector(this._injectedScript, hoveredElement);\n        if ((this._hoveredModel && this._hoveredModel.selector === selector) || this._hoveredElement !== hoveredElement)\n            return;\n        this._hoveredModel = selector ? { selector, elements } : null;\n        this._updateHighlight();\n        if (this._params.isUnderTest)\n            console.error('Highlight updated for test: ' + selector);\n    }\n    _updateHighlight() {\n        const elements = this._hoveredModel ? this._hoveredModel.elements : [];\n        // Code below should trigger one layout and leave with the\n        // destroyed layout.\n        // Destroy the layout\n        this._tooltipElement.textContent = this._hoveredModel ? this._hoveredModel.selector : '';\n        this._tooltipElement.style.top = '0';\n        this._tooltipElement.style.left = '0';\n        this._tooltipElement.style.display = 'flex';\n        // Trigger layout.\n        const boxes = elements.map(e => e.getBoundingClientRect());\n        const tooltipWidth = this._tooltipElement.offsetWidth;\n        const tooltipHeight = this._tooltipElement.offsetHeight;\n        const totalWidth = this._innerGlassPaneElement.offsetWidth;\n        const totalHeight = this._innerGlassPaneElement.offsetHeight;\n        // Destroy the layout again.\n        if (boxes.length) {\n            const primaryBox = boxes[0];\n            let anchorLeft = primaryBox.left;\n            if (anchorLeft + tooltipWidth > totalWidth - 5)\n                anchorLeft = totalWidth - tooltipWidth - 5;\n            let anchorTop = primaryBox.bottom + 5;\n            if (anchorTop + tooltipHeight > totalHeight - 5) {\n                // If can't fit below, either position above...\n                if (primaryBox.top > tooltipHeight + 5) {\n                    anchorTop = primaryBox.top - tooltipHeight - 5;\n                }\n                else {\n                    // Or on top in case of large element\n                    anchorTop = totalHeight - 5 - tooltipHeight;\n                }\n            }\n            this._tooltipElement.style.top = anchorTop + 'px';\n            this._tooltipElement.style.left = anchorLeft + 'px';\n        }\n        else {\n            this._tooltipElement.style.display = 'none';\n        }\n        const pool = this._highlightElements;\n        this._highlightElements = [];\n        for (const box of boxes) {\n            const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n            const color = this._mode === 'recording' ? '#dc6f6f7f' : '#6fa8dc7f';\n            highlightElement.style.backgroundColor = this._highlightElements.length ? '#f6b26b7f' : color;\n            highlightElement.style.left = box.x + 'px';\n            highlightElement.style.top = box.y + 'px';\n            highlightElement.style.width = box.width + 'px';\n            highlightElement.style.height = box.height + 'px';\n            highlightElement.style.display = 'block';\n            this._highlightElements.push(highlightElement);\n        }\n        for (const highlightElement of pool) {\n            highlightElement.style.display = 'none';\n            this._highlightElements.push(highlightElement);\n        }\n    }\n    _createHighlightElement() {\n        const highlightElement = document.createElement('x-pw-highlight');\n        highlightElement.style.position = 'absolute';\n        highlightElement.style.top = '0';\n        highlightElement.style.left = '0';\n        highlightElement.style.width = '0';\n        highlightElement.style.height = '0';\n        highlightElement.style.boxSizing = 'border-box';\n        this._glassPaneShadow.appendChild(highlightElement);\n        return highlightElement;\n    }\n    _onInput(event) {\n        if (this._mode !== 'recording')\n            return true;\n        const target = this._deepEventTarget(event);\n        if (['INPUT', 'TEXTAREA'].includes(target.nodeName)) {\n            const inputElement = target;\n            const elementType = (inputElement.type || '').toLowerCase();\n            if (elementType === 'checkbox') {\n                // Checkbox is handled in click, we can't let input trigger on checkbox - that would mean we dispatched click events while recording.\n                return;\n            }\n            if (elementType === 'file') {\n                globalThis._playwrightRecorderRecordAction({\n                    name: 'setInputFiles',\n                    selector: this._activeModel.selector,\n                    signals: [],\n                    files: [...(inputElement.files || [])].map(file => file.name),\n                });\n                return;\n            }\n            // Non-navigating actions are simply recorded by Playwright.\n            if (this._consumedDueWrongTarget(event))\n                return;\n            globalThis._playwrightRecorderRecordAction({\n                name: 'fill',\n                selector: this._activeModel.selector,\n                signals: [],\n                text: inputElement.value,\n            });\n        }\n        if (target.nodeName === 'SELECT') {\n            const selectElement = target;\n            if (this._actionInProgress(event))\n                return;\n            this._performAction({\n                name: 'select',\n                selector: this._hoveredModel.selector,\n                options: [...selectElement.selectedOptions].map(option => option.value),\n                signals: []\n            });\n        }\n    }\n    _shouldGenerateKeyPressFor(event) {\n        // Backspace, Delete, AltGraph are changing input, will handle it there.\n        if (['Backspace', 'Delete', 'AltGraph'].includes(event.key))\n            return false;\n        // Ignore the QWERTZ shortcut for creating a at sign on MacOS\n        if (event.key === '@' && event.code === 'KeyL')\n            return false;\n        // Allow and ignore common used shortcut for pasting.\n        if (navigator.platform.includes('Mac')) {\n            if (event.key === 'v' && event.metaKey)\n                return false;\n        }\n        else {\n            if (event.key === 'v' && event.ctrlKey)\n                return false;\n            if (event.key === 'Insert' && event.shiftKey)\n                return false;\n        }\n        if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key))\n            return false;\n        const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n        if (event.key.length === 1 && !hasModifier)\n            return !!asCheckbox(this._deepEventTarget(event));\n        return true;\n    }\n    _onKeyDown(event) {\n        if (this._mode === 'inspecting') {\n            consumeEvent(event);\n            return;\n        }\n        if (this._mode !== 'recording')\n            return true;\n        if (!this._shouldGenerateKeyPressFor(event))\n            return;\n        if (this._actionInProgress(event)) {\n            this._expectProgrammaticKeyUp = true;\n            return;\n        }\n        if (this._consumedDueWrongTarget(event))\n            return;\n        // Similarly to click, trigger checkbox on key event, not input.\n        if (event.key === ' ') {\n            const checkbox = asCheckbox(this._deepEventTarget(event));\n            if (checkbox) {\n                this._performAction({\n                    name: checkbox.checked ? 'uncheck' : 'check',\n                    selector: this._activeModel.selector,\n                    signals: [],\n                });\n                return;\n            }\n        }\n        this._performAction({\n            name: 'press',\n            selector: this._activeModel.selector,\n            signals: [],\n            key: event.key,\n            modifiers: modifiersForEvent(event),\n        });\n    }\n    _onKeyUp(event) {\n        if (!this._shouldGenerateKeyPressFor(event))\n            return;\n        // Only allow programmatic keyups, ignore user input.\n        if (!this._expectProgrammaticKeyUp) {\n            consumeEvent(event);\n            return;\n        }\n        this._expectProgrammaticKeyUp = false;\n    }\n    async _performAction(action) {\n        this._performingAction = true;\n        await globalThis._playwrightRecorderPerformAction(action).catch(() => { });\n        this._performingAction = false;\n        // Action could have changed DOM, update hovered model selectors.\n        this._updateModelForHoveredElement();\n        // If that was a keyboard action, it similarly requires new selectors for active model.\n        this._onFocus();\n        if (this._params.isUnderTest) {\n            // Serialize all to string as we cannot attribute console message to isolated world\n            // in Firefox.\n            console.error('Action performed for test: ' + JSON.stringify({\n                hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n                active: this._activeModel ? this._activeModel.selector : null,\n            }));\n        }\n    }\n    _deepEventTarget(event) {\n        return event.composedPath()[0];\n    }\n    _deepActiveElement(document) {\n        let activeElement = document.activeElement;\n        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n            activeElement = activeElement.shadowRoot.activeElement;\n        return activeElement;\n    }\n}\nexports.Recorder = Recorder;\nfunction modifiersForEvent(event) {\n    return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n    switch (event.which) {\n        case 1: return 'left';\n        case 2: return 'middle';\n        case 3: return 'right';\n    }\n    return 'left';\n}\nfunction consumeEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n    if (!node || node.nodeName !== 'INPUT')\n        return null;\n    const inputElement = node;\n    return inputElement.type === 'checkbox' ? inputElement : null;\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n    target.addEventListener(eventName, listener, useCapture);\n    const remove = () => {\n        target.removeEventListener(eventName, listener, useCapture);\n    };\n    return remove;\n}\nfunction removeEventListeners(listeners) {\n    for (const listener of listeners)\n        listener();\n    listeners.splice(0, listeners.length);\n}\nexports.default = Recorder;\n\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/selectorGenerator.ts\":\n/*!**************************************************************!*\\\n  !*** ./src/server/supplements/injected/selectorGenerator.ts ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSelector = exports.querySelector = void 0;\nconst selectorEvaluator_1 = __nccwpck_require__(/*! ../../injected/selectorEvaluator */ \"./src/server/injected/selectorEvaluator.ts\");\nconst cacheAllowText = new Map();\nconst cacheDisallowText = new Map();\nfunction querySelector(injectedScript, selector, ownerDocument) {\n    try {\n        const parsedSelector = injectedScript.parseSelector(selector);\n        return {\n            selector,\n            elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n        };\n    }\n    catch (e) {\n        return {\n            selector,\n            elements: [],\n        };\n    }\n}\nexports.querySelector = querySelector;\nfunction generateSelector(injectedScript, targetElement) {\n    injectedScript._evaluator.begin();\n    try {\n        targetElement = targetElement.closest('button,select,input,[role=button],[role=checkbox],[role=radio]') || targetElement;\n        const targetTokens = generateSelectorFor(injectedScript, targetElement);\n        const bestTokens = targetTokens || [cssFallback(injectedScript, targetElement)];\n        const selector = joinTokens(bestTokens);\n        const parsedSelector = injectedScript.parseSelector(selector);\n        return {\n            selector,\n            elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n        };\n    }\n    finally {\n        cacheAllowText.clear();\n        cacheDisallowText.clear();\n        injectedScript._evaluator.end();\n    }\n}\nexports.generateSelector = generateSelector;\nfunction filterRegexTokens(textCandidates) {\n    // Filter out regex-based selectors for better performance.\n    return textCandidates.filter(c => c[0].selector[0] !== '/');\n}\nfunction generateSelectorFor(injectedScript, targetElement) {\n    if (targetElement.ownerDocument.documentElement === targetElement)\n        return [{ engine: 'css', selector: 'html', score: 1 }];\n    const calculate = (element, allowText) => {\n        const allowNthMatch = element === targetElement;\n        let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map(token => [token]) : [];\n        if (element !== targetElement) {\n            // Do not use regex for parent elements (for performance).\n            textCandidates = filterRegexTokens(textCandidates);\n        }\n        const noTextCandidates = buildCandidates(injectedScript, element).map(token => [token]);\n        // First check all text and non-text candidates for the element.\n        let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n        // Do not use regex for chained selectors (for performance).\n        textCandidates = filterRegexTokens(textCandidates);\n        const checkWithText = (textCandidatesToUse) => {\n            // Use the deepest possible text selector - works pretty good and saves on compute time.\n            const allowParentText = allowText && !textCandidatesToUse.length;\n            const candidates = [...textCandidatesToUse, ...noTextCandidates].filter(c => {\n                if (!result)\n                    return true;\n                return combineScores(c) < combineScores(result);\n            });\n            // This is best theoretically possible candidate from the current parent.\n            // We use the fact that widening the scope to grand-parent makes any selector\n            // even less likely to match.\n            let bestPossibleInParent = candidates[0];\n            if (!bestPossibleInParent)\n                return;\n            for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n                const parentTokens = calculateCached(parent, allowParentText);\n                if (!parentTokens)\n                    continue;\n                // Even the best selector won't be too good - skip this parent.\n                if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n                    continue;\n                // Update the best candidate that finds \"element\" in the \"parent\".\n                bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n                if (!bestPossibleInParent)\n                    return;\n                const combined = [...parentTokens, ...bestPossibleInParent];\n                if (!result || combineScores(combined) < combineScores(result))\n                    result = combined;\n            }\n        };\n        checkWithText(textCandidates);\n        // Allow skipping text on the target element, and using text on one of the parents.\n        if (element === targetElement && textCandidates.length)\n            checkWithText([]);\n        return result;\n    };\n    const calculateCached = (element, allowText) => {\n        const cache = allowText ? cacheAllowText : cacheDisallowText;\n        let value = cache.get(element);\n        if (value === undefined) {\n            value = calculate(element, allowText);\n            cache.set(element, value);\n        }\n        return value;\n    };\n    return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n    const candidates = [];\n    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {\n        if (element.hasAttribute(attribute))\n            candidates.push({ engine: 'css', selector: `[${attribute}=${quoteString(element.getAttribute(attribute))}]`, score: 1 });\n    }\n    if (element.nodeName === 'INPUT') {\n        const input = element;\n        if (input.placeholder)\n            candidates.push({ engine: 'css', selector: `[placeholder=${quoteString(input.placeholder)}]`, score: 10 });\n    }\n    if (element.hasAttribute('aria-label'))\n        candidates.push({ engine: 'css', selector: `[aria-label=${quoteString(element.getAttribute('aria-label'))}]`, score: 10 });\n    if (element.getAttribute('alt') && ['APPLET', 'AREA', 'IMG', 'INPUT'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[alt=${quoteString(element.getAttribute('alt'))}]`, score: 10 });\n    if (element.hasAttribute('role'))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLocaleLowerCase()}[role=${quoteString(element.getAttribute('role'))}]`, score: 50 });\n    if (element.getAttribute('name') && ['BUTTON', 'FORM', 'FIELDSET', 'IFRAME', 'INPUT', 'KEYGEN', 'OBJECT', 'OUTPUT', 'SELECT', 'TEXTAREA', 'MAP', 'META', 'PARAM'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[name=${quoteString(element.getAttribute('name'))}]`, score: 50 });\n    if (['INPUT', 'TEXTAREA'].includes(element.nodeName) && element.getAttribute('type') !== 'hidden') {\n        if (element.getAttribute('type'))\n            candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[type=${quoteString(element.getAttribute('type'))}]`, score: 50 });\n    }\n    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: element.nodeName.toLowerCase(), score: 50 });\n    const idAttr = element.getAttribute('id');\n    if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: 'css', selector: makeSelectorForId(idAttr), score: 100 });\n    candidates.push({ engine: 'css', selector: element.nodeName.toLocaleLowerCase(), score: 200 });\n    return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n    if (element.nodeName === 'SELECT')\n        return [];\n    const text = selectorEvaluator_1.elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, ' ').substring(0, 80);\n    if (!text)\n        return [];\n    const candidates = [];\n    let escaped = text;\n    if (text.includes('\"') || text.includes('>>') || text[0] === '/')\n        escaped = `/.*${escapeForRegex(text)}.*/`;\n    candidates.push({ engine: 'text', selector: escaped, score: 10 });\n    if (allowHasText && escaped === text) {\n        let prefix = element.nodeName.toLocaleLowerCase();\n        if (element.hasAttribute('role'))\n            prefix += `[role=${quoteString(element.getAttribute('role'))}]`;\n        candidates.push({ engine: 'css', selector: `${prefix}:has-text(\"${text}\")`, score: 30 });\n    }\n    return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return null;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n    return null;\n}\nfunction makeSelectorForId(id) {\n    return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? '#' + id : `[id=\"${id}\"]`;\n}\nfunction cssFallback(injectedScript, targetElement) {\n    const kFallbackScore = 10000000;\n    const root = targetElement.ownerDocument;\n    const tokens = [];\n    function uniqueCSSSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        const selector = path.join(' ');\n        const parsedSelector = injectedScript.parseSelector(selector);\n        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);\n        return node === targetElement ? selector : undefined;\n    }\n    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n        const nodeName = element.nodeName.toLowerCase();\n        // Element ID is the strongest signal, use it.\n        let bestTokenForLevel = '';\n        if (element.id) {\n            const token = makeSelectorForId(element.id);\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            bestTokenForLevel = token;\n        }\n        const parent = element.parentNode;\n        // Combine class names until unique.\n        const classes = [...element.classList];\n        for (let i = 0; i < classes.length; ++i) {\n            const token = '.' + classes.slice(0, i + 1).join('.');\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            // Even if not unique, does this subset of classes uniquely identify node as a child?\n            if (!bestTokenForLevel && parent) {\n                const sameClassSiblings = parent.querySelectorAll(token);\n                if (sameClassSiblings.length === 1)\n                    bestTokenForLevel = token;\n            }\n        }\n        // Ordinal is the weakest signal.\n        if (parent) {\n            const siblings = [...parent.children];\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            if (!bestTokenForLevel)\n                bestTokenForLevel = token;\n        }\n        else if (!bestTokenForLevel) {\n            bestTokenForLevel = nodeName;\n        }\n        tokens.unshift(bestTokenForLevel);\n    }\n    return { engine: 'css', selector: uniqueCSSSelector(), score: kFallbackScore };\n}\nfunction escapeForRegex(text) {\n    return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction quoteString(text) {\n    return `\"${text.replaceAll(/\"/g, '\\\\\"').replaceAll(/\\n/g, '\\\\n')}\"`;\n}\nfunction joinTokens(tokens) {\n    const parts = [];\n    let lastEngine = '';\n    for (const { engine, selector } of tokens) {\n        if (parts.length && (lastEngine !== 'css' || engine !== 'css' || selector.startsWith(':nth-match(')))\n            parts.push('>>');\n        lastEngine = engine;\n        if (engine === 'css')\n            parts.push(selector);\n        else\n            parts.push(`${engine}=${selector}`);\n    }\n    return parts.join(' ');\n}\nfunction combineScores(tokens) {\n    let score = 0;\n    for (let i = 0; i < tokens.length; i++)\n        score += tokens[i].score * (tokens.length - i);\n    return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n    const joined = selectors.map(tokens => ({ tokens, score: combineScores(tokens) }));\n    joined.sort((a, b) => a.score - b.score);\n    let bestWithIndex = null;\n    for (const { tokens } of joined) {\n        const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n        const result = injectedScript.querySelectorAll(parsedSelector, scope);\n        const index = result.indexOf(targetElement);\n        if (index === 0) {\n            // We are the first match - found the best selector.\n            return tokens;\n        }\n        // Otherwise, perhaps we can get nth-match?\n        if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n            continue;\n        // To use nth-match, we must convert everything to css.\n        const allCss = tokens.map(token => {\n            if (token.engine !== 'text')\n                return token;\n            if (token.selector.startsWith('/') && token.selector.endsWith('/'))\n                return { engine: 'css', selector: `:text-matches(\"${token.selector.substring(1, token.selector.length - 1)}\")`, score: token.score };\n            return { engine: 'css', selector: `:text(\"${token.selector}\")`, score: token.score };\n        });\n        const combined = joinTokens(allCss);\n        bestWithIndex = [{ engine: 'css', selector: `:nth-match(${combined}, ${index + 1})`, score: combineScores(allCss) + 1000 }];\n    }\n    return bestWithIndex;\n}\nfunction isGuidLike(id) {\n    let lastCharacterType;\n    let transitionCount = 0;\n    for (let i = 0; i < id.length; ++i) {\n        const c = id[i];\n        let characterType;\n        if (c === '-' || c === '_')\n            continue;\n        if (c >= 'a' && c <= 'z')\n            characterType = 'lower';\n        else if (c >= 'A' && c <= 'Z')\n            characterType = 'upper';\n        else if (c >= '0' && c <= '9')\n            characterType = 'digit';\n        else\n            characterType = 'other';\n        if (characterType === 'lower' && lastCharacterType === 'upper') {\n            lastCharacterType = characterType;\n            continue;\n        }\n        if (lastCharacterType && lastCharacterType !== characterType)\n            ++transitionCount;\n        lastCharacterType = characterType;\n    }\n    return transitionCount >= id.length / 4;\n}\n\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=recorderSource.js.map

/***/ }),

/***/ 6507:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nccwpck_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nccwpck_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nccwpck_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nccwpck_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nccwpck_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nccwpck_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nccwpck_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nccwpck_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nccwpck_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nccwpck_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nccwpck_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nccwpck_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nccwpck_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(__nccwpck_require__.s = \"./src/server/injected/utilityScript.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/utilityScriptSerializers.ts\":\n/*!*******************************************************!*\\\n  !*** ./src/server/common/utilityScriptSerializers.ts ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeAsCallArgument = exports.parseEvaluationResultValue = void 0;\nfunction isRegExp(obj) {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nfunction isDate(obj) {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';\n}\nfunction isError(obj) {\n    return obj instanceof Error || (obj && obj.__proto__ && obj.__proto__.name === 'Error');\n}\nfunction parseEvaluationResultValue(value, handles = []) {\n    if (Object.is(value, undefined))\n        return undefined;\n    if (typeof value === 'object' && value) {\n        if ('v' in value) {\n            if (value.v === 'undefined')\n                return undefined;\n            if (value.v === 'null')\n                return null;\n            if (value.v === 'NaN')\n                return NaN;\n            if (value.v === 'Infinity')\n                return Infinity;\n            if (value.v === '-Infinity')\n                return -Infinity;\n            if (value.v === '-0')\n                return -0;\n            return undefined;\n        }\n        if ('d' in value)\n            return new Date(value.d);\n        if ('r' in value)\n            return new RegExp(value.r.p, value.r.f);\n        if ('a' in value)\n            return value.a.map((a) => parseEvaluationResultValue(a, handles));\n        if ('o' in value) {\n            const result = {};\n            for (const { k, v } of value.o)\n                result[k] = parseEvaluationResultValue(v, handles);\n            return result;\n        }\n        if ('h' in value)\n            return handles[value.h];\n    }\n    return value;\n}\nexports.parseEvaluationResultValue = parseEvaluationResultValue;\nfunction serializeAsCallArgument(value, handleSerializer) {\n    return serialize(value, handleSerializer, new Set());\n}\nexports.serializeAsCallArgument = serializeAsCallArgument;\nfunction serialize(value, handleSerializer, visited) {\n    const result = handleSerializer(value);\n    if ('fallThrough' in result)\n        value = result.fallThrough;\n    else\n        return result;\n    if (visited.has(value))\n        throw new Error('Argument is a circular structure');\n    if (typeof value === 'symbol')\n        return { v: 'undefined' };\n    if (Object.is(value, undefined))\n        return { v: 'undefined' };\n    if (Object.is(value, null))\n        return { v: 'null' };\n    if (Object.is(value, NaN))\n        return { v: 'NaN' };\n    if (Object.is(value, Infinity))\n        return { v: 'Infinity' };\n    if (Object.is(value, -Infinity))\n        return { v: '-Infinity' };\n    if (Object.is(value, -0))\n        return { v: '-0' };\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return value;\n    if (isError(value)) {\n        const error = value;\n        if ('captureStackTrace' in global.Error) {\n            // v8\n            return error.stack || '';\n        }\n        return `${error.name}: ${error.message}\\n${error.stack}`;\n    }\n    if (isDate(value))\n        return { d: value.toJSON() };\n    if (isRegExp(value))\n        return { r: { p: value.source, f: value.flags } };\n    if (Array.isArray(value)) {\n        const a = [];\n        visited.add(value);\n        for (let i = 0; i < value.length; ++i)\n            a.push(serialize(value[i], handleSerializer, visited));\n        visited.delete(value);\n        return { a };\n    }\n    if (typeof value === 'object') {\n        const o = [];\n        visited.add(value);\n        for (const name of Object.keys(value)) {\n            let item;\n            try {\n                item = value[name];\n            }\n            catch (e) {\n                continue; // native bindings will throw sometimes\n            }\n            if (name === 'toJSON' && typeof item === 'function')\n                o.push({ k: name, v: { o: [] } });\n            else\n                o.push({ k: name, v: serialize(item, handleSerializer, visited) });\n        }\n        visited.delete(value);\n        return { o };\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __nccwpck_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./src/server/injected/utilityScript.ts\":\n/*!**********************************************!*\\\n  !*** ./src/server/injected/utilityScript.ts ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nccwpck_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilityScriptSerializers_1 = __nccwpck_require__(/*! ../common/utilityScriptSerializers */ \"./src/server/common/utilityScriptSerializers.ts\");\nclass UtilityScript {\n    evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n        const args = argsAndHandles.slice(0, argCount);\n        const handles = argsAndHandles.slice(argCount);\n        const parameters = args.map(a => utilityScriptSerializers_1.parseEvaluationResultValue(a, handles));\n        let result = global.eval(expression);\n        if (isFunction === true) {\n            result = result(...parameters);\n        }\n        else if (isFunction === false) {\n            result = result;\n        }\n        else {\n            // auto detect.\n            if (typeof result === 'function')\n                result = result(...parameters);\n        }\n        return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n    }\n    jsonValue(returnByValue, value) {\n        // Special handling of undefined to work-around multi-step returnByValue handling in WebKit.\n        if (Object.is(value, undefined))\n            return undefined;\n        return utilityScriptSerializers_1.serializeAsCallArgument(value, (value) => ({ fallThrough: value }));\n    }\n    _promiseAwareJsonValueNoThrow(value) {\n        const safeJson = (value) => {\n            try {\n                return this.jsonValue(true, value);\n            }\n            catch (e) {\n                return undefined;\n            }\n        };\n        if (value && typeof value === 'object' && typeof value.then === 'function') {\n            return (async () => {\n                // By using async function we ensure that return value is a native Promise,\n                // and not some overridden Promise in the page.\n                // This makes Firefox and WebKit debugging protocols recognize it as a Promise,\n                // properly await and return the value.\n                const promiseValue = await value;\n                return safeJson(promiseValue);\n            })();\n        }\n        return safeJson(value);\n    }\n}\nexports.default = UtilityScript;\n\n/* WEBPACK VAR INJECTION */}.call(this, __nccwpck_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=utilityScriptSource.js.map

/***/ }),

/***/ 8842:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dispatcher_1 = __nccwpck_require__(5031);
const playwright_1 = __nccwpck_require__(8508);
const playwrightDispatcher_1 = __nccwpck_require__(930);
const connection_1 = __nccwpck_require__(4466);
const browserServerImpl_1 = __nccwpck_require__(3483);
function setupInProcess() {
    const playwright = playwright_1.createPlaywright();
    const clientConnection = new connection_1.Connection();
    const dispatcherConnection = new dispatcher_1.DispatcherConnection();
    // Dispatch synchronously at first.
    dispatcherConnection.onmessage = message => clientConnection.dispatch(message);
    clientConnection.onmessage = message => dispatcherConnection.dispatch(message);
    // Initialize Playwright channel.
    new playwrightDispatcher_1.PlaywrightDispatcher(dispatcherConnection.rootDispatcher(), playwright);
    const playwrightAPI = clientConnection.getObjectWithKnownName('Playwright');
    playwrightAPI.chromium._serverLauncher = new browserServerImpl_1.BrowserServerLauncherImpl('chromium');
    playwrightAPI.firefox._serverLauncher = new browserServerImpl_1.BrowserServerLauncherImpl('firefox');
    playwrightAPI.webkit._serverLauncher = new browserServerImpl_1.BrowserServerLauncherImpl('webkit');
    // Switch to async dispatch after we got Playwright object.
    dispatcherConnection.onmessage = message => setImmediate(() => clientConnection.dispatch(message));
    clientConnection.onmessage = message => setImmediate(() => dispatcherConnection.dispatch(message));
    playwrightAPI._toImpl = (x) => dispatcherConnection._dispatchers.get(x._guid)._object;
    return playwrightAPI;
}
module.exports = setupInProcess();
//# sourceMappingURL=inprocess.js.map

/***/ }),

/***/ 9546:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeValue = exports.parseSerializedValue = exports.parseError = exports.serializeError = void 0;
const errors_1 = __nccwpck_require__(4949);
function serializeError(e) {
    if (isError(e))
        return { error: { message: e.message, stack: e.stack, name: e.name } };
    return { value: serializeValue(e, value => ({ fallThrough: value }), new Set()) };
}
exports.serializeError = serializeError;
function parseError(error) {
    if (!error.error) {
        if (error.value === undefined)
            throw new Error('Serialized error must have either an error or a value');
        return parseSerializedValue(error.value, undefined);
    }
    if (error.error.name === 'TimeoutError') {
        const e = new errors_1.TimeoutError(error.error.message);
        e.stack = error.error.stack || '';
        return e;
    }
    const e = new Error(error.error.message);
    e.stack = error.error.stack || '';
    e.name = error.error.name;
    return e;
}
exports.parseError = parseError;
function parseSerializedValue(value, handles) {
    if (value.n !== undefined)
        return value.n;
    if (value.s !== undefined)
        return value.s;
    if (value.b !== undefined)
        return value.b;
    if (value.v !== undefined) {
        if (value.v === 'undefined')
            return undefined;
        if (value.v === 'null')
            return null;
        if (value.v === 'NaN')
            return NaN;
        if (value.v === 'Infinity')
            return Infinity;
        if (value.v === '-Infinity')
            return -Infinity;
        if (value.v === '-0')
            return -0;
    }
    if (value.d !== undefined)
        return new Date(value.d);
    if (value.r !== undefined)
        return new RegExp(value.r.p, value.r.f);
    if (value.a !== undefined)
        return value.a.map((a) => parseSerializedValue(a, handles));
    if (value.o !== undefined) {
        const result = {};
        for (const { k, v } of value.o)
            result[k] = parseSerializedValue(v, handles);
        return result;
    }
    if (value.h !== undefined) {
        if (handles === undefined)
            throw new Error('Unexpected handle');
        return handles[value.h];
    }
    throw new Error('Unexpected value');
}
exports.parseSerializedValue = parseSerializedValue;
function serializeValue(value, handleSerializer, visited) {
    const handle = handleSerializer(value);
    if ('fallThrough' in handle)
        value = handle.fallThrough;
    else
        return handle;
    if (visited.has(value))
        throw new Error('Argument is a circular structure');
    if (typeof value === 'symbol')
        return { v: 'undefined' };
    if (Object.is(value, undefined))
        return { v: 'undefined' };
    if (Object.is(value, null))
        return { v: 'null' };
    if (Object.is(value, NaN))
        return { v: 'NaN' };
    if (Object.is(value, Infinity))
        return { v: 'Infinity' };
    if (Object.is(value, -Infinity))
        return { v: '-Infinity' };
    if (Object.is(value, -0))
        return { v: '-0' };
    if (typeof value === 'boolean')
        return { b: value };
    if (typeof value === 'number')
        return { n: value };
    if (typeof value === 'string')
        return { s: value };
    if (isError(value)) {
        const error = value;
        if ('captureStackTrace' in global.Error) {
            // v8
            return { s: error.stack || '' };
        }
        return { s: `${error.name}: ${error.message}\n${error.stack}` };
    }
    if (isDate(value))
        return { d: value.toJSON() };
    if (isRegExp(value))
        return { r: { p: value.source, f: value.flags } };
    if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
            a.push(serializeValue(value[i], handleSerializer, visited));
        visited.delete(value);
        return { a };
    }
    if (typeof value === 'object') {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value))
            o.push({ k: name, v: serializeValue(value[name], handleSerializer, visited) });
        visited.delete(value);
        return { o };
    }
    throw new Error('Unexpected value');
}
exports.serializeValue = serializeValue;
function isRegExp(obj) {
    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
}
function isDate(obj) {
    return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
}
function isError(obj) {
    return obj instanceof Error || (obj && obj.__proto__ && obj.__proto__.name === 'Error');
}
//# sourceMappingURL=serializers.js.map

/***/ }),

/***/ 3481:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transport = void 0;
const utils_1 = __nccwpck_require__(6416);
class Transport {
    constructor(pipeWrite, pipeRead, closeable, endian = 'le') {
        this._data = Buffer.from([]);
        this._waitForNextTask = utils_1.makeWaitForNextTask();
        this._closed = false;
        this._bytesLeft = 0;
        this._pipeWrite = pipeWrite;
        this._endian = endian;
        this._closeableStream = closeable;
        pipeRead.on('data', buffer => this._dispatch(buffer));
        pipeRead.on('close', () => {
            this._closed = true;
            if (this.onclose)
                this.onclose();
        });
        this.onmessage = undefined;
        this.onclose = undefined;
    }
    send(message) {
        if (this._closed)
            throw new Error('Pipe has been closed');
        const data = Buffer.from(message, 'utf-8');
        const dataLength = Buffer.alloc(4);
        if (this._endian === 'be')
            dataLength.writeUInt32BE(data.length, 0);
        else
            dataLength.writeUInt32LE(data.length, 0);
        this._pipeWrite.write(dataLength);
        this._pipeWrite.write(data);
    }
    close() {
        // Let it throw.
        this._closeableStream.close();
    }
    _dispatch(buffer) {
        this._data = Buffer.concat([this._data, buffer]);
        while (true) {
            if (!this._bytesLeft && this._data.length < 4) {
                // Need more data.
                break;
            }
            if (!this._bytesLeft) {
                this._bytesLeft = this._endian === 'be' ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
                this._data = this._data.slice(4);
            }
            if (!this._bytesLeft || this._data.length < this._bytesLeft) {
                // Need more data.
                break;
            }
            const message = this._data.slice(0, this._bytesLeft);
            this._data = this._data.slice(this._bytesLeft);
            this._bytesLeft = 0;
            this._waitForNextTask(() => {
                if (this.onmessage)
                    this.onmessage(message.toString('utf-8'));
            });
        }
    }
}
exports.Transport = Transport;
//# sourceMappingURL=transport.js.map

/***/ }),

/***/ 6423:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createScheme = exports.ValidationError = void 0;
// This file is generated by generate_channels.js, do not edit manually.
const validatorPrimitives_1 = __nccwpck_require__(5814);
var validatorPrimitives_2 = __nccwpck_require__(5814);
Object.defineProperty(exports, "ValidationError", ({ enumerable: true, get: function () { return validatorPrimitives_2.ValidationError; } }));
function createScheme(tChannel) {
    const scheme = {};
    const tType = (name) => {
        return (arg, path) => {
            const v = scheme[name];
            if (!v)
                throw new validatorPrimitives_1.ValidationError(path + ': unknown type "' + name + '"');
            return v(arg, path);
        };
    };
    scheme.StackFrame = validatorPrimitives_1.tObject({
        file: validatorPrimitives_1.tString,
        line: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        column: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        function: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.Metadata = validatorPrimitives_1.tObject({
        stack: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('StackFrame'))),
        apiName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.WaitForEventInfo = validatorPrimitives_1.tObject({
        waitId: validatorPrimitives_1.tString,
        phase: validatorPrimitives_1.tEnum(['before', 'after', 'log']),
        apiName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        message: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        error: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.Point = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
    });
    scheme.Rect = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
        width: validatorPrimitives_1.tNumber,
        height: validatorPrimitives_1.tNumber,
    });
    scheme.SerializedValue = validatorPrimitives_1.tObject({
        n: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        b: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        s: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        v: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['null', 'undefined', 'NaN', 'Infinity', '-Infinity', '-0'])),
        d: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        r: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            p: validatorPrimitives_1.tString,
            f: validatorPrimitives_1.tString,
        })),
        a: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('SerializedValue'))),
        o: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
            k: validatorPrimitives_1.tString,
            v: tType('SerializedValue'),
        }))),
        h: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.SerializedArgument = validatorPrimitives_1.tObject({
        value: tType('SerializedValue'),
        handles: validatorPrimitives_1.tArray(tChannel('*')),
    });
    scheme.AXNode = validatorPrimitives_1.tObject({
        role: validatorPrimitives_1.tString,
        name: validatorPrimitives_1.tString,
        valueString: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        valueNumber: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        description: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        keyshortcuts: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        roledescription: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        valuetext: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        disabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        expanded: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        focused: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modal: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        multiline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        multiselectable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        readonly: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        required: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        selected: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        checked: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['checked', 'unchecked', 'mixed'])),
        pressed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['pressed', 'released', 'mixed'])),
        level: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        valuemin: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        valuemax: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        autocomplete: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        haspopup: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        invalid: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        orientation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        children: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('AXNode'))),
    });
    scheme.SetNetworkCookie = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        domain: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        path: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        expires: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        httpOnly: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        secure: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        sameSite: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['Strict', 'Lax', 'None'])),
    });
    scheme.NetworkCookie = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
        domain: validatorPrimitives_1.tString,
        path: validatorPrimitives_1.tString,
        expires: validatorPrimitives_1.tNumber,
        httpOnly: validatorPrimitives_1.tBoolean,
        secure: validatorPrimitives_1.tBoolean,
        sameSite: validatorPrimitives_1.tEnum(['Strict', 'Lax', 'None']),
    });
    scheme.NameValue = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
    });
    scheme.OriginStorage = validatorPrimitives_1.tObject({
        origin: validatorPrimitives_1.tString,
        localStorage: validatorPrimitives_1.tArray(tType('NameValue')),
    });
    scheme.SerializedError = validatorPrimitives_1.tObject({
        error: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            message: validatorPrimitives_1.tString,
            name: validatorPrimitives_1.tString,
            stack: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        })),
        value: validatorPrimitives_1.tOptional(tType('SerializedValue')),
    });
    scheme.PlaywrightSetForwardedPortsParams = validatorPrimitives_1.tObject({
        ports: validatorPrimitives_1.tArray(validatorPrimitives_1.tNumber),
    });
    scheme.SelectorsRegisterParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        source: validatorPrimitives_1.tString,
        contentScript: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.BrowserTypeLaunchParams = validatorPrimitives_1.tObject({
        channel: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        executablePath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        ignoreAllDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        ignoreDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        handleSIGINT: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGTERM: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGHUP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        env: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        headless: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        devtools: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            server: validatorPrimitives_1.tString,
            bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        })),
        downloadsPath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        tracesDir: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        chromiumSandbox: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        firefoxUserPrefs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
        slowMo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.BrowserTypeLaunchPersistentContextParams = validatorPrimitives_1.tObject({
        channel: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        executablePath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        ignoreAllDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        ignoreDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        handleSIGINT: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGTERM: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGHUP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        env: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        headless: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        devtools: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            server: validatorPrimitives_1.tString,
            bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        })),
        downloadsPath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        tracesDir: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        chromiumSandbox: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        sdkLanguage: validatorPrimitives_1.tString,
        noDefaultViewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        viewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber,
        })),
        screen: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber,
        })),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        javaScriptEnabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        userAgent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            longitude: validatorPrimitives_1.tNumber,
            latitude: validatorPrimitives_1.tNumber,
            accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        })),
        permissions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            username: validatorPrimitives_1.tString,
            password: validatorPrimitives_1.tString,
        })),
        deviceScaleFactor: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        isMobile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasTouch: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['dark', 'light', 'no-preference'])),
        reducedMotion: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['reduce', 'no-preference'])),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        _debugName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            dir: validatorPrimitives_1.tString,
            size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
                width: validatorPrimitives_1.tNumber,
                height: validatorPrimitives_1.tNumber,
            })),
        })),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
            path: validatorPrimitives_1.tString,
        })),
        userDataDir: validatorPrimitives_1.tString,
        slowMo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.BrowserTypeConnectOverCDPParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        endpointURL: validatorPrimitives_1.tString,
        headers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        slowMo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.BrowserCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserKillForTestsParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserNewContextParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        noDefaultViewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        viewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber,
        })),
        screen: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber,
        })),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        javaScriptEnabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        userAgent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            longitude: validatorPrimitives_1.tNumber,
            latitude: validatorPrimitives_1.tNumber,
            accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        })),
        permissions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            username: validatorPrimitives_1.tString,
            password: validatorPrimitives_1.tString,
        })),
        deviceScaleFactor: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        isMobile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasTouch: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['dark', 'light', 'no-preference'])),
        reducedMotion: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['reduce', 'no-preference'])),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        _debugName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            dir: validatorPrimitives_1.tString,
            size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
                width: validatorPrimitives_1.tNumber,
                height: validatorPrimitives_1.tNumber,
            })),
        })),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
            path: validatorPrimitives_1.tString,
        })),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            server: validatorPrimitives_1.tString,
            bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        })),
        storageState: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            cookies: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('SetNetworkCookie'))),
            origins: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('OriginStorage'))),
        })),
    });
    scheme.BrowserNewBrowserCDPSessionParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserStartTracingParams = validatorPrimitives_1.tObject({
        page: validatorPrimitives_1.tOptional(tChannel('Page')),
        path: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        screenshots: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        categories: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
    });
    scheme.BrowserStopTracingParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextAddCookiesParams = validatorPrimitives_1.tObject({
        cookies: validatorPrimitives_1.tArray(tType('SetNetworkCookie')),
    });
    scheme.BrowserContextAddInitScriptParams = validatorPrimitives_1.tObject({
        source: validatorPrimitives_1.tString,
    });
    scheme.BrowserContextClearCookiesParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextClearPermissionsParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextCookiesParams = validatorPrimitives_1.tObject({
        urls: validatorPrimitives_1.tArray(validatorPrimitives_1.tString),
    });
    scheme.BrowserContextExposeBindingParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        needsHandle: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.BrowserContextGrantPermissionsParams = validatorPrimitives_1.tObject({
        permissions: validatorPrimitives_1.tArray(validatorPrimitives_1.tString),
        origin: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.BrowserContextNewPageParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber,
    });
    scheme.BrowserContextSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber,
    });
    scheme.BrowserContextSetExtraHTTPHeadersParams = validatorPrimitives_1.tObject({
        headers: validatorPrimitives_1.tArray(tType('NameValue')),
    });
    scheme.BrowserContextSetGeolocationParams = validatorPrimitives_1.tObject({
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            longitude: validatorPrimitives_1.tNumber,
            latitude: validatorPrimitives_1.tNumber,
            accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        })),
    });
    scheme.BrowserContextSetHTTPCredentialsParams = validatorPrimitives_1.tObject({
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            username: validatorPrimitives_1.tString,
            password: validatorPrimitives_1.tString,
        })),
    });
    scheme.BrowserContextSetNetworkInterceptionEnabledParams = validatorPrimitives_1.tObject({
        enabled: validatorPrimitives_1.tBoolean,
    });
    scheme.BrowserContextSetOfflineParams = validatorPrimitives_1.tObject({
        offline: validatorPrimitives_1.tBoolean,
    });
    scheme.BrowserContextStorageStateParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextPauseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextRecorderSupplementEnableParams = validatorPrimitives_1.tObject({
        language: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        startRecording: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        pauseOnNextStatement: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        launchOptions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
        contextOptions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
        device: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        saveStorage: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        outputFile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.BrowserContextNewCDPSessionParams = validatorPrimitives_1.tObject({
        page: tChannel('Page'),
    });
    scheme.BrowserContextTracingStartParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        snapshots: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        screenshots: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.BrowserContextTracingStopParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BrowserContextTracingExportParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.PageSetDefaultNavigationTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber,
    });
    scheme.PageSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber,
    });
    scheme.PageSetFileChooserInterceptedNoReplyParams = validatorPrimitives_1.tObject({
        intercepted: validatorPrimitives_1.tBoolean,
    });
    scheme.PageAddInitScriptParams = validatorPrimitives_1.tObject({
        source: validatorPrimitives_1.tString,
    });
    scheme.PageCloseParams = validatorPrimitives_1.tObject({
        runBeforeUnload: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.PageEmulateMediaParams = validatorPrimitives_1.tObject({
        media: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['screen', 'print', 'null'])),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['dark', 'light', 'no-preference', 'null'])),
        reducedMotion: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['reduce', 'no-preference', 'null'])),
    });
    scheme.PageExposeBindingParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        needsHandle: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.PageGoBackParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['load', 'domcontentloaded', 'networkidle'])),
    });
    scheme.PageGoForwardParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['load', 'domcontentloaded', 'networkidle'])),
    });
    scheme.PageReloadParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['load', 'domcontentloaded', 'networkidle'])),
    });
    scheme.PageScreenshotParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        type: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['png', 'jpeg'])),
        quality: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        omitBackground: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        fullPage: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        clip: validatorPrimitives_1.tOptional(tType('Rect')),
    });
    scheme.PageSetExtraHTTPHeadersParams = validatorPrimitives_1.tObject({
        headers: validatorPrimitives_1.tArray(tType('NameValue')),
    });
    scheme.PageSetNetworkInterceptionEnabledParams = validatorPrimitives_1.tObject({
        enabled: validatorPrimitives_1.tBoolean,
    });
    scheme.PageSetViewportSizeParams = validatorPrimitives_1.tObject({
        viewportSize: validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber,
        }),
    });
    scheme.PageKeyboardDownParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
    });
    scheme.PageKeyboardUpParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
    });
    scheme.PageKeyboardInsertTextParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString,
    });
    scheme.PageKeyboardTypeParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.PageKeyboardPressParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.PageMouseMoveParams = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
        steps: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.PageMouseDownParams = validatorPrimitives_1.tObject({
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.PageMouseUpParams = validatorPrimitives_1.tObject({
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.PageMouseClickParams = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.PageTouchscreenTapParams = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
    });
    scheme.PageAccessibilitySnapshotParams = validatorPrimitives_1.tObject({
        interestingOnly: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        root: validatorPrimitives_1.tOptional(tChannel('ElementHandle')),
    });
    scheme.PagePdfParams = validatorPrimitives_1.tObject({
        scale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        displayHeaderFooter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        headerTemplate: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        footerTemplate: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        printBackground: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        landscape: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        pageRanges: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        format: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        width: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        height: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        preferCSSPageSize: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        margin: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            top: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            bottom: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            left: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            right: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        })),
    });
    scheme.PageStartJSCoverageParams = validatorPrimitives_1.tObject({
        resetOnNavigation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        reportAnonymousScripts: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.PageStopJSCoverageParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.PageStartCSSCoverageParams = validatorPrimitives_1.tObject({
        resetOnNavigation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.PageStopCSSCoverageParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.PageBringToFrontParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.FrameEvalOnSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.FrameEvalOnSelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.FrameAddScriptTagParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        content: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        type: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.FrameAddStyleTagParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        content: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.FrameCheckParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameClickParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameContentParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.FrameDblclickParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameDispatchEventParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        type: validatorPrimitives_1.tString,
        eventInit: tType('SerializedArgument'),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.FrameEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.FrameFillParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameFocusParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameFrameElementParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.FrameGetAttributeParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        name: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameGotoParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['load', 'domcontentloaded', 'networkidle'])),
        referer: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.FrameHoverParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameInnerHTMLParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameInnerTextParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameIsCheckedParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameIsDisabledParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameIsEnabledParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameIsHiddenParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameIsVisibleParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameIsEditableParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FramePressParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        key: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameQuerySelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
    });
    scheme.FrameQuerySelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
    });
    scheme.FrameSelectOptionParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        elements: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tChannel('ElementHandle'))),
        options: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
            value: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            label: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            index: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        }))),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameSetContentParams = validatorPrimitives_1.tObject({
        html: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['load', 'domcontentloaded', 'networkidle'])),
    });
    scheme.FrameSetInputFilesParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        files: validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
            name: validatorPrimitives_1.tString,
            mimeType: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            buffer: validatorPrimitives_1.tBinary,
        })),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameTapParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameTextContentParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameTitleParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.FrameTypeParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        text: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameUncheckParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.FrameWaitForFunctionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        pollingInterval: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.FrameWaitForSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        state: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['attached', 'detached', 'visible', 'hidden'])),
    });
    scheme.WorkerEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.WorkerEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.JSHandleDisposeParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleDisposeParams = tType('JSHandleDisposeParams');
    scheme.JSHandleEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.ElementHandleEvaluateExpressionParams = tType('JSHandleEvaluateExpressionParams');
    scheme.JSHandleEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.ElementHandleEvaluateExpressionHandleParams = tType('JSHandleEvaluateExpressionHandleParams');
    scheme.JSHandleGetPropertyListParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleGetPropertyListParams = tType('JSHandleGetPropertyListParams');
    scheme.JSHandleGetPropertyParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
    });
    scheme.ElementHandleGetPropertyParams = tType('JSHandleGetPropertyParams');
    scheme.JSHandleJsonValueParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleJsonValueParams = tType('JSHandleJsonValueParams');
    scheme.ElementHandleEvalOnSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.ElementHandleEvalOnSelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.ElementHandleBoundingBoxParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleCheckParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleClickParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleContentFrameParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleDblclickParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['left', 'right', 'middle'])),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleDispatchEventParams = validatorPrimitives_1.tObject({
        type: validatorPrimitives_1.tString,
        eventInit: tType('SerializedArgument'),
    });
    scheme.ElementHandleFillParams = validatorPrimitives_1.tObject({
        value: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleFocusParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleGetAttributeParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
    });
    scheme.ElementHandleHoverParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleInnerHTMLParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleInnerTextParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleIsCheckedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleIsDisabledParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleIsEditableParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleIsEnabledParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleIsHiddenParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleIsVisibleParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleOwnerFrameParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandlePressParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleQuerySelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
    });
    scheme.ElementHandleQuerySelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
    });
    scheme.ElementHandleScreenshotParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        type: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['png', 'jpeg'])),
        quality: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        omitBackground: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleScrollIntoViewIfNeededParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.ElementHandleSelectOptionParams = validatorPrimitives_1.tObject({
        elements: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tChannel('ElementHandle'))),
        options: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
            value: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            label: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            index: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        }))),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleSelectTextParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.ElementHandleSetInputFilesParams = validatorPrimitives_1.tObject({
        files: validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
            name: validatorPrimitives_1.tString,
            mimeType: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            buffer: validatorPrimitives_1.tBinary,
        })),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleTapParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(['Alt', 'Control', 'Meta', 'Shift']))),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleTextContentParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElementHandleTypeParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.ElementHandleUncheckParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType('Point')),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ElementHandleWaitForElementStateParams = validatorPrimitives_1.tObject({
        state: validatorPrimitives_1.tEnum(['visible', 'hidden', 'stable', 'enabled', 'disabled', 'editable']),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.ElementHandleWaitForSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        state: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['attached', 'detached', 'visible', 'hidden'])),
    });
    scheme.RequestResponseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.RouteAbortParams = validatorPrimitives_1.tObject({
        errorCode: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.RouteContinueParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        method: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        headers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        postData: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBinary),
    });
    scheme.RouteFulfillParams = validatorPrimitives_1.tObject({
        status: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        headers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        body: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        isBase64: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
    });
    scheme.ResourceTiming = validatorPrimitives_1.tObject({
        startTime: validatorPrimitives_1.tNumber,
        domainLookupStart: validatorPrimitives_1.tNumber,
        domainLookupEnd: validatorPrimitives_1.tNumber,
        connectStart: validatorPrimitives_1.tNumber,
        secureConnectionStart: validatorPrimitives_1.tNumber,
        connectEnd: validatorPrimitives_1.tNumber,
        requestStart: validatorPrimitives_1.tNumber,
        responseStart: validatorPrimitives_1.tNumber,
    });
    scheme.ResponseBodyParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ResponseFinishedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.BindingCallRejectParams = validatorPrimitives_1.tObject({
        error: tType('SerializedError'),
    });
    scheme.BindingCallResolveParams = validatorPrimitives_1.tObject({
        result: tType('SerializedArgument'),
    });
    scheme.DialogAcceptParams = validatorPrimitives_1.tObject({
        promptText: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.DialogDismissParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ArtifactPathAfterFinishedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ArtifactSaveAsParams = validatorPrimitives_1.tObject({
        path: validatorPrimitives_1.tString,
    });
    scheme.ArtifactSaveAsStreamParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ArtifactFailureParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ArtifactStreamParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ArtifactDeleteParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.StreamReadParams = validatorPrimitives_1.tObject({
        size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.StreamCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.CDPSessionSendParams = validatorPrimitives_1.tObject({
        method: validatorPrimitives_1.tString,
        params: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
    });
    scheme.CDPSessionDetachParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.ElectronLaunchParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        executablePath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        cwd: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        env: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['dark', 'light', 'no-preference'])),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            longitude: validatorPrimitives_1.tNumber,
            latitude: validatorPrimitives_1.tNumber,
            accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        })),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            username: validatorPrimitives_1.tString,
            password: validatorPrimitives_1.tString,
        })),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
            path: validatorPrimitives_1.tString,
        })),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            dir: validatorPrimitives_1.tString,
            size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
                width: validatorPrimitives_1.tNumber,
                height: validatorPrimitives_1.tNumber,
            })),
        })),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.ElectronApplicationBrowserWindowParams = validatorPrimitives_1.tObject({
        page: tChannel('Page'),
    });
    scheme.ElectronApplicationEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.ElectronApplicationEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType('SerializedArgument'),
    });
    scheme.ElectronApplicationCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.AndroidDevicesParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.AndroidSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber,
    });
    scheme.AndroidSocketWriteParams = validatorPrimitives_1.tObject({
        data: validatorPrimitives_1.tBinary,
    });
    scheme.AndroidSocketCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.AndroidDeviceWaitParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        state: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['gone'])),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceFillParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        text: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceTapParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        duration: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceDragParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        dest: tType('Point'),
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceFlingParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        direction: validatorPrimitives_1.tEnum(['up', 'down', 'left', 'right']),
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceLongTapParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDevicePinchCloseParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDevicePinchOpenParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceScrollParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        direction: validatorPrimitives_1.tEnum(['up', 'down', 'left', 'right']),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceSwipeParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
        direction: validatorPrimitives_1.tEnum(['up', 'down', 'left', 'right']),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceInfoParams = validatorPrimitives_1.tObject({
        selector: tType('AndroidSelector'),
    });
    scheme.AndroidDeviceScreenshotParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.AndroidDeviceInputTypeParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString,
    });
    scheme.AndroidDeviceInputPressParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
    });
    scheme.AndroidDeviceInputTapParams = validatorPrimitives_1.tObject({
        point: tType('Point'),
    });
    scheme.AndroidDeviceInputSwipeParams = validatorPrimitives_1.tObject({
        segments: validatorPrimitives_1.tArray(tType('Point')),
        steps: validatorPrimitives_1.tNumber,
    });
    scheme.AndroidDeviceInputDragParams = validatorPrimitives_1.tObject({
        from: tType('Point'),
        to: tType('Point'),
        steps: validatorPrimitives_1.tNumber,
    });
    scheme.AndroidDeviceLaunchBrowserParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        pkg: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        javaScriptEnabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        userAgent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            longitude: validatorPrimitives_1.tNumber,
            latitude: validatorPrimitives_1.tNumber,
            accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        })),
        permissions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('NameValue'))),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            username: validatorPrimitives_1.tString,
            password: validatorPrimitives_1.tString,
        })),
        deviceScaleFactor: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        isMobile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasTouch: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['dark', 'light', 'no-preference'])),
        reducedMotion: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(['reduce', 'no-preference'])),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        _debugName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            dir: validatorPrimitives_1.tString,
            size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
                width: validatorPrimitives_1.tNumber,
                height: validatorPrimitives_1.tNumber,
            })),
        })),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
            path: validatorPrimitives_1.tString,
        })),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            server: validatorPrimitives_1.tString,
            bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
            password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        })),
    });
    scheme.AndroidDeviceOpenParams = validatorPrimitives_1.tObject({
        command: validatorPrimitives_1.tString,
    });
    scheme.AndroidDeviceShellParams = validatorPrimitives_1.tObject({
        command: validatorPrimitives_1.tString,
    });
    scheme.AndroidDeviceInstallApkParams = validatorPrimitives_1.tObject({
        file: validatorPrimitives_1.tBinary,
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
    });
    scheme.AndroidDevicePushParams = validatorPrimitives_1.tObject({
        file: validatorPrimitives_1.tBinary,
        path: validatorPrimitives_1.tString,
        mode: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
    });
    scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber,
    });
    scheme.AndroidDeviceConnectToWebViewParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        pid: validatorPrimitives_1.tNumber,
    });
    scheme.AndroidDeviceCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.AndroidWebView = validatorPrimitives_1.tObject({
        pid: validatorPrimitives_1.tNumber,
        pkg: validatorPrimitives_1.tString,
    });
    scheme.AndroidSelector = validatorPrimitives_1.tObject({
        checkable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        checked: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        clazz: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        clickable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        depth: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        desc: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        enabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        focusable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        focused: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasChild: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            selector: tType('AndroidSelector'),
        })),
        hasDescendant: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            selector: tType('AndroidSelector'),
            maxDepth: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        })),
        longClickable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        pkg: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        res: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        scrollable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        selected: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        text: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
    });
    scheme.AndroidElementInfo = validatorPrimitives_1.tObject({
        children: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType('AndroidElementInfo'))),
        clazz: validatorPrimitives_1.tString,
        desc: validatorPrimitives_1.tString,
        res: validatorPrimitives_1.tString,
        pkg: validatorPrimitives_1.tString,
        text: validatorPrimitives_1.tString,
        bounds: tType('Rect'),
        checkable: validatorPrimitives_1.tBoolean,
        checked: validatorPrimitives_1.tBoolean,
        clickable: validatorPrimitives_1.tBoolean,
        enabled: validatorPrimitives_1.tBoolean,
        focusable: validatorPrimitives_1.tBoolean,
        focused: validatorPrimitives_1.tBoolean,
        longClickable: validatorPrimitives_1.tBoolean,
        scrollable: validatorPrimitives_1.tBoolean,
        selected: validatorPrimitives_1.tBoolean,
    });
    scheme.SocksSocketWriteParams = validatorPrimitives_1.tObject({
        data: validatorPrimitives_1.tBinary,
    });
    scheme.SocksSocketErrorParams = validatorPrimitives_1.tObject({
        error: validatorPrimitives_1.tString,
    });
    scheme.SocksSocketConnectedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    scheme.SocksSocketEndParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
    return scheme;
}
exports.createScheme = createScheme;
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ 5814:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tEnum = exports.tObject = exports.tArray = exports.tOptional = exports.tAny = exports.tUndefined = exports.tBinary = exports.tString = exports.tBoolean = exports.tNumber = exports.ValidationError = void 0;
const utils_1 = __nccwpck_require__(6416);
class ValidationError extends Error {
}
exports.ValidationError = ValidationError;
const tNumber = (arg, path) => {
    if (arg instanceof Number)
        return arg.valueOf();
    if (typeof arg === 'number')
        return arg;
    throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
};
exports.tNumber = tNumber;
const tBoolean = (arg, path) => {
    if (arg instanceof Boolean)
        return arg.valueOf();
    if (typeof arg === 'boolean')
        return arg;
    throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
};
exports.tBoolean = tBoolean;
const tString = (arg, path) => {
    if (arg instanceof String)
        return arg.valueOf();
    if (typeof arg === 'string')
        return arg;
    throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
};
exports.tString = tString;
const tBinary = (arg, path) => {
    if (arg instanceof String)
        return arg.valueOf();
    if (typeof arg === 'string')
        return arg;
    throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
};
exports.tBinary = tBinary;
const tUndefined = (arg, path) => {
    if (Object.is(arg, undefined))
        return arg;
    throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
};
exports.tUndefined = tUndefined;
const tAny = (arg, path) => {
    return arg;
};
exports.tAny = tAny;
const tOptional = (v) => {
    return (arg, path) => {
        if (Object.is(arg, undefined))
            return arg;
        return v(arg, path);
    };
};
exports.tOptional = tOptional;
const tArray = (v) => {
    return (arg, path) => {
        if (!Array.isArray(arg))
            throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
        return arg.map((x, index) => v(x, path + '[' + index + ']'));
    };
};
exports.tArray = tArray;
const tObject = (s) => {
    return (arg, path) => {
        if (Object.is(arg, null))
            throw new ValidationError(`${path}: expected object, got null`);
        if (typeof arg !== 'object')
            throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
        const result = {};
        for (const [key, v] of Object.entries(s)) {
            const value = v(arg[key], path ? path + '.' + key : key);
            if (!Object.is(value, undefined))
                result[key] = value;
        }
        if (utils_1.isUnderTest()) {
            for (const [key, value] of Object.entries(arg)) {
                if (key.startsWith('__testHook'))
                    result[key] = value;
            }
        }
        return result;
    };
};
exports.tObject = tObject;
const tEnum = (e) => {
    return (arg, path) => {
        if (!e.includes(arg))
            throw new ValidationError(`${path}: expected one of (${e.join('|')})`);
        return arg;
    };
};
exports.tEnum = tEnum;
//# sourceMappingURL=validatorPrimitives.js.map

/***/ }),

/***/ 4960:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlaywrightServer = void 0;
const debug_1 = __importDefault(__nccwpck_require__(2423));
const http = __importStar(__nccwpck_require__(8605));
const ws = __importStar(__nccwpck_require__(7550));
const dispatcher_1 = __nccwpck_require__(5031);
const playwrightDispatcher_1 = __nccwpck_require__(930);
const playwright_1 = __nccwpck_require__(8508);
const processLauncher_1 = __nccwpck_require__(9690);
const selectors_1 = __nccwpck_require__(5615);
const debugLog = debug_1.default('pw:server');
class PlaywrightServer {
    constructor(delegate) {
        this._clientsCount = 0;
        this._delegate = delegate;
    }
    static async startDefault({ acceptForwardedPorts } = {}) {
        const cleanup = async () => {
            await processLauncher_1.gracefullyCloseAll().catch(e => { });
            selectors_1.serverSelectors.unregisterAll();
        };
        const delegate = {
            path: '/ws',
            allowMultipleClients: false,
            onClose: cleanup,
            onConnect: async (rootScope) => {
                const playwright = playwright_1.createPlaywright();
                if (acceptForwardedPorts)
                    await playwright._enablePortForwarding();
                new playwrightDispatcher_1.PlaywrightDispatcher(rootScope, playwright);
                return () => {
                    cleanup();
                    playwright._disablePortForwarding();
                };
            },
        };
        return new PlaywrightServer(delegate);
    }
    async listen(port = 0) {
        const server = http.createServer((request, response) => {
            response.end('Running');
        });
        server.on('error', error => debugLog(error));
        const path = this._delegate.path;
        const wsEndpoint = await new Promise((resolve, reject) => {
            server.listen(port, () => {
                const address = server.address();
                const wsEndpoint = typeof address === 'string' ? `${address}${path}` : `ws://127.0.0.1:${address.port}${path}`;
                resolve(wsEndpoint);
            }).on('error', reject);
        });
        debugLog('Listening at ' + wsEndpoint);
        this._wsServer = new ws.Server({ server, path });
        this._wsServer.on('connection', async (socket) => {
            if (this._clientsCount && !this._delegate.allowMultipleClients) {
                socket.close();
                return;
            }
            this._clientsCount++;
            debugLog('Incoming connection');
            const connection = new dispatcher_1.DispatcherConnection();
            connection.onmessage = message => {
                if (socket.readyState !== ws.CLOSING)
                    socket.send(JSON.stringify(message));
            };
            socket.on('message', (message) => {
                connection.dispatch(JSON.parse(Buffer.from(message).toString()));
            });
            const forceDisconnect = () => socket.close();
            const scope = connection.rootDispatcher();
            let onDisconnect = () => { };
            const disconnected = () => {
                this._clientsCount--;
                // Avoid sending any more messages over closed socket.
                connection.onmessage = () => { };
                onDisconnect();
            };
            socket.on('close', () => {
                debugLog('Client closed');
                disconnected();
            });
            socket.on('error', error => {
                debugLog('Client error ' + error);
                disconnected();
            });
            onDisconnect = await this._delegate.onConnect(scope, forceDisconnect);
        });
        return wsEndpoint;
    }
    async close() {
        if (!this._wsServer)
            return;
        debugLog('Closing server');
        // First disconnect all remaining clients.
        await new Promise(f => this._wsServer.close(f));
        await new Promise(f => this._wsServer.options.server.close(f));
        this._wsServer = undefined;
        await this._delegate.onClose();
    }
}
exports.PlaywrightServer = PlaywrightServer;
//# sourceMappingURL=playwrightServer.js.map

/***/ }),

/***/ 6166:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Accessibility = void 0;
class Accessibility {
    constructor(getAXTree) {
        this._getAXTree = getAXTree;
    }
    async snapshot(options = {}) {
        const { interestingOnly = true, root = null, } = options;
        const { tree, needle } = await this._getAXTree(root || undefined);
        if (!interestingOnly) {
            if (root)
                return needle && serializeTree(needle)[0];
            return serializeTree(tree)[0];
        }
        const interestingNodes = new Set();
        collectInterestingNodes(interestingNodes, tree, false);
        if (root && (!needle || !interestingNodes.has(needle)))
            return null;
        return serializeTree(needle || tree, interestingNodes)[0];
    }
}
exports.Accessibility = Accessibility;
function collectInterestingNodes(collection, node, insideControl) {
    if (node.isInteresting(insideControl))
        collection.add(node);
    if (node.isLeafNode())
        return;
    insideControl = insideControl || node.isControl();
    for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
}
function serializeTree(node, whitelistedNodes) {
    const children = [];
    for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
    if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
    const serializedNode = node.serialize();
    if (children.length)
        serializedNode.children = children;
    return [serializedNode];
}
//# sourceMappingURL=accessibility.js.map

/***/ }),

/***/ 2184:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AndroidDevice = exports.Android = void 0;
const debug_1 = __importDefault(__nccwpck_require__(2423));
const events_1 = __nccwpck_require__(8614);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const ws = __importStar(__nccwpck_require__(7550));
const utils_1 = __nccwpck_require__(6416);
const browserContext_1 = __nccwpck_require__(7533);
const progress_1 = __nccwpck_require__(6707);
const crBrowser_1 = __nccwpck_require__(6419);
const helper_1 = __nccwpck_require__(7951);
const transport_1 = __nccwpck_require__(3481);
const debugLogger_1 = __nccwpck_require__(5203);
const timeoutSettings_1 = __nccwpck_require__(9255);
const instrumentation_1 = __nccwpck_require__(7490);
class Android extends instrumentation_1.SdkObject {
    constructor(backend, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, 'android');
        this._devices = new Map();
        this._backend = backend;
        this._playwrightOptions = playwrightOptions;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async devices() {
        const devices = (await this._backend.devices()).filter(d => d.status === 'device');
        const newSerials = new Set();
        for (const d of devices) {
            newSerials.add(d.serial);
            if (this._devices.has(d.serial))
                continue;
            const device = await AndroidDevice.create(this, d);
            this._devices.set(d.serial, device);
        }
        for (const d of this._devices.keys()) {
            if (!newSerials.has(d))
                this._devices.delete(d);
        }
        return [...this._devices.values()];
    }
    _deviceClosed(device) {
        this._devices.delete(device.serial);
    }
}
exports.Android = Android;
class AndroidDevice extends instrumentation_1.SdkObject {
    constructor(android, backend, model) {
        super(android, 'android-device');
        this._lastId = 0;
        this._callbacks = new Map();
        this._webViews = new Map();
        this._browserConnections = new Set();
        this._isClosed = false;
        this._android = android;
        this._backend = backend;
        this.model = model;
        this.serial = backend.serial;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(android._timeoutSettings);
    }
    static async create(android, backend) {
        await backend.init();
        const model = await backend.runCommand('shell:getprop ro.product.model');
        const device = new AndroidDevice(android, backend, model.toString().trim());
        await device._init();
        return device;
    }
    async _init() {
        await this._refreshWebViews();
        const poll = () => {
            this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => { }), 500);
        };
        poll();
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async shell(command) {
        const result = await this._backend.runCommand(`shell:${command}`);
        await this._refreshWebViews();
        return result;
    }
    async open(command) {
        return await this._backend.open(`${command}`);
    }
    async screenshot() {
        return await this._backend.runCommand(`shell:screencap -p`);
    }
    async _driver() {
        if (!this._driverPromise)
            this._driverPromise = this._installDriver();
        return this._driverPromise;
    }
    async _installDriver() {
        debug_1.default('pw:android')('Stopping the old driver');
        await this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
        debug_1.default('pw:android')('Uninstalling the old driver');
        await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
        await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
        debug_1.default('pw:android')('Installing the new driver');
        for (const file of ['android-driver.apk', 'android-driver-target.apk'])
            await this.installApk(await fs_1.default.promises.readFile(require.resolve(`../../../bin/${file}`)));
        debug_1.default('pw:android')('Starting the new driver');
        this.shell('am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner').catch(e => debug_1.default('pw:android')(e));
        const socket = await this._waitForLocalAbstract('playwright_android_driver_socket');
        const transport = new transport_1.Transport(socket, socket, socket, 'be');
        transport.onmessage = message => {
            const response = JSON.parse(message);
            const { id, result, error } = response;
            const callback = this._callbacks.get(id);
            if (!callback)
                return;
            if (error)
                callback.reject(new Error(error));
            else
                callback.fulfill(result);
            this._callbacks.delete(id);
        };
        return transport;
    }
    async _waitForLocalAbstract(socketName) {
        let socket;
        debug_1.default('pw:android')(`Polling the socket localabstract:${socketName}`);
        while (!socket) {
            try {
                socket = await this._backend.open(`localabstract:${socketName}`);
            }
            catch (e) {
                await new Promise(f => setTimeout(f, 250));
            }
        }
        debug_1.default('pw:android')(`Connected to localabstract:${socketName}`);
        return socket;
    }
    async send(method, params = {}) {
        // Patch the timeout in!
        params.timeout = this._timeoutSettings.timeout(params);
        const driver = await this._driver();
        const id = ++this._lastId;
        const result = new Promise((fulfill, reject) => this._callbacks.set(id, { fulfill, reject }));
        driver.send(JSON.stringify({ id, method, params }));
        return result;
    }
    async close() {
        this._isClosed = true;
        if (this._pollingWebViews)
            clearTimeout(this._pollingWebViews);
        for (const connection of this._browserConnections)
            await connection.close();
        if (this._driverPromise) {
            const driver = await this._driver();
            driver.close();
        }
        await this._backend.close();
        this._android._deviceClosed(this);
        this.emit(AndroidDevice.Events.Closed);
    }
    async launchBrowser(pkg = 'com.android.chrome', options) {
        debug_1.default('pw:android')('Force-stopping', pkg);
        await this._backend.runCommand(`shell:am force-stop ${pkg}`);
        const socketName = 'playwright-' + utils_1.createGuid();
        const commandLine = `_ --disable-fre --no-default-browser-check --no-first-run --remote-debugging-socket-name=${socketName}`;
        debug_1.default('pw:android')('Starting', pkg, commandLine);
        await this._backend.runCommand(`shell:echo "${commandLine}" > /data/local/tmp/chrome-command-line`);
        await this._backend.runCommand(`shell:am start -n ${pkg}/com.google.android.apps.chrome.Main about:blank`);
        return await this._connectToBrowser(socketName, options);
    }
    async connectToWebView(pid, sdkLanguage) {
        const webView = this._webViews.get(pid);
        if (!webView)
            throw new Error('WebView has been closed');
        return await this._connectToBrowser(`webview_devtools_remote_${pid}`, { sdkLanguage });
    }
    async _connectToBrowser(socketName, options) {
        const socket = await this._waitForLocalAbstract(socketName);
        const androidBrowser = new AndroidBrowser(this, socket);
        await androidBrowser._init();
        this._browserConnections.add(androidBrowser);
        const browserOptions = {
            ...this._android._playwrightOptions,
            name: 'clank',
            isChromium: true,
            slowMo: 0,
            persistent: { ...options, noDefaultViewport: true },
            artifactsDir: '',
            downloadsPath: '',
            tracesDir: '',
            browserProcess: new ClankBrowserProcess(androidBrowser),
            proxy: options.proxy,
            protocolLogger: helper_1.helper.debugProtocolLogger(),
            browserLogsCollector: new debugLogger_1.RecentLogsCollector()
        };
        browserContext_1.validateBrowserContextOptions(options, browserOptions);
        const browser = await crBrowser_1.CRBrowser.connect(androidBrowser, browserOptions);
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), this);
        const defaultContext = browser._defaultContext;
        await controller.run(async (progress) => {
            await defaultContext._loadDefaultContextAsIs(progress);
        });
        {
            // TODO: remove after rolling to r838157
            // Force page scale factor update.
            const page = defaultContext.pages()[0];
            const crPage = page._delegate;
            await crPage._mainFrameSession._client.send('Emulation.setDeviceMetricsOverride', { mobile: false, width: 0, height: 0, deviceScaleFactor: 0 });
            await crPage._mainFrameSession._client.send('Emulation.clearDeviceMetricsOverride', {});
        }
        return defaultContext;
    }
    webViews() {
        return [...this._webViews.values()];
    }
    async installApk(content, options) {
        const args = options && options.args ? options.args : ['-r', '-t', '-S'];
        debug_1.default('pw:android')('Opening install socket');
        const installSocket = await this._backend.open(`shell:cmd package install ${args.join(' ')} ${content.length}`);
        debug_1.default('pw:android')('Writing driver bytes: ' + content.length);
        await installSocket.write(content);
        const success = await new Promise(f => installSocket.on('data', f));
        debug_1.default('pw:android')('Written driver bytes: ' + success);
        installSocket.close();
    }
    async push(content, path, mode = 0o644) {
        const socket = await this._backend.open(`sync:`);
        const sendHeader = async (command, length) => {
            const buffer = Buffer.alloc(command.length + 4);
            buffer.write(command, 0);
            buffer.writeUInt32LE(length, command.length);
            await socket.write(buffer);
        };
        const send = async (command, data) => {
            await sendHeader(command, data.length);
            await socket.write(data);
        };
        await send('SEND', Buffer.from(`${path},${mode}`));
        const maxChunk = 65535;
        for (let i = 0; i < content.length; i += maxChunk)
            await send('DATA', content.slice(i, i + maxChunk));
        await sendHeader('DONE', (Date.now() / 1000) | 0);
        const result = await new Promise(f => socket.once('data', f));
        const code = result.slice(0, 4).toString();
        if (code !== 'OKAY')
            throw new Error('Could not push: ' + code);
        socket.close();
    }
    async _refreshWebViews() {
        const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split('\n');
        if (this._isClosed)
            return;
        const newPids = new Set();
        for (const line of sockets) {
            const match = line.match(/[^@]+@webview_devtools_remote_(\d+)/);
            if (!match)
                continue;
            const pid = +match[1];
            newPids.add(pid);
        }
        for (const pid of newPids) {
            if (this._webViews.has(pid))
                continue;
            const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split('\n');
            if (this._isClosed)
                return;
            let pkg = '';
            for (const proc of procs) {
                const match = proc.match(/[^\s]+\s+(\d+).*$/);
                if (!match)
                    continue;
                const p = match[1];
                if (+p !== pid)
                    continue;
                pkg = proc.substring(proc.lastIndexOf(' ') + 1);
            }
            const webView = { pid, pkg };
            this._webViews.set(pid, webView);
            this.emit(AndroidDevice.Events.WebViewAdded, webView);
        }
        for (const p of this._webViews.keys()) {
            if (!newPids.has(p)) {
                this._webViews.delete(p);
                this.emit(AndroidDevice.Events.WebViewRemoved, p);
            }
        }
    }
}
exports.AndroidDevice = AndroidDevice;
AndroidDevice.Events = {
    WebViewAdded: 'webViewAdded',
    WebViewRemoved: 'webViewRemoved',
    Closed: 'closed'
};
class AndroidBrowser extends events_1.EventEmitter {
    constructor(device, socket) {
        super();
        this._waitForNextTask = utils_1.makeWaitForNextTask();
        this.setMaxListeners(0);
        this.device = device;
        this._socket = socket;
        this._socket.on('close', () => {
            this._waitForNextTask(() => {
                if (this.onclose)
                    this.onclose();
            });
        });
        this._receiver = new ws.Receiver();
        this._receiver.on('message', message => {
            this._waitForNextTask(() => {
                if (this.onmessage)
                    this.onmessage(JSON.parse(message));
            });
        });
    }
    async _init() {
        await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
        // HTTP Upgrade response.
        await new Promise(f => this._socket.once('data', f));
        // Start sending web frame to receiver.
        this._socket.on('data', data => this._receiver._write(data, 'binary', () => { }));
    }
    async send(s) {
        await this._socket.write(encodeWebFrame(JSON.stringify(s)));
    }
    async close() {
        this._socket.close();
    }
}
function encodeWebFrame(data) {
    return ws.Sender.frame(Buffer.from(data), {
        opcode: 1,
        mask: true,
        fin: true,
        readOnly: true
    })[0];
}
class ClankBrowserProcess {
    constructor(browser) {
        this._browser = browser;
    }
    async kill() {
    }
    async close() {
        await this._browser.close();
    }
}
//# sourceMappingURL=android.js.map

/***/ }),

/***/ 8194:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdbBackend = void 0;
const assert_1 = __importDefault(__nccwpck_require__(2357));
const debug_1 = __importDefault(__nccwpck_require__(2423));
const net = __importStar(__nccwpck_require__(1631));
const events_1 = __nccwpck_require__(8614);
const utils_1 = __nccwpck_require__(6416);
class AdbBackend {
    async devices() {
        const result = await runCommand('host:devices');
        const lines = result.toString().trim().split('\n');
        return lines.map(line => {
            const [serial, status] = line.trim().split('\t');
            return new AdbDevice(serial, status);
        });
    }
}
exports.AdbBackend = AdbBackend;
class AdbDevice {
    constructor(serial, status) {
        this.serial = serial;
        this.status = status;
    }
    async init() {
    }
    async close() {
    }
    runCommand(command) {
        return runCommand(command, this.serial);
    }
    async open(command) {
        const result = await open(command, this.serial);
        result.becomeSocket();
        return result;
    }
}
async function runCommand(command, serial) {
    debug_1.default('pw:adb:runCommand')(command, serial);
    const socket = new BufferedSocketWrapper(command, net.createConnection({ port: 5037 }));
    if (serial) {
        await socket.write(encodeMessage(`host:transport:${serial}`));
        const status = await socket.read(4);
        assert_1.default(status.toString() === 'OKAY', status.toString());
    }
    await socket.write(encodeMessage(command));
    const status = await socket.read(4);
    assert_1.default(status.toString() === 'OKAY', status.toString());
    let commandOutput;
    if (!command.startsWith('shell:')) {
        const remainingLength = parseInt((await socket.read(4)).toString(), 16);
        commandOutput = await socket.read(remainingLength);
    }
    else {
        commandOutput = await socket.readAll();
    }
    socket.close();
    return commandOutput;
}
async function open(command, serial) {
    const socket = new BufferedSocketWrapper(command, net.createConnection({ port: 5037 }));
    if (serial) {
        await socket.write(encodeMessage(`host:transport:${serial}`));
        const status = await socket.read(4);
        assert_1.default(status.toString() === 'OKAY', status.toString());
    }
    await socket.write(encodeMessage(command));
    const status = await socket.read(4);
    assert_1.default(status.toString() === 'OKAY', status.toString());
    return socket;
}
function encodeMessage(message) {
    let lenHex = (message.length).toString(16);
    lenHex = '0'.repeat(4 - lenHex.length) + lenHex;
    return Buffer.from(lenHex + message);
}
class BufferedSocketWrapper extends events_1.EventEmitter {
    constructor(command, socket) {
        super();
        this.guid = utils_1.createGuid();
        this._buffer = Buffer.from([]);
        this._isSocket = false;
        this._isClosed = false;
        this._command = command;
        this._socket = socket;
        this._connectPromise = new Promise(f => this._socket.on('connect', f));
        this._socket.on('data', data => {
            debug_1.default('pw:adb:data')(data.toString());
            if (this._isSocket) {
                this.emit('data', data);
                return;
            }
            this._buffer = Buffer.concat([this._buffer, data]);
            if (this._notifyReader)
                this._notifyReader();
        });
        this._socket.on('close', () => {
            this._isClosed = true;
            if (this._notifyReader)
                this._notifyReader();
            this.close();
            this.emit('close');
        });
        this._socket.on('error', error => this.emit('error', error));
    }
    async write(data) {
        debug_1.default('pw:adb:send')(data.toString().substring(0, 100) + '...');
        await this._connectPromise;
        await new Promise(f => this._socket.write(data, f));
    }
    close() {
        if (this._isClosed)
            return;
        debug_1.default('pw:adb')('Close ' + this._command);
        this._socket.destroy();
    }
    async read(length) {
        await this._connectPromise;
        assert_1.default(!this._isSocket, 'Can not read by length in socket mode');
        while (this._buffer.length < length)
            await new Promise(f => this._notifyReader = f);
        const result = this._buffer.slice(0, length);
        this._buffer = this._buffer.slice(length);
        debug_1.default('pw:adb:recv')(result.toString().substring(0, 100) + '...');
        return result;
    }
    async readAll() {
        while (!this._isClosed)
            await new Promise(f => this._notifyReader = f);
        return this._buffer;
    }
    becomeSocket() {
        assert_1.default(!this._buffer.length);
        this._isSocket = true;
    }
}
//# sourceMappingURL=backendAdb.js.map

/***/ }),

/***/ 3293:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Artifact = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const instrumentation_1 = __nccwpck_require__(7490);
class Artifact extends instrumentation_1.SdkObject {
    constructor(parent, localPath, unaccessibleErrorMessage) {
        super(parent, 'artifact');
        this._saveCallbacks = [];
        this._finished = false;
        this._deleted = false;
        this._failureError = null;
        this._localPath = localPath;
        this._unaccessibleErrorMessage = unaccessibleErrorMessage;
        this._finishedCallback = () => { };
        this._finishedPromise = new Promise(f => this._finishedCallback = f);
    }
    finishedPromise() {
        return this._finishedPromise;
    }
    localPath() {
        return this._localPath;
    }
    async localPathAfterFinished() {
        if (this._unaccessibleErrorMessage)
            throw new Error(this._unaccessibleErrorMessage);
        await this._finishedPromise;
        if (this._failureError)
            return null;
        return this._localPath;
    }
    saveAs(saveCallback) {
        if (this._unaccessibleErrorMessage)
            throw new Error(this._unaccessibleErrorMessage);
        if (this._deleted)
            throw new Error(`File already deleted. Save before deleting.`);
        if (this._failureError)
            throw new Error(`File not found on disk. Check download.failure() for details.`);
        if (this._finished) {
            saveCallback(this._localPath).catch(e => { });
            return;
        }
        this._saveCallbacks.push(saveCallback);
    }
    async failureError() {
        if (this._unaccessibleErrorMessage)
            return this._unaccessibleErrorMessage;
        await this._finishedPromise;
        return this._failureError;
    }
    async delete() {
        if (this._unaccessibleErrorMessage)
            return;
        const fileName = await this.localPathAfterFinished();
        if (this._deleted)
            return;
        this._deleted = true;
        if (fileName)
            await fs_1.default.promises.unlink(fileName).catch(e => { });
    }
    async deleteOnContextClose() {
        // Compared to "delete", this method does not wait for the artifact to finish.
        // We use it when closing the context to avoid stalling.
        if (this._deleted)
            return;
        this._deleted = true;
        if (!this._unaccessibleErrorMessage)
            await fs_1.default.promises.unlink(this._localPath).catch(e => { });
        await this.reportFinished('File deleted upon browser context closure.');
    }
    async reportFinished(error) {
        if (this._finished)
            return;
        this._finished = true;
        this._failureError = error || null;
        if (error) {
            for (const callback of this._saveCallbacks)
                await callback('', error);
        }
        else {
            for (const callback of this._saveCallbacks)
                await callback(this._localPath);
        }
        this._saveCallbacks = [];
        this._finishedCallback();
    }
}
exports.Artifact = Artifact;
//# sourceMappingURL=artifact.js.map

/***/ }),

/***/ 6169:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Browser = void 0;
const browserContext_1 = __nccwpck_require__(7533);
const page_1 = __nccwpck_require__(9406);
const download_1 = __nccwpck_require__(6055);
const instrumentation_1 = __nccwpck_require__(7490);
const artifact_1 = __nccwpck_require__(3293);
class Browser extends instrumentation_1.SdkObject {
    constructor(options) {
        super(options.rootSdkObject, 'browser');
        this._downloads = new Map();
        this._defaultContext = null;
        this._startedClosing = false;
        this._idToVideo = new Map();
        this.attribution.browser = this;
        this.options = options;
    }
    _downloadCreated(page, uuid, url, suggestedFilename) {
        const download = new download_1.Download(page, this.options.downloadsPath || '', uuid, url, suggestedFilename);
        this._downloads.set(uuid, download);
    }
    _downloadFilenameSuggested(uuid, suggestedFilename) {
        const download = this._downloads.get(uuid);
        if (!download)
            return;
        download._filenameSuggested(suggestedFilename);
    }
    _downloadFinished(uuid, error) {
        const download = this._downloads.get(uuid);
        if (!download)
            return;
        download.artifact.reportFinished(error);
        this._downloads.delete(uuid);
    }
    _videoStarted(context, videoId, path, pageOrError) {
        const artifact = new artifact_1.Artifact(context, path);
        this._idToVideo.set(videoId, { context, artifact });
        context.emit(browserContext_1.BrowserContext.Events.VideoStarted, artifact);
        pageOrError.then(page => {
            if (page instanceof page_1.Page) {
                page._video = artifact;
                page.emit(page_1.Page.Events.Video, artifact);
            }
        });
    }
    _takeVideo(videoId) {
        const video = this._idToVideo.get(videoId);
        this._idToVideo.delete(videoId);
        return video === null || video === void 0 ? void 0 : video.artifact;
    }
    _didClose() {
        for (const context of this.contexts())
            context._browserClosed();
        if (this._defaultContext)
            this._defaultContext._browserClosed();
        this.emit(Browser.Events.Disconnected);
    }
    async close() {
        if (!this._startedClosing) {
            this._startedClosing = true;
            await this.options.browserProcess.close();
        }
        if (this.isConnected())
            await new Promise(x => this.once(Browser.Events.Disconnected, x));
    }
    async killForTests() {
        await this.options.browserProcess.kill();
    }
}
exports.Browser = Browser;
Browser.Events = {
    Disconnected: 'disconnected',
};
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 7533:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeProxySettings = exports.verifyGeolocation = exports.validateBrowserContextOptions = exports.assertBrowserContextIsNotOwned = exports.BrowserContext = void 0;
const os = __importStar(__nccwpck_require__(2087));
const timeoutSettings_1 = __nccwpck_require__(9255);
const utils_1 = __nccwpck_require__(6416);
const helper_1 = __nccwpck_require__(7951);
const network = __importStar(__nccwpck_require__(8781));
const page_1 = __nccwpck_require__(9406);
const selectors_1 = __nccwpck_require__(5615);
const path_1 = __importDefault(__nccwpck_require__(5622));
const instrumentation_1 = __nccwpck_require__(7490);
const debugger_1 = __nccwpck_require__(2407);
const tracing_1 = __nccwpck_require__(8852);
const harTracer_1 = __nccwpck_require__(3134);
const recorderSupplement_1 = __nccwpck_require__(1865);
const consoleApiSource = __importStar(__nccwpck_require__(5698));
class BrowserContext extends instrumentation_1.SdkObject {
    constructor(browser, options, browserContextId) {
        super(browser, 'browser-context');
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._pageBindings = new Map();
        this._closedStatus = 'open';
        this._permissions = new Map();
        this._downloads = new Set();
        this._origins = new Set();
        this.attribution.context = this;
        this._browser = browser;
        this._options = options;
        this._browserContextId = browserContextId;
        this._isPersistentContext = !browserContextId;
        this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);
        if (this._options.recordHar)
            this._harTracer = new harTracer_1.HarTracer(this, this._options.recordHar);
        this.tracing = new tracing_1.Tracing(this);
    }
    _setSelectors(selectors) {
        this._selectors = selectors;
    }
    selectors() {
        return this._selectors || selectors_1.serverSelectors;
    }
    async _initialize() {
        if (this.attribution.isInternal)
            return;
        // Create instrumentation per context.
        this.instrumentation = instrumentation_1.createInstrumentation();
        // Debugger will pause execution upon page.pause in headed mode.
        const contextDebugger = new debugger_1.Debugger(this);
        this.instrumentation.addListener(contextDebugger);
        // When PWDEBUG=1, show inspector for each context.
        if (utils_1.debugMode() === 'inspector')
            await recorderSupplement_1.RecorderSupplement.show(this, { pauseOnNextStatement: true });
        // When paused, show inspector.
        if (contextDebugger.isPaused())
            recorderSupplement_1.RecorderSupplement.showInspector(this);
        contextDebugger.on(debugger_1.Debugger.Events.PausedStateChanged, () => {
            recorderSupplement_1.RecorderSupplement.showInspector(this);
        });
        if (utils_1.debugMode() === 'console')
            await this.extendInjectedScript('main', consoleApiSource.source);
    }
    async _ensureVideosPath() {
        if (this._options.recordVideo)
            await utils_1.mkdirIfNeeded(path_1.default.join(this._options.recordVideo.dir, 'dummy'));
    }
    _browserClosed() {
        for (const page of this.pages())
            page._didClose();
        this._didCloseInternal();
    }
    _didCloseInternal() {
        if (this._closedStatus === 'closed') {
            // We can come here twice if we close browser context and browser
            // at the same time.
            return;
        }
        this._closedStatus = 'closed';
        this._deleteAllDownloads();
        this._downloads.clear();
        this._closePromiseFulfill(new Error('Context closed'));
        this.emit(BrowserContext.Events.Close);
    }
    async cookies(urls = []) {
        if (urls && !Array.isArray(urls))
            urls = [urls];
        return await this._doCookies(urls);
    }
    setHTTPCredentials(httpCredentials) {
        return this._doSetHTTPCredentials(httpCredentials);
    }
    async exposeBinding(name, needsHandle, playwrightBinding, world) {
        const identifier = page_1.PageBinding.identifier(name, world);
        if (this._pageBindings.has(identifier))
            throw new Error(`Function "${name}" has been already registered`);
        for (const page of this.pages()) {
            if (page.getBinding(name, world))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        const binding = new page_1.PageBinding(name, playwrightBinding, needsHandle, world);
        this._pageBindings.set(identifier, binding);
        await this._doExposeBinding(binding);
    }
    async grantPermissions(permissions, origin) {
        let resolvedOrigin = '*';
        if (origin) {
            const url = new URL(origin);
            resolvedOrigin = url.origin;
        }
        const existing = new Set(this._permissions.get(resolvedOrigin) || []);
        permissions.forEach(p => existing.add(p));
        const list = [...existing.values()];
        this._permissions.set(resolvedOrigin, list);
        await this._doGrantPermissions(resolvedOrigin, list);
    }
    async clearPermissions() {
        this._permissions.clear();
        await this._doClearPermissions();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async _loadDefaultContextAsIs(progress) {
        if (!this.pages().length) {
            const waitForEvent = helper_1.helper.waitForEvent(progress, this, BrowserContext.Events.Page);
            progress.cleanupWhenAborted(() => waitForEvent.dispose);
            const page = (await waitForEvent.promise);
            if (page._pageIsError)
                throw page._pageIsError;
        }
        const pages = this.pages();
        if (pages[0]._pageIsError)
            throw pages[0]._pageIsError;
        await pages[0].mainFrame()._waitForLoadState(progress, 'load');
        return pages;
    }
    async _loadDefaultContext(progress) {
        const pages = await this._loadDefaultContextAsIs(progress);
        if (this._options.isMobile || this._options.locale) {
            // Workaround for:
            // - chromium fails to change isMobile for existing page;
            // - webkit fails to change locale for existing page.
            const oldPage = pages[0];
            await this.newPage(progress.metadata);
            await oldPage.close(progress.metadata);
        }
    }
    _authenticateProxyViaHeader() {
        const proxy = this._options.proxy || this._browser.options.proxy || { username: undefined, password: undefined };
        const { username, password } = proxy;
        if (username) {
            this._options.httpCredentials = { username, password: password };
            const token = Buffer.from(`${username}:${password}`).toString('base64');
            this._options.extraHTTPHeaders = network.mergeHeaders([
                this._options.extraHTTPHeaders,
                network.singleHeader('Proxy-Authorization', `Basic ${token}`),
            ]);
        }
    }
    _authenticateProxyViaCredentials() {
        const proxy = this._options.proxy || this._browser.options.proxy;
        if (!proxy)
            return;
        const { username, password } = proxy;
        if (username)
            this._options.httpCredentials = { username, password: password || '' };
    }
    async _setRequestInterceptor(handler) {
        this._requestInterceptor = handler;
        await this._doUpdateRequestInterception();
    }
    isClosingOrClosed() {
        return this._closedStatus !== 'open';
    }
    async _deleteAllDownloads() {
        await Promise.all(Array.from(this._downloads).map(download => download.artifact.deleteOnContextClose()));
    }
    async close(metadata) {
        var _a;
        if (this._closedStatus === 'open') {
            this.emit(BrowserContext.Events.BeforeClose);
            this._closedStatus = 'closing';
            await ((_a = this._harTracer) === null || _a === void 0 ? void 0 : _a.flush());
            await this.tracing.dispose();
            // Cleanup.
            const promises = [];
            for (const { context, artifact } of this._browser._idToVideo.values()) {
                // Wait for the videos to finish.
                if (context === this)
                    promises.push(artifact.finishedPromise());
            }
            if (this._isPersistentContext) {
                // Close all the pages instead of the context,
                // because we cannot close the default context.
                await Promise.all(this.pages().map(page => page.close(metadata)));
                await this._onClosePersistent();
            }
            else {
                // Close the context.
                await this._doClose();
            }
            // We delete downloads after context closure
            // so that browser does not write to the download file anymore.
            promises.push(this._deleteAllDownloads());
            await Promise.all(promises);
            // Persistent context should also close the browser.
            if (this._isPersistentContext)
                await this._browser.close();
            // Bookkeeping.
            this._didCloseInternal();
        }
        await this._closePromise;
    }
    async newPage(metadata) {
        const pageDelegate = await this.newPageDelegate();
        const pageOrError = await pageDelegate.pageOrError();
        if (pageOrError instanceof page_1.Page) {
            if (pageOrError.isClosed())
                throw new Error('Page has been closed.');
            return pageOrError;
        }
        throw pageOrError;
    }
    addVisitedOrigin(origin) {
        this._origins.add(origin);
    }
    async storageState(metadata) {
        const result = {
            cookies: (await this.cookies()).filter(c => c.value !== ''),
            origins: []
        };
        if (this._origins.size) {
            const internalMetadata = instrumentation_1.internalCallMetadata();
            const page = await this.newPage(internalMetadata);
            await page._setServerRequestInterceptor(handler => {
                handler.fulfill({ body: '<html></html>' }).catch(() => { });
            });
            for (const origin of this._origins) {
                const originStorage = { origin, localStorage: [] };
                const frame = page.mainFrame();
                await frame.goto(internalMetadata, origin);
                const storage = await frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, false, undefined, 'utility');
                originStorage.localStorage = storage.localStorage;
                if (storage.localStorage.length)
                    result.origins.push(originStorage);
            }
            await page.close(internalMetadata);
        }
        return result;
    }
    async setStorageState(metadata, state) {
        if (state.cookies)
            await this.addCookies(state.cookies);
        if (state.origins && state.origins.length) {
            const internalMetadata = instrumentation_1.internalCallMetadata();
            const page = await this.newPage(internalMetadata);
            await page._setServerRequestInterceptor(handler => {
                handler.fulfill({ body: '<html></html>' }).catch(() => { });
            });
            for (const originState of state.origins) {
                const frame = page.mainFrame();
                await frame.goto(metadata, originState.origin);
                await frame.evaluateExpression(`
          originState => {
            for (const { name, value } of (originState.localStorage || []))
              localStorage.setItem(name, value);
          }`, true, originState, 'utility');
            }
            await page.close(internalMetadata);
        }
    }
    async extendInjectedScript(world, source, arg) {
        const installInFrame = (frame) => frame.extendInjectedScript(world, source, arg).catch(() => { });
        const installInPage = (page) => {
            page.on(page_1.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
            return Promise.all(page.frames().map(installInFrame));
        };
        this.on(BrowserContext.Events.Page, installInPage);
        return Promise.all(this.pages().map(installInPage));
    }
}
exports.BrowserContext = BrowserContext;
BrowserContext.Events = {
    Close: 'close',
    Page: 'page',
    Request: 'request',
    Response: 'response',
    RequestFailed: 'requestfailed',
    RequestFinished: 'requestfinished',
    BeforeClose: 'beforeclose',
    VideoStarted: 'videostarted',
};
function assertBrowserContextIsNotOwned(context) {
    for (const page of context.pages()) {
        if (page._ownedContext)
            throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');
    }
}
exports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
function validateBrowserContextOptions(options, browserOptions) {
    if (options.noDefaultViewport && options.deviceScaleFactor !== undefined)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
    if (options.noDefaultViewport && options.isMobile !== undefined)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
    if (!options.viewport && !options.noDefaultViewport)
        options.viewport = { width: 1280, height: 720 };
    if (options.recordVideo) {
        if (!options.recordVideo.size) {
            if (options.noDefaultViewport) {
                options.recordVideo.size = { width: 800, height: 600 };
            }
            else {
                const size = options.viewport;
                const scale = Math.min(1, 800 / Math.max(size.width, size.height));
                options.recordVideo.size = {
                    width: Math.floor(size.width * scale),
                    height: Math.floor(size.height * scale)
                };
            }
        }
        // Make sure both dimensions are odd, this is required for vp8
        options.recordVideo.size.width &= ~1;
        options.recordVideo.size.height &= ~1;
    }
    if (options.proxy) {
        if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === 'win32')
            throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
        options.proxy = normalizeProxySettings(options.proxy);
    }
    if (utils_1.debugMode() === 'inspector')
        options.bypassCSP = true;
    verifyGeolocation(options.geolocation);
    if (!options._debugName)
        options._debugName = utils_1.createGuid();
}
exports.validateBrowserContextOptions = validateBrowserContextOptions;
function verifyGeolocation(geolocation) {
    if (!geolocation)
        return;
    geolocation.accuracy = geolocation.accuracy || 0;
    const { longitude, latitude, accuracy } = geolocation;
    if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
    if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
    if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
}
exports.verifyGeolocation = verifyGeolocation;
function normalizeProxySettings(proxy) {
    let { server, bypass } = proxy;
    let url;
    try {
        // new URL('127.0.0.1:8080') throws
        // new URL('localhost:8080') fails to parse host or protocol
        // In both of these cases, we need to try re-parse URL with `http://` prefix.
        url = new URL(server);
        if (!url.host || !url.protocol)
            url = new URL('http://' + server);
    }
    catch (e) {
        url = new URL('http://' + server);
    }
    if (url.protocol === 'socks4:' && (proxy.username || proxy.password))
        throw new Error(`Socks4 proxy protocol does not support authentication`);
    if (url.protocol === 'socks5:' && (proxy.username || proxy.password))
        throw new Error(`Browser does not support socks5 proxy authentication`);
    server = url.protocol + '//' + url.host;
    if (bypass)
        bypass = bypass.split(',').map(t => t.trim()).join(',');
    return { ...proxy, server, bypass };
}
exports.normalizeProxySettings = normalizeProxySettings;
//# sourceMappingURL=browserContext.js.map

/***/ }),

/***/ 3783:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserType = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const os = __importStar(__nccwpck_require__(2087));
const path_1 = __importDefault(__nccwpck_require__(5622));
const browserContext_1 = __nccwpck_require__(7533);
const transport_1 = __nccwpck_require__(3581);
const processLauncher_1 = __nccwpck_require__(9690);
const pipeTransport_1 = __nccwpck_require__(8410);
const progress_1 = __nccwpck_require__(6707);
const timeoutSettings_1 = __nccwpck_require__(9255);
const validateDependencies_1 = __nccwpck_require__(6342);
const utils_1 = __nccwpck_require__(6416);
const helper_1 = __nccwpck_require__(7951);
const debugLogger_1 = __nccwpck_require__(5203);
const instrumentation_1 = __nccwpck_require__(7490);
const ARTIFACTS_FOLDER = path_1.default.join(os.tmpdir(), 'playwright-artifacts-');
class BrowserType extends instrumentation_1.SdkObject {
    constructor(browserName, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, 'browser-type');
        this.attribution.browserType = this;
        this._playwrightOptions = playwrightOptions;
        this._name = browserName;
        this._registry = playwrightOptions.registry;
    }
    executablePath(channel) {
        return this._registry.executablePath(this._name) || '';
    }
    name() {
        return this._name;
    }
    async launch(metadata, options, protocolLogger) {
        var _a, _b;
        options = validateLaunchOptions(options, (_b = (_a = this._playwrightOptions).loopbackProxyOverride) === null || _b === void 0 ? void 0 : _b.call(_a));
        const controller = new progress_1.ProgressController(metadata, this);
        controller.setLogName('browser');
        const browser = await controller.run(progress => {
            return this._innerLaunchWithRetries(progress, options, undefined, helper_1.helper.debugProtocolLogger(protocolLogger)).catch(e => { throw this._rewriteStartupError(e); });
        }, timeoutSettings_1.TimeoutSettings.timeout(options));
        return browser;
    }
    async launchPersistentContext(metadata, userDataDir, options) {
        var _a, _b;
        options = validateLaunchOptions(options, (_b = (_a = this._playwrightOptions).loopbackProxyOverride) === null || _b === void 0 ? void 0 : _b.call(_a));
        const controller = new progress_1.ProgressController(metadata, this);
        const persistent = options;
        controller.setLogName('browser');
        const browser = await controller.run(progress => {
            return this._innerLaunchWithRetries(progress, options, persistent, helper_1.helper.debugProtocolLogger(), userDataDir).catch(e => { throw this._rewriteStartupError(e); });
        }, timeoutSettings_1.TimeoutSettings.timeout(options));
        return browser._defaultContext;
    }
    async _innerLaunchWithRetries(progress, options, persistent, protocolLogger, userDataDir) {
        try {
            return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
        }
        catch (error) {
            // @see https://github.com/microsoft/playwright/issues/5214
            const errorMessage = typeof error === 'object' && typeof error.message === 'string' ? error.message : '';
            if (errorMessage.includes('Inconsistency detected by ld.so')) {
                progress.log(`<restarting browser due to hitting race condition in glibc>`);
                return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
            }
            throw error;
        }
    }
    async _innerLaunch(progress, options, persistent, protocolLogger, userDataDir) {
        options.proxy = options.proxy ? browserContext_1.normalizeProxySettings(options.proxy) : undefined;
        const browserLogsCollector = new debugLogger_1.RecentLogsCollector();
        const { browserProcess, artifactsDir, transport } = await this._launchProcess(progress, options, !!persistent, browserLogsCollector, userDataDir);
        if (options.__testHookBeforeCreateBrowser)
            await options.__testHookBeforeCreateBrowser();
        const browserOptions = {
            ...this._playwrightOptions,
            name: this._name,
            isChromium: this._name === 'chromium',
            channel: options.channel,
            slowMo: options.slowMo,
            persistent,
            headful: !options.headless,
            artifactsDir,
            downloadsPath: (options.downloadsPath || artifactsDir),
            tracesDir: (options.tracesDir || artifactsDir),
            browserProcess,
            customExecutablePath: options.executablePath,
            proxy: options.proxy,
            protocolLogger,
            browserLogsCollector,
            wsEndpoint: options.useWebSocket ? transport.wsEndpoint : undefined,
        };
        if (persistent)
            browserContext_1.validateBrowserContextOptions(persistent, browserOptions);
        copyTestHooks(options, browserOptions);
        const browser = await this._connectToTransport(transport, browserOptions);
        // We assume no control when using custom arguments, and do not prepare the default context in that case.
        if (persistent && !options.ignoreAllDefaultArgs)
            await browser._defaultContext._loadDefaultContext(progress);
        return browser;
    }
    async _launchProcess(progress, options, isPersistent, browserLogsCollector, userDataDir) {
        var _a;
        const { ignoreDefaultArgs, ignoreAllDefaultArgs, args = [], executablePath = null, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, } = options;
        const env = options.env ? processLauncher_1.envArrayToObject(options.env) : process.env;
        const tempDirectories = [];
        if (options.downloadsPath)
            await fs_1.default.promises.mkdir(options.downloadsPath, { recursive: true });
        if (options.tracesDir)
            await fs_1.default.promises.mkdir(options.tracesDir, { recursive: true });
        const artifactsDir = await fs_1.default.promises.mkdtemp(ARTIFACTS_FOLDER);
        tempDirectories.push(artifactsDir);
        if (!userDataDir) {
            userDataDir = await fs_1.default.promises.mkdtemp(path_1.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
            tempDirectories.push(userDataDir);
        }
        const browserArguments = [];
        if (ignoreAllDefaultArgs)
            browserArguments.push(...args);
        else if (ignoreDefaultArgs)
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter(arg => ignoreDefaultArgs.indexOf(arg) === -1));
        else
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));
        const executable = executablePath || this.executablePath(options.channel);
        if (!executable)
            throw new Error(`No executable path is specified. Pass "executablePath" option directly.`);
        if (!(await utils_1.existsAsync(executable))) {
            const errorMessageLines = [`Failed to launch ${this._name} because executable doesn't exist at ${executable}`];
            // If we tried using stock downloaded browser, suggest re-installing playwright.
            if (!executablePath)
                errorMessageLines.push(`Try re-installing playwright with "npm install playwright"`);
            throw new Error(errorMessageLines.join('\n'));
        }
        // Only validate dependencies for downloadable browsers.
        if (!executablePath && !options.channel)
            await validateDependencies_1.validateHostRequirements(this._registry, this._name);
        else if (!executablePath && options.channel && this._registry.isSupportedBrowser(options.channel))
            await validateDependencies_1.validateHostRequirements(this._registry, options.channel);
        let wsEndpointCallback;
        const shouldWaitForWSListening = options.useWebSocket || ((_a = options.args) === null || _a === void 0 ? void 0 : _a.some(a => a.startsWith('--remote-debugging-port')));
        const waitForWSEndpoint = shouldWaitForWSListening ? new Promise(f => wsEndpointCallback = f) : undefined;
        // Note: it is important to define these variables before launchProcess, so that we don't get
        // "Cannot access 'browserServer' before initialization" if something went wrong.
        let transport = undefined;
        let browserProcess = undefined;
        const { launchedProcess, gracefullyClose, kill } = await processLauncher_1.launchProcess({
            executablePath: executable,
            args: browserArguments,
            env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
            handleSIGINT,
            handleSIGTERM,
            handleSIGHUP,
            log: (message) => {
                if (wsEndpointCallback) {
                    const match = message.match(/DevTools listening on (.*)/);
                    if (match)
                        wsEndpointCallback(match[1]);
                }
                progress.log(message);
                browserLogsCollector.log(message);
            },
            stdio: 'pipe',
            tempDirectories,
            attemptToGracefullyClose: async () => {
                if (options.__testHookGracefullyClose)
                    await options.__testHookGracefullyClose();
                // We try to gracefully close to prevent crash reporting and core dumps.
                // Note that it's fine to reuse the pipe transport, since
                // our connection ignores kBrowserCloseMessageId.
                this._attemptToGracefullyCloseBrowser(transport);
            },
            onExit: (exitCode, signal) => {
                if (browserProcess && browserProcess.onclose)
                    browserProcess.onclose(exitCode, signal);
            },
        });
        async function closeOrKill(timeout) {
            let timer;
            try {
                await Promise.race([
                    gracefullyClose(),
                    new Promise((resolve, reject) => timer = setTimeout(reject, timeout)),
                ]);
            }
            catch (ignored) {
                await kill().catch(ignored => { }); // Make sure to await actual process exit.
            }
            finally {
                clearTimeout(timer);
            }
        }
        browserProcess = {
            onclose: undefined,
            process: launchedProcess,
            close: () => closeOrKill(options.__testHookBrowserCloseTimeout || timeoutSettings_1.DEFAULT_TIMEOUT),
            kill
        };
        progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));
        let wsEndpoint;
        if (shouldWaitForWSListening)
            wsEndpoint = await waitForWSEndpoint;
        if (options.useWebSocket) {
            transport = await transport_1.WebSocketTransport.connect(progress, wsEndpoint);
        }
        else {
            const stdio = launchedProcess.stdio;
            transport = new pipeTransport_1.PipeTransport(stdio[3], stdio[4]);
        }
        return { browserProcess, artifactsDir, transport };
    }
    async connectOverCDP(metadata, endpointURL, options, timeout) {
        throw new Error('CDP connections are only supported by Chromium');
    }
}
exports.BrowserType = BrowserType;
function copyTestHooks(from, to) {
    for (const [key, value] of Object.entries(from)) {
        if (key.startsWith('__testHook'))
            to[key] = value;
    }
}
function validateLaunchOptions(options, proxyOverride) {
    const { devtools = false } = options;
    let { headless = !devtools, downloadsPath, proxy } = options;
    if (utils_1.debugMode())
        headless = false;
    if (downloadsPath && !path_1.default.isAbsolute(downloadsPath))
        downloadsPath = path_1.default.join(process.cwd(), downloadsPath);
    if (proxyOverride)
        proxy = { server: proxyOverride };
    return { ...options, devtools, headless, downloadsPath, proxy };
}
//# sourceMappingURL=browserType.js.map

/***/ }),

/***/ 8974:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chromium = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const os_1 = __importDefault(__nccwpck_require__(2087));
const path_1 = __importDefault(__nccwpck_require__(5622));
const crBrowser_1 = __nccwpck_require__(6419);
const crConnection_1 = __nccwpck_require__(8899);
const stackTrace_1 = __nccwpck_require__(6010);
const browserType_1 = __nccwpck_require__(3783);
const transport_1 = __nccwpck_require__(3581);
const crDevTools_1 = __nccwpck_require__(4272);
const utils_1 = __nccwpck_require__(6416);
const debugLogger_1 = __nccwpck_require__(5203);
const progress_1 = __nccwpck_require__(6707);
const timeoutSettings_1 = __nccwpck_require__(9255);
const helper_1 = __nccwpck_require__(7951);
const findChromiumChannel_1 = __nccwpck_require__(4655);
const http_1 = __importDefault(__nccwpck_require__(8605));
const ARTIFACTS_FOLDER = path_1.default.join(os_1.default.tmpdir(), 'playwright-artifacts-');
class Chromium extends browserType_1.BrowserType {
    constructor(playwrightOptions) {
        super('chromium', playwrightOptions);
        if (utils_1.debugMode())
            this._devtools = this._createDevTools();
    }
    executablePath(channel) {
        if (channel)
            return findChromiumChannel_1.findChromiumChannel(channel);
        return super.executablePath(channel);
    }
    async connectOverCDP(metadata, endpointURL, options, timeout) {
        const controller = new progress_1.ProgressController(metadata, this);
        controller.setLogName('browser');
        const browserLogsCollector = new debugLogger_1.RecentLogsCollector();
        return controller.run(async (progress) => {
            let headersMap;
            if (options.headers)
                headersMap = utils_1.headersArrayToObject(options.headers, false);
            const artifactsDir = await fs_1.default.promises.mkdtemp(ARTIFACTS_FOLDER);
            const chromeTransport = await transport_1.WebSocketTransport.connect(progress, await urlToWSEndpoint(endpointURL), headersMap);
            const browserProcess = {
                close: async () => {
                    await utils_1.removeFolders([artifactsDir]);
                    await chromeTransport.closeAndWait();
                },
                kill: async () => {
                    await utils_1.removeFolders([artifactsDir]);
                    await chromeTransport.closeAndWait();
                }
            };
            const browserOptions = {
                ...this._playwrightOptions,
                slowMo: options.slowMo,
                name: 'chromium',
                isChromium: true,
                persistent: { sdkLanguage: options.sdkLanguage, noDefaultViewport: true },
                browserProcess,
                protocolLogger: helper_1.helper.debugProtocolLogger(),
                browserLogsCollector,
                artifactsDir,
                downloadsPath: artifactsDir,
                tracesDir: artifactsDir
            };
            return await crBrowser_1.CRBrowser.connect(chromeTransport, browserOptions);
        }, timeoutSettings_1.TimeoutSettings.timeout({ timeout }));
    }
    _createDevTools() {
        return new crDevTools_1.CRDevTools(path_1.default.join(this._registry.browserDirectory('chromium'), 'devtools-preferences.json'));
    }
    async _connectToTransport(transport, options) {
        let devtools = this._devtools;
        if (options.__testHookForDevTools) {
            devtools = this._createDevTools();
            await options.__testHookForDevTools(devtools);
        }
        return crBrowser_1.CRBrowser.connect(transport, options, devtools);
    }
    _rewriteStartupError(error) {
        // These error messages are taken from Chromium source code as of July, 2020:
        // https://github.com/chromium/chromium/blob/70565f67e79f79e17663ad1337dc6e63ee207ce9/content/browser/zygote_host/zygote_host_impl_linux.cc
        if (!error.message.includes('crbug.com/357670') && !error.message.includes('No usable sandbox!') && !error.message.includes('crbug.com/638180'))
            return error;
        return stackTrace_1.rewriteErrorMessage(error, [
            `Chromium sandboxing failed!`,
            `================================`,
            `To workaround sandboxing issues, do either of the following:`,
            `  - (preferred): Configure environment to support sandboxing: https://github.com/microsoft/playwright/blob/master/docs/troubleshooting.md`,
            `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`,
            `================================`,
            ``,
        ].join('\n'));
    }
    _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return env;
    }
    _attemptToGracefullyCloseBrowser(transport) {
        const message = { method: 'Browser.close', id: crConnection_1.kBrowserCloseMessageId, params: {} };
        transport.send(message);
    }
    _defaultArgs(options, isPersistent, userDataDir) {
        const { args = [], proxy } = options;
        const userDataDirArg = args.find(arg => arg.startsWith('--user-data-dir'));
        if (userDataDirArg)
            throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument');
        if (args.find(arg => arg.startsWith('--remote-debugging-pipe')))
            throw new Error('Playwright manages remote debugging connection itself.');
        if (args.find(arg => !arg.startsWith('-')))
            throw new Error('Arguments can not specify page to be opened');
        const chromeArguments = [...DEFAULT_ARGS];
        chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (options.useWebSocket)
            chromeArguments.push('--remote-debugging-port=0');
        else
            chromeArguments.push('--remote-debugging-pipe');
        if (options.devtools)
            chromeArguments.push('--auto-open-devtools-for-tabs');
        if (options.headless) {
            chromeArguments.push('--headless', '--hide-scrollbars', '--mute-audio', '--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4');
        }
        if (options.chromiumSandbox !== true)
            chromeArguments.push('--no-sandbox');
        if (proxy) {
            const proxyURL = new URL(proxy.server);
            const isSocks = proxyURL.protocol === 'socks5:';
            // https://www.chromium.org/developers/design-documents/network-settings
            if (isSocks) {
                // https://www.chromium.org/developers/design-documents/network-stack/socks-proxy
                chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
            }
            chromeArguments.push(`--proxy-server=${proxy.server}`);
            const proxyBypassRules = [];
            // https://source.chromium.org/chromium/chromium/src/+/master:net/docs/proxy.md;l=548;drc=71698e610121078e0d1a811054dcf9fd89b49578
            if (this._playwrightOptions.loopbackProxyOverride)
                proxyBypassRules.push('<-loopback>');
            if (proxy.bypass)
                proxyBypassRules.push(...proxy.bypass.split(',').map(t => t.trim()).map(t => t.startsWith('.') ? '*' + t : t));
            if (proxyBypassRules.length > 0)
                chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(';')}`);
        }
        chromeArguments.push(...args);
        if (isPersistent)
            chromeArguments.push('about:blank');
        else
            chromeArguments.push('--no-startup-window');
        return chromeArguments;
    }
}
exports.Chromium = Chromium;
const DEFAULT_ARGS = [
    '--disable-background-networking',
    '--enable-features=NetworkService,NetworkServiceInProcess',
    '--disable-background-timer-throttling',
    '--disable-backgrounding-occluded-windows',
    '--disable-breakpad',
    '--disable-client-side-phishing-detection',
    '--disable-component-extensions-with-background-pages',
    '--disable-default-apps',
    '--disable-dev-shm-usage',
    '--disable-extensions',
    // BlinkGenPropertyTrees disabled due to crbug.com/937609
    '--disable-features=TranslateUI,BlinkGenPropertyTrees,ImprovedCookieControls,SameSiteByDefaultCookies,LazyFrameLoading,GlobalMediaControls',
    '--allow-pre-commit-input',
    '--disable-hang-monitor',
    '--disable-ipc-flooding-protection',
    '--disable-popup-blocking',
    '--disable-prompt-on-repost',
    '--disable-renderer-backgrounding',
    '--disable-sync',
    '--force-color-profile=srgb',
    '--metrics-recording-only',
    '--no-first-run',
    '--enable-automation',
    '--password-store=basic',
    '--use-mock-keychain',
    // See https://chromium-review.googlesource.com/c/chromium/src/+/2436773
    '--no-service-autorun',
];
async function urlToWSEndpoint(endpointURL) {
    if (endpointURL.startsWith('ws'))
        return endpointURL;
    const httpURL = endpointURL.endsWith('/') ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
    const json = await new Promise((resolve, reject) => {
        http_1.default.get(httpURL, resp => {
            let data = '';
            resp.on('data', chunk => data += chunk);
            resp.on('end', () => resolve(data));
        }).on('error', reject);
    });
    return JSON.parse(json).webSocketDebuggerUrl;
}
//# sourceMappingURL=chromium.js.map

/***/ }),

/***/ 7443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAccessibilityTree = void 0;
async function getAccessibilityTree(client, needle) {
    const { nodes } = await client.send('Accessibility.getFullAXTree');
    const tree = CRAXNode.createTree(client, nodes);
    return {
        tree,
        needle: needle ? await tree._findElement(needle) : null
    };
}
exports.getAccessibilityTree = getAccessibilityTree;
class CRAXNode {
    constructor(client, payload) {
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : '';
        this._role = this._payload.role ? this._payload.role.value : 'Unknown';
        for (const property of this._payload.properties || []) {
            if (property.name === 'editable') {
                this._richlyEditable = property.value.value === 'richtext';
                this._editable = true;
            }
            if (property.name === 'focusable')
                this._focusable = property.value.value;
            if (property.name === 'expanded')
                this._expanded = property.value.value;
            if (property.name === 'hidden')
                this._hidden = property.value.value;
        }
    }
    _isPlainTextField() {
        if (this._richlyEditable)
            return false;
        if (this._editable)
            return true;
        return this._role === 'textbox' || this._role === 'ComboBox' || this._role === 'searchbox';
    }
    _isTextOnlyObject() {
        const role = this._role;
        return (role === 'LineBreak' || role === 'text' ||
            role === 'InlineTextBox' || role === 'StaticText');
    }
    _hasFocusableChild() {
        if (this._cachedHasFocusableChild === undefined) {
            this._cachedHasFocusableChild = false;
            for (const child of this._children) {
                if (child._focusable || child._hasFocusableChild()) {
                    this._cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this._cachedHasFocusableChild;
    }
    children() {
        return this._children;
    }
    async _findElement(element) {
        const objectId = element._objectId;
        const { node: { backendNodeId } } = await this._client.send('DOM.describeNode', { objectId });
        const needle = this.find(node => node._payload.backendDOMNodeId === backendNodeId);
        return needle || null;
    }
    find(predicate) {
        if (predicate(this))
            return this;
        for (const child of this._children) {
            const result = child.find(predicate);
            if (result)
                return result;
        }
        return null;
    }
    isLeafNode() {
        if (!this._children.length)
            return true;
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this._isPlainTextField() || this._isTextOnlyObject())
            return true;
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this._role) {
            case 'doc-cover':
            case 'graphics-symbol':
            case 'img':
            case 'Meter':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
            default:
                break;
        }
        // Here and below: Android heuristics
        if (this._hasFocusableChild())
            return false;
        if (this._focusable && this._role !== 'WebArea' && this._role !== 'RootWebArea' && this._name)
            return true;
        if (this._role === 'heading' && this._name)
            return true;
        return false;
    }
    isControl() {
        switch (this._role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'tree':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        const role = this._role;
        if (role === 'Ignored' || this._hidden)
            return false;
        if (this._focusable || this._richlyEditable)
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!this._name;
    }
    normalizedRole() {
        switch (this._role) {
            case 'RootWebArea':
                return 'WebArea';
            case 'StaticText':
                return 'text';
            default:
                return this._role;
        }
    }
    serialize() {
        const properties = new Map();
        for (const property of this._payload.properties || [])
            properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.description)
            properties.set('description', this._payload.description.value);
        const node = {
            role: this.normalizedRole(),
            name: this._payload.name ? (this._payload.name.value || '') : '',
        };
        const userStringProperties = [
            'description',
            'keyshortcuts',
            'roledescription',
            'valuetext',
        ];
        for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty))
                continue;
            node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        for (const booleanProperty of booleanProperties) {
            // WebArea's treat focus differently than other nodes. They report whether their frame  has focus,
            // not whether focus is specifically on the root node.
            if (booleanProperty === 'focused' && (this._role === 'WebArea' || this._role === 'RootWebArea'))
                continue;
            const value = properties.get(booleanProperty);
            if (!value)
                continue;
            node[booleanProperty] = value;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty))
                continue;
            node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        for (const tokenProperty of tokenProperties) {
            const value = properties.get(tokenProperty);
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = value;
        }
        const axNode = node;
        if (this._payload.value) {
            if (typeof this._payload.value.value === 'string')
                axNode.valueString = this._payload.value.value;
            if (typeof this._payload.value.value === 'number')
                axNode.valueNumber = this._payload.value.value;
        }
        if (properties.has('checked'))
            axNode.checked = properties.get('checked') === 'true' ? 'checked' : properties.get('checked') === 'false' ? 'unchecked' : 'mixed';
        if (properties.has('pressed'))
            axNode.pressed = properties.get('pressed') === 'true' ? 'pressed' : properties.get('pressed') === 'false' ? 'released' : 'mixed';
        return axNode;
    }
    static createTree(client, payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
            nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
            for (const childId of node._payload.childIds || [])
                node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
    }
}
//# sourceMappingURL=crAccessibility.js.map

/***/ }),

/***/ 6419:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRBrowserContext = exports.CRBrowser = void 0;
const browser_1 = __nccwpck_require__(6169);
const browserContext_1 = __nccwpck_require__(7533);
const utils_1 = __nccwpck_require__(6416);
const network = __importStar(__nccwpck_require__(8781));
const page_1 = __nccwpck_require__(9406);
const crConnection_1 = __nccwpck_require__(8899);
const crPage_1 = __nccwpck_require__(3380);
const crProtocolHelper_1 = __nccwpck_require__(3089);
const crExecutionContext_1 = __nccwpck_require__(9262);
class CRBrowser extends browser_1.Browser {
    constructor(connection, options) {
        super(options);
        this._clientRootSessionPromise = null;
        this._contexts = new Map();
        this._crPages = new Map();
        this._backgroundPages = new Map();
        this._serviceWorkers = new Map();
        this._isMac = false;
        this._version = '';
        this._tracingRecording = false;
        this._tracingPath = '';
        this._connection = connection;
        this._session = this._connection.rootSession;
        this._connection.on(crConnection_1.ConnectionEvents.Disconnected, () => this._didClose());
        this._session.on('Target.attachedToTarget', this._onAttachedToTarget.bind(this));
        this._session.on('Target.detachedFromTarget', this._onDetachedFromTarget.bind(this));
        this._session.on('Browser.downloadWillBegin', this._onDownloadWillBegin.bind(this));
        this._session.on('Browser.downloadProgress', this._onDownloadProgress.bind(this));
    }
    static async connect(transport, options, devtools) {
        const connection = new crConnection_1.CRConnection(transport, options.protocolLogger, options.browserLogsCollector);
        const browser = new CRBrowser(connection, options);
        browser._devtools = devtools;
        const session = connection.rootSession;
        if (options.__testHookOnConnectToBrowser)
            await options.__testHookOnConnectToBrowser();
        const version = await session.send('Browser.getVersion');
        browser._isMac = version.userAgent.includes('Macintosh');
        browser._version = version.product.substring(version.product.indexOf('/') + 1);
        if (!options.persistent) {
            await session.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
            return browser;
        }
        browser._defaultContext = new CRBrowserContext(browser, undefined, options.persistent);
        await Promise.all([
            session.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }).then(async () => {
                // Target.setAutoAttach has a bug where it does not wait for new Targets being attached.
                // However making a dummy call afterwards fixes this.
                // This can be removed after https://chromium-review.googlesource.com/c/chromium/src/+/2885888 lands in stable.
                await session.send('Target.getTargetInfo');
            }),
            browser._defaultContext._initialize(),
        ]);
        await browser._waitForAllPagesToBeInitialized();
        return browser;
    }
    async newContext(options) {
        browserContext_1.validateBrowserContextOptions(options, this.options);
        const { browserContextId } = await this._session.send('Target.createBrowserContext', {
            disposeOnDetach: true,
            proxyServer: options.proxy ? options.proxy.server : undefined,
            proxyBypassList: options.proxy ? options.proxy.bypass : undefined,
        });
        const context = new CRBrowserContext(this, browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    version() {
        return this._version;
    }
    isClank() {
        return this.options.name === 'clank';
    }
    async _waitForAllPagesToBeInitialized() {
        await Promise.all([...this._crPages.values()].map(page => page.pageOrError()));
    }
    _onAttachedToTarget({ targetInfo, sessionId, waitingForDebugger }) {
        if (targetInfo.type === 'browser')
            return;
        const session = this._connection.session(sessionId);
        utils_1.assert(targetInfo.browserContextId, 'targetInfo: ' + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
            // TODO: auto attach only to pages from our contexts.
            // assert(this._defaultContext);
            context = this._defaultContext;
        }
        if (targetInfo.type === 'other' && targetInfo.url.startsWith('devtools://devtools') && this._devtools) {
            this._devtools.install(session);
            return;
        }
        if (targetInfo.type === 'other' || !context) {
            if (waitingForDebugger) {
                // Ideally, detaching should resume any target, but there is a bug in the backend.
                session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {
                    this._session._sendMayFail('Target.detachFromTarget', { sessionId });
                });
            }
            return;
        }
        utils_1.assert(!this._crPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
        utils_1.assert(!this._backgroundPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
        utils_1.assert(!this._serviceWorkers.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
        if (targetInfo.type === 'background_page') {
            const backgroundPage = new crPage_1.CRPage(session, targetInfo.targetId, context, null, false, true);
            this._backgroundPages.set(targetInfo.targetId, backgroundPage);
            return;
        }
        if (targetInfo.type === 'page') {
            const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
            const crPage = new crPage_1.CRPage(session, targetInfo.targetId, context, opener, true, false);
            this._crPages.set(targetInfo.targetId, crPage);
            return;
        }
        if (targetInfo.type === 'service_worker') {
            const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);
            this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
            context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
            return;
        }
        utils_1.assert(false, 'Unknown target type: ' + targetInfo.type);
    }
    _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
            this._crPages.delete(targetId);
            crPage.didClose();
            return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
            this._backgroundPages.delete(targetId);
            backgroundPage.didClose();
            return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
            this._serviceWorkers.delete(targetId);
            serviceWorker.emit(page_1.Worker.Events.Close);
            return;
        }
    }
    _findOwningPage(frameId) {
        for (const crPage of this._crPages.values()) {
            const frame = crPage._page._frameManager.frame(frameId);
            if (frame)
                return crPage;
        }
        return null;
    }
    _onDownloadWillBegin(payload) {
        const page = this._findOwningPage(payload.frameId);
        utils_1.assert(page, 'Download started in unknown page: ' + JSON.stringify(payload));
        page.willBeginDownload();
        let originPage = page._initializedPage;
        // If it's a new window download, report it on the opener page.
        if (!originPage && page._opener)
            originPage = page._opener._initializedPage;
        if (!originPage)
            return;
        this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
    }
    _onDownloadProgress(payload) {
        if (payload.state === 'completed')
            this._downloadFinished(payload.guid, '');
        if (payload.state === 'canceled')
            this._downloadFinished(payload.guid, 'canceled');
    }
    async _closePage(crPage) {
        await this._session.send('Target.closeTarget', { targetId: crPage._targetId });
    }
    async newBrowserCDPSession() {
        return await this._connection.createBrowserSession();
    }
    async startTracing(page, options = {}) {
        utils_1.assert(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');
        this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
        const defaultCategories = [
            '-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame', 'toplevel',
            'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'
        ];
        const { path = null, screenshots = false, categories = defaultCategories, } = options;
        if (screenshots)
            categories.push('disabled-by-default-devtools.screenshot');
        this._tracingPath = path;
        this._tracingRecording = true;
        await this._tracingClient.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            categories: categories.join(',')
        });
    }
    async stopTracing() {
        utils_1.assert(this._tracingClient, 'Tracing was not started.');
        const [event] = await Promise.all([
            new Promise(f => this._tracingClient.once('Tracing.tracingComplete', f)),
            this._tracingClient.send('Tracing.end')
        ]);
        const result = await crProtocolHelper_1.readProtocolStream(this._tracingClient, event.stream, this._tracingPath);
        this._tracingRecording = false;
        return result;
    }
    isConnected() {
        return !this._connection._closed;
    }
    async _clientRootSession() {
        if (!this._clientRootSessionPromise)
            this._clientRootSessionPromise = this._connection.createBrowserSession();
        return this._clientRootSessionPromise;
    }
}
exports.CRBrowser = CRBrowser;
class CRServiceWorker extends page_1.Worker {
    constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = browserContext;
        session.once('Runtime.executionContextCreated', event => {
            this._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
        });
        // This might fail if the target is closed before we receive all execution contexts.
        session.send('Runtime.enable', {}).catch(e => { });
        session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
    }
}
class CRBrowserContext extends browserContext_1.BrowserContext {
    constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._browser = browser;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaCredentials();
    }
    async _initialize() {
        utils_1.assert(!Array.from(this._browser._crPages.values()).some(page => page._browserContext === this));
        const promises = [super._initialize()];
        if (this._browser.options.name !== 'electron' && this._browser.options.name !== 'clank') {
            promises.push(this._browser._session.send('Browser.setDownloadBehavior', {
                behavior: this._options.acceptDownloads ? 'allowAndName' : 'deny',
                browserContextId: this._browserContextId,
                downloadPath: this._browser.options.downloadsPath,
                eventsEnabled: true,
            }));
        }
        if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
        await Promise.all(promises);
    }
    pages() {
        const result = [];
        for (const crPage of this._browser._crPages.values()) {
            if (crPage._browserContext === this && crPage._initializedPage)
                result.push(crPage._initializedPage);
        }
        return result;
    }
    async newPageDelegate() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : undefined;
        let { targetId } = await this._browser._session.send('Target.createTarget', { url: 'about:blank', browserContextId: this._browserContextId });
        if (oldKeys) {
            // Chrome for Android returns tab ids (1, 2, 3, 4, 5) instead of content target ids here, work around it via the
            // heuristic assuming that there is only one page created at a time.
            const newKeys = new Set(this._browser._crPages.keys());
            // Remove old keys.
            for (const key of oldKeys)
                newKeys.delete(key);
            // Remove potential concurrent popups.
            for (const key of newKeys) {
                const page = this._browser._crPages.get(key);
                if (page._opener)
                    newKeys.delete(key);
            }
            utils_1.assert(newKeys.size === 1);
            [targetId] = [...newKeys];
        }
        return this._browser._crPages.get(targetId);
    }
    async _doCookies(urls) {
        const { cookies } = await this._browser._session.send('Storage.getCookies', { browserContextId: this._browserContextId });
        return network.filterCookies(cookies.map(c => {
            const copy = { sameSite: 'None', ...c };
            delete copy.size;
            delete copy.priority;
            delete copy.session;
            delete copy.sameParty;
            delete copy.sourceScheme;
            delete copy.sourcePort;
            return copy;
        }), urls);
    }
    async addCookies(cookies) {
        await this._browser._session.send('Storage.setCookies', { cookies: network.rewriteCookies(cookies), browserContextId: this._browserContextId });
    }
    async clearCookies() {
        await this._browser._session.send('Storage.clearCookies', { browserContextId: this._browserContextId });
    }
    async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
            ['geolocation', 'geolocation'],
            ['midi', 'midi'],
            ['notifications', 'notifications'],
            ['camera', 'videoCapture'],
            ['microphone', 'audioCapture'],
            ['background-sync', 'backgroundSync'],
            ['ambient-light-sensor', 'sensors'],
            ['accelerometer', 'sensors'],
            ['gyroscope', 'sensors'],
            ['magnetometer', 'sensors'],
            ['accessibility-events', 'accessibilityEvents'],
            ['clipboard-read', 'clipboardReadWrite'],
            ['clipboard-write', 'clipboardSanitizedWrite'],
            ['payment-handler', 'paymentHandler'],
            // chrome-specific permissions we have.
            ['midi-sysex', 'midiSysex'],
        ]);
        const filtered = permissions.map(permission => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._browser._session.send('Browser.grantPermissions', { origin: origin === '*' ? undefined : origin, browserContextId: this._browserContextId, permissions: filtered });
    }
    async _doClearPermissions() {
        await this._browser._session.send('Browser.resetPermissions', { browserContextId: this._browserContextId });
    }
    async setGeolocation(geolocation) {
        browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation;
        for (const page of this.pages())
            await page._delegate.updateGeolocation();
    }
    async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        for (const page of this.pages())
            await page._delegate.updateExtraHTTPHeaders();
    }
    async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
            await page._delegate.updateOffline();
    }
    async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        for (const page of this.pages())
            await page._delegate.updateHttpCredentials();
    }
    async _doAddInitScript(source) {
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
            await page._delegate.evaluateOnNewDocument(source);
    }
    async _doExposeBinding(binding) {
        for (const page of this.pages())
            await page._delegate.exposeBinding(binding);
    }
    async _doUpdateRequestInterception() {
        for (const page of this.pages())
            await page._delegate.updateRequestInterception();
    }
    async _doClose() {
        utils_1.assert(this._browserContextId);
        await this._browser._session.send('Target.disposeBrowserContext', { browserContextId: this._browserContextId });
        this._browser._contexts.delete(this._browserContextId);
        for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
            if (serviceWorker._browserContext !== this)
                continue;
            // When closing a browser context, service workers are shutdown
            // asynchronously and we get detached from them later.
            // To avoid the wrong order of notifications, we manually fire
            // "close" event here and forget about the serivce worker.
            serviceWorker.emit(page_1.Worker.Events.Close);
            this._browser._serviceWorkers.delete(targetId);
        }
    }
    async _onClosePersistent() {
        for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
            if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {
                backgroundPage.didClose();
                this._browser._backgroundPages.delete(targetId);
            }
        }
    }
    backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
            if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
                result.push(backgroundPage._initializedPage);
        }
        return result;
    }
    serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter(serviceWorker => serviceWorker._browserContext === this);
    }
    async newCDPSession(page) {
        if (!(page instanceof page_1.Page))
            throw new Error('page: expected Page');
        const targetId = page._delegate._targetId;
        const rootSession = await this._browser._clientRootSession();
        const { sessionId } = await rootSession.send('Target.attachToTarget', { targetId, flatten: true });
        return this._browser._connection.session(sessionId);
    }
}
exports.CRBrowserContext = CRBrowserContext;
CRBrowserContext.CREvents = {
    BackgroundPage: 'backgroundpage',
    ServiceWorker: 'serviceworker',
};
//# sourceMappingURL=crBrowser.js.map

/***/ }),

/***/ 8899:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRSession = exports.CRSessionEvents = exports.CRConnection = exports.kBrowserCloseMessageId = exports.ConnectionEvents = void 0;
const utils_1 = __nccwpck_require__(6416);
const events_1 = __nccwpck_require__(8614);
const stackTrace_1 = __nccwpck_require__(6010);
const debugLogger_1 = __nccwpck_require__(5203);
const helper_1 = __nccwpck_require__(7951);
exports.ConnectionEvents = {
    Disconnected: Symbol('ConnectionEvents.Disconnected')
};
// CRPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
class CRConnection extends events_1.EventEmitter {
    constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = 0;
        this._sessions = new Map();
        this._closed = false;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, '', 'browser', '');
        this._sessions.set('', this.rootSession);
    }
    static fromSession(session) {
        return session._connection;
    }
    session(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
    _rawSend(sessionId, method, params) {
        const id = ++this._lastId;
        const message = { id, method, params };
        if (sessionId)
            message.sessionId = sessionId;
        this._protocolLogger('send', message);
        this._transport.send(message);
        return id;
    }
    async _onMessage(message) {
        this._protocolLogger('receive', message);
        if (message.id === exports.kBrowserCloseMessageId)
            return;
        if (message.method === 'Target.attachedToTarget') {
            const sessionId = message.params.sessionId;
            const rootSessionId = message.sessionId || '';
            const session = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session);
        }
        else if (message.method === 'Target.detachedFromTarget') {
            const session = this._sessions.get(message.params.sessionId);
            if (session) {
                session._onClosed(undefined);
                this._sessions.delete(message.params.sessionId);
            }
        }
        const session = this._sessions.get(message.sessionId || '');
        if (session)
            session._onMessage(message);
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        const browserDisconnectedLogs = helper_1.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
            session._onClosed(browserDisconnectedLogs);
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(exports.ConnectionEvents.Disconnected));
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
    async createSession(targetInfo) {
        const { sessionId } = await this.rootSession.send('Target.attachToTarget', { targetId: targetInfo.targetId, flatten: true });
        return this._sessions.get(sessionId);
    }
    async createBrowserSession() {
        const { sessionId } = await this.rootSession.send('Target.attachToBrowserTarget');
        return this._sessions.get(sessionId);
    }
}
exports.CRConnection = CRConnection;
exports.CRSessionEvents = {
    Disconnected: Symbol('Events.CDPSession.Disconnected')
};
class CRSession extends events_1.EventEmitter {
    constructor(connection, rootSessionId, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._crashed = false;
        this.guid = `cdp-session@${sessionId}`;
        this.setMaxListeners(0);
        this._connection = connection;
        this._rootSessionId = rootSessionId;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    _markAsCrashed() {
        this._crashed = true;
    }
    async send(method, params) {
        if (this._crashed)
            throw new Error('Target crashed');
        if (this._browserDisconnectedLogs !== undefined)
            throw new Error(`Protocol error (${method}): Browser closed.` + this._browserDisconnectedLogs);
        if (!this._connection)
            throw new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`);
        const id = this._connection._rawSend(this._sessionId, method, params);
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    _sendMayFail(method, params) {
        return this.send(method, params).catch((error) => debugLogger_1.debugLogger.log('error', error));
    }
    _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object.error));
            else
                callback.resolve(object.result);
        }
        else {
            utils_1.assert(!object.id);
            Promise.resolve().then(() => {
                if (this._eventListener)
                    this._eventListener(object.method, object.params);
                this.emit(object.method, object.params);
            });
        }
    }
    async detach() {
        if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        const rootSession = this._connection.session(this._rootSessionId);
        if (!rootSession)
            throw new Error('Root session has been closed');
        await rootSession.send('Target.detachFromTarget', { sessionId: this._sessionId });
    }
    _onClosed(browserDisconnectedLogs) {
        this._browserDisconnectedLogs = browserDisconnectedLogs;
        const errorMessage = browserDisconnectedLogs !== undefined ? 'Browser closed.' + browserDisconnectedLogs : 'Target closed.';
        for (const callback of this._callbacks.values())
            callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): ` + errorMessage));
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(exports.CRSessionEvents.Disconnected));
    }
}
exports.CRSession = CRSession;
function createProtocolError(error, method, protocolError) {
    let message = `Protocol error (${method}): ${protocolError.message}`;
    if ('data' in protocolError)
        message += ` ${protocolError.data}`;
    return stackTrace_1.rewriteErrorMessage(error, message);
}
//# sourceMappingURL=crConnection.js.map

/***/ }),

/***/ 1319:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRCoverage = void 0;
const helper_1 = __nccwpck_require__(7951);
const utils_1 = __nccwpck_require__(6416);
class CRCoverage {
    constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
    }
    async startJSCoverage(options) {
        return await this._jsCoverage.start(options);
    }
    async stopJSCoverage() {
        return await this._jsCoverage.stop();
    }
    async startCSSCoverage(options) {
        return await this._cssCoverage.start(options);
    }
    async stopCSSCoverage() {
        return await this._cssCoverage.stop();
    }
}
exports.CRCoverage = CRCoverage;
class JSCoverage {
    constructor(client) {
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = new Set();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
    }
    async start(options = {}) {
        utils_1.assert(!this._enabled, 'JSCoverage is already enabled');
        const { resetOnNavigation = true, reportAnonymousScripts = false } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptIds.clear();
        this._scriptSources.clear();
        this._eventListeners = [
            helper_1.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
            helper_1.helper.addEventListener(this._client, 'Debugger.paused', this._onDebuggerPaused.bind(this)),
        ];
        await Promise.all([
            this._client.send('Profiler.enable'),
            this._client.send('Profiler.startPreciseCoverage', { callCount: true, detailed: true }),
            this._client.send('Debugger.enable'),
            this._client.send('Debugger.setSkipAllPauses', { skip: true })
        ]);
    }
    _onDebuggerPaused() {
        this._client.send('Debugger.resume');
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._scriptIds.clear();
        this._scriptSources.clear();
    }
    async _onScriptParsed(event) {
        this._scriptIds.add(event.scriptId);
        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.
        if (!event.url && !this._reportAnonymousScripts)
            return;
        // This might fail if the page has already navigated away.
        const response = await this._client._sendMayFail('Debugger.getScriptSource', { scriptId: event.scriptId });
        if (response)
            this._scriptSources.set(event.scriptId, response.scriptSource);
    }
    async stop() {
        utils_1.assert(this._enabled, 'JSCoverage is not enabled');
        this._enabled = false;
        const [profileResponse] = await Promise.all([
            this._client.send('Profiler.takePreciseCoverage'),
            this._client.send('Profiler.stopPreciseCoverage'),
            this._client.send('Profiler.disable'),
            this._client.send('Debugger.disable'),
        ]);
        helper_1.helper.removeEventListeners(this._eventListeners);
        const coverage = [];
        for (const entry of profileResponse.result) {
            if (!this._scriptIds.has(entry.scriptId))
                continue;
            if (!entry.url && !this._reportAnonymousScripts)
                continue;
            const source = this._scriptSources.get(entry.scriptId);
            if (source)
                coverage.push({ ...entry, source });
            else
                coverage.push(entry);
        }
        return coverage;
    }
}
class CSSCoverage {
    constructor(client) {
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
    }
    async start(options = {}) {
        utils_1.assert(!this._enabled, 'CSSCoverage is already enabled');
        const { resetOnNavigation = true } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [
            helper_1.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this._client.send('DOM.enable'),
            this._client.send('CSS.enable'),
            this._client.send('CSS.startRuleUsageTracking'),
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
    }
    async _onStyleSheet(event) {
        const header = event.header;
        // Ignore anonymous scripts
        if (!header.sourceURL)
            return;
        // This might fail if the page has already navigated away.
        const response = await this._client._sendMayFail('CSS.getStyleSheetText', { styleSheetId: header.styleSheetId });
        if (response) {
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
        }
    }
    async stop() {
        utils_1.assert(this._enabled, 'CSSCoverage is not enabled');
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');
        await Promise.all([
            this._client.send('CSS.disable'),
            this._client.send('DOM.disable'),
        ]);
        helper_1.helper.removeEventListeners(this._eventListeners);
        // aggregate by styleSheetId
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
                ranges = [];
                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
                startOffset: entry.startOffset,
                endOffset: entry.endOffset,
                count: entry.used ? 1 : 0,
            });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
    }
    // Sort points to form a valid parenthesis sequence.
    points.sort((a, b) => {
        // Sort with increasing offsets.
        if (a.offset !== b.offset)
            return a.offset - b.offset;
        // All "end" points should go before "start" points.
        if (a.type !== b.type)
            return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        // For two "start" points, the one with longer range goes first.
        if (a.type === 0)
            return bLength - aLength;
        // For two "end" points, the one with shorter range goes first.
        return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    // Run scanning line to intersect all ranges.
    for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
            const lastResult = results.length ? results[results.length - 1] : null;
            if (lastResult && lastResult.end === lastOffset)
                lastResult.end = point.offset;
            else
                results.push({ start: lastOffset, end: point.offset });
        }
        lastOffset = point.offset;
        if (point.type === 0)
            hitCountStack.push(point.range.count);
        else
            hitCountStack.pop();
    }
    // Filter out empty ranges.
    return results.filter(range => range.end - range.start > 1);
}
//# sourceMappingURL=crCoverage.js.map

/***/ }),

/***/ 4272:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRDevTools = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const kBindingName = '__pw_devtools__';
// This class intercepts preferences-related DevTools embedder methods
// and stores preferences as a json file in the browser installation directory.
class CRDevTools {
    constructor(preferencesPath) {
        this._preferencesPath = preferencesPath;
        this._savePromise = Promise.resolve();
    }
    install(session) {
        session.on('Runtime.bindingCalled', async (event) => {
            if (event.name !== kBindingName)
                return;
            const parsed = JSON.parse(event.payload);
            let result = undefined;
            if (this.__testHookOnBinding)
                this.__testHookOnBinding(parsed);
            if (parsed.method === 'getPreferences') {
                if (this._prefs === undefined) {
                    try {
                        const json = await fs_1.default.promises.readFile(this._preferencesPath, 'utf8');
                        this._prefs = JSON.parse(json);
                    }
                    catch (e) {
                        this._prefs = {};
                    }
                }
                result = this._prefs;
            }
            else if (parsed.method === 'setPreference') {
                this._prefs[parsed.params[0]] = parsed.params[1];
                this._save();
            }
            else if (parsed.method === 'removePreference') {
                delete this._prefs[parsed.params[0]];
                this._save();
            }
            else if (parsed.method === 'clearPreferences') {
                this._prefs = {};
                this._save();
            }
            session.send('Runtime.evaluate', {
                expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
                contextId: event.executionContextId
            }).catch(e => null);
        });
        Promise.all([
            session.send('Runtime.enable'),
            session.send('Runtime.addBinding', { name: kBindingName }),
            session.send('Page.enable'),
            session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      ` }),
            session.send('Runtime.runIfWaitingForDebugger'),
        ]).catch(e => null);
    }
    _save() {
        // Serialize saves to avoid corruption.
        this._savePromise = this._savePromise.then(async () => {
            await fs_1.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch(e => null);
        });
    }
}
exports.CRDevTools = CRDevTools;
//# sourceMappingURL=crDevTools.js.map

/***/ }),

/***/ 5220:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DragManager = void 0;
const utils_1 = __nccwpck_require__(6416);
const crProtocolHelper_1 = __nccwpck_require__(3089);
class DragManager {
    constructor(page) {
        this._dragState = null;
        this._lastPosition = { x: 0, y: 0 };
        this._crPage = page;
    }
    async cancelDrag() {
        if (!this._dragState)
            return false;
        await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
            type: 'dragCancel',
            x: this._lastPosition.x,
            y: this._lastPosition.y,
            data: {
                items: [],
                dragOperationsMask: 0xFFFF,
            }
        });
        this._dragState = null;
        return true;
    }
    async interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
        this._lastPosition = { x, y };
        if (this._dragState) {
            await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
                type: 'dragOver',
                x,
                y,
                data: this._dragState,
                modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
            });
            return;
        }
        if (button !== 'left')
            return moveCallback();
        const client = this._crPage._mainFrameSession._client;
        let onDragIntercepted;
        const dragInterceptedPromise = new Promise(x => onDragIntercepted = x);
        await Promise.all(this._crPage._page.frames().map(async (frame) => {
            await frame.nonStallingEvaluateInExistingContext((function () {
                let didStartDrag = Promise.resolve(false);
                let dragEvent = null;
                const dragListener = (event) => dragEvent = event;
                const mouseListener = () => {
                    didStartDrag = new Promise(callback => {
                        window.addEventListener('dragstart', dragListener, { once: true, capture: true });
                        setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
                    });
                };
                window.addEventListener('mousemove', mouseListener, { once: true, capture: true });
                window.__cleanupDrag = async () => {
                    const val = await didStartDrag;
                    window.removeEventListener('mousemove', mouseListener, { capture: true });
                    window.removeEventListener('dragstart', dragListener, { capture: true });
                    return val;
                };
            }).toString(), true, 'utility').catch(() => { });
        }));
        client.on('Input.dragIntercepted', onDragIntercepted);
        try {
            await client.send('Input.setInterceptDrags', { enabled: true });
        }
        catch {
            // If Input.setInterceptDrags is not supported, just do a regular move.
            // This can be removed once we stop supporting old Electron.
            client.off('Input.dragIntercepted', onDragIntercepted);
            return moveCallback();
        }
        await moveCallback();
        const expectingDrag = (await Promise.all(this._crPage._page.frames().map(async (frame) => {
            return frame.nonStallingEvaluateInExistingContext('window.__cleanupDrag && window.__cleanupDrag()', false, 'utility').catch(() => false);
        }))).some(x => x);
        this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;
        client.off('Input.dragIntercepted', onDragIntercepted);
        await client.send('Input.setInterceptDrags', { enabled: false });
        if (this._dragState) {
            await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
                type: 'dragEnter',
                x,
                y,
                data: this._dragState,
                modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
            });
        }
    }
    isDragging() {
        return !!this._dragState;
    }
    async drop(x, y, modifiers) {
        utils_1.assert(this._dragState, 'missing drag state');
        await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
            type: 'drop',
            x,
            y,
            data: this._dragState,
            modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
        });
        this._dragState = null;
    }
}
exports.DragManager = DragManager;
//# sourceMappingURL=crDragDrop.js.map

/***/ }),

/***/ 9262:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRExecutionContext = void 0;
const crProtocolHelper_1 = __nccwpck_require__(3089);
const js = __importStar(__nccwpck_require__(1762));
const stackTrace_1 = __nccwpck_require__(6010);
const utilityScriptSerializers_1 = __nccwpck_require__(4734);
class CRExecutionContext {
    constructor(client, contextPayload) {
        this._client = client;
        this._contextId = contextPayload.id;
    }
    async rawEvaluateJSON(expression) {
        const { exceptionDetails, result: remoteObject } = await this._client.send('Runtime.evaluate', {
            expression,
            contextId: this._contextId,
            returnByValue: true,
        }).catch(rewriteError);
        if (exceptionDetails)
            throw new Error('Evaluation failed: ' + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return remoteObject.value;
    }
    async rawEvaluateHandle(expression) {
        const { exceptionDetails, result: remoteObject } = await this._client.send('Runtime.evaluate', {
            expression,
            contextId: this._contextId,
        }).catch(rewriteError);
        if (exceptionDetails)
            throw new Error('Evaluation failed: ' + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return remoteObject.objectId;
    }
    rawCallFunctionNoReply(func, ...args) {
        this._client.send('Runtime.callFunctionOn', {
            functionDeclaration: func.toString(),
            arguments: args.map(a => a instanceof js.JSHandle ? { objectId: a._objectId } : { value: a }),
            returnByValue: true,
            executionContextId: this._contextId,
            userGesture: true
        }).catch(() => { });
    }
    async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        const { exceptionDetails, result: remoteObject } = await this._client.send('Runtime.callFunctionOn', {
            functionDeclaration: expression,
            objectId: utilityScript._objectId,
            arguments: [
                { objectId: utilityScript._objectId },
                ...values.map(value => ({ value })),
                ...objectIds.map(objectId => ({ objectId })),
            ],
            returnByValue,
            awaitPromise: true,
            userGesture: true
        }).catch(rewriteError);
        if (exceptionDetails)
            throw new Error('Evaluation failed: ' + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return returnByValue ? utilityScriptSerializers_1.parseEvaluationResultValue(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
    }
    async getProperties(context, objectId) {
        const response = await this._client.send('Runtime.getProperties', {
            objectId,
            ownProperties: true
        });
        const result = new Map();
        for (const property of response.result) {
            if (!property.enumerable || !property.value)
                continue;
            result.set(property.name, context.createHandle(property.value));
        }
        return result;
    }
    createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
    }
    async releaseHandle(objectId) {
        await crProtocolHelper_1.releaseObject(this._client, objectId);
    }
}
exports.CRExecutionContext = CRExecutionContext;
function rewriteError(error) {
    if (error.message.includes('Object reference chain is too long'))
        return { result: { type: 'undefined' } };
    if (error.message.includes('Object couldn\'t be returned by value'))
        return { result: { type: 'undefined' } };
    if (js.isContextDestroyedError(error) || error.message.endsWith('Inspected target navigated or closed'))
        throw new Error('Execution context was destroyed, most likely because of a navigation.');
    if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON'))
        stackTrace_1.rewriteErrorMessage(error, error.message + ' Are you passing a nested JSHandle?');
    throw error;
}
function potentiallyUnserializableValue(remoteObject) {
    const value = remoteObject.value;
    const unserializableValue = remoteObject.unserializableValue;
    return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
}
//# sourceMappingURL=crExecutionContext.js.map

/***/ }),

/***/ 6834:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;
const input = __importStar(__nccwpck_require__(487));
const macEditingCommands_1 = __nccwpck_require__(3377);
const utils_1 = __nccwpck_require__(6416);
const crProtocolHelper_1 = __nccwpck_require__(3089);
class RawKeyboardImpl {
    constructor(_client, _isMac, _dragManger) {
        this._client = _client;
        this._isMac = _isMac;
        this._dragManger = _dragManger;
    }
    _commandsForCode(code, modifiers) {
        if (!this._isMac)
            return [];
        const parts = [];
        for (const modifier of (['Shift', 'Control', 'Alt', 'Meta'])) {
            if (modifiers.has(modifier))
                parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join('+');
        let commands = macEditingCommands_1.macEditingCommands[shortcut] || [];
        if (utils_1.isString(commands))
            commands = [commands];
        // Commands that insert text are not supported
        commands = commands.filter(x => !x.startsWith('insert'));
        // remove the trailing : to match the Chromium command names.
        return commands.map(c => c.substring(0, c.length - 1));
    }
    async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
        if (code === 'Escape' && await this._dragManger.cancelDrag())
            return;
        const commands = this._commandsForCode(code, modifiers);
        await this._client.send('Input.dispatchKeyEvent', {
            type: text ? 'keyDown' : 'rawKeyDown',
            modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            commands,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            location,
            isKeypad: location === input.keypadLocation
        });
    }
    async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
        await this._client.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            location
        });
    }
    async sendText(text) {
        await this._client.send('Input.insertText', { text });
    }
}
exports.RawKeyboardImpl = RawKeyboardImpl;
class RawMouseImpl {
    constructor(page, client, dragManager) {
        this._page = page;
        this._client = client;
        this._dragManager = dragManager;
    }
    async move(x, y, button, buttons, modifiers) {
        await this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, async () => {
            await this._client.send('Input.dispatchMouseEvent', {
                type: 'mouseMoved',
                button,
                x,
                y,
                modifiers: crProtocolHelper_1.toModifiersMask(modifiers)
            });
        });
    }
    async down(x, y, button, buttons, modifiers, clickCount) {
        if (this._dragManager.isDragging())
            return;
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mousePressed',
            button,
            x,
            y,
            modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
            clickCount
        });
    }
    async up(x, y, button, buttons, modifiers, clickCount) {
        if (this._dragManager.isDragging()) {
            await this._dragManager.drop(x, y, modifiers);
            return;
        }
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseReleased',
            button,
            x,
            y,
            modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
            clickCount
        });
    }
}
exports.RawMouseImpl = RawMouseImpl;
class RawTouchscreenImpl {
    constructor(client) {
        this._client = client;
    }
    async tap(x, y, modifiers) {
        await Promise.all([
            this._client.send('Input.dispatchTouchEvent', {
                type: 'touchStart',
                modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
                touchPoints: [{
                        x, y
                    }]
            }),
            this._client.send('Input.dispatchTouchEvent', {
                type: 'touchEnd',
                modifiers: crProtocolHelper_1.toModifiersMask(modifiers),
                touchPoints: []
            }),
        ]);
    }
}
exports.RawTouchscreenImpl = RawTouchscreenImpl;
//# sourceMappingURL=crInput.js.map

/***/ }),

/***/ 550:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRNetworkManager = void 0;
const helper_1 = __nccwpck_require__(7951);
const network = __importStar(__nccwpck_require__(8781));
const utils_1 = __nccwpck_require__(6416);
class CRNetworkManager {
    constructor(client, page, parentManager) {
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._requestIdToRequestPausedEvent = new Map();
        this._requestIdToExtraInfo = new Map();
        this._client = client;
        this._page = page;
        this._parentManager = parentManager;
        this._eventListeners = this.instrumentNetworkEvents(client);
    }
    instrumentNetworkEvents(session, workerFrame) {
        return [
            helper_1.helper.addEventListener(session, 'Fetch.requestPaused', this._onRequestPaused.bind(this, workerFrame)),
            helper_1.helper.addEventListener(session, 'Fetch.authRequired', this._onAuthRequired.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this, workerFrame)),
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSentExtraInfo', this._onRequestWillBeSentExtraInfo.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.loadingFinished', this._onLoadingFinished.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.loadingFailed', this._onLoadingFailed.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.webSocketCreated', e => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)),
            helper_1.helper.addEventListener(session, 'Network.webSocketWillSendHandshakeRequest', e => this._page._frameManager.onWebSocketRequest(e.requestId)),
            helper_1.helper.addEventListener(session, 'Network.webSocketHandshakeResponseReceived', e => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
            helper_1.helper.addEventListener(session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
            helper_1.helper.addEventListener(session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
            helper_1.helper.addEventListener(session, 'Network.webSocketClosed', e => this._page._frameManager.webSocketClosed(e.requestId)),
            helper_1.helper.addEventListener(session, 'Network.webSocketFrameError', e => this._page._frameManager.webSocketError(e.requestId, e.errorMessage)),
        ];
    }
    async initialize() {
        await this._client.send('Network.enable');
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
    }
    async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
    }
    async setOffline(offline) {
        await this._client.send('Network.emulateNetworkConditions', {
            offline,
            // values of 0 remove any active throttling. crbug.com/456324#c9
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1
        });
    }
    async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
    }
    async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
            return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
            await Promise.all([
                this._client.send('Network.setCacheDisabled', { cacheDisabled: true }),
                this._client.send('Fetch.enable', {
                    handleAuthRequests: true,
                    patterns: [{ urlPattern: '*' }],
                }),
            ]);
        }
        else {
            await Promise.all([
                this._client.send('Network.setCacheDisabled', { cacheDisabled: false }),
                this._client.send('Fetch.disable')
            ]);
        }
    }
    _onRequestWillBeSent(workerFrame, event) {
        // Request interception doesn't happen for data URLs with Network Service.
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {
            const requestId = event.requestId;
            const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
            if (requestPausedEvent) {
                this._onRequest(workerFrame, event, requestPausedEvent);
                this._requestIdToRequestPausedEvent.delete(requestId);
            }
            else {
                this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
            }
        }
        else {
            this._onRequest(workerFrame, event, null);
        }
        const extraInfo = this._requestIdToExtraInfo.get(event.requestId);
        if (extraInfo)
            this._onRequestWillBeSentExtraInfo(extraInfo);
    }
    _onRequestWillBeSentExtraInfo(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request) {
            request.request.updateWithRawHeaders(utils_1.headersObjectToArray(event.headers));
            this._requestIdToExtraInfo.delete(event.requestId);
        }
        else {
            this._requestIdToExtraInfo.set(event.requestId, event);
        }
    }
    _onAuthRequired(event) {
        let response = 'Default';
        if (this._attemptedAuthentications.has(event.requestId)) {
            response = 'CancelAuth';
        }
        else if (this._credentials) {
            response = 'ProvideCredentials';
            this._attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this._credentials || { username: undefined, password: undefined };
        this._client._sendMayFail('Fetch.continueWithAuth', {
            requestId: event.requestId,
            authChallengeResponse: { response, username, password },
        });
    }
    _onRequestPaused(workerFrame, event) {
        if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
            this._client._sendMayFail('Fetch.continueRequest', {
                requestId: event.requestId
            });
        }
        if (!event.networkId) {
            // Fetch without networkId means that request was not recongnized by inspector, and
            // it will never receive Network.requestWillBeSent. Most likely, this is an internal request
            // that we can safely fail.
            this._client._sendMayFail('Fetch.failRequest', {
                requestId: event.requestId,
                errorReason: 'Aborted',
            });
            return;
        }
        if (event.request.url.startsWith('data:'))
            return;
        const requestId = event.networkId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
            this._onRequest(workerFrame, requestWillBeSentEvent, event);
            this._requestIdToRequestWillBeSentEvent.delete(requestId);
        }
        else {
            this._requestIdToRequestPausedEvent.set(requestId, event);
        }
    }
    _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {
        if (requestWillBeSentEvent.request.url.startsWith('data:'))
            return;
        let redirectedFrom = null;
        if (requestWillBeSentEvent.redirectResponse) {
            const request = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
            // If we connect late to the target, we could have missed the requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp);
                redirectedFrom = request.request;
            }
        }
        let frame = requestWillBeSentEvent.frameId ? this._page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame;
        // Requests from workers lack frameId, because we receive Network.requestWillBeSent
        // on the worker target. However, we receive Fetch.requestPaused on the page target,
        // and lack workerFrame there. Luckily, Fetch.requestPaused provides a frameId.
        if (!frame && requestPausedEvent && requestPausedEvent.frameId)
            frame = this._page._frameManager.frame(requestPausedEvent.frameId);
        // Check if it's main resource request interception (targetId === main frame id).
        if (!frame && requestWillBeSentEvent.frameId === this._page._delegate._targetId) {
            // Main resource request for the page is being intercepted so the Frame is not created
            // yet. Precreate it here for the purposes of request interception. It will be updated
            // later as soon as the request continues and we receive frame tree from the page.
            frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
        }
        // CORS options request is generated by the network stack. If interception is enabled,
        // we accept all CORS options, assuming that this was intended when setting route.
        //
        // Note: it would be better to match the URL against interception patterns, but
        // that information is only available to the client. Perhaps we can just route to the client?
        if (requestPausedEvent && requestPausedEvent.request.method === 'OPTIONS' && this._page._needsRequestInterception()) {
            const requestHeaders = requestPausedEvent.request.headers;
            const responseHeaders = [
                { name: 'Access-Control-Allow-Origin', value: requestHeaders['Origin'] || '*' },
                { name: 'Access-Control-Allow-Methods', value: requestHeaders['Access-Control-Request-Method'] || 'GET, POST, OPTIONS, DELETE' },
                { name: 'Access-Control-Allow-Credentials', value: 'true' }
            ];
            if (requestHeaders['Access-Control-Request-Headers'])
                responseHeaders.push({ name: 'Access-Control-Allow-Headers', value: requestHeaders['Access-Control-Request-Headers'] });
            this._client._sendMayFail('Fetch.fulfillRequest', {
                requestId: requestPausedEvent.requestId,
                responseCode: 204,
                responsePhrase: network.STATUS_TEXTS['204'],
                responseHeaders,
                body: '',
            });
            return;
        }
        if (!frame) {
            if (requestPausedEvent)
                this._client._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId });
            return;
        }
        let allowInterception = this._userRequestInterceptionEnabled;
        if (redirectedFrom) {
            allowInterception = false;
            // We do not support intercepting redirects.
            if (requestPausedEvent)
                this._client._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId });
        }
        const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
        const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : undefined;
        const request = new InterceptableRequest({
            client: this._client,
            frame,
            documentId,
            allowInterception,
            requestWillBeSentEvent,
            requestPausedEvent,
            redirectedFrom
        });
        this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _createResponse(request, responsePayload) {
        const getResponseBody = async () => {
            const response = await this._client.send('Network.getResponseBody', { requestId: request._requestId });
            return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
        };
        const timingPayload = responsePayload.timing;
        let timing;
        if (timingPayload) {
            timing = {
                startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1000,
                domainLookupStart: timingPayload.dnsStart,
                domainLookupEnd: timingPayload.dnsEnd,
                connectStart: timingPayload.connectStart,
                secureConnectionStart: timingPayload.sslStart,
                connectEnd: timingPayload.connectEnd,
                requestStart: timingPayload.sendStart,
                responseStart: timingPayload.receiveHeadersEnd,
            };
        }
        else {
            timing = {
                startTime: request._wallTime * 1000,
                domainLookupStart: -1,
                domainLookupEnd: -1,
                connectStart: -1,
                secureConnectionStart: -1,
                connectEnd: -1,
                requestStart: -1,
                responseStart: -1,
            };
        }
        return new network.Response(request.request, responsePayload.status, responsePayload.statusText, utils_1.headersObjectToArray(responsePayload.headers), timing, getResponseBody);
    }
    _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = this._createResponse(request, responsePayload);
        response._requestFinished((timestamp - request._timestamp) * 1000, 'Response body is unavailable for redirect responses');
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
            this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = this._createResponse(request, event.response);
        this._page._frameManager.requestReceivedResponse(response);
    }
    _onLoadingFinished(event) {
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
            request = this._maybeAdoptMainRequest(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        const response = request.request._existingResponse();
        if (response)
            response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
            this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestFinished(request.request);
    }
    _onLoadingFailed(event) {
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
            request = this._maybeAdoptMainRequest(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        const response = request.request._existingResponse();
        if (response)
            response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
            this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, !!event.canceled);
    }
    _maybeAdoptMainRequest(requestId) {
        // OOPIF has a main request that starts in the parent session but finishes in the child session.
        if (!this._parentManager)
            return;
        const request = this._parentManager._requestIdToRequest.get(requestId);
        // Main requests have matching loaderId and requestId.
        if (!request || request._documentId !== requestId)
            return;
        this._requestIdToRequest.set(requestId, request);
        this._parentManager._requestIdToRequest.delete(requestId);
        if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
            this._parentManager._attemptedAuthentications.delete(request._interceptionId);
            this._attemptedAuthentications.add(request._interceptionId);
        }
        return request;
    }
}
exports.CRNetworkManager = CRNetworkManager;
class InterceptableRequest {
    constructor(options) {
        const { client, frame, documentId, allowInterception, requestWillBeSentEvent, requestPausedEvent, redirectedFrom } = options;
        this._client = client;
        this._timestamp = requestWillBeSentEvent.timestamp;
        this._wallTime = requestWillBeSentEvent.wallTime;
        this._requestId = requestWillBeSentEvent.requestId;
        this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
        this._documentId = documentId;
        const { headers, method, url, postDataEntries = null, } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
        const type = (requestWillBeSentEvent.type || '').toLowerCase();
        let postDataBuffer = null;
        if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes)
            postDataBuffer = Buffer.from(postDataEntries[0].bytes, 'base64');
        this.request = new network.Request(allowInterception ? this : null, frame, redirectedFrom, documentId, url, type, method, postDataBuffer, utils_1.headersObjectToArray(headers));
    }
    async continue(overrides) {
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._client._sendMayFail('Fetch.continueRequest', {
            requestId: this._interceptionId,
            url: overrides.url,
            headers: overrides.headers,
            method: overrides.method,
            postData: overrides.postData ? overrides.postData.toString('base64') : undefined
        });
    }
    async fulfill(response) {
        const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._client._sendMayFail('Fetch.fulfillRequest', {
            requestId: this._interceptionId,
            responseCode: response.status,
            responsePhrase: network.STATUS_TEXTS[String(response.status)],
            responseHeaders: response.headers,
            body,
        });
    }
    async abort(errorCode = 'failed') {
        const errorReason = errorReasons[errorCode];
        utils_1.assert(errorReason, 'Unknown error code: ' + errorCode);
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._client._sendMayFail('Fetch.failRequest', {
            requestId: this._interceptionId,
            errorReason
        });
    }
}
const errorReasons = {
    'aborted': 'Aborted',
    'accessdenied': 'AccessDenied',
    'addressunreachable': 'AddressUnreachable',
    'blockedbyclient': 'BlockedByClient',
    'blockedbyresponse': 'BlockedByResponse',
    'connectionaborted': 'ConnectionAborted',
    'connectionclosed': 'ConnectionClosed',
    'connectionfailed': 'ConnectionFailed',
    'connectionrefused': 'ConnectionRefused',
    'connectionreset': 'ConnectionReset',
    'internetdisconnected': 'InternetDisconnected',
    'namenotresolved': 'NameNotResolved',
    'timedout': 'TimedOut',
    'failed': 'Failed',
};
//# sourceMappingURL=crNetworkManager.js.map

/***/ }),

/***/ 3380:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRPage = void 0;
const dom = __importStar(__nccwpck_require__(9418));
const helper_1 = __nccwpck_require__(7951);
const network = __importStar(__nccwpck_require__(8781));
const crConnection_1 = __nccwpck_require__(8899);
const crExecutionContext_1 = __nccwpck_require__(9262);
const crNetworkManager_1 = __nccwpck_require__(550);
const page_1 = __nccwpck_require__(9406);
const crProtocolHelper_1 = __nccwpck_require__(3089);
const dialog = __importStar(__nccwpck_require__(7639));
const path_1 = __importDefault(__nccwpck_require__(5622));
const crInput_1 = __nccwpck_require__(6834);
const crAccessibility_1 = __nccwpck_require__(7443);
const crCoverage_1 = __nccwpck_require__(1319);
const crPdf_1 = __nccwpck_require__(8826);
const crBrowser_1 = __nccwpck_require__(6419);
const console_1 = __nccwpck_require__(381);
const stackTrace_1 = __nccwpck_require__(6010);
const utils_1 = __nccwpck_require__(6416);
const videoRecorder_1 = __nccwpck_require__(6835);
const crDragDrop_1 = __nccwpck_require__(5220);
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
class CRPage {
    constructor(client, targetId, browserContext, opener, hasUIWindow, isBackgroundPage) {
        this._sessions = new Map();
        this._initializedPage = null;
        // Holds window features for the next popup being opened via window.open,
        // until the popup target arrives. This could be racy if two oopifs
        // simultaneously call window.open with window features: the order
        // of their Page.windowOpen events is not guaranteed to match the order
        // of new popup targets.
        this._nextWindowOpenPopupFeatures = [];
        this._targetId = targetId;
        this._opener = opener;
        this._isBackgroundPage = isBackgroundPage;
        const dragManager = new crDragDrop_1.DragManager(this);
        this.rawKeyboard = new crInput_1.RawKeyboardImpl(client, browserContext._browser._isMac, dragManager);
        this.rawMouse = new crInput_1.RawMouseImpl(this, client, dragManager);
        this.rawTouchscreen = new crInput_1.RawTouchscreenImpl(client);
        this._pdf = new crPdf_1.CRPDF(client);
        this._coverage = new crCoverage_1.CRCoverage(client);
        this._browserContext = browserContext;
        this._page = new page_1.Page(this, browserContext);
        this._mainFrameSession = new FrameSession(this, client, targetId, null);
        this._sessions.set(targetId, this._mainFrameSession);
        client.once(crConnection_1.CRSessionEvents.Disconnected, () => this._page._didDisconnect());
        if (opener && !browserContext._options.noDefaultViewport) {
            const features = opener._nextWindowOpenPopupFeatures.shift() || [];
            const viewportSize = helper_1.helper.getViewportSizeFromWindowFeatures(features);
            if (viewportSize)
                this._page._state.emulatedSize = { viewport: viewportSize, screen: viewportSize };
        }
        // Note: it is important to call |reportAsNew| before resolving pageOrError promise,
        // so that anyone who awaits pageOrError got a ready and reported page.
        this._pagePromise = this._mainFrameSession._initialize(hasUIWindow).then(async (r) => {
            await this._page.initOpener(this._opener);
            return r;
        }).catch(async (e) => {
            await this._page.initOpener(this._opener);
            throw e;
        }).then(() => {
            this._initializedPage = this._page;
            this._reportAsNew();
            return this._page;
        }).catch(e => {
            this._reportAsNew(e);
            return e;
        });
    }
    static mainFrameSession(page) {
        const crPage = page._delegate;
        return crPage._mainFrameSession;
    }
    _reportAsNew(error) {
        if (this._isBackgroundPage) {
            if (!error)
                this._browserContext.emit(crBrowser_1.CRBrowserContext.CREvents.BackgroundPage, this._page);
        }
        else {
            this._page.reportAsNew(error);
        }
    }
    async _forAllFrameSessions(cb) {
        const frameSessions = Array.from(this._sessions.values());
        await Promise.all(frameSessions.map(frameSession => {
            if (frameSession._isMainFrame())
                return cb(frameSession);
            return cb(frameSession).catch(e => {
                // Broadcasting a message to the closed iframe shoule be a noop.
                if (e.message && (e.message.includes('Target closed.') || e.message.includes('Session closed.')))
                    return;
                throw e;
            });
        }));
    }
    _sessionForFrame(frame) {
        // Frame id equals target id.
        while (!this._sessions.has(frame._id)) {
            const parent = frame.parentFrame();
            if (!parent)
                throw new Error(`Frame has been detached.`);
            frame = parent;
        }
        return this._sessions.get(frame._id);
    }
    _sessionForHandle(handle) {
        const frame = handle._context.frame;
        return this._sessionForFrame(frame);
    }
    willBeginDownload() {
        this._mainFrameSession._willBeginDownload();
    }
    async pageOrError() {
        return this._pagePromise;
    }
    didClose() {
        for (const session of this._sessions.values())
            session.dispose();
        this._page._didClose();
    }
    async navigateFrame(frame, url, referrer) {
        return this._sessionForFrame(frame)._navigate(frame, url, referrer);
    }
    async exposeBinding(binding) {
        await this._forAllFrameSessions(frame => frame._initBinding(binding));
        await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source, false, {}, binding.world).catch(e => { })));
    }
    async updateExtraHTTPHeaders() {
        await this._forAllFrameSessions(frame => frame._updateExtraHTTPHeaders(false));
    }
    async updateGeolocation() {
        await this._forAllFrameSessions(frame => frame._updateGeolocation(false));
    }
    async updateOffline() {
        await this._forAllFrameSessions(frame => frame._updateOffline(false));
    }
    async updateHttpCredentials() {
        await this._forAllFrameSessions(frame => frame._updateHttpCredentials(false));
    }
    async setEmulatedSize(emulatedSize) {
        utils_1.assert(this._page._state.emulatedSize === emulatedSize);
        await this._mainFrameSession._updateViewport();
    }
    async bringToFront() {
        await this._mainFrameSession._client.send('Page.bringToFront');
    }
    async updateEmulateMedia() {
        await this._forAllFrameSessions(frame => frame._updateEmulateMedia(false));
    }
    async updateRequestInterception() {
        await this._forAllFrameSessions(frame => frame._updateRequestInterception(false));
    }
    async setFileChooserIntercepted(enabled) {
        await this._forAllFrameSessions(frame => frame._setFileChooserIntercepted(enabled));
    }
    async reload() {
        await this._mainFrameSession._client.send('Page.reload');
    }
    async _go(delta) {
        const history = await this._mainFrameSession._client.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
            return false;
        await this._mainFrameSession._client.send('Page.navigateToHistoryEntry', { entryId: entry.id });
        return true;
    }
    goBack() {
        return this._go(-1);
    }
    goForward() {
        return this._go(+1);
    }
    async evaluateOnNewDocument(source, world = 'main') {
        await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(source, world));
    }
    async closePage(runBeforeUnload) {
        if (runBeforeUnload)
            await this._mainFrameSession._client.send('Page.close');
        else
            await this._browserContext._browser._closePage(this);
    }
    canScreenshotOutsideViewport() {
        return false;
    }
    async setBackgroundColor(color) {
        await this._mainFrameSession._client.send('Emulation.setDefaultBackgroundColorOverride', { color });
    }
    async takeScreenshot(progress, format, documentRect, viewportRect, quality) {
        const { visualViewport } = await this._mainFrameSession._client.send('Page.getLayoutMetrics');
        if (!documentRect) {
            documentRect = {
                x: visualViewport.pageX + viewportRect.x,
                y: visualViewport.pageY + viewportRect.y,
                ...helper_1.helper.enclosingIntSize({
                    width: viewportRect.width / visualViewport.scale,
                    height: viewportRect.height / visualViewport.scale,
                })
            };
        }
        // When taking screenshots with documentRect (based on the page content, not viewport),
        // ignore current page scale.
        const clip = { ...documentRect, scale: viewportRect ? visualViewport.scale : 1 };
        progress.throwIfAborted();
        const result = await this._mainFrameSession._client.send('Page.captureScreenshot', { format, quality, clip });
        return Buffer.from(result.data, 'base64');
    }
    async resetViewport() {
        await this._mainFrameSession._client.send('Emulation.setDeviceMetricsOverride', { mobile: false, width: 0, height: 0, deviceScaleFactor: 0 });
    }
    async getContentFrame(handle) {
        return this._sessionForHandle(handle)._getContentFrame(handle);
    }
    async getOwnerFrame(handle) {
        return this._sessionForHandle(handle)._getOwnerFrame(handle);
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        return this._sessionForHandle(handle)._getBoundingBox(handle);
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
    }
    async setScreencastOptions(options) {
        if (options) {
            await this._mainFrameSession._startScreencast(this, {
                format: 'jpeg',
                quality: options.quality,
                maxWidth: options.width,
                maxHeight: options.height
            });
        }
        else {
            await this._mainFrameSession._stopScreencast(this);
        }
    }
    rafCountForStablePosition() {
        return 1;
    }
    async getContentQuads(handle) {
        return this._sessionForHandle(handle)._getContentQuads(handle);
    }
    async setInputFiles(handle, files) {
        await handle.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), files);
    }
    async adoptElementHandle(handle, to) {
        return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
    }
    async getAccessibilityTree(needle) {
        return crAccessibility_1.getAccessibilityTree(this._mainFrameSession._client, needle);
    }
    async inputActionEpilogue() {
        await this._mainFrameSession._client.send('Page.enable').catch(e => { });
    }
    async pdf(options) {
        return this._pdf.generate(options);
    }
    coverage() {
        return this._coverage;
    }
    async getFrameElement(frame) {
        let parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const parentSession = this._sessionForFrame(parent);
        const { backendNodeId } = await parentSession._client.send('DOM.getFrameOwner', { frameId: frame._id }).catch(e => {
            if (e instanceof Error && e.message.includes('Frame with the given id was not found.'))
                stackTrace_1.rewriteErrorMessage(e, 'Frame has been detached.');
            throw e;
        });
        parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());
    }
}
exports.CRPage = CRPage;
class FrameSession {
    constructor(crPage, client, targetId, parentSession) {
        this._contextIdToContext = new Map();
        this._eventListeners = [];
        this._firstNonInitialNavigationCommittedFulfill = () => { };
        this._firstNonInitialNavigationCommittedReject = (e) => { };
        // Marks the oopif session that remote -> local transition has happened in the parent.
        // See Target.detachedFromTarget handler for details.
        this._swappedIn = false;
        this._videoRecorder = null;
        this._screencastId = null;
        this._screencastClients = new Set();
        this._client = client;
        this._crPage = crPage;
        this._page = crPage._page;
        this._targetId = targetId;
        this._networkManager = new crNetworkManager_1.CRNetworkManager(client, this._page, parentSession ? parentSession._networkManager : null);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
            this._firstNonInitialNavigationCommittedFulfill = f;
            this._firstNonInitialNavigationCommittedReject = r;
        });
        client.once(crConnection_1.CRSessionEvents.Disconnected, () => {
            this._firstNonInitialNavigationCommittedReject(new Error('Page closed'));
        });
    }
    _isMainFrame() {
        return this._targetId === this._crPage._targetId;
    }
    _addRendererListeners() {
        this._eventListeners.push(...[
            helper_1.helper.addEventListener(this._client, 'Log.entryAdded', event => this._onLogEntryAdded(event)),
            helper_1.helper.addEventListener(this._client, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)),
            helper_1.helper.addEventListener(this._client, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)),
            helper_1.helper.addEventListener(this._client, 'Page.frameDetached', event => this._onFrameDetached(event.frameId, event.reason)),
            helper_1.helper.addEventListener(this._client, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)),
            helper_1.helper.addEventListener(this._client, 'Page.frameRequestedNavigation', event => this._onFrameRequestedNavigation(event)),
            helper_1.helper.addEventListener(this._client, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)),
            helper_1.helper.addEventListener(this._client, 'Page.javascriptDialogOpening', event => this._onDialog(event)),
            helper_1.helper.addEventListener(this._client, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
            helper_1.helper.addEventListener(this._client, 'Runtime.bindingCalled', event => this._onBindingCalled(event)),
            helper_1.helper.addEventListener(this._client, 'Runtime.consoleAPICalled', event => this._onConsoleAPI(event)),
            helper_1.helper.addEventListener(this._client, 'Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', event => this._onExecutionContextsCleared()),
            helper_1.helper.addEventListener(this._client, 'Target.attachedToTarget', event => this._onAttachedToTarget(event)),
            helper_1.helper.addEventListener(this._client, 'Target.detachedFromTarget', event => this._onDetachedFromTarget(event)),
        ]);
    }
    _addBrowserListeners() {
        this._eventListeners.push(...[
            helper_1.helper.addEventListener(this._client, 'Inspector.targetCrashed', event => this._onTargetCrashed()),
            helper_1.helper.addEventListener(this._client, 'Page.screencastFrame', event => this._onScreencastFrame(event)),
            helper_1.helper.addEventListener(this._client, 'Page.windowOpen', event => this._onWindowOpen(event)),
        ]);
    }
    async _initialize(hasUIWindow) {
        if (hasUIWindow &&
            !this._crPage._browserContext._browser.isClank() &&
            !this._crPage._browserContext._options.noDefaultViewport) {
            const { windowId } = await this._client.send('Browser.getWindowForTarget');
            this._windowId = windowId;
        }
        let screencastOptions;
        if (this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
            const screencastId = utils_1.createGuid();
            const outputFile = path_1.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + '.webm');
            screencastOptions = {
                // validateBrowserContextOptions ensures correct video size.
                ...this._crPage._browserContext._options.recordVideo.size,
                outputFile,
            };
            await this._crPage._browserContext._ensureVideosPath();
            // Note: it is important to start video recorder before sending Page.startScreencast,
            // and it is equally important to send Page.startScreencast before sending Runtime.runIfWaitingForDebugger.
            await this._createVideoRecorder(screencastId, screencastOptions);
            this._crPage.pageOrError().then(p => {
                if (p instanceof Error)
                    this._stopVideoRecording().catch(() => { });
            });
        }
        let lifecycleEventsEnabled;
        if (!this._isMainFrame())
            this._addRendererListeners();
        this._addBrowserListeners();
        const promises = [
            this._client.send('Page.enable'),
            this._client.send('Page.getFrameTree').then(({ frameTree }) => {
                if (this._isMainFrame()) {
                    this._handleFrameTree(frameTree);
                    this._addRendererListeners();
                }
                const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
                for (const frame of localFrames) {
                    // Note: frames might be removed before we send these.
                    this._client._sendMayFail('Page.createIsolatedWorld', {
                        frameId: frame._id,
                        grantUniveralAccess: true,
                        worldName: UTILITY_WORLD_NAME,
                    });
                    for (const binding of this._crPage._browserContext._pageBindings.values())
                        frame.evaluateExpression(binding.source, false, undefined, binding.world).catch(e => { });
                    for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
                        frame.evaluateExpression(source, false, undefined, 'main').catch(e => { });
                }
                const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
                if (isInitialEmptyPage) {
                    // Ignore lifecycle events for the initial empty page. It is never the final page
                    // hence we are going to get more lifecycle updates after the actual navigation has
                    // started (even if the target url is about:blank).
                    lifecycleEventsEnabled.then(() => {
                        this._eventListeners.push(helper_1.helper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
                    });
                }
                else {
                    this._firstNonInitialNavigationCommittedFulfill();
                    this._eventListeners.push(helper_1.helper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
                }
            }),
            this._client.send('Log.enable', {}),
            lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
            this._client.send('Runtime.enable', {}),
            this._client.send('Page.addScriptToEvaluateOnNewDocument', {
                source: '',
                worldName: UTILITY_WORLD_NAME,
            }),
            this._networkManager.initialize(),
            this._client.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }),
        ];
        if (this._isMainFrame())
            promises.push(this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }));
        const options = this._crPage._browserContext._options;
        if (options.bypassCSP)
            promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
        if (options.ignoreHTTPSErrors)
            promises.push(this._client.send('Security.setIgnoreCertificateErrors', { ignore: true }));
        if (this._isMainFrame())
            promises.push(this._updateViewport());
        if (options.hasTouch)
            promises.push(this._client.send('Emulation.setTouchEmulationEnabled', { enabled: true }));
        if (options.javaScriptEnabled === false)
            promises.push(this._client.send('Emulation.setScriptExecutionDisabled', { value: true }));
        if (options.userAgent || options.locale)
            promises.push(this._client.send('Emulation.setUserAgentOverride', { userAgent: options.userAgent || '', acceptLanguage: options.locale }));
        if (options.locale)
            promises.push(emulateLocale(this._client, options.locale));
        if (options.timezoneId)
            promises.push(emulateTimezone(this._client, options.timezoneId));
        promises.push(this._updateGeolocation(true));
        promises.push(this._updateExtraHTTPHeaders(true));
        promises.push(this._updateRequestInterception(true));
        promises.push(this._updateOffline(true));
        promises.push(this._updateHttpCredentials(true));
        promises.push(this._updateEmulateMedia(true));
        for (const binding of this._crPage._page.allBindings())
            promises.push(this._initBinding(binding));
        for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
            promises.push(this._evaluateOnNewDocument(source, 'main'));
        for (const source of this._crPage._page._evaluateOnNewDocumentSources)
            promises.push(this._evaluateOnNewDocument(source, 'main'));
        if (screencastOptions)
            promises.push(this._startVideoRecording(screencastOptions));
        promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
        promises.push(this._firstNonInitialNavigationCommittedPromise);
        await Promise.all(promises);
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._crPage._sessions.delete(this._targetId);
    }
    async _navigate(frame, url, referrer) {
        const response = await this._client.send('Page.navigate', { url, referrer, frameId: frame._id });
        if (response.errorText)
            throw new Error(`${response.errorText} at ${url}`);
        return { newDocumentId: response.loaderId };
    }
    _onLifecycleEvent(event) {
        if (event.name === 'load')
            this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');
        else if (event.name === 'DOMContentLoaded')
            this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
    }
    _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
    }
    _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    _onFrameAttached(frameId, parentFrameId) {
        const frameSession = this._crPage._sessions.get(frameId);
        if (frameSession && frameId !== this._targetId) {
            // This is a remote -> local frame transition.
            frameSession._swappedIn = true;
            const frame = this._page._frameManager.frame(frameId);
            // Frame or even a whole subtree may be already gone, because some ancestor did navigate.
            if (frame)
                this._page._frameManager.removeChildFramesRecursively(frame);
            return;
        }
        if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
            // Parent frame may be gone already because some ancestor frame navigated and
            // destroyed the whole subtree of some oopif, while oopif's process is still sending us events.
            // Be careful to not confuse this with "main frame navigated cross-process" scenario
            // where parentFrameId is null.
            return;
        }
        this._page._frameManager.frameAttached(frameId, parentFrameId);
    }
    _onFrameNavigated(framePayload, initial) {
        if (!this._page._frameManager.frame(framePayload.id))
            return; // Subtree may be already gone because some ancestor navigation destroyed the oopif.
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
        if (!initial)
            this._firstNonInitialNavigationCommittedFulfill();
    }
    _onFrameRequestedNavigation(payload) {
        if (payload.disposition === 'currentTab')
            this._page._frameManager.frameRequestedNavigation(payload.frameId);
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
    }
    _onFrameDetached(frameId, reason) {
        if (this._crPage._sessions.has(frameId)) {
            // This is a local -> remote frame transtion, where
            // Page.frameDetached arrives after Target.attachedToTarget.
            // We've already handled the new target and frame reattach - nothing to do here.
            return;
        }
        if (reason === 'swap') {
            // This is a local -> remote frame transtion, where
            // Page.frameDetached arrives before Target.attachedToTarget.
            // We should keep the frame in the tree, and it will be used for the new target.
            const frame = this._page._frameManager.frame(frameId);
            if (frame)
                this._page._frameManager.removeChildFramesRecursively(frame);
            return;
        }
        // Just a regular frame detach.
        this._page._frameManager.frameDetached(frameId);
    }
    _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame)
            return;
        const delegate = new crExecutionContext_1.CRExecutionContext(this._client, contextPayload);
        let worldName = null;
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
            worldName = 'main';
        else if (contextPayload.name === UTILITY_WORLD_NAME)
            worldName = 'utility';
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        if (worldName)
            frame._contextCreated(worldName, context);
        this._contextIdToContext.set(contextPayload.id, context);
    }
    _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
    }
    _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
            this._onExecutionContextDestroyed(contextId);
    }
    _onAttachedToTarget(event) {
        const session = crConnection_1.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type === 'iframe') {
            // Frame id equals target id.
            const targetId = event.targetInfo.targetId;
            const frame = this._page._frameManager.frame(targetId);
            if (!frame)
                return; // Subtree may be already gone due to renderer/browser race.
            this._page._frameManager.removeChildFramesRecursively(frame);
            const frameSession = new FrameSession(this._crPage, session, targetId, this);
            this._crPage._sessions.set(targetId, frameSession);
            frameSession._initialize(false).catch(e => e);
            return;
        }
        if (event.targetInfo.type !== 'worker') {
            // Ideally, detaching should resume any target, but there is a bug in the backend.
            session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {
                this._client._sendMayFail('Target.detachFromTarget', { sessionId: event.sessionId });
            });
            return;
        }
        const url = event.targetInfo.url;
        const worker = new page_1.Worker(this._page, url);
        this._page._addWorker(event.sessionId, worker);
        session.once('Runtime.executionContextCreated', async (event) => {
            worker._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
        });
        // This might fail if the target is closed before we initialize.
        session._sendMayFail('Runtime.enable');
        session._sendMayFail('Network.enable');
        session._sendMayFail('Runtime.runIfWaitingForDebugger');
        session.on('Runtime.consoleAPICalled', event => {
            const args = event.args.map(o => worker._existingExecutionContext.createHandle(o));
            this._page._addConsoleMessage(event.type, args, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
        });
        session.on('Runtime.exceptionThrown', exception => this._page.emit(page_1.Page.Events.PageError, crProtocolHelper_1.exceptionToError(exception.exceptionDetails)));
        // TODO: attribute workers to the right frame.
        this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));
    }
    _onDetachedFromTarget(event) {
        // This might be a worker...
        this._page._removeWorker(event.sessionId);
        // ... or an oopif.
        const childFrameSession = this._crPage._sessions.get(event.targetId);
        if (!childFrameSession)
            return;
        // Usually, we get frameAttached in this session first and mark child as swappedIn.
        if (childFrameSession._swappedIn) {
            childFrameSession.dispose();
            return;
        }
        // However, sometimes we get detachedFromTarget before frameAttached.
        // In this case we don't know wheter this is a remote frame detach,
        // or just a remote -> local transition. In the latter case, frameAttached
        // is already inflight, so let's make a safe roundtrip to ensure it arrives.
        this._client.send('Page.enable').catch(e => null).then(() => {
            // Child was not swapped in - that means frameAttached did not happen and
            // this is remote detach rather than remote -> local swap.
            if (!childFrameSession._swappedIn)
                this._page._frameManager.frameDetached(event.targetId);
            childFrameSession.dispose();
        });
    }
    _onWindowOpen(event) {
        this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
    }
    async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
            // DevTools protocol stores the last 1000 console messages. These
            // messages are always reported even for removed execution contexts. In
            // this case, they are marked with executionContextId = 0 and are
            // reported upon enabling Runtime agent.
            //
            // Ignore these messages since:
            // - there's no execution context we can use to operate with message
            //   arguments
            // - these messages are reported before Playwright clients can subscribe
            //   to the 'console'
            //   page event.
            //
            // @see https://github.com/GoogleChrome/puppeteer/issues/3865
            return;
        }
        const context = this._contextIdToContext.get(event.executionContextId);
        const values = event.args.map(arg => context.createHandle(arg));
        this._page._addConsoleMessage(event.type, values, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
    }
    async _initBinding(binding) {
        const worldName = binding.world === 'utility' ? UTILITY_WORLD_NAME : undefined;
        await Promise.all([
            this._client.send('Runtime.addBinding', { name: binding.name, executionContextName: worldName }),
            this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: binding.source, worldName })
        ]);
    }
    async _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        const pageOrError = await this._crPage.pageOrError();
        if (!(pageOrError instanceof Error))
            await this._page._onBindingCalled(event.payload, context);
    }
    _onDialog(event) {
        if (!this._page._frameManager.frame(this._targetId))
            return; // Our frame/subtree may be gone already.
        this._page.emit(page_1.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
            await this._client.send('Page.handleJavaScriptDialog', { accept, promptText });
        }, event.defaultPrompt));
    }
    _handleException(exceptionDetails) {
        this._page.emit(page_1.Page.Events.PageError, crProtocolHelper_1.exceptionToError(exceptionDetails));
    }
    async _onTargetCrashed() {
        this._client._markAsCrashed();
        this._page._didCrash();
    }
    _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
            args.map(arg => crProtocolHelper_1.releaseObject(this._client, arg.objectId));
        if (source !== 'worker') {
            const location = {
                url: url || '',
                lineNumber: lineNumber || 0,
                columnNumber: 0,
            };
            this._page.emit(page_1.Page.Events.Console, new console_1.ConsoleMessage(this._page, level, text, [], location));
        }
    }
    async _onFileChooserOpened(event) {
        const frame = this._page._frameManager.frame(event.frameId);
        if (!frame)
            return;
        let handle;
        try {
            const utilityContext = await frame._utilityContext();
            handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);
        }
        catch (e) {
            // During async processing, frame/context may go away. We should not throw.
            return;
        }
        await this._page._onFileChooserOpened(handle);
    }
    _willBeginDownload() {
        const originPage = this._crPage._initializedPage;
        if (!originPage) {
            // Resume the page creation with an error. The page will automatically close right
            // after the download begins.
            this._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));
        }
    }
    _onScreencastFrame(payload) {
        this._client.send('Page.screencastFrameAck', { sessionId: payload.sessionId }).catch(() => { });
        const buffer = Buffer.from(payload.data, 'base64');
        this._page.emit(page_1.Page.Events.ScreencastFrame, {
            buffer,
            timestamp: payload.metadata.timestamp,
            width: payload.metadata.deviceWidth,
            height: payload.metadata.deviceHeight,
        });
    }
    async _createVideoRecorder(screencastId, options) {
        utils_1.assert(!this._screencastId);
        const ffmpegPath = this._crPage._browserContext._browser.options.registry.executablePath('ffmpeg');
        if (!ffmpegPath)
            throw new Error('ffmpeg executable was not found');
        if (!utils_1.canAccessFile(ffmpegPath)) {
            let message = '';
            switch (this._page._browserContext._options.sdkLanguage) {
                case 'python':
                    message = 'playwright install ffmpeg';
                    break;
                case 'python-async':
                    message = 'playwright install ffmpeg';
                    break;
                case 'javascript':
                    message = 'npx playwright install ffmpeg';
                    break;
                case 'java':
                    message = 'mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="install ffmpeg"';
                    break;
            }
            throw new Error(`
============================================================
  Please install ffmpeg in order to record video.

  $ ${message}
============================================================
      `);
        }
        this._videoRecorder = await videoRecorder_1.VideoRecorder.launch(this._crPage._page, ffmpegPath, options);
        this._screencastId = screencastId;
    }
    async _startVideoRecording(options) {
        const screencastId = this._screencastId;
        utils_1.assert(screencastId);
        this._page.once(page_1.Page.Events.Close, () => this._stopVideoRecording().catch(() => { }));
        const gotFirstFrame = new Promise(f => this._client.once('Page.screencastFrame', f));
        await this._startScreencast(this._videoRecorder, {
            format: 'jpeg',
            quality: 90,
            maxWidth: options.width,
            maxHeight: options.height,
        });
        // Wait for the first frame before reporting video to the client.
        gotFirstFrame.then(() => {
            this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options.outputFile, this._crPage.pageOrError());
        });
    }
    async _stopVideoRecording() {
        if (!this._screencastId)
            return;
        const screencastId = this._screencastId;
        this._screencastId = null;
        const recorder = this._videoRecorder;
        this._videoRecorder = null;
        await this._stopScreencast(recorder);
        await recorder.stop().catch(() => { });
        // Keep the video artifact in the map utntil encoding is fully finished, if the context
        // starts closing before the video is fully written to disk it will wait for it.
        const video = this._crPage._browserContext._browser._takeVideo(screencastId);
        video === null || video === void 0 ? void 0 : video.reportFinished();
    }
    async _startScreencast(client, options = {}) {
        this._screencastClients.add(client);
        if (this._screencastClients.size === 1)
            await this._client.send('Page.startScreencast', options);
    }
    async _stopScreencast(client) {
        this._screencastClients.delete(client);
        if (!this._screencastClients.size)
            await this._client._sendMayFail('Page.stopScreencast');
    }
    async _updateExtraHTTPHeaders(initial) {
        const headers = network.mergeHeaders([
            this._crPage._browserContext._options.extraHTTPHeaders,
            this._page._state.extraHTTPHeaders
        ]);
        if (!initial || headers.length)
            await this._client.send('Network.setExtraHTTPHeaders', { headers: utils_1.headersArrayToObject(headers, false /* lowerCase */) });
    }
    async _updateGeolocation(initial) {
        const geolocation = this._crPage._browserContext._options.geolocation;
        if (!initial || geolocation)
            await this._client.send('Emulation.setGeolocationOverride', geolocation || {});
    }
    async _updateOffline(initial) {
        const offline = !!this._crPage._browserContext._options.offline;
        if (!initial || offline)
            await this._networkManager.setOffline(offline);
    }
    async _updateHttpCredentials(initial) {
        const credentials = this._crPage._browserContext._options.httpCredentials || null;
        if (!initial || credentials)
            await this._networkManager.authenticate(credentials);
    }
    async _updateViewport() {
        if (this._crPage._browserContext._browser.isClank())
            return;
        utils_1.assert(this._isMainFrame());
        const options = this._crPage._browserContext._options;
        const emulatedSize = this._page._state.emulatedSize;
        if (emulatedSize === null)
            return;
        const viewportSize = emulatedSize.viewport;
        const screenSize = emulatedSize.screen;
        const isLandscape = viewportSize.width > viewportSize.height;
        const promises = [
            this._client.send('Emulation.setDeviceMetricsOverride', {
                mobile: !!options.isMobile,
                width: viewportSize.width,
                height: viewportSize.height,
                screenWidth: screenSize.width,
                screenHeight: screenSize.height,
                deviceScaleFactor: options.deviceScaleFactor || 1,
                screenOrientation: isLandscape ? { angle: 90, type: 'landscapePrimary' } : { angle: 0, type: 'portraitPrimary' },
            }),
        ];
        if (this._windowId) {
            let insets = { width: 0, height: 0 };
            if (this._crPage._browserContext._browser.options.headful) {
                // TODO: popup windows have their own insets.
                insets = { width: 24, height: 88 };
                if (process.platform === 'win32')
                    insets = { width: 16, height: 88 };
                else if (process.platform === 'linux')
                    insets = { width: 8, height: 85 };
                else if (process.platform === 'darwin')
                    insets = { width: 2, height: 80 };
            }
            promises.push(this.setWindowBounds({
                width: viewportSize.width + insets.width,
                height: viewportSize.height + insets.height
            }));
        }
        await Promise.all(promises);
    }
    async windowBounds() {
        const { bounds } = await this._client.send('Browser.getWindowBounds', {
            windowId: this._windowId
        });
        return bounds;
    }
    async setWindowBounds(bounds) {
        return await this._client.send('Browser.setWindowBounds', {
            windowId: this._windowId,
            bounds
        });
    }
    async _updateEmulateMedia(initial) {
        if (this._crPage._browserContext._browser.isClank())
            return;
        const colorScheme = this._page._state.colorScheme === null ? '' : this._page._state.colorScheme;
        const reducedMotion = this._page._state.reducedMotion === null ? '' : this._page._state.reducedMotion;
        const features = [
            { name: 'prefers-color-scheme', value: colorScheme },
            { name: 'prefers-reduced-motion', value: reducedMotion },
        ];
        // Empty string disables the override.
        await this._client.send('Emulation.setEmulatedMedia', { media: this._page._state.mediaType || '', features });
    }
    async _updateRequestInterception(initial) {
        await this._networkManager.setRequestInterception(this._page._needsRequestInterception());
    }
    async _setFileChooserIntercepted(enabled) {
        await this._client.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async _evaluateOnNewDocument(source, world) {
        const worldName = world === 'utility' ? UTILITY_WORLD_NAME : undefined;
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source, worldName });
    }
    async _getContentFrame(handle) {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: handle._objectId
        });
        if (!nodeInfo || typeof nodeInfo.node.frameId !== 'string')
            return null;
        return this._page._frameManager.frame(nodeInfo.node.frameId);
    }
    async _getOwnerFrame(handle) {
        // document.documentElement has frameId of the owner frame.
        const documentElement = await handle.evaluateHandle(node => {
            const doc = node;
            if (doc.documentElement && doc.documentElement.ownerDocument === doc)
                return doc.documentElement;
            return node.ownerDocument ? node.ownerDocument.documentElement : null;
        });
        if (!documentElement)
            return null;
        if (!documentElement._objectId)
            return null;
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: documentElement._objectId
        });
        const frameId = nodeInfo && typeof nodeInfo.node.frameId === 'string' ?
            nodeInfo.node.frameId : null;
        documentElement.dispose();
        return frameId;
    }
    async _getBoundingBox(handle) {
        const result = await this._client._sendMayFail('DOM.getBoxModel', {
            objectId: handle._objectId
        });
        if (!result)
            return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        const position = await this._framePosition();
        if (!position)
            return null;
        return { x: x + position.x, y: y + position.y, width, height };
    }
    async _framePosition() {
        const frame = this._page._frameManager.frame(this._targetId);
        if (!frame)
            return null;
        if (frame === this._page.mainFrame())
            return { x: 0, y: 0 };
        const element = await frame.frameElement();
        const box = await element.boundingBox();
        return box;
    }
    async _scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._client.send('DOM.scrollIntoViewIfNeeded', {
            objectId: handle._objectId,
            rect,
        }).then(() => 'done').catch(e => {
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                return 'error:notvisible';
            if (e instanceof Error && e.message.includes('Node is detached from document'))
                return 'error:notconnected';
            throw e;
        });
    }
    async _getContentQuads(handle) {
        const result = await this._client._sendMayFail('DOM.getContentQuads', {
            objectId: handle._objectId
        });
        if (!result)
            return null;
        const position = await this._framePosition();
        if (!position)
            return null;
        return result.quads.map(quad => [
            { x: quad[0] + position.x, y: quad[1] + position.y },
            { x: quad[2] + position.x, y: quad[3] + position.y },
            { x: quad[4] + position.x, y: quad[5] + position.y },
            { x: quad[6] + position.x, y: quad[7] + position.y }
        ]);
    }
    async _adoptElementHandle(handle, to) {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: handle._objectId,
        });
        return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
    }
    async _adoptBackendNodeId(backendNodeId, to) {
        const result = await this._client._sendMayFail('DOM.resolveNode', {
            backendNodeId,
            executionContextId: to._delegate._contextId,
        });
        if (!result || result.object.subtype === 'null')
            throw new Error(dom.kUnableToAdoptErrorMessage);
        return to.createHandle(result.object).asElement();
    }
}
async function emulateLocale(session, locale) {
    try {
        await session.send('Emulation.setLocaleOverride', { locale });
    }
    catch (exception) {
        // All pages in the same renderer share locale. All such pages belong to the same
        // context and if locale is overridden for one of them its value is the same as
        // we are trying to set so it's not a problem.
        if (exception.message.includes('Another locale override is already in effect'))
            return;
        throw exception;
    }
}
async function emulateTimezone(session, timezoneId) {
    try {
        await session.send('Emulation.setTimezoneOverride', { timezoneId: timezoneId });
    }
    catch (exception) {
        if (exception.message.includes('Timezone override is already in effect'))
            return;
        if (exception.message.includes('Invalid timezone'))
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
        throw exception;
    }
}
//# sourceMappingURL=crPage.js.map

/***/ }),

/***/ 8826:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CRPDF = void 0;
const utils_1 = __nccwpck_require__(6416);
const crProtocolHelper_1 = __nccwpck_require__(3089);
const PagePaperFormats = {
    letter: { width: 8.5, height: 11 },
    legal: { width: 8.5, height: 14 },
    tabloid: { width: 11, height: 17 },
    ledger: { width: 17, height: 11 },
    a0: { width: 33.1, height: 46.8 },
    a1: { width: 23.4, height: 33.1 },
    a2: { width: 16.54, height: 23.4 },
    a3: { width: 11.7, height: 16.54 },
    a4: { width: 8.27, height: 11.7 },
    a5: { width: 5.83, height: 8.27 },
    a6: { width: 4.13, height: 5.83 },
};
const unitToPixels = {
    'px': 1,
    'in': 96,
    'cm': 37.8,
    'mm': 3.78
};
function convertPrintParameterToInches(text) {
    if (text === undefined)
        return undefined;
    let unit = text.substring(text.length - 2).toLowerCase();
    let valueText = '';
    if (unitToPixels.hasOwnProperty(unit)) {
        valueText = text.substring(0, text.length - 2);
    }
    else {
        // In case of unknown unit try to parse the whole parameter as number of pixels.
        // This is consistent with phantom's paperSize behavior.
        unit = 'px';
        valueText = text;
    }
    const value = Number(valueText);
    utils_1.assert(!isNaN(value), 'Failed to parse parameter value: ' + text);
    const pixels = value * unitToPixels[unit];
    return pixels / 96;
}
class CRPDF {
    constructor(client) {
        this._client = client;
    }
    async generate(options = {}) {
        const { scale = 1, displayHeaderFooter = false, headerTemplate = '', footerTemplate = '', printBackground = false, landscape = false, pageRanges = '', preferCSSPageSize = false, margin = {}, } = options;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options.format) {
            const format = PagePaperFormats[options.format.toLowerCase()];
            utils_1.assert(format, 'Unknown paper format: ' + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
        }
        else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        const result = await this._client.send('Page.printToPDF', {
            transferMode: 'ReturnAsStream',
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize
        });
        return await crProtocolHelper_1.readProtocolStream(this._client, result.stream, null);
    }
}
exports.CRPDF = CRPDF;
//# sourceMappingURL=crPdf.js.map

/***/ }),

/***/ 3089:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toModifiersMask = exports.exceptionToError = exports.toConsoleMessageLocation = exports.readProtocolStream = exports.releaseObject = exports.getExceptionMessage = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const utils_1 = __nccwpck_require__(6416);
const stackTrace_1 = __nccwpck_require__(6010);
function getExceptionMessage(exceptionDetails) {
    if (exceptionDetails.exception)
        return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
    let message = exceptionDetails.text;
    if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
            const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;
            const functionName = callframe.functionName || '<anonymous>';
            message += `\n    at ${functionName} (${location})`;
        }
    }
    return message;
}
exports.getExceptionMessage = getExceptionMessage;
async function releaseObject(client, objectId) {
    await client.send('Runtime.releaseObject', { objectId }).catch(error => { });
}
exports.releaseObject = releaseObject;
async function readProtocolStream(client, handle, path) {
    let eof = false;
    let fd;
    if (path) {
        await utils_1.mkdirIfNeeded(path);
        fd = await fs_1.default.promises.open(path, 'w');
    }
    const bufs = [];
    while (!eof) {
        const response = await client.send('IO.read', { handle });
        eof = response.eof;
        const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);
        bufs.push(buf);
        if (fd)
            await fd.write(buf);
    }
    if (fd)
        await fd.close();
    await client.send('IO.close', { handle });
    return Buffer.concat(bufs);
}
exports.readProtocolStream = readProtocolStream;
function toConsoleMessageLocation(stackTrace) {
    return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber,
    } : { url: '', lineNumber: 0, columnNumber: 0 };
}
exports.toConsoleMessageLocation = toConsoleMessageLocation;
function exceptionToError(exceptionDetails) {
    const messageWithStack = getExceptionMessage(exceptionDetails);
    const lines = messageWithStack.split('\n');
    const firstStackTraceLine = lines.findIndex(line => line.startsWith('    at'));
    let messageWithName = '';
    let stack = '';
    if (firstStackTraceLine === -1) {
        messageWithName = messageWithStack;
    }
    else {
        messageWithName = lines.slice(0, firstStackTraceLine).join('\n');
        stack = messageWithStack;
    }
    const { name, message } = stackTrace_1.splitErrorMessage(messageWithName);
    const err = new Error(message);
    err.stack = stack;
    err.name = name;
    return err;
}
exports.exceptionToError = exceptionToError;
function toModifiersMask(modifiers) {
    let mask = 0;
    if (modifiers.has('Alt'))
        mask |= 1;
    if (modifiers.has('Control'))
        mask |= 2;
    if (modifiers.has('Meta'))
        mask |= 4;
    if (modifiers.has('Shift'))
        mask |= 8;
    return mask;
}
exports.toModifiersMask = toModifiersMask;
//# sourceMappingURL=crProtocolHelper.js.map

/***/ }),

/***/ 4655:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findChromiumChannel = void 0;
const path_1 = __importDefault(__nccwpck_require__(5622));
const utils_1 = __nccwpck_require__(6416);
function darwin(channel) {
    switch (channel) {
        case 'chrome': return ['/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'];
        case 'chrome-beta': return ['/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta'];
        case 'chrome-dev': return ['/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev'];
        case 'chrome-canary': return ['/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary'];
        case 'msedge': return ['/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'];
        case 'msedge-beta': return ['/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta'];
        case 'msedge-dev': return ['/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev'];
        case 'msedge-canary': return ['/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary'];
    }
}
function linux(channel) {
    switch (channel) {
        case 'chrome': return ['/opt/google/chrome/chrome'];
        case 'chrome-beta': return ['/opt/google/chrome-beta/chrome'];
        case 'chrome-dev': return ['/opt/google/chrome-unstable/chrome'];
        case 'msedge-dev': return ['/opt/microsoft/msedge-dev/msedge'];
    }
}
function win32(channel) {
    let suffix;
    switch (channel) {
        case 'chrome':
            suffix = `\\Google\\Chrome\\Application\\chrome.exe`;
            break;
        case 'chrome-beta':
            suffix = `\\Google\\Chrome Beta\\Application\\chrome.exe`;
            break;
        case 'chrome-dev':
            suffix = `\\Google\\Chrome Dev\\Application\\chrome.exe`;
            break;
        case 'chrome-canary':
            suffix = `\\Google\\Chrome SxS\\Application\\chrome.exe`;
            break;
        case 'msedge':
            suffix = `\\Microsoft\\Edge\\Application\\msedge.exe`;
            break;
        case 'msedge-beta':
            suffix = `\\Microsoft\\Edge Beta\\Application\\msedge.exe`;
            break;
        case 'msedge-dev':
            suffix = `\\Microsoft\\Edge Dev\\Application\\msedge.exe`;
            break;
        case 'msedge-canary':
            suffix = `\\Microsoft\\Edge SxS\\Application\\msedge.exe`;
            break;
    }
    if (!suffix)
        return;
    const prefixes = [
        process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env['PROGRAMFILES(X86)']
    ].filter(Boolean);
    return prefixes.map(prefix => path_1.default.join(prefix, suffix));
}
function findChromiumChannel(channel) {
    let installationPaths;
    if (process.platform === 'linux')
        installationPaths = linux(channel);
    else if (process.platform === 'win32')
        installationPaths = win32(channel);
    else if (process.platform === 'darwin')
        installationPaths = darwin(channel);
    if (!installationPaths)
        throw new Error(`Chromium distribution '${channel}' is not supported on ${process.platform}`);
    let result;
    installationPaths.forEach(chromePath => {
        if (utils_1.canAccessFile(chromePath))
            result = chromePath;
    });
    if (result)
        return result;
    throw new Error(`Chromium distribution is not installed on the system: ${channel}`);
}
exports.findChromiumChannel = findChromiumChannel;
//# sourceMappingURL=findChromiumChannel.js.map

/***/ }),

/***/ 6835:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VideoRecorder = void 0;
const utils_1 = __nccwpck_require__(6416);
const page_1 = __nccwpck_require__(9406);
const processLauncher_1 = __nccwpck_require__(9690);
const progress_1 = __nccwpck_require__(6707);
const instrumentation_1 = __nccwpck_require__(7490);
const fps = 25;
class VideoRecorder {
    constructor(page, ffmpegPath, progress) {
        this._process = null;
        this._gracefullyClose = null;
        this._lastWritePromise = Promise.resolve();
        this._lastFrameTimestamp = 0;
        this._lastFrameBuffer = null;
        this._lastWriteTimestamp = 0;
        this._frameQueue = [];
        this._isStopped = false;
        this._progress = progress;
        this._ffmpegPath = ffmpegPath;
        page.on(page_1.Page.Events.ScreencastFrame, frame => this.writeFrame(frame.buffer, frame.timestamp));
    }
    static async launch(page, ffmpegPath, options) {
        if (!options.outputFile.endsWith('.webm'))
            throw new Error('File must have .webm extension');
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), page);
        controller.setLogName('browser');
        return await controller.run(async (progress) => {
            const recorder = new VideoRecorder(page, ffmpegPath, progress);
            await recorder._launch(options);
            return recorder;
        });
    }
    async _launch(options) {
        // How to tune the codec:
        // 1. Read vp8 documentation to figure out the options.
        //   https://www.webmproject.org/docs/encoder-parameters/
        // 2. Use the following command to map the options to ffmpeg arguments.
        //   $ ./third_party/ffmpeg/ffmpeg-mac -h encoder=vp8
        // 3. A bit more about passing vp8 options to ffmpeg.
        //   https://trac.ffmpeg.org/wiki/Encode/VP8
        //
        // We use the following vp8 options:
        //   "-qmin 0 -qmax 50" - quality variation from 0 to 50.
        //     Suggested here: https://trac.ffmpeg.org/wiki/Encode/VP8
        //   "-crf 8" - constant quality mode, 4-63, lower means better quality.
        //   "-deadline realtime" - do not use too much cpu to keep up with incoming frames.
        //   "-b:v 1M" - video bitrate. Default value is too low for vp8
        //     Suggested here: https://trac.ffmpeg.org/wiki/Encode/VP8
        //
        // We use "pad" and "crop" video filters (-vf option) to resize incoming frames
        // that might be of the different size to the desired video size.
        //   https://ffmpeg.org/ffmpeg-filters.html#pad-1
        //   https://ffmpeg.org/ffmpeg-filters.html#crop
        //
        // We use "image2pipe" mode to pipe frames and get a single video.
        // "-f image2pipe -c:v mjpeg -i -" forces input to be read from standard input, and forces
        // mjpeg input image format.
        //   https://trac.ffmpeg.org/wiki/Slideshow
        //
        // "-y" means overwrite output.
        // "-an" means no audio.
        const w = options.width;
        const h = options.height;
        const args = `-loglevel error -f image2pipe -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -b:v 1M -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(' ');
        args.push(options.outputFile);
        const progress = this._progress;
        const { launchedProcess, gracefullyClose } = await processLauncher_1.launchProcess({
            executablePath: this._ffmpegPath,
            args,
            stdio: 'stdin',
            log: (message) => progress.log(message),
            tempDirectories: [],
            attemptToGracefullyClose: async () => {
                progress.log('Closing stdin...');
                launchedProcess.stdin.end();
            },
            onExit: (exitCode, signal) => {
                progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
            },
        });
        launchedProcess.stdin.on('finish', () => {
            progress.log('ffmpeg finished input.');
        });
        launchedProcess.stdin.on('error', () => {
            progress.log('ffmpeg error.');
        });
        this._process = launchedProcess;
        this._gracefullyClose = gracefullyClose;
    }
    writeFrame(frame, timestamp) {
        utils_1.assert(this._process);
        if (this._isStopped)
            return;
        this._progress.log(`writing frame ` + timestamp);
        if (this._lastFrameBuffer) {
            const durationSec = timestamp - this._lastFrameTimestamp;
            const repeatCount = Math.max(1, Math.round(fps * durationSec));
            for (let i = 0; i < repeatCount; ++i)
                this._frameQueue.push(this._lastFrameBuffer);
            this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
        }
        this._lastFrameBuffer = frame;
        this._lastFrameTimestamp = timestamp;
        this._lastWriteTimestamp = utils_1.monotonicTime();
    }
    async _sendFrames() {
        while (this._frameQueue.length)
            await this._sendFrame(this._frameQueue.shift());
    }
    async _sendFrame(frame) {
        return new Promise(f => this._process.stdin.write(frame, f)).then(error => {
            if (error)
                this._progress.log(`ffmpeg failed to write: ${error}`);
        });
    }
    async stop() {
        if (this._isStopped)
            return;
        this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + (utils_1.monotonicTime() - this._lastWriteTimestamp) / 1000);
        this._isStopped = true;
        await this._lastWritePromise;
        await this._gracefullyClose();
    }
}
exports.VideoRecorder = VideoRecorder;
//# sourceMappingURL=videoRecorder.js.map

/***/ }),

/***/ 2140:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeSelector = exports.parseCSS = void 0;
const css = __importStar(__nccwpck_require__(610));
function parseCSS(selector, customNames) {
    let tokens;
    try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
            tokens.push(new css.EOFToken());
    }
    catch (e) {
        const newMessage = e.message + ` while parsing selector "${selector}"`;
        const index = (e.stack || '').indexOf(e.message);
        if (index !== -1)
            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
    }
    const unsupportedToken = tokens.find(token => {
        return (token instanceof css.AtKeywordToken) ||
            (token instanceof css.BadStringToken) ||
            (token instanceof css.BadURLToken) ||
            (token instanceof css.ColumnToken) ||
            (token instanceof css.CDOToken) ||
            (token instanceof css.CDCToken) ||
            (token instanceof css.SemicolonToken) ||
            // TODO: Consider using these for something, e.g. to escape complex strings.
            // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
            // Or this way :xpath( {complex-xpath-goes-here("hello")} )
            (token instanceof css.OpenCurlyToken) ||
            (token instanceof css.CloseCurlyToken) ||
            // TODO: Consider treating these as strings?
            (token instanceof css.URLToken) ||
            (token instanceof css.PercentageToken);
    });
    if (unsupportedToken)
        throw new Error(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
    let pos = 0;
    const names = new Set();
    function unexpected() {
        return new Error(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
    }
    function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
            pos++;
    }
    function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
    }
    function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
    }
    function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
    }
    function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
    }
    function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
    }
    function isStar(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';
    }
    function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
    }
    function isClauseCombinator(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));
    }
    function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);
    }
    function consumeFunctionArguments() {
        const result = [consumeArgument()];
        while (true) {
            skipWhitespace();
            if (!isComma())
                break;
            pos++;
            result.push(consumeArgument());
        }
        return result;
    }
    function consumeArgument() {
        skipWhitespace();
        if (isNumber())
            return tokens[pos++].value;
        if (isString())
            return tokens[pos++].value;
        return consumeComplexSelector();
    }
    function consumeComplexSelector() {
        skipWhitespace();
        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };
        while (true) {
            skipWhitespace();
            if (isClauseCombinator()) {
                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;
                skipWhitespace();
            }
            else if (isSelectorClauseEnd()) {
                break;
            }
            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });
        }
        return result;
    }
    function consumeSimpleSelector() {
        let rawCSSString = '';
        const functions = [];
        while (!isSelectorClauseEnd()) {
            if (isIdent() || isStar()) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if (tokens[pos] instanceof css.HashToken) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {
                pos++;
                if (isIdent())
                    rawCSSString += '.' + tokens[pos++].toSource();
                else
                    throw unexpected();
            }
            else if (tokens[pos] instanceof css.ColonToken) {
                pos++;
                if (isIdent()) {
                    if (!customNames.has(tokens[pos].value.toLowerCase())) {
                        rawCSSString += ':' + tokens[pos++].toSource();
                    }
                    else {
                        const name = tokens[pos++].value.toLowerCase();
                        functions.push({ name, args: [] });
                        names.add(name);
                    }
                }
                else if (tokens[pos] instanceof css.FunctionToken) {
                    const name = tokens[pos++].value.toLowerCase();
                    if (!customNames.has(name)) {
                        rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
                    }
                    else {
                        functions.push({ name, args: consumeFunctionArguments() });
                        names.add(name);
                    }
                    skipWhitespace();
                    if (!isCloseParen())
                        throw unexpected();
                    pos++;
                }
                else {
                    throw unexpected();
                }
            }
            else if (tokens[pos] instanceof css.OpenSquareToken) {
                rawCSSString += '[';
                pos++;
                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
                    rawCSSString += tokens[pos++].toSource();
                if (!(tokens[pos] instanceof css.CloseSquareToken))
                    throw unexpected();
                rawCSSString += ']';
                pos++;
            }
            else {
                throw unexpected();
            }
        }
        if (!rawCSSString && !functions.length)
            throw unexpected();
        return { css: rawCSSString || undefined, functions };
    }
    function consumeBuiltinFunctionArguments() {
        let s = '';
        while (!isCloseParen() && !isEOF())
            s += tokens[pos++].toSource();
        return s;
    }
    const result = consumeFunctionArguments();
    if (!isEOF())
        throw new Error(`Error while parsing selector "${selector}"`);
    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))
        throw new Error(`Error while parsing selector "${selector}"`);
    return { selector: result, names: Array.from(names) };
}
exports.parseCSS = parseCSS;
function serializeSelector(args) {
    return args.map(arg => {
        if (typeof arg === 'string')
            return `"${arg}"`;
        if (typeof arg === 'number')
            return String(arg);
        return arg.simples.map(({ selector, combinator }) => {
            let s = selector.css || '';
            s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');
            if (combinator)
                s += ' ' + combinator;
            return s;
        }).join(' ');
    }).join(', ');
}
exports.serializeSelector = serializeSelector;
//# sourceMappingURL=cssParser.js.map

/***/ }),

/***/ 610:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/*
 * Original at https://github.com/tabatkins/parse-css
 * licensed under http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Changes from https://github.com/tabatkins/parse-css
//   - Tabs are replaced with two spaces.
//   - Everything not related to tokenizing - below the first exports block - is removed.
// @ts-nocheck
(function (root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    }
    else if (true) {
        factory(exports);
    }
    else {}
}(this, function (exports) {
    var between = function (num, first, last) { return num >= first && num <= last; };
    function digit(code) { return between(code, 0x30, 0x39); }
    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }
    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }
    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }
    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
    function nonascii(code) { return code >= 0x80; }
    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }
    function newline(code) { return code == 0xa; }
    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
    function badescape(code) { return newline(code) || isNaN(code); }
    var maximumallowedcodepoint = 0x10ffff;
    var InvalidCharacterError = function (message) {
        this.message = message;
    };
    InvalidCharacterError.prototype = new Error;
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';
    function preprocess(str) {
        // Turn a string into an array of code points,
        // following the preprocessing cleanup rules.
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {
                code = 0xa;
                i++;
            }
            if (code == 0xd || code == 0xc)
                code = 0xa;
            if (code == 0x0)
                code = 0xfffd;
            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {
                // Decode a surrogate pair into an astral codepoint.
                var lead = code - 0xd800;
                var trail = str.charCodeAt(i + 1) - 0xdc00;
                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
                i++;
            }
            codepoints.push(code);
        }
        return codepoints;
    }
    function stringFromCode(code) {
        if (code <= 0xffff)
            return String.fromCharCode(code);
        // Otherwise, encode astral char as surrogate pair.
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
        var trail = code % Math.pow(2, 10) + 0xdc00;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
    }
    function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        // Line number information.
        var line = 0;
        var column = 0;
        // The only use of lastLineLength is in reconsume().
        var lastLineLength = 0;
        var incrLineno = function () {
            line += 1;
            lastLineLength = column;
            column = 0;
        };
        var locStart = { line: line, column: column };
        var codepoint = function (i) {
            if (i >= str.length) {
                return -1;
            }
            return str[i];
        };
        var next = function (num) {
            if (num === undefined)
                num = 1;
            if (num > 3)
                throw "Spec Error: no more than three codepoints of lookahead.";
            return codepoint(i + num);
        };
        var consume = function (num) {
            if (num === undefined)
                num = 1;
            i += num;
            code = codepoint(i);
            if (newline(code))
                incrLineno();
            else
                column += num;
            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
            return true;
        };
        var reconsume = function () {
            i -= 1;
            if (newline(code)) {
                line -= 1;
                column = lastLineLength;
            }
            else {
                column -= 1;
            }
            locStart.line = line;
            locStart.column = column;
            return true;
        };
        var eof = function (codepoint) {
            if (codepoint === undefined)
                codepoint = code;
            return codepoint == -1;
        };
        var donothing = function () { };
        var parseerror = function () { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + "."); return true; };
        var consumeAToken = function () {
            consumeComments();
            consume();
            if (whitespace(code)) {
                while (whitespace(next()))
                    consume();
                return new WhitespaceToken;
            }
            else if (code == 0x22)
                return consumeAStringToken();
            else if (code == 0x23) {
                if (namechar(next()) || areAValidEscape(next(1), next(2))) {
                    var token = new HashToken();
                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                        token.type = "id";
                    token.value = consumeAName();
                    return token;
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x24) {
                if (next() == 0x3d) {
                    consume();
                    return new SuffixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x27)
                return consumeAStringToken();
            else if (code == 0x28)
                return new OpenParenToken();
            else if (code == 0x29)
                return new CloseParenToken();
            else if (code == 0x2a) {
                if (next() == 0x3d) {
                    consume();
                    return new SubstringMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2b) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2c)
                return new CommaToken();
            else if (code == 0x2d) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else if (next(1) == 0x2d && next(2) == 0x3e) {
                    consume(2);
                    return new CDCToken();
                }
                else if (startsWithAnIdentifier()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2e) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x3a)
                return new ColonToken;
            else if (code == 0x3b)
                return new SemicolonToken;
            else if (code == 0x3c) {
                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
                    consume(3);
                    return new CDOToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x40) {
                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                    return new AtKeywordToken(consumeAName());
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5b)
                return new OpenSquareToken();
            else if (code == 0x5c) {
                if (startsWithAValidEscape()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    parseerror();
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5d)
                return new CloseSquareToken();
            else if (code == 0x5e) {
                if (next() == 0x3d) {
                    consume();
                    return new PrefixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7b)
                return new OpenCurlyToken();
            else if (code == 0x7c) {
                if (next() == 0x3d) {
                    consume();
                    return new DashMatchToken();
                }
                else if (next() == 0x7c) {
                    consume();
                    return new ColumnToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7d)
                return new CloseCurlyToken();
            else if (code == 0x7e) {
                if (next() == 0x3d) {
                    consume();
                    return new IncludeMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (digit(code)) {
                reconsume();
                return consumeANumericToken();
            }
            else if (namestartchar(code)) {
                reconsume();
                return consumeAnIdentlikeToken();
            }
            else if (eof())
                return new EOFToken();
            else
                return new DelimToken(code);
        };
        var consumeComments = function () {
            while (next(1) == 0x2f && next(2) == 0x2a) {
                consume(2);
                while (true) {
                    consume();
                    if (code == 0x2a && next() == 0x2f) {
                        consume();
                        break;
                    }
                    else if (eof()) {
                        parseerror();
                        return;
                    }
                }
            }
        };
        var consumeANumericToken = function () {
            var num = consumeANumber();
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                var token = new DimensionToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                token.unit = consumeAName();
                return token;
            }
            else if (next() == 0x25) {
                consume();
                var token = new PercentageToken();
                token.value = num.value;
                token.repr = num.repr;
                return token;
            }
            else {
                var token = new NumberToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                return token;
            }
        };
        var consumeAnIdentlikeToken = function () {
            var str = consumeAName();
            if (str.toLowerCase() == "url" && next() == 0x28) {
                consume();
                while (whitespace(next(1)) && whitespace(next(2)))
                    consume();
                if (next() == 0x22 || next() == 0x27) {
                    return new FunctionToken(str);
                }
                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
                    return new FunctionToken(str);
                }
                else {
                    return consumeAURLToken();
                }
            }
            else if (next() == 0x28) {
                consume();
                return new FunctionToken(str);
            }
            else {
                return new IdentToken(str);
            }
        };
        var consumeAStringToken = function (endingCodePoint) {
            if (endingCodePoint === undefined)
                endingCodePoint = code;
            var string = "";
            while (consume()) {
                if (code == endingCodePoint || eof()) {
                    return new StringToken(string);
                }
                else if (newline(code)) {
                    parseerror();
                    reconsume();
                    return new BadStringToken();
                }
                else if (code == 0x5c) {
                    if (eof(next())) {
                        donothing();
                    }
                    else if (newline(next())) {
                        consume();
                    }
                    else {
                        string += stringFromCode(consumeEscape());
                    }
                }
                else {
                    string += stringFromCode(code);
                }
            }
        };
        var consumeAURLToken = function () {
            var token = new URLToken("");
            while (whitespace(next()))
                consume();
            if (eof(next()))
                return token;
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return token;
                }
                else if (whitespace(code)) {
                    while (whitespace(next()))
                        consume();
                    if (next() == 0x29 || eof(next())) {
                        consume();
                        return token;
                    }
                    else {
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
                    parseerror();
                    consumeTheRemnantsOfABadURL();
                    return new BadURLToken();
                }
                else if (code == 0x5c) {
                    if (startsWithAValidEscape()) {
                        token.value += stringFromCode(consumeEscape());
                    }
                    else {
                        parseerror();
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else {
                    token.value += stringFromCode(code);
                }
            }
        };
        var consumeEscape = function () {
            // Assume the the current character is the \
            // and the next code point is not a newline.
            consume();
            if (hexdigit(code)) {
                // Consume 1-6 hex digits
                var digits = [code];
                for (var total = 0; total < 5; total++) {
                    if (hexdigit(next())) {
                        consume();
                        digits.push(code);
                    }
                    else {
                        break;
                    }
                }
                if (whitespace(next()))
                    consume();
                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);
                if (value > maximumallowedcodepoint)
                    value = 0xfffd;
                return value;
            }
            else if (eof()) {
                return 0xfffd;
            }
            else {
                return code;
            }
        };
        var areAValidEscape = function (c1, c2) {
            if (c1 != 0x5c)
                return false;
            if (newline(c2))
                return false;
            return true;
        };
        var startsWithAValidEscape = function () {
            return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function (c1, c2, c3) {
            if (c1 == 0x2d) {
                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
            }
            else if (namestartchar(c1)) {
                return true;
            }
            else if (c1 == 0x5c) {
                return areAValidEscape(c1, c2);
            }
            else {
                return false;
            }
        };
        var startsWithAnIdentifier = function () {
            return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function (c1, c2, c3) {
            if (c1 == 0x2b || c1 == 0x2d) {
                if (digit(c2))
                    return true;
                if (c2 == 0x2e && digit(c3))
                    return true;
                return false;
            }
            else if (c1 == 0x2e) {
                if (digit(c2))
                    return true;
                return false;
            }
            else if (digit(c1)) {
                return true;
            }
            else {
                return false;
            }
        };
        var startsWithANumber = function () {
            return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function () {
            var result = "";
            while (consume()) {
                if (namechar(code)) {
                    result += stringFromCode(code);
                }
                else if (startsWithAValidEscape()) {
                    result += stringFromCode(consumeEscape());
                }
                else {
                    reconsume();
                    return result;
                }
            }
        };
        var consumeANumber = function () {
            var repr = [];
            var type = "integer";
            if (next() == 0x2b || next() == 0x2d) {
                consume();
                repr += stringFromCode(code);
            }
            while (digit(next())) {
                consume();
                repr += stringFromCode(code);
            }
            if (next(1) == 0x2e && digit(next(2))) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var c1 = next(1), c2 = next(2), c3 = next(3);
            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var value = convertAStringToANumber(repr);
            return { type: type, value: value, repr: repr };
        };
        var convertAStringToANumber = function (string) {
            // CSS's number rules are identical to JS, afaik.
            return +string;
        };
        var consumeTheRemnantsOfABadURL = function () {
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return;
                }
                else if (startsWithAValidEscape()) {
                    consumeEscape();
                    donothing();
                }
                else {
                    donothing();
                }
            }
        };
        var iterationCount = 0;
        while (!eof(next())) {
            tokens.push(consumeAToken());
            iterationCount++;
            if (iterationCount > str.length * 2)
                return "I'm infinite-looping!";
        }
        return tokens;
    }
    function CSSParserToken() { throw "Abstract Base Class"; }
    CSSParserToken.prototype.toJSON = function () {
        return { token: this.tokenType };
    };
    CSSParserToken.prototype.toString = function () { return this.tokenType; };
    CSSParserToken.prototype.toSource = function () { return '' + this; };
    function BadStringToken() { return this; }
    BadStringToken.prototype = Object.create(CSSParserToken.prototype);
    BadStringToken.prototype.tokenType = "BADSTRING";
    function BadURLToken() { return this; }
    BadURLToken.prototype = Object.create(CSSParserToken.prototype);
    BadURLToken.prototype.tokenType = "BADURL";
    function WhitespaceToken() { return this; }
    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
    WhitespaceToken.prototype.tokenType = "WHITESPACE";
    WhitespaceToken.prototype.toString = function () { return "WS"; };
    WhitespaceToken.prototype.toSource = function () { return " "; };
    function CDOToken() { return this; }
    CDOToken.prototype = Object.create(CSSParserToken.prototype);
    CDOToken.prototype.tokenType = "CDO";
    CDOToken.prototype.toSource = function () { return "<!--"; };
    function CDCToken() { return this; }
    CDCToken.prototype = Object.create(CSSParserToken.prototype);
    CDCToken.prototype.tokenType = "CDC";
    CDCToken.prototype.toSource = function () { return "-->"; };
    function ColonToken() { return this; }
    ColonToken.prototype = Object.create(CSSParserToken.prototype);
    ColonToken.prototype.tokenType = ":";
    function SemicolonToken() { return this; }
    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
    SemicolonToken.prototype.tokenType = ";";
    function CommaToken() { return this; }
    CommaToken.prototype = Object.create(CSSParserToken.prototype);
    CommaToken.prototype.tokenType = ",";
    function GroupingToken() { throw "Abstract Base Class"; }
    GroupingToken.prototype = Object.create(CSSParserToken.prototype);
    function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
    OpenCurlyToken.prototype.tokenType = "{";
    function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
    CloseCurlyToken.prototype.tokenType = "}";
    function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
    OpenSquareToken.prototype.tokenType = "[";
    function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
    CloseSquareToken.prototype.tokenType = "]";
    function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
    OpenParenToken.prototype = Object.create(GroupingToken.prototype);
    OpenParenToken.prototype.tokenType = "(";
    function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
    CloseParenToken.prototype = Object.create(GroupingToken.prototype);
    CloseParenToken.prototype.tokenType = ")";
    function IncludeMatchToken() { return this; }
    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
    IncludeMatchToken.prototype.tokenType = "~=";
    function DashMatchToken() { return this; }
    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
    DashMatchToken.prototype.tokenType = "|=";
    function PrefixMatchToken() { return this; }
    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    PrefixMatchToken.prototype.tokenType = "^=";
    function SuffixMatchToken() { return this; }
    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SuffixMatchToken.prototype.tokenType = "$=";
    function SubstringMatchToken() { return this; }
    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SubstringMatchToken.prototype.tokenType = "*=";
    function ColumnToken() { return this; }
    ColumnToken.prototype = Object.create(CSSParserToken.prototype);
    ColumnToken.prototype.tokenType = "||";
    function EOFToken() { return this; }
    EOFToken.prototype = Object.create(CSSParserToken.prototype);
    EOFToken.prototype.tokenType = "EOF";
    EOFToken.prototype.toSource = function () { return ""; };
    function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
    }
    DelimToken.prototype = Object.create(CSSParserToken.prototype);
    DelimToken.prototype.tokenType = "DELIM";
    DelimToken.prototype.toString = function () { return "DELIM(" + this.value + ")"; };
    DelimToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    DelimToken.prototype.toSource = function () {
        if (this.value == "\\")
            return "\\\n";
        else
            return this.value;
    };
    function StringValuedToken() { throw "Abstract Base Class"; }
    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
    StringValuedToken.prototype.ASCIIMatch = function (str) {
        return this.value.toLowerCase() == str.toLowerCase();
    };
    StringValuedToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    function IdentToken(val) {
        this.value = val;
    }
    IdentToken.prototype = Object.create(StringValuedToken.prototype);
    IdentToken.prototype.tokenType = "IDENT";
    IdentToken.prototype.toString = function () { return "IDENT(" + this.value + ")"; };
    IdentToken.prototype.toSource = function () {
        return escapeIdent(this.value);
    };
    function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
    }
    FunctionToken.prototype = Object.create(StringValuedToken.prototype);
    FunctionToken.prototype.tokenType = "FUNCTION";
    FunctionToken.prototype.toString = function () { return "FUNCTION(" + this.value + ")"; };
    FunctionToken.prototype.toSource = function () {
        return escapeIdent(this.value) + "(";
    };
    function AtKeywordToken(val) {
        this.value = val;
    }
    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
    AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
    AtKeywordToken.prototype.toString = function () { return "AT(" + this.value + ")"; };
    AtKeywordToken.prototype.toSource = function () {
        return "@" + escapeIdent(this.value);
    };
    function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
    }
    HashToken.prototype = Object.create(StringValuedToken.prototype);
    HashToken.prototype.tokenType = "HASH";
    HashToken.prototype.toString = function () { return "HASH(" + this.value + ")"; };
    HashToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
    };
    HashToken.prototype.toSource = function () {
        if (this.type == "id") {
            return "#" + escapeIdent(this.value);
        }
        else {
            return "#" + escapeHash(this.value);
        }
    };
    function StringToken(val) {
        this.value = val;
    }
    StringToken.prototype = Object.create(StringValuedToken.prototype);
    StringToken.prototype.tokenType = "STRING";
    StringToken.prototype.toString = function () {
        return '"' + escapeString(this.value) + '"';
    };
    function URLToken(val) {
        this.value = val;
    }
    URLToken.prototype = Object.create(StringValuedToken.prototype);
    URLToken.prototype.tokenType = "URL";
    URLToken.prototype.toString = function () { return "URL(" + this.value + ")"; };
    URLToken.prototype.toSource = function () {
        return 'url("' + escapeString(this.value) + '")';
    };
    function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
    }
    NumberToken.prototype = Object.create(CSSParserToken.prototype);
    NumberToken.prototype.tokenType = "NUMBER";
    NumberToken.prototype.toString = function () {
        if (this.type == "integer")
            return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
    };
    NumberToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
    };
    NumberToken.prototype.toSource = function () { return this.repr; };
    function PercentageToken() {
        this.value = null;
        this.repr = "";
    }
    PercentageToken.prototype = Object.create(CSSParserToken.prototype);
    PercentageToken.prototype.tokenType = "PERCENTAGE";
    PercentageToken.prototype.toString = function () { return "PERCENTAGE(" + this.value + ")"; };
    PercentageToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
    };
    PercentageToken.prototype.toSource = function () { return this.repr + "%"; };
    function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
    }
    DimensionToken.prototype = Object.create(CSSParserToken.prototype);
    DimensionToken.prototype.tokenType = "DIMENSION";
    DimensionToken.prototype.toString = function () { return "DIM(" + this.value + "," + this.unit + ")"; };
    DimensionToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
    };
    DimensionToken.prototype.toSource = function () {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
            // Unit is ambiguous with scinot
            // Remove the leading "e", replace with escape.
            unit = "\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
    };
    function escapeIdent(string) {
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f ||
                (i == 0 && between(code, 0x30, 0x39)) ||
                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {
                result += '\\' + code.toString(16) + ' ';
            }
            else if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\' + string[i];
            }
        }
        return result;
    }
    function escapeHash(string) {
        // Escapes the contents of "unrestricted"-type hash tokens.
        // Won't preserve the ID-ness of "id"-type hash tokens;
        // use escapeIdent() for that.
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\' + code.toString(16) + ' ';
            }
        }
        return result;
    }
    function escapeString(string) {
        string = '' + string;
        var result = '';
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f) {
                result += '\\' + code.toString(16) + ' ';
            }
            else if (code == 0x22 || code == 0x5c) {
                result += '\\' + string[i];
            }
            else {
                result += string[i];
            }
        }
        return result;
    }
    // Exportation.
    exports.tokenize = tokenize;
    exports.IdentToken = IdentToken;
    exports.FunctionToken = FunctionToken;
    exports.AtKeywordToken = AtKeywordToken;
    exports.HashToken = HashToken;
    exports.StringToken = StringToken;
    exports.BadStringToken = BadStringToken;
    exports.URLToken = URLToken;
    exports.BadURLToken = BadURLToken;
    exports.DelimToken = DelimToken;
    exports.NumberToken = NumberToken;
    exports.PercentageToken = PercentageToken;
    exports.DimensionToken = DimensionToken;
    exports.IncludeMatchToken = IncludeMatchToken;
    exports.DashMatchToken = DashMatchToken;
    exports.PrefixMatchToken = PrefixMatchToken;
    exports.SuffixMatchToken = SuffixMatchToken;
    exports.SubstringMatchToken = SubstringMatchToken;
    exports.ColumnToken = ColumnToken;
    exports.WhitespaceToken = WhitespaceToken;
    exports.CDOToken = CDOToken;
    exports.CDCToken = CDCToken;
    exports.ColonToken = ColonToken;
    exports.SemicolonToken = SemicolonToken;
    exports.CommaToken = CommaToken;
    exports.OpenParenToken = OpenParenToken;
    exports.CloseParenToken = CloseParenToken;
    exports.OpenSquareToken = OpenSquareToken;
    exports.CloseSquareToken = CloseSquareToken;
    exports.OpenCurlyToken = OpenCurlyToken;
    exports.CloseCurlyToken = CloseCurlyToken;
    exports.EOFToken = EOFToken;
    exports.CSSParserToken = CSSParserToken;
    exports.GroupingToken = GroupingToken;
}));
//# sourceMappingURL=cssTokenizer.js.map

/***/ }),

/***/ 8204:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSelector = exports.customCSSNames = void 0;
const cssParser_1 = __nccwpck_require__(2140);
exports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);
function parseSelector(selector) {
    const result = parseSelectorV1(selector);
    result.parts = result.parts.map(part => {
        if (Array.isArray(part))
            return part;
        if (part.name === 'css' || part.name === 'css:light') {
            if (part.name === 'css:light')
                part.body = ':light(' + part.body + ')';
            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);
            return parsedCSS.selector;
        }
        return part;
    });
    return {
        parts: result.parts,
        capture: result.capture,
    };
}
exports.parseSelector = parseSelector;
function parseSelectorV1(selector) {
    let index = 0;
    let quote;
    let start = 0;
    const result = { parts: [] };
    const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf('=');
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
            name = part.substring(0, eqIndex).trim();
            body = part.substring(eqIndex + 1);
        }
        else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
            name = 'text';
            body = part;
        }
        else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
            name = 'text';
            body = part;
        }
        else if (/^\(*\/\//.test(part) || part.startsWith('..')) {
            // If selector starts with '//' or '//' prefixed with multiple opening
            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
            // If selector starts with '..', consider xpath as well.
            name = 'xpath';
            body = part;
        }
        else {
            name = 'css';
            body = part;
        }
        let capture = false;
        if (name[0] === '*') {
            capture = true;
            name = name.substring(1);
        }
        result.parts.push({ name, body });
        if (capture) {
            if (result.capture !== undefined)
                throw new Error(`Only one of the selectors can capture using * modifier`);
            result.capture = result.parts.length - 1;
        }
    };
    if (!selector.includes('>>')) {
        index = selector.length;
        append();
        return result;
    }
    while (index < selector.length) {
        const c = selector[index];
        if (c === '\\' && index + 1 < selector.length) {
            index += 2;
        }
        else if (c === quote) {
            quote = undefined;
            index++;
        }
        else if (!quote && (c === '"' || c === '\'' || c === '`')) {
            quote = c;
            index++;
        }
        else if (!quote && c === '>' && selector[index + 1] === '>') {
            append();
            index += 2;
            start = index;
        }
        else {
            index++;
        }
    }
    append();
    return result;
}
//# sourceMappingURL=selectorParser.js.map

/***/ }),

/***/ 4734:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeAsCallArgument = exports.parseEvaluationResultValue = void 0;
function isRegExp(obj) {
    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
}
function isDate(obj) {
    return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
}
function isError(obj) {
    return obj instanceof Error || (obj && obj.__proto__ && obj.__proto__.name === 'Error');
}
function parseEvaluationResultValue(value, handles = []) {
    if (Object.is(value, undefined))
        return undefined;
    if (typeof value === 'object' && value) {
        if ('v' in value) {
            if (value.v === 'undefined')
                return undefined;
            if (value.v === 'null')
                return null;
            if (value.v === 'NaN')
                return NaN;
            if (value.v === 'Infinity')
                return Infinity;
            if (value.v === '-Infinity')
                return -Infinity;
            if (value.v === '-0')
                return -0;
            return undefined;
        }
        if ('d' in value)
            return new Date(value.d);
        if ('r' in value)
            return new RegExp(value.r.p, value.r.f);
        if ('a' in value)
            return value.a.map((a) => parseEvaluationResultValue(a, handles));
        if ('o' in value) {
            const result = {};
            for (const { k, v } of value.o)
                result[k] = parseEvaluationResultValue(v, handles);
            return result;
        }
        if ('h' in value)
            return handles[value.h];
    }
    return value;
}
exports.parseEvaluationResultValue = parseEvaluationResultValue;
function serializeAsCallArgument(value, handleSerializer) {
    return serialize(value, handleSerializer, new Set());
}
exports.serializeAsCallArgument = serializeAsCallArgument;
function serialize(value, handleSerializer, visited) {
    const result = handleSerializer(value);
    if ('fallThrough' in result)
        value = result.fallThrough;
    else
        return result;
    if (visited.has(value))
        throw new Error('Argument is a circular structure');
    if (typeof value === 'symbol')
        return { v: 'undefined' };
    if (Object.is(value, undefined))
        return { v: 'undefined' };
    if (Object.is(value, null))
        return { v: 'null' };
    if (Object.is(value, NaN))
        return { v: 'NaN' };
    if (Object.is(value, Infinity))
        return { v: 'Infinity' };
    if (Object.is(value, -Infinity))
        return { v: '-Infinity' };
    if (Object.is(value, -0))
        return { v: '-0' };
    if (typeof value === 'boolean')
        return value;
    if (typeof value === 'number')
        return value;
    if (typeof value === 'string')
        return value;
    if (isError(value)) {
        const error = value;
        if ('captureStackTrace' in global.Error) {
            // v8
            return error.stack || '';
        }
        return `${error.name}: ${error.message}\n${error.stack}`;
    }
    if (isDate(value))
        return { d: value.toJSON() };
    if (isRegExp(value))
        return { r: { p: value.source, f: value.flags } };
    if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
            a.push(serialize(value[i], handleSerializer, visited));
        visited.delete(value);
        return { a };
    }
    if (typeof value === 'object') {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value)) {
            let item;
            try {
                item = value[name];
            }
            catch (e) {
                continue; // native bindings will throw sometimes
            }
            if (name === 'toJSON' && typeof item === 'function')
                o.push({ k: name, v: { o: [] } });
            else
                o.push({ k: name, v: serialize(item, handleSerializer, visited) });
        }
        visited.delete(value);
        return { o };
    }
}
//# sourceMappingURL=utilityScriptSerializers.js.map

/***/ }),

/***/ 381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleMessage = void 0;
const instrumentation_1 = __nccwpck_require__(7490);
class ConsoleMessage extends instrumentation_1.SdkObject {
    constructor(parent, type, text, args, location) {
        super(parent, 'console-message');
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location || { url: '', lineNumber: 0, columnNumber: 0 };
    }
    type() {
        return this._type;
    }
    text() {
        if (this._text === undefined)
            this._text = this._args.map(arg => arg._value).join(' ');
        return this._text;
    }
    args() {
        return this._args;
    }
    location() {
        return this._location;
    }
}
exports.ConsoleMessage = ConsoleMessage;
//# sourceMappingURL=console.js.map

/***/ }),

/***/ 5:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @type {import('./types').Devices}
 */
module.exports = __nccwpck_require__(1956);
//# sourceMappingURL=deviceDescriptors.js.map

/***/ }),

/***/ 7639:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dialog = void 0;
const utils_1 = __nccwpck_require__(6416);
const instrumentation_1 = __nccwpck_require__(7490);
class Dialog extends instrumentation_1.SdkObject {
    constructor(page, type, message, onHandle, defaultValue) {
        super(page, 'dialog');
        this._handled = false;
        this._page = page;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || '';
    }
    type() {
        return this._type;
    }
    message() {
        return this._message;
    }
    defaultValue() {
        return this._defaultValue;
    }
    async accept(promptText) {
        utils_1.assert(!this._handled, 'Cannot accept dialog which is already handled!');
        this._handled = true;
        await this._onHandle(true, promptText);
    }
    async dismiss() {
        utils_1.assert(!this._handled, 'Cannot dismiss dialog which is already handled!');
        this._handled = true;
        await this._onHandle(false);
    }
}
exports.Dialog = Dialog;
//# sourceMappingURL=dialog.js.map

/***/ }),

/***/ 9418:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kUnableToAdoptErrorMessage = exports.elementStateTask = exports.getAttributeTask = exports.innerHTMLTask = exports.innerTextTask = exports.textContentTask = exports.dispatchEventTask = exports.waitForSelectorTask = exports.assertDone = exports.throwRetargetableDOMError = exports.throwFatalDOMError = exports.InjectedScriptPollHandler = exports.ElementHandle = exports.FrameExecutionContext = void 0;
const utils_1 = __nccwpck_require__(6416);
const injectedScriptSource = __importStar(__nccwpck_require__(7788));
const js = __importStar(__nccwpck_require__(1762));
const mime = __importStar(__nccwpck_require__(8640));
const progress_1 = __nccwpck_require__(6707);
class FrameExecutionContext extends js.ExecutionContext {
    constructor(delegate, frame, world) {
        super(frame, delegate);
        this.frame = frame;
        this.world = world;
    }
    async waitForSignalsCreatedBy(action) {
        return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);
    }
    adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
            return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
    }
    async evaluate(pageFunction, arg) {
        return js.evaluate(this, true /* returnByValue */, pageFunction, arg);
    }
    async evaluateHandle(pageFunction, arg) {
        return js.evaluate(this, false /* returnByValue */, pageFunction, arg);
    }
    async evaluateExpression(expression, isFunction, arg) {
        return js.evaluateExpression(this, true /* returnByValue */, expression, isFunction, arg);
    }
    async evaluateAndWaitForSignals(pageFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return this.evaluate(pageFunction, arg);
        });
    }
    async evaluateExpressionAndWaitForSignals(expression, isFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return this.evaluateExpression(expression, isFunction, arg);
        });
    }
    async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluateExpression(this, false /* returnByValue */, expression, isFunction, arg);
        });
    }
    createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
            return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
    }
    injectedScript() {
        if (!this._injectedScriptPromise) {
            const custom = [];
            for (const [name, { source }] of this.frame._page.selectors._engines)
                custom.push(`{ name: '${name}', engine: (${source}) }`);
            const source = `
        (() => {
        ${injectedScriptSource.source}
        return new pwExport(
          ${this.frame._page._delegate.rafCountForStablePosition()},
          ${!!process.env.PWTEST_USE_TIMEOUT_FOR_RAF},
          [${custom.join(',\n')}]
        );
        })();
      `;
            this._injectedScriptPromise = this._delegate.rawEvaluateHandle(source).then(objectId => new js.JSHandle(this, 'object', objectId));
        }
        return this._injectedScriptPromise;
    }
    async doSlowMo() {
        return this.frame._page._doSlowMo();
    }
}
exports.FrameExecutionContext = FrameExecutionContext;
class ElementHandle extends js.JSHandle {
    constructor(context, objectId) {
        super(context, 'node', objectId);
        this._objectId = objectId;
        this._context = context;
        this._page = context.frame._page;
        this._initializePreview().catch(e => { });
    }
    async _initializePreview() {
        const utility = await this._context.injectedScript();
        this._setPreview(await utility.evaluate((injected, e) => 'JSHandle@' + injected.previewNode(e), this));
    }
    asElement() {
        return this;
    }
    async _evaluateInMainAndWaitForSignals(pageFunction, arg) {
        const main = await this._context.frame._mainContext();
        return main.evaluateAndWaitForSignals(pageFunction, [await main.injectedScript(), this, arg]);
    }
    async evaluateInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);
    }
    async evaluateHandleInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
    }
    async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
            return null;
        const frame = this._page._frameManager.frame(frameId);
        if (frame)
            return frame;
        for (const page of this._page._browserContext.pages()) {
            const frame = page._frameManager.frame(frameId);
            if (frame)
                return frame;
        }
        return null;
    }
    async contentFrame() {
        const isFrameElement = await this.evaluateInUtility(([injected, node]) => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'), {});
        if (!isFrameElement)
            return null;
        return this._page._delegate.getContentFrame(this);
    }
    async getAttribute(name) {
        return throwFatalDOMError(await this.evaluateInUtility(([injeced, node, name]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'error:notelement';
            const element = node;
            return { value: element.getAttribute(name) };
        }, name)).value;
    }
    async textContent() {
        return this.evaluateInUtility(([injected, node]) => node.textContent, {});
    }
    async innerText() {
        return throwFatalDOMError(await this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'error:notelement';
            if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml')
                return 'error:nothtmlelement';
            const element = node;
            return { value: element.innerText };
        }, {})).value;
    }
    async innerHTML() {
        return throwFatalDOMError(await this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'error:notelement';
            const element = node;
            return { value: element.innerHTML };
        }, {})).value;
    }
    async dispatchEvent(type, eventInit = {}) {
        await this._evaluateInMainAndWaitForSignals(([injected, node, { type, eventInit }]) => injected.dispatchEvent(node, type, eventInit), { type, eventInit });
        await this._page._doSlowMo();
    }
    async _scrollRectIntoViewIfNeeded(rect) {
        return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
    }
    async _waitAndScrollIntoViewIfNeeded(progress) {
        while (progress.isRunning()) {
            assertDone(throwRetargetableDOMError(await this._waitForDisplayedAtStablePosition(progress, false /* waitForEnabled */)));
            progress.throwIfAborted(); // Avoid action that has side-effects.
            const result = throwRetargetableDOMError(await this._scrollRectIntoViewIfNeeded());
            if (result === 'error:notvisible')
                continue;
            assertDone(result);
            return;
        }
    }
    async scrollIntoViewIfNeeded(metadata, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this._waitAndScrollIntoViewIfNeeded(progress), this._page._timeoutSettings.timeout(options));
    }
    async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
            return quad.map(point => ({
                x: Math.min(Math.max(point.x, 0), metrics.width),
                y: Math.min(Math.max(point.y, 0), metrics.height),
            }));
        };
        const computeQuadArea = (quad) => {
            // Compute sum of all directed areas of adjacent triangles
            // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
                const p1 = quad[i];
                const p2 = quad[(i + 1) % quad.length];
                area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([
            this._page._delegate.getContentQuads(this),
            this._page.mainFrame()._utilityContext().then(utility => utility.evaluate(() => ({ width: innerWidth, height: innerHeight }))),
        ]);
        if (!quads || !quads.length)
            return 'error:notvisible';
        // Allow 1x1 elements. Compensate for rounding errors by comparing with 0.99 instead.
        const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 0.99);
        if (!filtered.length)
            return 'error:notinviewport';
        // Return the middle point of the first quad.
        const result = { x: 0, y: 0 };
        for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
        }
        compensateHalfIntegerRoundingError(result);
        return result;
    }
    async _offsetPoint(offset) {
        const [box, border] = await Promise.all([
            this.boundingBox(),
            this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch(e => { }),
        ]);
        if (!box || !border)
            return 'error:notvisible';
        // Make point relative to the padding box to align with offsetX/offsetY.
        return {
            x: box.x + border.left + offset.x,
            y: box.y + border.top + offset.y,
        };
    }
    async _retryPointerAction(progress, actionName, waitForEnabled, action, options) {
        let retry = 0;
        // We progressively wait longer between retries, up to 500ms.
        const waitTime = [0, 20, 100, 100, 500];
        // By default, we scroll with protocol method to reveal the action point.
        // However, that might not work to scroll from under position:sticky elements
        // that overlay the target element. To fight this, we cycle through different
        // scroll alignments. This works in most scenarios.
        const scrollOptions = [
            undefined,
            { block: 'end', inline: 'end' },
            { block: 'center', inline: 'center' },
            { block: 'start', inline: 'start' },
        ];
        while (progress.isRunning()) {
            if (retry) {
                progress.log(`retrying ${actionName} action${options.trial ? ' (trial run)' : ''}, attempt #${retry}`);
                const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];
                if (timeout) {
                    progress.log(`  waiting ${timeout}ms`);
                    await this.evaluateInUtility(([injected, node, timeout]) => new Promise(f => setTimeout(f, timeout)), timeout);
                }
            }
            else {
                progress.log(`attempting ${actionName} action${options.trial ? ' (trial run)' : ''}`);
            }
            const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
            const result = await this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options);
            ++retry;
            if (result === 'error:notvisible') {
                if (options.force)
                    throw new Error('Element is not visible');
                progress.log('  element is not visible');
                continue;
            }
            if (result === 'error:notinviewport') {
                if (options.force)
                    throw new Error('Element is outside of the viewport');
                progress.log('  element is outside of the viewport');
                continue;
            }
            if (typeof result === 'object' && 'hitTargetDescription' in result) {
                if (options.force)
                    throw new Error(`Element does not receive pointer events, ${result.hitTargetDescription} intercepts them`);
                progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);
                continue;
            }
            return result;
        }
        return 'done';
    }
    async _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options) {
        const { force = false, position } = options;
        if (options.__testHookBeforeStable)
            await options.__testHookBeforeStable();
        if (!force) {
            const result = await this._waitForDisplayedAtStablePosition(progress, waitForEnabled);
            if (result !== 'done')
                return result;
        }
        if (options.__testHookAfterStable)
            await options.__testHookAfterStable();
        progress.log('  scrolling into view if needed');
        progress.throwIfAborted(); // Avoid action that has side-effects.
        if (forceScrollOptions) {
            await this.evaluateInUtility(([injected, node, options]) => {
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */)
                    node.scrollIntoView(options);
            }, forceScrollOptions);
        }
        else {
            const scrolled = await this._scrollRectIntoViewIfNeeded(position ? { x: position.x, y: position.y, width: 0, height: 0 } : undefined);
            if (scrolled !== 'done')
                return scrolled;
        }
        progress.log('  done scrolling');
        const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
        if (typeof maybePoint === 'string')
            return maybePoint;
        const point = roundPoint(maybePoint);
        if (!force) {
            if (options.__testHookBeforeHitTarget)
                await options.__testHookBeforeHitTarget();
            progress.log(`  checking that element receives pointer events at (${point.x},${point.y})`);
            const hitTargetResult = await this._checkHitTargetAt(point);
            if (hitTargetResult !== 'done')
                return hitTargetResult;
            progress.log(`  element does receive pointer events`);
        }
        progress.metadata.point = point;
        if (options.trial) {
            progress.log(`  trial ${actionName} has finished`);
            return 'done';
        }
        await progress.beforeInputAction(this);
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            if (options.__testHookBeforePointerAction)
                await options.__testHookBeforePointerAction();
            progress.throwIfAborted(); // Avoid action that has side-effects.
            let restoreModifiers;
            if (options && options.modifiers)
                restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);
            progress.log(`  performing ${actionName} action`);
            await action(point);
            progress.log(`  ${actionName} action done`);
            progress.log('  waiting for scheduled navigations to finish');
            if (options.__testHookAfterPointerAction)
                await options.__testHookAfterPointerAction();
            if (restoreModifiers)
                await this._page.keyboard._ensureModifiers(restoreModifiers);
        }, 'input');
        progress.log('  navigations have finished');
        return 'done';
    }
    async hover(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._hover(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    _hover(progress, options) {
        return this._retryPointerAction(progress, 'hover', false /* waitForEnabled */, point => this._page.mouse.move(point.x, point.y), options);
    }
    async click(metadata, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._click(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    _click(progress, options) {
        return this._retryPointerAction(progress, 'click', true /* waitForEnabled */, point => this._page.mouse.click(point.x, point.y, options), options);
    }
    async dblclick(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._dblclick(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    _dblclick(progress, options) {
        return this._retryPointerAction(progress, 'dblclick', true /* waitForEnabled */, point => this._page.mouse.dblclick(point.x, point.y, options), options);
    }
    async tap(metadata, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._tap(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    _tap(progress, options) {
        return this._retryPointerAction(progress, 'tap', true /* waitForEnabled */, point => this._page.touchscreen.tap(point.x, point.y), options);
    }
    async selectOption(metadata, elements, values, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._selectOption(progress, elements, values, options);
            return throwRetargetableDOMError(result);
        }, this._page._timeoutSettings.timeout(options));
    }
    async _selectOption(progress, elements, values, options) {
        const optionsToSelect = [...elements, ...values];
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            progress.throwIfAborted(); // Avoid action that has side-effects.
            progress.log('  selecting specified option(s)');
            const poll = await this.evaluateHandleInUtility(([injected, node, optionsToSelect]) => {
                return injected.waitForElementStatesAndPerformAction(node, ['visible', 'enabled'], injected.selectOptions.bind(injected, optionsToSelect));
            }, optionsToSelect);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            const result = throwFatalDOMError(await pollHandler.finish());
            await this._page._doSlowMo();
            return result;
        });
    }
    async fill(metadata, value, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._fill(progress, value, options);
            assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async _fill(progress, value, options) {
        progress.log(`elementHandle.fill("${value}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            progress.log('  waiting for element to be visible, enabled and editable');
            const poll = await this.evaluateHandleInUtility(([injected, node, value]) => {
                return injected.waitForElementStatesAndPerformAction(node, ['visible', 'enabled', 'editable'], injected.fill.bind(injected, value));
            }, value);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            const filled = throwFatalDOMError(await pollHandler.finish());
            progress.throwIfAborted(); // Avoid action that has side-effects.
            if (filled === 'error:notconnected')
                return filled;
            progress.log('  element is visible, enabled and editable');
            if (filled === 'needsinput') {
                progress.throwIfAborted(); // Avoid action that has side-effects.
                if (value)
                    await this._page.keyboard.insertText(value);
                else
                    await this._page.keyboard.press('Delete');
            }
            else {
                assertDone(filled);
            }
            return 'done';
        }, 'input');
    }
    async selectText(metadata, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            progress.throwIfAborted(); // Avoid action that has side-effects.
            const poll = await this.evaluateHandleInUtility(([injected, node]) => {
                return injected.waitForElementStatesAndPerformAction(node, ['visible'], injected.selectText.bind(injected));
            }, {});
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            const result = throwFatalDOMError(await pollHandler.finish());
            assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async setInputFiles(metadata, files, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._setInputFiles(progress, files, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async _setInputFiles(progress, files, options) {
        for (const payload of files) {
            if (!payload.mimeType)
                payload.mimeType = mime.getType(payload.name) || 'application/octet-stream';
        }
        const multiple = throwFatalDOMError(await this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE || node.tagName !== 'INPUT')
                return 'error:notinput';
            const input = node;
            return input.multiple;
        }, {}));
        if (typeof multiple === 'string')
            return multiple;
        utils_1.assert(multiple || files.length <= 1, 'Non-multiple file input can only accept single file!');
        await progress.beforeInputAction(this);
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            progress.throwIfAborted(); // Avoid action that has side-effects.
            await this._page._delegate.setInputFiles(this, files);
        });
        await this._page._doSlowMo();
        return 'done';
    }
    async focus(metadata) {
        const controller = new progress_1.ProgressController(metadata, this);
        await controller.run(async (progress) => {
            const result = await this._focus(progress);
            await this._page._doSlowMo();
            return assertDone(throwRetargetableDOMError(result));
        }, 0);
    }
    async _focus(progress, resetSelectionIfNotFocused) {
        progress.throwIfAborted(); // Avoid action that has side-effects.
        const result = await this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused]) => injected.focusNode(node, resetSelectionIfNotFocused), resetSelectionIfNotFocused);
        return throwFatalDOMError(result);
    }
    async type(metadata, text, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._type(progress, text, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async _type(progress, text, options) {
        progress.log(`elementHandle.type("${text}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);
            if (result !== 'done')
                return result;
            progress.throwIfAborted(); // Avoid action that has side-effects.
            await this._page.keyboard.type(text, options);
            return 'done';
        }, 'input');
    }
    async press(metadata, key, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._press(progress, key, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async _press(progress, key, options) {
        progress.log(`elementHandle.press("${key}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);
            if (result !== 'done')
                return result;
            progress.throwIfAborted(); // Avoid action that has side-effects.
            await this._page.keyboard.press(key, options);
            return 'done';
        }, 'input');
    }
    async check(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._setChecked(progress, true, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async uncheck(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            const result = await this._setChecked(progress, false, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options));
    }
    async _setChecked(progress, state, options) {
        const isChecked = async () => {
            const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'checked'), {});
            return throwRetargetableDOMError(throwFatalDOMError(result));
        };
        if (await isChecked() === state)
            return 'done';
        const result = await this._click(progress, options);
        if (result !== 'done')
            return result;
        if (options.trial)
            return 'done';
        if (await isChecked() !== state)
            throw new Error('Clicking the checkbox did not change its state');
        return 'done';
    }
    async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
    }
    async screenshot(metadata, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this._page._screenshotter.screenshotElement(progress, this, options), this._page._timeoutSettings.timeout(options));
    }
    async $(selector) {
        return this._page.selectors._query(this._context.frame, selector, this);
    }
    async $$(selector) {
        return this._page.selectors._queryAll(this._context.frame, selector, this, true /* adoptToMain */);
    }
    async evalOnSelectorAndWaitForSignals(selector, expression, isFunction, arg) {
        const handle = await this._page.selectors._query(this._context.frame, selector, this);
        if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        handle.dispose();
        return result;
    }
    async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        const arrayHandle = await this._page.selectors._queryArray(this._context.frame, selector, this);
        const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
    }
    async isVisible() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'visible'), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
    }
    async isHidden() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'hidden'), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
    }
    async isEnabled() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'enabled'), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
    }
    async isDisabled() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'disabled'), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
    }
    async isEditable() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'editable'), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
    }
    async isChecked() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, 'checked'), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
    }
    async waitForElementState(metadata, state, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            progress.log(`  waiting for element to be ${state}`);
            const poll = await this.evaluateHandleInUtility(([injected, node, state]) => {
                return injected.waitForElementStatesAndPerformAction(node, [state], () => 'done');
            }, state);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            assertDone(throwRetargetableDOMError(throwFatalDOMError(await pollHandler.finish())));
        }, this._page._timeoutSettings.timeout(options));
    }
    async waitForSelector(metadata, selector, options = {}) {
        const { state = 'visible' } = options;
        if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
        const info = this._page.selectors._parseSelector(selector);
        const task = waitForSelectorTask(info, state, this);
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            progress.log(`waiting for selector "${selector}"${state === 'attached' ? '' : ' to be ' + state}`);
            const context = await this._context.frame._context(info.world);
            const injected = await context.injectedScript();
            const pollHandler = new InjectedScriptPollHandler(progress, await task(injected));
            const result = await pollHandler.finishHandle();
            if (!result.asElement()) {
                result.dispose();
                return null;
            }
            const handle = result.asElement();
            return handle._adoptTo(await this._context.frame._mainContext());
        }, this._page._timeoutSettings.timeout(options));
    }
    async _adoptTo(context) {
        if (this._context !== context) {
            const adopted = await this._page._delegate.adoptElementHandle(this, context);
            this.dispose();
            return adopted;
        }
        return this;
    }
    async _waitForDisplayedAtStablePosition(progress, waitForEnabled) {
        if (waitForEnabled)
            progress.log(`  waiting for element to be visible, enabled and stable`);
        else
            progress.log(`  waiting for element to be visible and stable`);
        const poll = this.evaluateHandleInUtility(([injected, node, waitForEnabled]) => {
            return injected.waitForElementStatesAndPerformAction(node, waitForEnabled ? ['visible', 'stable', 'enabled'] : ['visible', 'stable'], () => 'done');
        }, waitForEnabled);
        const pollHandler = new InjectedScriptPollHandler(progress, await poll);
        const result = await pollHandler.finish();
        if (waitForEnabled)
            progress.log('  element is visible, enabled and stable');
        else
            progress.log('  element is visible and stable');
        return throwFatalDOMError(result);
    }
    async _checkHitTargetAt(point) {
        const frame = await this.ownerFrame();
        if (frame && frame.parentFrame()) {
            const element = await frame.frameElement();
            const box = await element.boundingBox();
            if (!box)
                return 'error:notconnected';
            // Translate from viewport coordinates to frame coordinates.
            point = { x: point.x - box.x, y: point.y - box.y };
        }
        return this.evaluateInUtility(([injected, node, point]) => injected.checkHitTargetAt(node, point), point);
    }
}
exports.ElementHandle = ElementHandle;
// Handles an InjectedScriptPoll running in injected script:
// - streams logs into progress;
// - cancels the poll when progress cancels.
class InjectedScriptPollHandler {
    constructor(progress, poll) {
        this._progress = progress;
        this._poll = poll;
        // Ensure we cancel the poll before progress aborts and returns:
        //   - no unnecessary work in the page;
        //   - no possible side effects after progress promsie rejects.
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
    }
    async _streamLogs() {
        while (this._poll && this._progress.isRunning()) {
            const messages = await this._poll.evaluate(poll => poll.takeNextLogs()).catch(e => []);
            if (!this._poll || !this._progress.isRunning())
                return;
            for (const message of messages)
                this._progress.log(message);
        }
    }
    async finishHandle() {
        try {
            const result = await this._poll.evaluateHandle(poll => poll.run());
            await this._finishInternal();
            return result;
        }
        finally {
            await this.cancel();
        }
    }
    async finish() {
        try {
            const result = await this._poll.evaluate(poll => poll.run());
            await this._finishInternal();
            return result;
        }
        finally {
            await this.cancel();
        }
    }
    async _finishInternal() {
        if (!this._poll)
            return;
        // Retrieve all the logs before continuing.
        const messages = await this._poll.evaluate(poll => poll.takeLastLogs()).catch(e => []);
        for (const message of messages)
            this._progress.log(message);
    }
    async cancel() {
        if (!this._poll)
            return;
        const copy = this._poll;
        this._poll = null;
        await copy.evaluate(p => p.cancel()).catch(e => { });
        copy.dispose();
    }
}
exports.InjectedScriptPollHandler = InjectedScriptPollHandler;
function throwFatalDOMError(result) {
    if (result === 'error:notelement')
        throw new Error('Node is not an element');
    if (result === 'error:nothtmlelement')
        throw new Error('Not an HTMLElement');
    if (result === 'error:notfillableelement')
        throw new Error('Element is not an <input>, <textarea> or [contenteditable] element');
    if (result === 'error:notfillableinputtype')
        throw new Error('Input of this type cannot be filled');
    if (result === 'error:notfillablenumberinput')
        throw new Error('Cannot type text into input[type=number]');
    if (result === 'error:notvaliddate')
        throw new Error(`Malformed value`);
    if (result === 'error:notinput')
        throw new Error('Node is not an HTMLInputElement');
    if (result === 'error:notselect')
        throw new Error('Element is not a <select> element.');
    if (result === 'error:notcheckbox')
        throw new Error('Not a checkbox or radio button');
    return result;
}
exports.throwFatalDOMError = throwFatalDOMError;
function throwRetargetableDOMError(result) {
    if (result === 'error:notconnected')
        throw new Error('Element is not attached to the DOM');
    return result;
}
exports.throwRetargetableDOMError = throwRetargetableDOMError;
function assertDone(result) {
    // This function converts 'done' to void and ensures typescript catches unhandled errors.
}
exports.assertDone = assertDone;
function roundPoint(point) {
    return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100,
    };
}
function compensateHalfIntegerRoundingError(point) {
    // Firefox internally uses integer coordinates, so 8.5 is converted to 9 when clicking.
    //
    // This does not work nicely for small elements. For example, 1x1 square with corners
    // (8;8) and (9;9) is targeted when clicking at (8;8) but not when clicking at (9;9).
    // So, clicking at (8.5;8.5) will effectively click at (9;9) and miss the target.
    //
    // Therefore, we skew half-integer values from the interval (8.49, 8.51) towards
    // (8.47, 8.49) that is rounded towards 8. This means clicking at (8.5;8.5) will
    // be replaced with (8.48;8.48) and will effectively click at (8;8).
    //
    // Other browsers use float coordinates, so this change should not matter.
    const remainderX = point.x - Math.floor(point.x);
    if (remainderX > 0.49 && remainderX < 0.51)
        point.x -= 0.02;
    const remainderY = point.y - Math.floor(point.y);
    if (remainderY > 0.49 && remainderY < 0.51)
        point.y -= 0.02;
}
function waitForSelectorTask(selector, state, root) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, state, root }) => {
        let lastElement;
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, root || document);
            const visible = element ? injected.isVisible(element) : false;
            if (lastElement !== element) {
                lastElement = element;
                if (!element)
                    progress.log(`  selector did not resolve to any element`);
                else
                    progress.log(`  selector resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`);
            }
            switch (state) {
                case 'attached':
                    return element ? element : continuePolling;
                case 'detached':
                    return !element ? undefined : continuePolling;
                case 'visible':
                    return visible ? element : continuePolling;
                case 'hidden':
                    return !visible ? undefined : continuePolling;
            }
        });
    }, { parsed: selector.parsed, state, root });
}
exports.waitForSelectorTask = waitForSelectorTask;
function dispatchEventTask(selector, type, eventInit) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, type, eventInit }) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            injected.dispatchEvent(element, type, eventInit);
        });
    }, { parsed: selector.parsed, type, eventInit });
}
exports.dispatchEventTask = dispatchEventTask;
function textContentTask(selector) {
    return injectedScript => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return element.textContent;
        });
    }, selector.parsed);
}
exports.textContentTask = textContentTask;
function innerTextTask(selector) {
    return injectedScript => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            if (element.namespaceURI !== 'http://www.w3.org/1999/xhtml')
                return 'error:nothtmlelement';
            return { innerText: element.innerText };
        });
    }, selector.parsed);
}
exports.innerTextTask = innerTextTask;
function innerHTMLTask(selector) {
    return injectedScript => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return element.innerHTML;
        });
    }, selector.parsed);
}
exports.innerHTMLTask = innerHTMLTask;
function getAttributeTask(selector, name) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, name }) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return element.getAttribute(name);
        });
    }, { parsed: selector.parsed, name });
}
exports.getAttributeTask = getAttributeTask;
function elementStateTask(selector, state) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, state }) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return injected.checkElementState(element, state);
        });
    }, { parsed: selector.parsed, state });
}
exports.elementStateTask = elementStateTask;
exports.kUnableToAdoptErrorMessage = 'Unable to adopt element handle from a different document';
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ 6055:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Download = void 0;
const path_1 = __importDefault(__nccwpck_require__(5622));
const page_1 = __nccwpck_require__(9406);
const utils_1 = __nccwpck_require__(6416);
const artifact_1 = __nccwpck_require__(3293);
class Download {
    constructor(page, downloadsPath, uuid, url, suggestedFilename) {
        const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? 'Pass { acceptDownloads: true } when you are creating your browser context.' : undefined;
        this.artifact = new artifact_1.Artifact(page, path_1.default.join(downloadsPath, uuid), unaccessibleErrorMessage);
        this._page = page;
        this.url = url;
        this._suggestedFilename = suggestedFilename;
        page._browserContext._downloads.add(this);
        if (suggestedFilename !== undefined)
            this._page.emit(page_1.Page.Events.Download, this);
    }
    _filenameSuggested(suggestedFilename) {
        utils_1.assert(this._suggestedFilename === undefined);
        this._suggestedFilename = suggestedFilename;
        this._page.emit(page_1.Page.Events.Download, this);
    }
    suggestedFilename() {
        return this._suggestedFilename;
    }
}
exports.Download = Download;
//# sourceMappingURL=download.js.map

/***/ }),

/***/ 8259:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Electron = exports.ElectronApplication = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const os_1 = __importDefault(__nccwpck_require__(2087));
const path_1 = __importDefault(__nccwpck_require__(5622));
const crBrowser_1 = __nccwpck_require__(6419);
const crConnection_1 = __nccwpck_require__(8899);
const crExecutionContext_1 = __nccwpck_require__(9262);
const js = __importStar(__nccwpck_require__(1762));
const timeoutSettings_1 = __nccwpck_require__(9255);
const transport_1 = __nccwpck_require__(3581);
const processLauncher_1 = __nccwpck_require__(9690);
const browserContext_1 = __nccwpck_require__(7533);
const progress_1 = __nccwpck_require__(6707);
const helper_1 = __nccwpck_require__(7951);
const readline = __importStar(__nccwpck_require__(1058));
const debugLogger_1 = __nccwpck_require__(5203);
const instrumentation_1 = __nccwpck_require__(7490);
const ARTIFACTS_FOLDER = path_1.default.join(os_1.default.tmpdir(), 'playwright-artifacts-');
class ElectronApplication extends instrumentation_1.SdkObject {
    constructor(parent, browser, nodeConnection) {
        super(parent, 'electron-app');
        this._lastWindowId = 0;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._browserContext = browser._defaultContext;
        this._browserContext.on(browserContext_1.BrowserContext.Events.Close, () => {
            // Emit application closed after context closed.
            Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
        });
        for (const page of this._browserContext.pages())
            this._onPage(page);
        this._browserContext.on(browserContext_1.BrowserContext.Events.Page, event => this._onPage(event));
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
        this._nodeElectronHandlePromise = new Promise(f => {
            this._nodeSession.on('Runtime.executionContextCreated', async (event) => {
                if (event.context.auxData && event.context.auxData.isDefault) {
                    this._nodeExecutionContext = new js.ExecutionContext(this, new crExecutionContext_1.CRExecutionContext(this._nodeSession, event.context));
                    f(await js.evaluate(this._nodeExecutionContext, false /* returnByValue */, `process.mainModule.require('electron')`));
                }
            });
        });
        this._nodeSession.send('Runtime.enable', {}).catch(e => { });
    }
    _onPage(page) {
        // Needs to be sync.
        const windowId = ++this._lastWindowId;
        page._browserWindowId = windowId;
    }
    context() {
        return this._browserContext;
    }
    async close() {
        const progressController = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), this);
        const closed = progressController.run(progress => helper_1.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise, this._timeoutSettings.timeout({}));
        const electronHandle = await this._nodeElectronHandlePromise;
        await electronHandle.evaluate(({ app }) => app.quit());
        this._nodeConnection.close();
        await closed;
    }
    async browserWindow(page) {
        const electronHandle = await this._nodeElectronHandlePromise;
        return await electronHandle.evaluateHandle(({ BrowserWindow }, windowId) => BrowserWindow.fromId(windowId), page._browserWindowId);
    }
}
exports.ElectronApplication = ElectronApplication;
ElectronApplication.Events = {
    Close: 'close',
};
class Electron extends instrumentation_1.SdkObject {
    constructor(playwrightOptions) {
        super(playwrightOptions.rootSdkObject, 'electron');
        this._playwrightOptions = playwrightOptions;
    }
    async launch(options) {
        const { args = [], } = options;
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), this);
        controller.setLogName('browser');
        return controller.run(async (progress) => {
            let app = undefined;
            const electronArguments = ['--inspect=0', '--remote-debugging-port=0', ...args];
            if (os_1.default.platform() === 'linux') {
                const runningAsRoot = process.geteuid && process.geteuid() === 0;
                if (runningAsRoot && electronArguments.indexOf('--no-sandbox') === -1)
                    electronArguments.push('--no-sandbox');
            }
            const artifactsDir = await fs_1.default.promises.mkdtemp(ARTIFACTS_FOLDER);
            const browserLogsCollector = new debugLogger_1.RecentLogsCollector();
            const { launchedProcess, gracefullyClose, kill } = await processLauncher_1.launchProcess({
                executablePath: options.executablePath || __nccwpck_require__(9506),
                args: electronArguments,
                env: options.env ? processLauncher_1.envArrayToObject(options.env) : process.env,
                log: (message) => {
                    progress.log(message);
                    browserLogsCollector.log(message);
                },
                stdio: 'pipe',
                cwd: options.cwd,
                tempDirectories: [artifactsDir],
                attemptToGracefullyClose: () => app.close(),
                handleSIGINT: true,
                handleSIGTERM: true,
                handleSIGHUP: true,
                onExit: () => { },
            });
            const nodeMatch = await waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
            const nodeTransport = await transport_1.WebSocketTransport.connect(progress, nodeMatch[1]);
            const nodeConnection = new crConnection_1.CRConnection(nodeTransport, helper_1.helper.debugProtocolLogger(), browserLogsCollector);
            const chromeMatch = await waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/);
            const chromeTransport = await transport_1.WebSocketTransport.connect(progress, chromeMatch[1]);
            const browserProcess = {
                onclose: undefined,
                process: launchedProcess,
                close: gracefullyClose,
                kill
            };
            const browserOptions = {
                ...this._playwrightOptions,
                name: 'electron',
                isChromium: true,
                headful: true,
                persistent: {
                    sdkLanguage: options.sdkLanguage,
                    noDefaultViewport: true,
                    acceptDownloads: options.acceptDownloads,
                    bypassCSP: options.bypassCSP,
                    colorScheme: options.colorScheme,
                    extraHTTPHeaders: options.extraHTTPHeaders,
                    geolocation: options.geolocation,
                    httpCredentials: options.httpCredentials,
                    ignoreHTTPSErrors: options.ignoreHTTPSErrors,
                    locale: options.locale,
                    offline: options.offline,
                    recordHar: options.recordHar,
                    recordVideo: options.recordVideo,
                    timezoneId: options.timezoneId,
                },
                browserProcess,
                protocolLogger: helper_1.helper.debugProtocolLogger(),
                browserLogsCollector,
                artifactsDir,
                downloadsPath: artifactsDir,
                tracesDir: artifactsDir,
            };
            const browser = await crBrowser_1.CRBrowser.connect(chromeTransport, browserOptions);
            app = new ElectronApplication(this, browser, nodeConnection);
            return app;
        }, timeoutSettings_1.TimeoutSettings.timeout(options));
    }
}
exports.Electron = Electron;
function waitForLine(progress, process, regex) {
    return new Promise((resolve, reject) => {
        const rl = readline.createInterface({ input: process.stderr });
        const failError = new Error('Process failed to launch!');
        const listeners = [
            helper_1.helper.addEventListener(rl, 'line', onLine),
            helper_1.helper.addEventListener(rl, 'close', reject.bind(null, failError)),
            helper_1.helper.addEventListener(process, 'exit', reject.bind(null, failError)),
            // It is Ok to remove error handler because we did not create process and there is another listener.
            helper_1.helper.addEventListener(process, 'error', reject.bind(null, failError))
        ];
        progress.cleanupWhenAborted(cleanup);
        function onLine(line) {
            const match = line.match(regex);
            if (!match)
                return;
            cleanup();
            resolve(match);
        }
        function cleanup() {
            helper_1.helper.removeEventListeners(listeners);
        }
    });
}
//# sourceMappingURL=electron.js.map

/***/ }),

/***/ 3764:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChooser = void 0;
class FileChooser {
    constructor(page, elementHandle, isMultiple) {
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
    }
    element() {
        return this._elementHandle;
    }
    isMultiple() {
        return this._isMultiple;
    }
    page() {
        return this._page;
    }
}
exports.FileChooser = FileChooser;
//# sourceMappingURL=fileChooser.js.map

/***/ }),

/***/ 3319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAccessibilityTree = void 0;
async function getAccessibilityTree(session, needle) {
    const objectId = needle ? needle._objectId : undefined;
    const { tree } = await session.send('Accessibility.getFullAXTree', { objectId });
    const axNode = new FFAXNode(tree);
    return {
        tree: axNode,
        needle: needle ? axNode._findNeedle() : null
    };
}
exports.getAccessibilityTree = getAccessibilityTree;
const FFRoleToARIARole = new Map(Object.entries({
    'pushbutton': 'button',
    'checkbutton': 'checkbox',
    'editcombobox': 'combobox',
    'content deletion': 'deletion',
    'footnote': 'doc-footnote',
    'non-native document': 'document',
    'grouping': 'group',
    'graphic': 'img',
    'content insertion': 'insertion',
    'animation': 'marquee',
    'flat equation': 'math',
    'menupopup': 'menu',
    'check menu item': 'menuitemcheckbox',
    'radio menu item': 'menuitemradio',
    'listbox option': 'option',
    'radiobutton': 'radio',
    'statusbar': 'status',
    'pagetab': 'tab',
    'pagetablist': 'tablist',
    'propertypage': 'tabpanel',
    'entry': 'textbox',
    'outline': 'tree',
    'tree table': 'treegrid',
    'outlineitem': 'treeitem',
}));
class FFAXNode {
    constructor(payload) {
        this._payload = payload;
        this._children = (payload.children || []).map(x => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && (payload.tag !== 'textarea' && payload.tag !== 'input');
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
    }
    _isPlainTextField() {
        if (this._richlyEditable)
            return false;
        if (this._editable)
            return true;
        return this._role === 'entry';
    }
    _isTextOnlyObject() {
        const role = this._role;
        return (role === 'text leaf' || role === 'text' || role === 'statictext');
    }
    _hasFocusableChild() {
        if (this._cachedHasFocusableChild === undefined) {
            this._cachedHasFocusableChild = false;
            for (const child of this._children) {
                if (child._focusable || child._hasFocusableChild()) {
                    this._cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this._cachedHasFocusableChild;
    }
    children() {
        return this._children;
    }
    _findNeedle() {
        if (this._payload.foundObject)
            return this;
        for (const child of this._children) {
            const found = child._findNeedle();
            if (found)
                return found;
        }
        return null;
    }
    isLeafNode() {
        if (!this._children.length)
            return true;
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this._isPlainTextField() || this._isTextOnlyObject())
            return true;
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this._role) {
            case 'graphic':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
            default:
                break;
        }
        // Here and below: Android heuristics
        if (this._hasFocusableChild())
            return false;
        if (this._focusable && this._role !== 'document' && this._name)
            return true;
        if (this._role === 'heading' && this._name)
            return true;
        return false;
    }
    isControl() {
        switch (this._role) {
            case 'checkbutton':
            case 'check menu item':
            case 'check rich option':
            case 'combobox':
            case 'combobox option':
            case 'color chooser':
            case 'listbox':
            case 'listbox option':
            case 'listbox rich option':
            case 'popup menu':
            case 'menupopup':
            case 'menuitem':
            case 'menubar':
            case 'button':
            case 'pushbutton':
            case 'radiobutton':
            case 'radio menuitem':
            case 'scrollbar':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'pagetab':
            case 'entry':
            case 'tree table':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!this._name.trim();
    }
    serialize() {
        const node = {
            role: FFRoleToARIARole.get(this._role) || this._role,
            name: this._name || '',
        };
        const userStringProperties = [
            'name',
            'description',
            'roledescription',
            'valuetext',
            'keyshortcuts',
        ];
        for (const userStringProperty of userStringProperties) {
            if (!(userStringProperty in this._payload))
                continue;
            node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        for (const booleanProperty of booleanProperties) {
            if (this._role === 'document' && booleanProperty === 'focused')
                continue; // document focusing is strange
            const value = this._payload[booleanProperty];
            if (!value)
                continue;
            node[booleanProperty] = value;
        }
        const numericalProperties = [
            'level'
        ];
        for (const numericalProperty of numericalProperties) {
            if (!(numericalProperty in this._payload))
                continue;
            node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        for (const tokenProperty of tokenProperties) {
            const value = this._payload[tokenProperty];
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = value;
        }
        const axNode = node;
        axNode.valueString = this._payload.value;
        if ('checked' in this._payload)
            axNode.checked = this._payload.checked === true ? 'checked' : this._payload.checked === 'mixed' ? 'mixed' : 'unchecked';
        if ('pressed' in this._payload)
            axNode.pressed = this._payload.pressed === true ? 'pressed' : 'released';
        return axNode;
    }
}
//# sourceMappingURL=ffAccessibility.js.map

/***/ }),

/***/ 7212:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FFBrowserContext = exports.FFBrowser = void 0;
const errors_1 = __nccwpck_require__(4949);
const utils_1 = __nccwpck_require__(6416);
const browser_1 = __nccwpck_require__(6169);
const browserContext_1 = __nccwpck_require__(7533);
const network = __importStar(__nccwpck_require__(8781));
const ffConnection_1 = __nccwpck_require__(8256);
const ffPage_1 = __nccwpck_require__(8103);
class FFBrowser extends browser_1.Browser {
    constructor(connection, options) {
        super(options);
        this._version = '';
        this._connection = connection;
        this._ffPages = new Map();
        this._contexts = new Map();
        this._connection.on(ffConnection_1.ConnectionEvents.Disconnected, () => this._onDisconnect());
        this._connection.on('Browser.attachedToTarget', this._onAttachedToTarget.bind(this));
        this._connection.on('Browser.detachedFromTarget', this._onDetachedFromTarget.bind(this));
        this._connection.on('Browser.downloadCreated', this._onDownloadCreated.bind(this));
        this._connection.on('Browser.downloadFinished', this._onDownloadFinished.bind(this));
        this._connection.on('Browser.videoRecordingFinished', this._onVideoRecordingFinished.bind(this));
    }
    static async connect(transport, options) {
        const connection = new ffConnection_1.FFConnection(transport, options.protocolLogger, options.browserLogsCollector);
        const browser = new FFBrowser(connection, options);
        if (options.__testHookOnConnectToBrowser)
            await options.__testHookOnConnectToBrowser();
        const promises = [
            connection.send('Browser.enable', { attachToDefaultContext: !!options.persistent }),
            browser._initVersion(),
        ];
        if (options.persistent) {
            browser._defaultContext = new FFBrowserContext(browser, undefined, options.persistent);
            promises.push(browser._defaultContext._initialize());
        }
        if (options.proxy)
            promises.push(browser._connection.send('Browser.setBrowserProxy', toJugglerProxyOptions(options.proxy)));
        await Promise.all(promises);
        return browser;
    }
    async _initVersion() {
        const result = await this._connection.send('Browser.getInfo');
        this._version = result.version.substring(result.version.indexOf('/') + 1);
    }
    isConnected() {
        return !this._connection._closed;
    }
    async newContext(options) {
        browserContext_1.validateBrowserContextOptions(options, this.options);
        if (options.isMobile)
            throw new Error('options.isMobile is not supported in Firefox');
        const { browserContextId } = await this._connection.send('Browser.createBrowserContext', { removeOnDetach: true });
        const context = new FFBrowserContext(this, browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    version() {
        return this._version;
    }
    _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
    }
    _onAttachedToTarget(payload) {
        const { targetId, browserContextId, openerId, type } = payload.targetInfo;
        utils_1.assert(type === 'page');
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        utils_1.assert(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId, type);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new ffPage_1.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
    }
    _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        utils_1.assert(ffPage);
        if (!ffPage)
            return;
        let originPage = ffPage._initializedPage;
        // If it's a new window download, report it on the opener page.
        if (!originPage) {
            // Resume the page creation with an error. The page will automatically close right
            // after the download begins.
            ffPage._markAsError(new Error('Starting new page download'));
            if (ffPage._opener)
                originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
            return;
        this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
    }
    _onDownloadFinished(payload) {
        const error = payload.canceled ? 'canceled' : payload.error;
        this._downloadFinished(payload.uuid, error);
    }
    _onVideoRecordingFinished(payload) {
        var _a;
        (_a = this._takeVideo(payload.screencastId)) === null || _a === void 0 ? void 0 : _a.reportFinished();
    }
    _onDisconnect() {
        for (const video of this._idToVideo.values())
            video.artifact.reportFinished(errors_1.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
    }
}
exports.FFBrowser = FFBrowser;
class FFBrowserContext extends browserContext_1.BrowserContext {
    constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._browser = browser;
    }
    async _initialize() {
        utils_1.assert(!this._ffPages().length);
        const browserContextId = this._browserContextId;
        const promises = [super._initialize()];
        promises.push(this._browser._connection.send('Browser.setDownloadOptions', {
            browserContextId,
            downloadOptions: {
                behavior: this._options.acceptDownloads ? 'saveToDisk' : 'cancel',
                downloadsDir: this._browser.options.downloadsPath,
            },
        }));
        if (this._options.viewport) {
            const viewport = {
                viewportSize: { width: this._options.viewport.width, height: this._options.viewport.height },
                deviceScaleFactor: this._options.deviceScaleFactor || 1,
            };
            promises.push(this._browser._connection.send('Browser.setDefaultViewport', { browserContextId, viewport }));
        }
        if (this._options.hasTouch)
            promises.push(this._browser._connection.send('Browser.setTouchOverride', { browserContextId, hasTouch: true }));
        if (this._options.userAgent)
            promises.push(this._browser._connection.send('Browser.setUserAgentOverride', { browserContextId, userAgent: this._options.userAgent }));
        if (this._options.bypassCSP)
            promises.push(this._browser._connection.send('Browser.setBypassCSP', { browserContextId, bypassCSP: true }));
        if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._connection.send('Browser.setIgnoreHTTPSErrors', { browserContextId, ignoreHTTPSErrors: true }));
        if (this._options.javaScriptEnabled === false)
            promises.push(this._browser._connection.send('Browser.setJavaScriptDisabled', { browserContextId, javaScriptDisabled: true }));
        if (this._options.locale)
            promises.push(this._browser._connection.send('Browser.setLocaleOverride', { browserContextId, locale: this._options.locale }));
        if (this._options.timezoneId)
            promises.push(this._browser._connection.send('Browser.setTimezoneOverride', { browserContextId, timezoneId: this._options.timezoneId }));
        if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.extraHTTPHeaders || this._options.locale)
            promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
        if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
        promises.push(this._browser._connection.send('Browser.setColorScheme', {
            browserContextId,
            colorScheme: this._options.colorScheme !== undefined ? this._options.colorScheme : 'light',
        }));
        promises.push(this._browser._connection.send('Browser.setReducedMotion', {
            browserContextId,
            reducedMotion: this._options.reducedMotion !== undefined ? this._options.reducedMotion : 'no-preference',
        }));
        if (this._options.recordVideo) {
            promises.push(this._ensureVideosPath().then(() => {
                return this._browser._connection.send('Browser.setVideoRecordingOptions', {
                    // validateBrowserContextOptions ensures correct video size.
                    ...this._options.recordVideo.size,
                    dir: this._options.recordVideo.dir,
                    browserContextId: this._browserContextId
                });
            }));
        }
        if (this._options.proxy) {
            promises.push(this._browser._connection.send('Browser.setContextProxy', {
                browserContextId: this._browserContextId,
                ...toJugglerProxyOptions(this._options.proxy)
            }));
        }
        await Promise.all(promises);
    }
    _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter(ffPage => ffPage._browserContext === this);
    }
    pages() {
        return this._ffPages().map(ffPage => ffPage._initializedPage).filter(pageOrNull => !!pageOrNull);
    }
    async newPageDelegate() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const { targetId } = await this._browser._connection.send('Browser.newPage', {
            browserContextId: this._browserContextId
        }).catch(e => {
            if (e.message.includes('Failed to override timezone'))
                throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
            throw e;
        });
        return this._browser._ffPages.get(targetId);
    }
    async _doCookies(urls) {
        const { cookies } = await this._browser._connection.send('Browser.getCookies', { browserContextId: this._browserContextId });
        return network.filterCookies(cookies.map(c => {
            const copy = { ...c };
            delete copy.size;
            delete copy.session;
            return copy;
        }), urls);
    }
    async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map(c => ({
            ...c,
            expires: c.expires && c.expires !== -1 ? c.expires : undefined,
        }));
        await this._browser._connection.send('Browser.setCookies', { browserContextId: this._browserContextId, cookies: cc });
    }
    async clearCookies() {
        await this._browser._connection.send('Browser.clearCookies', { browserContextId: this._browserContextId });
    }
    async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
            ['geolocation', 'geo'],
            ['persistent-storage', 'persistent-storage'],
            ['push', 'push'],
            ['notifications', 'desktop-notification'],
        ]);
        const filtered = permissions.map(permission => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._browser._connection.send('Browser.grantPermissions', { origin: origin, browserContextId: this._browserContextId, permissions: filtered });
    }
    async _doClearPermissions() {
        await this._browser._connection.send('Browser.resetPermissions', { browserContextId: this._browserContextId });
    }
    async setGeolocation(geolocation) {
        browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation;
        await this._browser._connection.send('Browser.setGeolocationOverride', { browserContextId: this._browserContextId, geolocation: geolocation || null });
    }
    async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        let allHeaders = this._options.extraHTTPHeaders;
        if (this._options.locale)
            allHeaders = network.mergeHeaders([allHeaders, network.singleHeader('Accept-Language', this._options.locale)]);
        await this._browser._connection.send('Browser.setExtraHTTPHeaders', { browserContextId: this._browserContextId, headers: allHeaders });
    }
    async setOffline(offline) {
        this._options.offline = offline;
        await this._browser._connection.send('Browser.setOnlineOverride', { browserContextId: this._browserContextId, override: offline ? 'offline' : 'online' });
    }
    async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        await this._browser._connection.send('Browser.setHTTPCredentials', { browserContextId: this._browserContextId, credentials: httpCredentials || null });
    }
    async _doAddInitScript(source) {
        await this._browser._connection.send('Browser.addScriptToEvaluateOnNewDocument', { browserContextId: this._browserContextId, script: source });
    }
    async _doExposeBinding(binding) {
        const worldName = binding.world === 'utility' ? ffPage_1.UTILITY_WORLD_NAME : '';
        await this._browser._connection.send('Browser.addBinding', { browserContextId: this._browserContextId, worldName, name: binding.name, script: binding.source });
    }
    async _doUpdateRequestInterception() {
        await this._browser._connection.send('Browser.setRequestInterception', { browserContextId: this._browserContextId, enabled: !!this._requestInterceptor });
    }
    async _onClosePersistent() { }
    async _doClose() {
        utils_1.assert(this._browserContextId);
        await this._browser._connection.send('Browser.removeBrowserContext', { browserContextId: this._browserContextId });
        this._browser._contexts.delete(this._browserContextId);
    }
}
exports.FFBrowserContext = FFBrowserContext;
function toJugglerProxyOptions(proxy) {
    const proxyServer = new URL(proxy.server);
    let port = parseInt(proxyServer.port, 10);
    let type = 'http';
    if (proxyServer.protocol === 'socks5:')
        type = 'socks';
    else if (proxyServer.protocol === 'socks4:')
        type = 'socks4';
    else if (proxyServer.protocol === 'https:')
        type = 'https';
    if (proxyServer.port === '') {
        if (proxyServer.protocol === 'http:')
            port = 80;
        else if (proxyServer.protocol === 'https:')
            port = 443;
    }
    return {
        type,
        bypass: proxy.bypass ? proxy.bypass.split(',').map(domain => domain.trim()) : [],
        host: proxyServer.hostname,
        port,
        username: proxy.username,
        password: proxy.password
    };
}
//# sourceMappingURL=ffBrowser.js.map

/***/ }),

/***/ 8256:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FFSession = exports.FFSessionEvents = exports.FFConnection = exports.kBrowserCloseMessageId = exports.ConnectionEvents = void 0;
const events_1 = __nccwpck_require__(8614);
const utils_1 = __nccwpck_require__(6416);
const stackTrace_1 = __nccwpck_require__(6010);
const debugLogger_1 = __nccwpck_require__(5203);
const helper_1 = __nccwpck_require__(7951);
exports.ConnectionEvents = {
    Disconnected: Symbol('Disconnected'),
};
// FFPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
class FFConnection extends events_1.EventEmitter {
    constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._lastId = 0;
        this._callbacks = new Map();
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    async send(method, params) {
        this._checkClosed(method);
        const id = this.nextMessageId();
        this._rawSend({ id, method, params });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    nextMessageId() {
        return ++this._lastId;
    }
    _checkClosed(method) {
        if (this._closed)
            throw new Error(`Protocol error (${method}): Browser closed.` + helper_1.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
    }
    _rawSend(message) {
        this._protocolLogger('send', message);
        this._transport.send(message);
    }
    async _onMessage(message) {
        this._protocolLogger('receive', message);
        if (message.id === exports.kBrowserCloseMessageId)
            return;
        if (message.sessionId) {
            const session = this._sessions.get(message.sessionId);
            if (session)
                session.dispatchMessage(message);
        }
        else if (message.id) {
            const callback = this._callbacks.get(message.id);
            // Callbacks could be all rejected if someone has called `.dispose()`.
            if (callback) {
                this._callbacks.delete(message.id);
                if (message.error)
                    callback.reject(createProtocolError(callback.error, callback.method, message.error));
                else
                    callback.resolve(message.result);
            }
        }
        else {
            Promise.resolve().then(() => this.emit(message.method, message.params));
        }
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        const formattedBrowserLogs = helper_1.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
            session.dispose(formattedBrowserLogs);
        this._sessions.clear();
        for (const callback of this._callbacks.values())
            callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs));
        this._callbacks.clear();
        Promise.resolve().then(() => this.emit(exports.ConnectionEvents.Disconnected));
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
    createSession(sessionId, type) {
        const session = new FFSession(this, type, sessionId, message => this._rawSend({ ...message, sessionId }));
        this._sessions.set(sessionId, session);
        return session;
    }
}
exports.FFConnection = FFConnection;
exports.FFSessionEvents = {
    Disconnected: Symbol('Disconnected')
};
class FFSession extends events_1.EventEmitter {
    constructor(connection, targetType, sessionId, rawSend) {
        super();
        this._disposed = false;
        this._crashed = false;
        this.setMaxListeners(0);
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    markAsCrashed() {
        this._crashed = true;
    }
    async send(method, params) {
        if (this._crashed)
            throw new Error('Page crashed');
        this._connection._checkClosed(method);
        if (this._disposed)
            throw new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`);
        const id = this._connection.nextMessageId();
        this._rawSend({ method, params, id });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    sendMayFail(method, params) {
        return this.send(method, params).catch(error => debugLogger_1.debugLogger.log('error', error));
    }
    dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object.error));
            else
                callback.resolve(object.result);
        }
        else {
            utils_1.assert(!object.id);
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
    dispose(formattedBrowserLogs) {
        for (const callback of this._callbacks.values())
            callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): Target closed.` + formattedBrowserLogs));
        this._callbacks.clear();
        this._disposed = true;
        this._connection._sessions.delete(this._sessionId);
        Promise.resolve().then(() => this.emit(exports.FFSessionEvents.Disconnected));
    }
}
exports.FFSession = FFSession;
function createProtocolError(error, method, protocolError) {
    let message = `Protocol error (${method}): ${protocolError.message}`;
    if ('data' in protocolError)
        message += ` ${protocolError.data}`;
    return stackTrace_1.rewriteErrorMessage(error, message);
}
//# sourceMappingURL=ffConnection.js.map

/***/ }),

/***/ 7796:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FFExecutionContext = void 0;
const js = __importStar(__nccwpck_require__(1762));
const stackTrace_1 = __nccwpck_require__(6010);
const utilityScriptSerializers_1 = __nccwpck_require__(4734);
class FFExecutionContext {
    constructor(session, executionContextId) {
        this._session = session;
        this._executionContextId = executionContextId;
    }
    async rawEvaluateJSON(expression) {
        const payload = await this._session.send('Runtime.evaluate', {
            expression,
            returnByValue: true,
            executionContextId: this._executionContextId,
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        return payload.result.value;
    }
    async rawEvaluateHandle(expression) {
        const payload = await this._session.send('Runtime.evaluate', {
            expression,
            returnByValue: false,
            executionContextId: this._executionContextId,
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        return payload.result.objectId;
    }
    rawCallFunctionNoReply(func, ...args) {
        this._session.send('Runtime.callFunction', {
            functionDeclaration: func.toString(),
            args: args.map(a => a instanceof js.JSHandle ? { objectId: a._objectId } : { value: a }),
            returnByValue: true,
            executionContextId: this._executionContextId
        }).catch(() => { });
    }
    async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        const payload = await this._session.send('Runtime.callFunction', {
            functionDeclaration: expression,
            args: [
                { objectId: utilityScript._objectId, value: undefined },
                ...values.map(value => ({ value })),
                ...objectIds.map(objectId => ({ objectId, value: undefined })),
            ],
            returnByValue,
            executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        if (returnByValue)
            return utilityScriptSerializers_1.parseEvaluationResultValue(payload.result.value);
        return utilityScript._context.createHandle(payload.result);
    }
    async getProperties(context, objectId) {
        const response = await this._session.send('Runtime.getObjectProperties', {
            executionContextId: this._executionContextId,
            objectId,
        });
        const result = new Map();
        for (const property of response.properties)
            result.set(property.name, context.createHandle(property.value));
        return result;
    }
    createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || '', remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
    }
    async releaseHandle(objectId) {
        await this._session.send('Runtime.disposeObject', {
            executionContextId: this._executionContextId,
            objectId
        });
    }
}
exports.FFExecutionContext = FFExecutionContext;
function checkException(exceptionDetails) {
    if (!exceptionDetails)
        return;
    if (exceptionDetails.value)
        throw new Error('Evaluation failed: ' + JSON.stringify(exceptionDetails.value));
    else
        throw new Error('Evaluation failed: ' + exceptionDetails.text + '\n' + exceptionDetails.stack);
}
function rewriteError(error) {
    if (error.message.includes('cyclic object value') || error.message.includes('Object is not serializable'))
        return { result: { type: 'undefined', value: undefined } };
    if (js.isContextDestroyedError(error))
        throw new Error('Execution context was destroyed, most likely because of a navigation.');
    if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON'))
        stackTrace_1.rewriteErrorMessage(error, error.message + ' Are you passing a nested JSHandle?');
    throw error;
}
function potentiallyUnserializableValue(remoteObject) {
    const value = remoteObject.value;
    const unserializableValue = remoteObject.unserializableValue;
    return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
}
//# sourceMappingURL=ffExecutionContext.js.map

/***/ }),

/***/ 9106:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;
function toModifiersMask(modifiers) {
    let mask = 0;
    if (modifiers.has('Alt'))
        mask |= 1;
    if (modifiers.has('Control'))
        mask |= 2;
    if (modifiers.has('Shift'))
        mask |= 4;
    if (modifiers.has('Meta'))
        mask |= 8;
    return mask;
}
function toButtonNumber(button) {
    if (button === 'left')
        return 0;
    if (button === 'middle')
        return 1;
    if (button === 'right')
        return 2;
    return 0;
}
function toButtonsMask(buttons) {
    let mask = 0;
    if (buttons.has('left'))
        mask |= 1;
    if (buttons.has('right'))
        mask |= 2;
    if (buttons.has('middle'))
        mask |= 4;
    return mask;
}
class RawKeyboardImpl {
    constructor(client) {
        this._client = client;
    }
    async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
        if (code === 'MetaLeft')
            code = 'OSLeft';
        if (code === 'MetaRight')
            code = 'OSRight';
        // Firefox will figure out Enter by itself
        if (text === '\r')
            text = '';
        await this._client.send('Page.dispatchKeyEvent', {
            type: 'keydown',
            keyCode: keyCodeWithoutLocation,
            code,
            key,
            repeat: autoRepeat,
            location,
            text,
        });
    }
    async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
        if (code === 'MetaLeft')
            code = 'OSLeft';
        if (code === 'MetaRight')
            code = 'OSRight';
        await this._client.send('Page.dispatchKeyEvent', {
            type: 'keyup',
            key,
            keyCode: keyCodeWithoutLocation,
            code,
            location,
            repeat: false
        });
    }
    async sendText(text) {
        await this._client.send('Page.insertText', { text });
    }
}
exports.RawKeyboardImpl = RawKeyboardImpl;
class RawMouseImpl {
    constructor(client) {
        this._client = client;
    }
    async move(x, y, button, buttons, modifiers) {
        await this._client.send('Page.dispatchMouseEvent', {
            type: 'mousemove',
            button: 0,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers)
        });
    }
    async down(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send('Page.dispatchMouseEvent', {
            type: 'mousedown',
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
    async up(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send('Page.dispatchMouseEvent', {
            type: 'mouseup',
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
}
exports.RawMouseImpl = RawMouseImpl;
class RawTouchscreenImpl {
    constructor(client) {
        this._client = client;
    }
    async tap(x, y, modifiers) {
        await this._client.send('Page.dispatchTapEvent', {
            x,
            y,
            modifiers: toModifiersMask(modifiers),
        });
    }
}
exports.RawTouchscreenImpl = RawTouchscreenImpl;
//# sourceMappingURL=ffInput.js.map

/***/ }),

/***/ 9396:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FFNetworkManager = void 0;
const helper_1 = __nccwpck_require__(7951);
const network = __importStar(__nccwpck_require__(8781));
class FFNetworkManager {
    constructor(session, page) {
        this._startTime = 0;
        this._session = session;
        this._requests = new Map();
        this._page = page;
        this._eventListeners = [
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.requestFinished', this._onRequestFinished.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.requestFailed', this._onRequestFailed.bind(this)),
        ];
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
    }
    async setRequestInterception(enabled) {
        await this._session.send('Network.setRequestInterception', { enabled });
    }
    _onRequestWillBeSent(event) {
        const redirectedFrom = event.redirectedFrom ? (this._requests.get(event.redirectedFrom) || null) : null;
        const frame = redirectedFrom ? redirectedFrom.request.frame() : (event.frameId ? this._page._frameManager.frame(event.frameId) : null);
        if (!frame)
            return;
        if (redirectedFrom)
            this._requests.delete(redirectedFrom._id);
        const request = new InterceptableRequest(this._session, frame, redirectedFrom, event);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _onResponseReceived(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
            return;
        const getResponseBody = async () => {
            const response = await this._session.send('Network.getResponseBody', {
                requestId: request._id
            });
            if (response.evicted)
                throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
            return Buffer.from(response.base64body, 'base64');
        };
        this._startTime = event.timing.startTime;
        const timing = {
            startTime: this._startTime / 1000,
            domainLookupStart: this._relativeTiming(event.timing.domainLookupStart),
            domainLookupEnd: this._relativeTiming(event.timing.domainLookupEnd),
            connectStart: this._relativeTiming(event.timing.connectStart),
            secureConnectionStart: this._relativeTiming(event.timing.secureConnectionStart),
            connectEnd: this._relativeTiming(event.timing.connectEnd),
            requestStart: this._relativeTiming(event.timing.requestStart),
            responseStart: this._relativeTiming(event.timing.responseStart),
        };
        const response = new network.Response(request.request, event.status, event.statusText, event.headers, timing, getResponseBody);
        this._page._frameManager.requestReceivedResponse(response);
    }
    _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
            return;
        const response = request.request._existingResponse();
        // Keep redirected requests in the map for future reference as redirectedFrom.
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        if (isRedirected) {
            response._requestFinished(this._relativeTiming(event.responseEndTime), 'Response body is unavailable for redirect responses');
        }
        else {
            this._requests.delete(request._id);
            response._requestFinished(this._relativeTiming(event.responseEndTime));
        }
        this._page._frameManager.requestFinished(request.request);
    }
    _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
            return;
        this._requests.delete(request._id);
        const response = request.request._existingResponse();
        if (response)
            response._requestFinished(-1);
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === 'NS_BINDING_ABORTED');
    }
    _relativeTiming(time) {
        if (!time)
            return -1;
        return (time - this._startTime) / 1000;
    }
}
exports.FFNetworkManager = FFNetworkManager;
const causeToResourceType = {
    TYPE_INVALID: 'other',
    TYPE_OTHER: 'other',
    TYPE_SCRIPT: 'script',
    TYPE_IMAGE: 'image',
    TYPE_STYLESHEET: 'stylesheet',
    TYPE_OBJECT: 'other',
    TYPE_DOCUMENT: 'document',
    TYPE_SUBDOCUMENT: 'document',
    TYPE_REFRESH: 'document',
    TYPE_XBL: 'other',
    TYPE_PING: 'other',
    TYPE_XMLHTTPREQUEST: 'xhr',
    TYPE_OBJECT_SUBREQUEST: 'other',
    TYPE_DTD: 'other',
    TYPE_FONT: 'font',
    TYPE_MEDIA: 'media',
    TYPE_WEBSOCKET: 'websocket',
    TYPE_CSP_REPORT: 'other',
    TYPE_XSLT: 'other',
    TYPE_BEACON: 'other',
    TYPE_FETCH: 'fetch',
    TYPE_IMAGESET: 'images',
    TYPE_WEB_MANIFEST: 'manifest',
};
const internalCauseToResourceType = {
    TYPE_INTERNAL_EVENTSOURCE: 'eventsource',
};
class InterceptableRequest {
    constructor(session, frame, redirectedFrom, payload) {
        this._id = payload.requestId;
        this._session = session;
        let postDataBuffer = null;
        if (payload.postData)
            postDataBuffer = Buffer.from(payload.postData, 'base64');
        this.request = new network.Request(payload.isIntercepted ? this : null, frame, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || 'other', payload.method, postDataBuffer, payload.headers);
    }
    async continue(overrides) {
        await this._session.sendMayFail('Network.resumeInterceptedRequest', {
            requestId: this._id,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
        });
    }
    async fulfill(response) {
        const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
        await this._session.sendMayFail('Network.fulfillInterceptedRequest', {
            requestId: this._id,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)] || '',
            headers: response.headers,
            base64body,
        });
    }
    async abort(errorCode) {
        await this._session.sendMayFail('Network.abortInterceptedRequest', {
            requestId: this._id,
            errorCode,
        });
    }
}
//# sourceMappingURL=ffNetworkManager.js.map

/***/ }),

/***/ 8103:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FFPage = exports.UTILITY_WORLD_NAME = void 0;
const dialog = __importStar(__nccwpck_require__(7639));
const dom = __importStar(__nccwpck_require__(9418));
const helper_1 = __nccwpck_require__(7951);
const utils_1 = __nccwpck_require__(6416);
const page_1 = __nccwpck_require__(9406);
const ffAccessibility_1 = __nccwpck_require__(3319);
const ffConnection_1 = __nccwpck_require__(8256);
const ffExecutionContext_1 = __nccwpck_require__(7796);
const ffInput_1 = __nccwpck_require__(9106);
const ffNetworkManager_1 = __nccwpck_require__(9396);
const stackTrace_1 = __nccwpck_require__(6010);
const debugLogger_1 = __nccwpck_require__(5203);
exports.UTILITY_WORLD_NAME = '__playwright_utility_world__';
class FFPage {
    constructor(session, browserContext, opener) {
        this.cspErrorsAsynchronousForInlineScipts = true;
        this._pageCallback = () => { };
        this._initializedPage = null;
        this._initializationFailed = false;
        this._workers = new Map();
        this._session = session;
        this._opener = opener;
        this.rawKeyboard = new ffInput_1.RawKeyboardImpl(session);
        this.rawMouse = new ffInput_1.RawMouseImpl(session);
        this.rawTouchscreen = new ffInput_1.RawTouchscreenImpl(session);
        this._contextIdToContext = new Map();
        this._browserContext = browserContext;
        this._page = new page_1.Page(this, browserContext);
        this._networkManager = new ffNetworkManager_1.FFNetworkManager(session, this._page);
        this._page.on(page_1.Page.Events.FrameDetached, frame => this._removeContextsForFrame(frame));
        // TODO: remove Page.willOpenNewWindowAsynchronously from the protocol.
        this._eventListeners = [
            helper_1.helper.addEventListener(this._session, 'Page.eventFired', this._onEventFired.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.frameAttached', this._onFrameAttached.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.frameDetached', this._onFrameDetached.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationAborted', this._onNavigationAborted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationCommitted', this._onNavigationCommitted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationStarted', this._onNavigationStarted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.sameDocumentNavigation', this._onSameDocumentNavigation.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextCreated', this._onExecutionContextCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextDestroyed', this._onExecutionContextDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.linkClicked', event => this._onLinkClicked(event.phase)),
            helper_1.helper.addEventListener(this._session, 'Page.uncaughtError', this._onUncaughtError.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.console', this._onConsole.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.dialogOpened', this._onDialogOpened.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.bindingCalled', this._onBindingCalled.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.fileChooserOpened', this._onFileChooserOpened.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.workerCreated', this._onWorkerCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.workerDestroyed', this._onWorkerDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.dispatchMessageFromWorker', this._onDispatchMessageFromWorker.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.crashed', this._onCrashed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.videoRecordingStarted', this._onVideoRecordingStarted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.webSocketCreated', this._onWebSocketCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.webSocketClosed', this._onWebSocketClosed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.webSocketFrameReceived', this._onWebSocketFrameReceived.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.webSocketFrameSent', this._onWebSocketFrameSent.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.screencastFrame', this._onScreencastFrame.bind(this)),
        ];
        this._pagePromise = new Promise(f => this._pageCallback = f);
        session.once(ffConnection_1.FFSessionEvents.Disconnected, () => {
            this._markAsError(new Error('Page closed'));
            this._page._didDisconnect();
        });
        this._session.once('Page.ready', async () => {
            await this._page.initOpener(this._opener);
            // Note: it is important to call |reportAsNew| before resolving pageOrError promise,
            // so that anyone who awaits pageOrError got a ready and reported page.
            this._initializedPage = this._page;
            this._page.reportAsNew();
            this._pageCallback(this._page);
        });
        // Ideally, we somehow ensure that utility world is created before Page.ready arrives, but currently it is racy.
        // Therefore, we can end up with an initialized page without utility world, although very unlikely.
        this._session.send('Page.addScriptToEvaluateOnNewDocument', { script: '', worldName: exports.UTILITY_WORLD_NAME }).catch(e => this._markAsError(e));
    }
    async _markAsError(error) {
        // Same error may be report twice: channer disconnected and session.send fails.
        if (this._initializationFailed)
            return;
        this._initializationFailed = true;
        if (!this._initializedPage) {
            await this._page.initOpener(this._opener);
            this._page.reportAsNew(error);
            this._pageCallback(error);
        }
    }
    async pageOrError() {
        return this._pagePromise;
    }
    _onWebSocketCreated(event) {
        this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
        this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
    }
    _onWebSocketClosed(event) {
        if (event.error)
            this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
        this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
    }
    _onWebSocketFrameReceived(event) {
        this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
    }
    _onWebSocketFrameSent(event) {
        this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
    }
    _onExecutionContextCreated(payload) {
        const { executionContextId, auxData } = payload;
        const frame = this._page._frameManager.frame(auxData.frameId);
        if (!frame)
            return;
        const delegate = new ffExecutionContext_1.FFExecutionContext(this._session, executionContextId);
        let worldName = null;
        if (auxData.name === exports.UTILITY_WORLD_NAME)
            worldName = 'utility';
        else if (!auxData.name)
            worldName = 'main';
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        if (worldName)
            frame._contextCreated(worldName, context);
        this._contextIdToContext.set(executionContextId, context);
    }
    _onExecutionContextDestroyed(payload) {
        const { executionContextId } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
    }
    _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
            if (context.frame === frame)
                this._contextIdToContext.delete(contextId);
        }
    }
    _onLinkClicked(phase) {
        if (phase === 'before')
            this._page._frameManager.frameWillPotentiallyRequestNavigation();
        else
            this._page._frameManager.frameDidPotentiallyRequestNavigation();
    }
    _onNavigationStarted(params) {
        this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
    }
    _onNavigationAborted(params) {
        this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
    }
    _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
            if (worker.frameId === params.frameId)
                this._onWorkerDestroyed({ workerId });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || '', params.navigationId || '', false);
    }
    _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
    }
    _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
    }
    _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
    }
    _onEventFired(payload) {
        const { frameId, name } = payload;
        if (name === 'load')
            this._page._frameManager.frameLifecycleEvent(frameId, 'load');
        if (name === 'DOMContentLoaded')
            this._page._frameManager.frameLifecycleEvent(frameId, 'domcontentloaded');
    }
    _onUncaughtError(params) {
        const { name, message } = stackTrace_1.splitErrorMessage(params.message);
        const error = new Error(message);
        error.stack = params.stack;
        error.name = name;
        this._page.emit(page_1.Page.Events.PageError, error);
    }
    _onConsole(payload) {
        const { type, args, executionContextId, location } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        this._page._addConsoleMessage(type, args.map(arg => context.createHandle(arg)), location);
    }
    _onDialogOpened(params) {
        this._page.emit(page_1.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, async (accept, promptText) => {
            await this._session.sendMayFail('Page.handleDialog', { dialogId: params.dialogId, accept, promptText });
        }, params.defaultValue));
    }
    async _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        const pageOrError = await this.pageOrError();
        if (!(pageOrError instanceof Error))
            await this._page._onBindingCalled(event.payload, context);
    }
    async _onFileChooserOpened(payload) {
        const { executionContextId, element } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        const handle = context.createHandle(element).asElement();
        await this._page._onFileChooserOpened(handle);
    }
    async _onWorkerCreated(event) {
        const workerId = event.workerId;
        const worker = new page_1.Worker(this._page, event.url);
        const workerSession = new ffConnection_1.FFSession(this._session._connection, 'worker', workerId, (message) => {
            this._session.send('Page.sendMessageToWorker', {
                frameId: event.frameId,
                workerId: workerId,
                message: JSON.stringify(message)
            }).catch(e => {
                workerSession.dispatchMessage({ id: message.id, method: '', params: {}, error: { message: e.message, data: undefined } });
            });
        });
        this._workers.set(workerId, { session: workerSession, frameId: event.frameId });
        this._page._addWorker(workerId, worker);
        workerSession.once('Runtime.executionContextCreated', event => {
            worker._createExecutionContext(new ffExecutionContext_1.FFExecutionContext(workerSession, event.executionContextId));
        });
        workerSession.on('Runtime.console', event => {
            const { type, args, location } = event;
            const context = worker._existingExecutionContext;
            this._page._addConsoleMessage(type, args.map(arg => context.createHandle(arg)), location);
        });
        // Note: we receive worker exceptions directly from the page.
    }
    _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
            return;
        worker.session.dispose();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
    }
    async _onDispatchMessageFromWorker(event) {
        const worker = this._workers.get(event.workerId);
        if (!worker)
            return;
        worker.session.dispatchMessage(JSON.parse(event.message));
    }
    async _onCrashed(event) {
        this._session.markAsCrashed();
        this._page._didCrash();
    }
    _onVideoRecordingStarted(event) {
        this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
    }
    async exposeBinding(binding) {
        const worldName = binding.world === 'utility' ? exports.UTILITY_WORLD_NAME : '';
        await this._session.send('Page.addBinding', { name: binding.name, script: binding.source, worldName });
    }
    didClose() {
        this._session.dispose();
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
    }
    async navigateFrame(frame, url, referer) {
        const response = await this._session.send('Page.navigate', { url, referer, frameId: frame._id });
        return { newDocumentId: response.navigationId || undefined };
    }
    async updateExtraHTTPHeaders() {
        await this._session.send('Network.setExtraHTTPHeaders', { headers: this._page._state.extraHTTPHeaders || [] });
    }
    async setEmulatedSize(emulatedSize) {
        utils_1.assert(this._page._state.emulatedSize === emulatedSize);
        await this._session.send('Page.setViewportSize', {
            viewportSize: {
                width: emulatedSize.viewport.width,
                height: emulatedSize.viewport.height,
            },
        });
    }
    async bringToFront() {
        await this._session.send('Page.bringToFront', {});
    }
    async updateEmulateMedia() {
        const colorScheme = this._page._state.colorScheme === null ? undefined : this._page._state.colorScheme;
        const reducedMotion = this._page._state.reducedMotion === null ? undefined : this._page._state.reducedMotion;
        await this._session.send('Page.setEmulatedMedia', {
            // Empty string means reset.
            type: this._page._state.mediaType === null ? '' : this._page._state.mediaType,
            colorScheme,
            reducedMotion,
        });
    }
    async updateRequestInterception() {
        await this._networkManager.setRequestInterception(this._page._needsRequestInterception());
    }
    async setFileChooserIntercepted(enabled) {
        await this._session.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async reload() {
        await this._session.send('Page.reload', { frameId: this._page.mainFrame()._id });
    }
    async goBack() {
        const { success } = await this._session.send('Page.goBack', { frameId: this._page.mainFrame()._id });
        return success;
    }
    async goForward() {
        const { success } = await this._session.send('Page.goForward', { frameId: this._page.mainFrame()._id });
        return success;
    }
    async evaluateOnNewDocument(source) {
        await this._session.send('Page.addScriptToEvaluateOnNewDocument', { script: source });
    }
    async closePage(runBeforeUnload) {
        await this._session.send('Page.close', { runBeforeUnload });
    }
    canScreenshotOutsideViewport() {
        return true;
    }
    async setBackgroundColor(color) {
        if (color)
            throw new Error('Not implemented');
    }
    async takeScreenshot(progress, format, documentRect, viewportRect, quality) {
        if (!documentRect) {
            const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({ x: window.scrollX, y: window.scrollY }));
            documentRect = {
                x: viewportRect.x + scrollOffset.x,
                y: viewportRect.y + scrollOffset.y,
                width: viewportRect.width,
                height: viewportRect.height,
            };
        }
        // TODO: remove fullPage option from Page.screenshot.
        // TODO: remove Page.getBoundingBox method.
        progress.throwIfAborted();
        const { data } = await this._session.send('Page.screenshot', {
            mimeType: ('image/' + format),
            clip: documentRect,
        });
        return Buffer.from(data, 'base64');
    }
    async resetViewport() {
        utils_1.assert(false, 'Should not be called');
    }
    async getContentFrame(handle) {
        const { contentFrameId } = await this._session.send('Page.describeNode', {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
        });
        if (!contentFrameId)
            return null;
        return this._page._frameManager.frame(contentFrameId);
    }
    async getOwnerFrame(handle) {
        const { ownerFrameId } = await this._session.send('Page.describeNode', {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
        });
        return ownerFrameId || null;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
            return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
            for (const point of quad) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._session.send('Page.scrollIntoViewIfNeeded', {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            rect,
        }).then(() => 'done').catch(e => {
            if (e instanceof Error && e.message.includes('Node is detached from document'))
                return 'error:notconnected';
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                return 'error:notvisible';
            throw e;
        });
    }
    async setScreencastOptions(options) {
        if (options) {
            const { screencastId } = await this._session.send('Page.startScreencast', options);
            this._screencastId = screencastId;
        }
        else {
            await this._session.send('Page.stopScreencast');
        }
    }
    _onScreencastFrame(event) {
        if (!this._screencastId)
            return;
        this._session.send('Page.screencastFrameAck', { screencastId: this._screencastId }).catch(e => debugLogger_1.debugLogger.log('error', e));
        const buffer = Buffer.from(event.data, 'base64');
        this._page.emit(page_1.Page.Events.ScreencastFrame, {
            buffer,
            width: event.deviceWidth,
            height: event.deviceHeight,
        });
    }
    rafCountForStablePosition() {
        return 1;
    }
    async getContentQuads(handle) {
        const result = await this._session.sendMayFail('Page.getContentQuads', {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
        });
        if (!result)
            return null;
        return result.quads.map(quad => [quad.p1, quad.p2, quad.p3, quad.p4]);
    }
    async setInputFiles(handle, files) {
        await handle.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), files);
    }
    async adoptElementHandle(handle, to) {
        const result = await this._session.send('Page.adoptNode', {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            executionContextId: to._delegate._executionContextId
        });
        if (!result.remoteObject)
            throw new Error(dom.kUnableToAdoptErrorMessage);
        return to.createHandle(result.remoteObject);
    }
    async getAccessibilityTree(needle) {
        return ffAccessibility_1.getAccessibilityTree(this._session, needle);
    }
    async inputActionEpilogue() {
    }
    async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const handles = await this._page.selectors._queryAll(parent, 'frame,iframe', undefined);
        const items = await Promise.all(handles.map(async (handle) => {
            const frame = await handle.contentFrame().catch(e => null);
            return { handle, frame };
        }));
        const result = items.find(item => item.frame === frame);
        items.map(item => item === result ? Promise.resolve() : item.handle.dispose());
        if (!result)
            throw new Error('Frame has been detached.');
        return result.handle;
    }
}
exports.FFPage = FFPage;
function webSocketId(frameId, wsid) {
    return `${frameId}---${wsid}`;
}
//# sourceMappingURL=ffPage.js.map

/***/ }),

/***/ 6175:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Firefox = void 0;
const os = __importStar(__nccwpck_require__(2087));
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
const utils_1 = __nccwpck_require__(6416);
const ffBrowser_1 = __nccwpck_require__(7212);
const ffConnection_1 = __nccwpck_require__(8256);
const browserType_1 = __nccwpck_require__(3783);
class Firefox extends browserType_1.BrowserType {
    constructor(playwrightOptions) {
        super('firefox', playwrightOptions);
    }
    executablePath(channel) {
        if (channel) {
            let executablePath = undefined;
            if (channel === 'firefox-beta')
                executablePath = this._registry.executablePath('firefox-beta');
            utils_1.assert(executablePath, `unsupported firefox channel "${channel}"`);
            utils_1.assert(fs_1.default.existsSync(executablePath), `"${channel}" channel is not installed. Try running 'npx playwright install ${channel}'`);
            return executablePath;
        }
        return super.executablePath(channel);
    }
    _connectToTransport(transport, options) {
        return ffBrowser_1.FFBrowser.connect(transport, options);
    }
    _rewriteStartupError(error) {
        return error;
    }
    _amendEnvironment(env, userDataDir, executable, browserArguments) {
        if (!path_1.default.isAbsolute(os.homedir()))
            throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === 'win32' ? 'USERPROFILE' : 'HOME'} to a relative path?`);
        if (os.platform() === 'linux') {
            return {
                ...env,
                // On linux Juggler ships the libstdc++ it was linked against.
                LD_LIBRARY_PATH: `${path_1.default.dirname(executable)}:${process.env.LD_LIBRARY_PATH}`,
            };
        }
        if (os.platform() === 'darwin') {
            return {
                ...env,
                // @see https://github.com/microsoft/playwright/issues/5721
                MOZ_WEBRENDER: 0,
            };
        }
        return env;
    }
    _attemptToGracefullyCloseBrowser(transport) {
        const message = { method: 'Browser.close', params: {}, id: ffConnection_1.kBrowserCloseMessageId };
        transport.send(message);
    }
    _defaultArgs(options, isPersistent, userDataDir) {
        const { args = [], devtools, headless } = options;
        if (devtools)
            console.warn('devtools parameter is not supported as a launch argument in Firefox. You can launch the devtools window manually.');
        const userDataDirArg = args.find(arg => arg.startsWith('-profile') || arg.startsWith('--profile'));
        if (userDataDirArg)
            throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument');
        if (args.find(arg => arg.startsWith('-juggler')))
            throw new Error('Use the port parameter instead of -juggler argument');
        const firefoxUserPrefs = isPersistent ? undefined : options.firefoxUserPrefs;
        if (firefoxUserPrefs) {
            const lines = [];
            for (const [name, value] of Object.entries(firefoxUserPrefs))
                lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);
            fs_1.default.writeFileSync(path_1.default.join(userDataDir, 'user.js'), lines.join('\n'));
        }
        const firefoxArguments = ['-no-remote'];
        if (headless) {
            firefoxArguments.push('-headless');
        }
        else {
            firefoxArguments.push('-wait-for-browser');
            firefoxArguments.push('-foreground');
        }
        firefoxArguments.push(`-profile`, userDataDir);
        firefoxArguments.push('-juggler-pipe');
        firefoxArguments.push(...args);
        if (isPersistent)
            firefoxArguments.push('about:blank');
        else
            firefoxArguments.push('-silent');
        return firefoxArguments;
    }
}
exports.Firefox = Firefox;
//# sourceMappingURL=firefox.js.map

/***/ }),

/***/ 3735:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Frame = exports.FrameManager = void 0;
const dom = __importStar(__nccwpck_require__(9418));
const helper_1 = __nccwpck_require__(7951);
const js = __importStar(__nccwpck_require__(1762));
const network = __importStar(__nccwpck_require__(8781));
const page_1 = __nccwpck_require__(9406);
const types = __importStar(__nccwpck_require__(6581));
const browserContext_1 = __nccwpck_require__(7533);
const progress_1 = __nccwpck_require__(6707);
const utils_1 = __nccwpck_require__(6416);
const debugLogger_1 = __nccwpck_require__(5203);
const instrumentation_1 = __nccwpck_require__(7490);
class FrameManager {
    constructor(page) {
        this._frames = new Map();
        this._consoleMessageTags = new Map();
        this._signalBarriers = new Set();
        this._webSockets = new Map();
        this._responses = [];
        this._page = page;
        this._mainFrame = undefined;
    }
    dispose() {
        for (const frame of this._frames.values())
            frame._stopNetworkIdleTimer();
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
            frames.push(frame);
            for (const subframe of frame.childFrames())
                collect(subframe);
        }
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
            if (this._mainFrame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(this._mainFrame._id);
                this._mainFrame._id = frameId;
            }
            else {
                utils_1.assert(!this._frames.has(frameId));
                this._mainFrame = new Frame(this._page, frameId, parentFrame);
            }
            this._frames.set(frameId, this._mainFrame);
            return this._mainFrame;
        }
        else {
            utils_1.assert(!this._frames.has(frameId));
            const frame = new Frame(this._page, frameId, parentFrame);
            this._frames.set(frameId, frame);
            this._page.emit(page_1.Page.Events.FrameAttached, frame);
            return frame;
        }
    }
    async waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
        if (noWaitAfter)
            return action();
        const barrier = new SignalBarrier(progress);
        this._signalBarriers.add(barrier);
        if (progress)
            progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
        const result = await action();
        if (source === 'input')
            await this._page._delegate.inputActionEpilogue();
        await barrier.waitFor();
        this._signalBarriers.delete(barrier);
        // Resolve in the next task, after all waitForNavigations.
        await new Promise(utils_1.makeWaitForNextTask());
        return result;
    }
    frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
            barrier.retain();
    }
    frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
            barrier.release();
    }
    frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        for (const barrier of this._signalBarriers)
            barrier.addFrameNavigation(frame);
        if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
            // Do not override request with undefined.
            return;
        }
        frame.setPendingDocument({ documentId, request: undefined });
    }
    frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        this.clearWebSockets(frame);
        frame._url = url;
        frame._name = name;
        let keepPending;
        const pendingDocument = frame.pendingDocument();
        if (pendingDocument) {
            if (pendingDocument.documentId === undefined) {
                // Pending with unknown documentId - assume it is the one being committed.
                pendingDocument.documentId = documentId;
            }
            if (pendingDocument.documentId === documentId) {
                // Committing a pending document.
                frame._currentDocument = pendingDocument;
            }
            else {
                // Sometimes, we already have a new pending when the old one commits.
                // An example would be Chromium error page followed by a new navigation request,
                // where the error page commit arrives after Network.requestWillBeSent for the
                // new navigation.
                // We commit, but keep the pending request since it's not done yet.
                keepPending = pendingDocument;
                frame._currentDocument = { documentId, request: undefined };
            }
            frame.setPendingDocument(undefined);
        }
        else {
            // No pending - just commit a new document.
            frame._currentDocument = { documentId, request: undefined };
        }
        frame._onClearLifecycle();
        const navigationEvent = { url, name, newDocument: frame._currentDocument };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        this._responses.length = 0;
        if (!initial) {
            debugLogger_1.debugLogger.log('api', `  navigated to "${url}"`);
            this._page.frameNavigatedToNewDocument(frame);
        }
        // Restore pending if any - see comments above about keepPending.
        frame.setPendingDocument(keepPending);
    }
    frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._url = url;
        const navigationEvent = { url, name: frame._name };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        debugLogger_1.debugLogger.log('api', `  navigated to "${url}"`);
    }
    frameAbortedNavigation(frameId, errorText, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame || !frame.pendingDocument())
            return;
        if (documentId !== undefined && frame.pendingDocument().documentId !== documentId)
            return;
        const navigationEvent = {
            url: frame._url,
            name: frame._name,
            newDocument: frame.pendingDocument(),
            error: new Error(errorText),
        };
        frame.setPendingDocument(undefined);
        frame.emit(Frame.Events.Navigation, navigationEvent);
    }
    frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    frameStoppedLoading(frameId) {
        this.frameLifecycleEvent(frameId, 'domcontentloaded');
        this.frameLifecycleEvent(frameId, 'load');
    }
    frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (frame)
            frame._onLifecycleEvent(event);
    }
    requestStarted(request) {
        const frame = request.frame();
        this._inflightRequestStarted(request);
        if (request._documentId)
            frame.setPendingDocument({ documentId: request._documentId, request });
        if (request._isFavicon) {
            const route = request._route();
            if (route)
                route.continue();
            return;
        }
        this._page._browserContext.emit(browserContext_1.BrowserContext.Events.Request, request);
        this._page._requestStarted(request);
    }
    requestReceivedResponse(response) {
        if (response.request()._isFavicon)
            return;
        this._responses.push(response);
        this._page._browserContext.emit(browserContext_1.BrowserContext.Events.Response, response);
    }
    requestFinished(request) {
        this._inflightRequestFinished(request);
        if (request._isFavicon)
            return;
        this._page._browserContext.emit(browserContext_1.BrowserContext.Events.RequestFinished, request);
    }
    requestFailed(request, canceled) {
        const frame = request.frame();
        this._inflightRequestFinished(request);
        if (frame.pendingDocument() && frame.pendingDocument().request === request) {
            let errorText = request.failure().errorText;
            if (canceled)
                errorText += '; maybe frame was detached?';
            this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
        }
        if (request._isFavicon)
            return;
        this._page._browserContext.emit(browserContext_1.BrowserContext.Events.RequestFailed, request);
    }
    removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
    }
    _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        if (!this._page.isClosed())
            this._page.emit(page_1.Page.Events.FrameDetached, frame);
    }
    _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
            return;
        if (!frame._inflightRequests.has(request))
            return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
            frame._startNetworkIdleTimer();
    }
    _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
            return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
            frame._stopNetworkIdleTimer();
    }
    interceptConsoleMessage(message) {
        if (message.type() !== 'debug')
            return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
            return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
    }
    clearWebSockets(frame) {
        // TODO: attribute sockets to frames.
        if (frame.parentFrame())
            return;
        this._webSockets.clear();
    }
    onWebSocketCreated(requestId, url) {
        const ws = new network.WebSocket(this._page, url);
        this._webSockets.set(requestId, ws);
    }
    onWebSocketRequest(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
            this._page.emit(page_1.Page.Events.WebSocket, ws);
    }
    onWebSocketResponse(requestId, status, statusText) {
        const ws = this._webSockets.get(requestId);
        if (status < 400)
            return;
        if (ws)
            ws.error(`${statusText}: ${status}`);
    }
    onWebSocketFrameSent(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
            ws.frameSent(opcode, data);
    }
    webSocketFrameReceived(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
            ws.frameReceived(opcode, data);
    }
    webSocketClosed(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
            ws.closed();
        this._webSockets.delete(requestId);
    }
    webSocketError(requestId, errorMessage) {
        const ws = this._webSockets.get(requestId);
        if (ws)
            ws.error(errorMessage);
    }
}
exports.FrameManager = FrameManager;
class Frame extends instrumentation_1.SdkObject {
    constructor(page, id, parentFrame) {
        super(page, 'frame');
        this._firedLifecycleEvents = new Set();
        this._subtreeLifecycleEvents = new Set();
        this._url = '';
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = '';
        this._inflightRequests = new Set();
        this._setContentCounter = 0;
        this._detachedCallback = () => { };
        this._nonStallingEvaluations = new Set();
        this.attribution.frame = this;
        this._id = id;
        this._page = page;
        this._parentFrame = parentFrame;
        this._currentDocument = { documentId: undefined, request: undefined };
        this._detachedPromise = new Promise(x => this._detachedCallback = x);
        this._contextData.set('main', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._contextData.set('utility', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._setContext('main', null);
        this._setContext('utility', null);
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    _onLifecycleEvent(event) {
        if (this._firedLifecycleEvents.has(event))
            return;
        this._firedLifecycleEvents.add(event);
        // Recalculate subtree lifecycle for the whole tree - it should not be that big.
        this._page.mainFrame()._recalculateLifecycle();
    }
    _onClearLifecycle() {
        this._firedLifecycleEvents.clear();
        // Recalculate subtree lifecycle for the whole tree - it should not be that big.
        this._page.mainFrame()._recalculateLifecycle();
        // Keep the current navigation request if any.
        this._inflightRequests = new Set(Array.from(this._inflightRequests).filter(request => request === this._currentDocument.request));
        this._stopNetworkIdleTimer();
        if (this._inflightRequests.size === 0)
            this._startNetworkIdleTimer();
    }
    setPendingDocument(documentInfo) {
        this._pendingDocument = documentInfo;
        if (documentInfo)
            this._invalidateNonStallingEvaluations();
    }
    pendingDocument() {
        return this._pendingDocument;
    }
    async _invalidateNonStallingEvaluations() {
        if (!this._nonStallingEvaluations)
            return;
        const error = new Error('Navigation interrupted the evaluation');
        for (const callback of this._nonStallingEvaluations)
            callback(error);
    }
    async nonStallingRawEvaluateInExistingMainContext(expression) {
        if (this._pendingDocument)
            throw new Error('Frame is currently attempting a navigation');
        const context = this._existingMainContext();
        if (!context)
            throw new Error('Frame does not yet have a main execution context');
        let callback = () => { };
        const frameInvalidated = new Promise((f, r) => callback = r);
        this._nonStallingEvaluations.add(callback);
        try {
            return await Promise.race([
                context.rawEvaluateJSON(expression),
                frameInvalidated
            ]);
        }
        finally {
            this._nonStallingEvaluations.delete(callback);
        }
    }
    async nonStallingEvaluateInExistingContext(expression, isFunction, world) {
        var _a;
        if (this._pendingDocument)
            throw new Error('Frame is currently attempting a navigation');
        const context = (_a = this._contextData.get(world)) === null || _a === void 0 ? void 0 : _a.context;
        if (!context)
            throw new Error('Frame does not yet have the execution context');
        let callback = () => { };
        const frameInvalidated = new Promise((f, r) => callback = r);
        this._nonStallingEvaluations.add(callback);
        try {
            return await Promise.race([
                context.evaluateExpression(expression, isFunction),
                frameInvalidated
            ]);
        }
        finally {
            this._nonStallingEvaluations.delete(callback);
        }
    }
    _recalculateLifecycle() {
        const events = new Set(this._firedLifecycleEvents);
        for (const child of this._childFrames) {
            child._recalculateLifecycle();
            // We require a particular lifecycle event to be fired in the whole
            // frame subtree, and then consider it done.
            for (const event of events) {
                if (!child._subtreeLifecycleEvents.has(event))
                    events.delete(event);
            }
        }
        const mainFrame = this._page.mainFrame();
        for (const event of events) {
            // Checking whether we have already notified about this event.
            if (!this._subtreeLifecycleEvents.has(event)) {
                this.emit(Frame.Events.AddLifecycle, event);
                if (this === mainFrame && this._url !== 'about:blank')
                    debugLogger_1.debugLogger.log('api', `  "${event}" event fired`);
                if (this === mainFrame && event === 'load')
                    this._page.emit(page_1.Page.Events.Load);
                if (this === mainFrame && event === 'domcontentloaded')
                    this._page.emit(page_1.Page.Events.DOMContentLoaded);
            }
        }
        for (const event of this._subtreeLifecycleEvents) {
            if (!events.has(event))
                this.emit(Frame.Events.RemoveLifecycle, event);
        }
        this._subtreeLifecycleEvents = events;
    }
    async raceNavigationAction(action) {
        return Promise.race([
            this._page._disconnectedPromise.then(() => { throw new Error('Navigation failed because page was closed!'); }),
            this._page._crashedPromise.then(() => { throw new Error('Navigation failed because page crashed!'); }),
            this._detachedPromise.then(() => { throw new Error('Navigating frame was detached!'); }),
            action(),
        ]);
    }
    async goto(metadata, url, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this._goto(progress, url, options), this._page._timeoutSettings.navigationTimeout(options));
    }
    async _goto(progress, url, options) {
        return this.raceNavigationAction(async () => {
            const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
            progress.log(`navigating to "${url}", waiting until "${waitUntil}"`);
            const headers = this._page._state.extraHTTPHeaders || [];
            const refererHeader = headers.find(h => h.name.toLowerCase() === 'referer');
            let referer = refererHeader ? refererHeader.value : undefined;
            if (options.referer !== undefined) {
                if (referer !== undefined && referer !== options.referer)
                    throw new Error('"referer" is already specified as extra HTTP header');
                referer = options.referer;
            }
            url = helper_1.helper.completeUserURL(url);
            const sameDocument = helper_1.helper.waitForEvent(progress, this, Frame.Events.Navigation, (e) => !e.newDocument);
            const navigateResult = await this._page._delegate.navigateFrame(this, url, referer);
            let event;
            if (navigateResult.newDocumentId) {
                sameDocument.dispose();
                event = await helper_1.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event) => {
                    // We are interested either in this specific document, or any other document that
                    // did commit and replaced the expected document.
                    return event.newDocument && (event.newDocument.documentId === navigateResult.newDocumentId || !event.error);
                }).promise;
                if (event.newDocument.documentId !== navigateResult.newDocumentId) {
                    // This is just a sanity check. In practice, new navigation should
                    // cancel the previous one and report "request cancelled"-like error.
                    throw new Error('Navigation interrupted by another one');
                }
                if (event.error)
                    throw event.error;
            }
            else {
                event = await sameDocument.promise;
            }
            if (!this._subtreeLifecycleEvents.has(waitUntil))
                await helper_1.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
            const request = event.newDocument ? event.newDocument.request : undefined;
            const response = request ? request._finalRequest().response() : null;
            await this._page._doSlowMo();
            return response;
        });
    }
    async _waitForNavigation(progress, options) {
        const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
        progress.log(`waiting for navigation until "${waitUntil}"`);
        const navigationEvent = await helper_1.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event) => {
            // Any failed navigation results in a rejection.
            if (event.error)
                return true;
            progress.log(`  navigated to "${this._url}"`);
            return true;
        }).promise;
        if (navigationEvent.error)
            throw navigationEvent.error;
        if (!this._subtreeLifecycleEvents.has(waitUntil))
            await helper_1.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
        const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : undefined;
        return request ? request._finalRequest().response() : null;
    }
    async _waitForLoadState(progress, state) {
        const waitUntil = verifyLifecycle('state', state);
        if (!this._subtreeLifecycleEvents.has(waitUntil))
            await helper_1.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
    }
    async frameElement() {
        return this._page._delegate.getFrameElement(this);
    }
    _context(world) {
        if (this._detached)
            throw new Error(`Execution Context is not available in detached frame "${this.url()}" (are you trying to evaluate?)`);
        return this._contextData.get(world).contextPromise;
    }
    _mainContext() {
        return this._context('main');
    }
    _existingMainContext() {
        var _a;
        return ((_a = this._contextData.get('main')) === null || _a === void 0 ? void 0 : _a.context) || null;
    }
    _utilityContext() {
        return this._context('utility');
    }
    async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = 'main') {
        const context = await this._context(world);
        const handle = await context.evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg);
        if (world === 'main')
            await this._page._doSlowMo();
        return handle;
    }
    async evaluateExpression(expression, isFunction, arg, world = 'main') {
        const context = await this._context(world);
        const value = await context.evaluateExpression(expression, isFunction, arg);
        if (world === 'main')
            await this._page._doSlowMo();
        return value;
    }
    async evaluateExpressionAndWaitForSignals(expression, isFunction, arg, world = 'main') {
        const context = await this._context(world);
        const value = await context.evaluateExpressionAndWaitForSignals(expression, isFunction, arg);
        if (world === 'main')
            await this._page._doSlowMo();
        return value;
    }
    async $(selector) {
        return this._page.selectors._query(this, selector);
    }
    async waitForSelector(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        if (options.visibility)
            throw new Error('options.visibility is not supported, did you mean options.state?');
        if (options.waitFor && options.waitFor !== 'visible')
            throw new Error('options.waitFor is not supported, did you mean options.state?');
        const { state = 'visible' } = options;
        if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.waitForSelectorTask(info, state);
        return controller.run(async (progress) => {
            progress.log(`waiting for selector "${selector}"${state === 'attached' ? '' : ' to be ' + state}`);
            while (progress.isRunning()) {
                const result = await this._scheduleRerunnableHandleTask(progress, info.world, task);
                if (!result.asElement()) {
                    result.dispose();
                    return null;
                }
                if (options.__testHookBeforeAdoptNode)
                    await options.__testHookBeforeAdoptNode();
                try {
                    const handle = result.asElement();
                    const adopted = await handle._adoptTo(await this._mainContext());
                    return adopted;
                }
                catch (e) {
                    // Navigated while trying to adopt the node.
                    if (!js.isContextDestroyedError(e) && !e.message.includes(dom.kUnableToAdoptErrorMessage))
                        throw e;
                    result.dispose();
                }
            }
            return null;
        }, this._page._timeoutSettings.timeout(options));
    }
    async dispatchEvent(metadata, selector, type, eventInit, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.dispatchEventTask(info, type, eventInit || {});
        await controller.run(async (progress) => {
            progress.log(`Dispatching "${type}" event on selector "${selector}"...`);
            // Note: we always dispatch events in the main world.
            await this._scheduleRerunnableTask(progress, 'main', task);
        }, this._page._timeoutSettings.timeout(options));
        await this._page._doSlowMo();
    }
    async evalOnSelectorAndWaitForSignals(selector, expression, isFunction, arg) {
        const handle = await this.$(selector);
        if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        handle.dispose();
        return result;
    }
    async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        const arrayHandle = await this._page.selectors._queryArray(this, selector);
        const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
    }
    async $$(selector) {
        return this._page.selectors._queryAll(this, selector, undefined, true /* adoptToMain */);
    }
    async content() {
        const context = await this._utilityContext();
        return context.evaluate(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(metadata, html, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this.raceNavigationAction(async () => {
            const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
            progress.log(`setting frame content, waiting until "${waitUntil}"`);
            const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
            const context = await this._utilityContext();
            const lifecyclePromise = new Promise((resolve, reject) => {
                this._page._frameManager._consoleMessageTags.set(tag, () => {
                    // Clear lifecycle right after document.open() - see 'tag' below.
                    this._onClearLifecycle();
                    this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
                });
            });
            const contentPromise = context.evaluate(({ html, tag }) => {
                window.stop();
                document.open();
                console.debug(tag); // eslint-disable-line no-console
                document.write(html);
                document.close();
            }, { html, tag });
            await Promise.all([contentPromise, lifecyclePromise]);
            await this._page._doSlowMo();
        }), this._page._timeoutSettings.navigationTimeout(options));
    }
    name() {
        return this._name || '';
    }
    url() {
        return this._url;
    }
    parentFrame() {
        return this._parentFrame;
    }
    childFrames() {
        return Array.from(this._childFrames);
    }
    async addScriptTag(params) {
        const { url = null, content = null, type = '' } = params;
        if (!url && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandle(addScriptUrl, { url, type })).asElement();
            const result = (await context.evaluateHandle(addScriptContent, { content: content, type })).asElement();
            // Another round trip to the browser to ensure that we receive CSP error messages
            // (if any) logged asynchronously in a separate task on the content main thread.
            if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
                await context.evaluate(() => true);
            return result;
        });
        async function addScriptUrl(params) {
            const script = document.createElement('script');
            script.src = params.url;
            if (params.type)
                script.type = params.type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = e => rej(typeof e === 'string' ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(params) {
            const script = document.createElement('script');
            script.type = params.type || 'text/javascript';
            script.text = params.content;
            let error = null;
            script.onerror = e => error = e;
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    async addStyleTag(params) {
        const { url = null, content = null } = params;
        if (!url && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandle(addStyleUrl, url)).asElement();
            return (await context.evaluateHandle(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error;
        let cspMessage;
        const actionPromise = new Promise(async (resolve) => {
            try {
                result = await func();
            }
            catch (e) {
                error = e;
            }
            resolve();
        });
        const errorPromise = new Promise(resolve => {
            listeners.push(helper_1.helper.addEventListener(this._page, page_1.Page.Events.Console, (message) => {
                if (message.type() === 'error' && message.text().includes('Content Security Policy')) {
                    cspMessage = message;
                    resolve();
                }
            }));
        });
        await Promise.race([actionPromise, errorPromise]);
        helper_1.helper.removeEventListeners(listeners);
        if (cspMessage)
            throw new Error(cspMessage.text());
        if (error)
            throw error;
        return result;
    }
    async _retryWithProgressIfNotConnected(progress, selector, action) {
        const info = this._page.selectors._parseSelector(selector);
        while (progress.isRunning()) {
            progress.log(`waiting for selector "${selector}"`);
            const task = dom.waitForSelectorTask(info, 'attached');
            const handle = await this._scheduleRerunnableHandleTask(progress, info.world, task);
            const element = handle.asElement();
            progress.cleanupWhenAborted(() => {
                // Do not await here to avoid being blocked, either by stalled
                // page (e.g. alert) or unresolved navigation in Chromium.
                element.dispose();
            });
            const result = await action(element);
            element.dispose();
            if (result === 'error:notconnected') {
                progress.log('element was detached from the DOM, retrying');
                continue;
            }
            return result;
        }
        return undefined;
    }
    async _retryWithSelectorIfNotConnected(controller, selector, options, action) {
        return controller.run(async (progress) => {
            return this._retryWithProgressIfNotConnected(progress, selector, handle => action(progress, handle));
        }, this._page._timeoutSettings.timeout(options));
    }
    async click(metadata, selector, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._click(progress, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async dblclick(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._dblclick(progress, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async tap(metadata, selector, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._tap(progress, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async fill(metadata, selector, value, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._fill(progress, value, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async focus(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        await this._retryWithSelectorIfNotConnected(controller, selector, options, (progress, handle) => handle._focus(progress));
        await this._page._doSlowMo();
    }
    async textContent(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.textContentTask(info);
        return controller.run(async (progress) => {
            progress.log(`  retrieving textContent from "${selector}"`);
            return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options));
    }
    async innerText(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.innerTextTask(info);
        return controller.run(async (progress) => {
            progress.log(`  retrieving innerText from "${selector}"`);
            const result = dom.throwFatalDOMError(await this._scheduleRerunnableTask(progress, info.world, task));
            return result.innerText;
        }, this._page._timeoutSettings.timeout(options));
    }
    async innerHTML(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.innerHTMLTask(info);
        return controller.run(async (progress) => {
            progress.log(`  retrieving innerHTML from "${selector}"`);
            return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options));
    }
    async getAttribute(metadata, selector, name, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.getAttributeTask(info, name);
        return controller.run(async (progress) => {
            progress.log(`  retrieving attribute "${name}" from "${selector}"`);
            return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options));
    }
    async _checkElementState(metadata, selector, state, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.elementStateTask(info, state);
        const result = await controller.run(async (progress) => {
            progress.log(`  checking "${state}" state of "${selector}"`);
            return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options));
        return dom.throwFatalDOMError(dom.throwRetargetableDOMError(result));
    }
    async isVisible(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            progress.log(`  checking visibility of "${selector}"`);
            const element = await this.$(selector);
            return element ? await element.isVisible() : false;
        }, this._page._timeoutSettings.timeout(options));
    }
    async isHidden(metadata, selector, options = {}) {
        return !(await this.isVisible(metadata, selector, options));
    }
    async isDisabled(metadata, selector, options = {}) {
        return this._checkElementState(metadata, selector, 'disabled', options);
    }
    async isEnabled(metadata, selector, options = {}) {
        return this._checkElementState(metadata, selector, 'enabled', options);
    }
    async isEditable(metadata, selector, options = {}) {
        return this._checkElementState(metadata, selector, 'editable', options);
    }
    async isChecked(metadata, selector, options = {}) {
        return this._checkElementState(metadata, selector, 'checked', options);
    }
    async hover(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._hover(progress, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async selectOption(metadata, selector, elements, values, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._selectOption(progress, elements, values, options));
        }, this._page._timeoutSettings.timeout(options));
    }
    async setInputFiles(metadata, selector, files, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._setInputFiles(progress, files, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async type(metadata, selector, text, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._type(progress, text, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async press(metadata, selector, key, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._press(progress, key, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async check(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._setChecked(progress, true, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async uncheck(metadata, selector, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
            return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, handle => handle._setChecked(progress, false, options)));
        }, this._page._timeoutSettings.timeout(options));
    }
    async _waitForFunctionExpression(metadata, expression, isFunction, arg, options, world = 'main') {
        const controller = new progress_1.ProgressController(metadata, this);
        if (typeof options.pollingInterval === 'number')
            utils_1.assert(options.pollingInterval > 0, 'Cannot poll with non-positive interval: ' + options.pollingInterval);
        expression = js.normalizeEvaluationExpression(expression, isFunction);
        const task = injectedScript => injectedScript.evaluateHandle((injectedScript, { expression, isFunction, polling, arg }) => {
            const predicate = (arg) => {
                let result = self.eval(expression);
                if (isFunction === true) {
                    result = result(arg);
                }
                else if (isFunction === false) {
                    result = result;
                }
                else {
                    // auto detect.
                    if (typeof result === 'function')
                        result = result(arg);
                }
                return result;
            };
            if (typeof polling !== 'number')
                return injectedScript.pollRaf((progress, continuePolling) => predicate(arg) || continuePolling);
            return injectedScript.pollInterval(polling, (progress, continuePolling) => predicate(arg) || continuePolling);
        }, { expression, isFunction, polling: options.pollingInterval, arg });
        return controller.run(progress => this._scheduleRerunnableHandleTask(progress, world, task), this._page._timeoutSettings.timeout(options));
    }
    async waitForFunctionValueInUtility(progress, pageFunction) {
        const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
        const handle = await this._waitForFunctionExpression(instrumentation_1.internalCallMetadata(), expression, true, undefined, { timeout: progress.timeUntilDeadline() }, 'utility');
        return JSON.parse(handle.rawValue());
    }
    async title() {
        const context = await this._utilityContext();
        return context.evaluate(() => document.title);
    }
    _onDetached() {
        this._stopNetworkIdleTimer();
        this._detached = true;
        this._detachedCallback();
        for (const data of this._contextData.values()) {
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        }
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
    _scheduleRerunnableTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, true /* returnByValue */);
        if (this._detached)
            rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        if (data.context)
            rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
    }
    _scheduleRerunnableHandleTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, false /* returnByValue */);
        if (this._detached)
            rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        if (data.context)
            rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
    }
    _setContext(world, context) {
        const data = this._contextData.get(world);
        data.context = context;
        if (context) {
            data.contextResolveCallback.call(null, context);
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.rerun(context);
        }
        else {
            data.contextPromise = new Promise(fulfill => {
                data.contextResolveCallback = fulfill;
            });
        }
    }
    _contextCreated(world, context) {
        const data = this._contextData.get(world);
        // In case of multiple sessions to the same target, there's a race between
        // connections so we might end up creating multiple isolated worlds.
        // We can use either.
        if (data.context)
            this._setContext(world, null);
        this._setContext(world, context);
    }
    _contextDestroyed(context) {
        for (const [world, data] of this._contextData) {
            if (data.context === context)
                this._setContext(world, null);
        }
    }
    _startNetworkIdleTimer() {
        utils_1.assert(!this._networkIdleTimer);
        // We should not start a timer and report networkidle in detached frames.
        // This happens at least in Firefox for child frames, where we may get requestFinished
        // after the frame was detached - probably a race in the Firefox itself.
        if (this._firedLifecycleEvents.has('networkidle') || this._detached)
            return;
        this._networkIdleTimer = setTimeout(() => this._onLifecycleEvent('networkidle'), 500);
    }
    _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
            clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = undefined;
    }
    async extendInjectedScript(world, source, arg) {
        const context = await this._context(world);
        const injectedScriptHandle = await context.injectedScript();
        return injectedScriptHandle.evaluateHandle((injectedScript, { source, arg }) => {
            return injectedScript.extend(source, arg);
        }, { source, arg });
    }
}
exports.Frame = Frame;
Frame.Events = {
    Navigation: 'navigation',
    AddLifecycle: 'addlifecycle',
    RemoveLifecycle: 'removelifecycle',
};
class RerunnableTask {
    constructor(data, progress, task, returnByValue) {
        this._resolve = () => { };
        this._reject = () => { };
        this._task = task;
        this._progress = progress;
        this._returnByValue = returnByValue;
        this._contextData = data;
        this._contextData.rerunnableTasks.add(this);
        this.promise = new Promise((resolve, reject) => {
            // The task is either resolved with a value, or rejected with a meaningful evaluation error.
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    terminate(error) {
        this._reject(error);
    }
    async rerun(context) {
        try {
            const injectedScript = await context.injectedScript();
            const pollHandler = new dom.InjectedScriptPollHandler(this._progress, await this._task(injectedScript));
            const result = this._returnByValue ? await pollHandler.finish() : await pollHandler.finishHandle();
            this._contextData.rerunnableTasks.delete(this);
            this._resolve(result);
        }
        catch (e) {
            // We will try again in the new execution context.
            if (js.isContextDestroyedError(e))
                return;
            this._contextData.rerunnableTasks.delete(this);
            this._reject(e);
        }
    }
}
class SignalBarrier {
    constructor(progress) {
        this._protectCount = 0;
        this._promiseCallback = () => { };
        this._progress = progress;
        this._promise = new Promise(f => this._promiseCallback = f);
        this.retain();
    }
    waitFor() {
        this.release();
        return this._promise;
    }
    async addFrameNavigation(frame) {
        // Auto-wait top-level navigations only.
        if (frame.parentFrame())
            return;
        this.retain();
        const waiter = helper_1.helper.waitForEvent(null, frame, Frame.Events.Navigation, (e) => {
            if (!e.error && this._progress)
                this._progress.log(`  navigated to "${frame._url}"`);
            return true;
        });
        await Promise.race([
            frame._page._disconnectedPromise,
            frame._page._crashedPromise,
            frame._detachedPromise,
            waiter.promise,
        ]).catch(e => { });
        waiter.dispose();
        this.release();
    }
    retain() {
        ++this._protectCount;
    }
    release() {
        --this._protectCount;
        if (!this._protectCount)
            this._promiseCallback();
    }
}
function verifyLifecycle(name, waitUntil) {
    if (waitUntil === 'networkidle0')
        waitUntil = 'networkidle';
    if (!types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle)`);
    return waitUntil;
}
//# sourceMappingURL=frames.js.map

/***/ }),

/***/ 7951:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.helper = void 0;
const debugLogger_1 = __nccwpck_require__(5203);
class Helper {
    static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return { emitter, eventName, handler };
    }
    static removeEventListeners(listeners) {
        for (const listener of listeners)
            listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
    }
    static completeUserURL(urlString) {
        if (urlString.startsWith('localhost') || urlString.startsWith('127.0.0.1'))
            urlString = 'http://' + urlString;
        return urlString;
    }
    static enclosingIntRect(rect) {
        const x = Math.floor(rect.x + 1e-3);
        const y = Math.floor(rect.y + 1e-3);
        const x2 = Math.ceil(rect.x + rect.width - 1e-3);
        const y2 = Math.ceil(rect.y + rect.height - 1e-3);
        return { x, y, width: x2 - x, height: y2 - y };
    }
    static enclosingIntSize(size) {
        return { width: Math.floor(size.width + 1e-3), height: Math.floor(size.height + 1e-3) };
    }
    static getViewportSizeFromWindowFeatures(features) {
        const widthString = features.find(f => f.startsWith('width='));
        const heightString = features.find(f => f.startsWith('height='));
        const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
        const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
        if (!Number.isNaN(width) && !Number.isNaN(height))
            return { width, height };
        return null;
    }
    static waitForEvent(progress, emitter, event, predicate) {
        const listeners = [];
        const promise = new Promise((resolve, reject) => {
            listeners.push(exports.helper.addEventListener(emitter, event, eventArg => {
                try {
                    if (predicate && !predicate(eventArg))
                        return;
                    exports.helper.removeEventListeners(listeners);
                    resolve(eventArg);
                }
                catch (e) {
                    exports.helper.removeEventListeners(listeners);
                    reject(e);
                }
            }));
        });
        const dispose = () => exports.helper.removeEventListeners(listeners);
        if (progress)
            progress.cleanupWhenAborted(dispose);
        return { promise, dispose };
    }
    static secondsToRoundishMillis(value) {
        return ((value * 1000000) | 0) / 1000;
    }
    static millisToRoundishMillis(value) {
        return ((value * 1000) | 0) / 1000;
    }
    static debugProtocolLogger(protocolLogger) {
        return (direction, message) => {
            if (protocolLogger)
                protocolLogger(direction, message);
            if (debugLogger_1.debugLogger.isEnabled('protocol'))
                debugLogger_1.debugLogger.log('protocol', (direction === 'send' ? 'SEND ► ' : '◀ RECV ') + JSON.stringify(message));
        };
    }
    static formatBrowserLogs(logs) {
        if (!logs.length)
            return '';
        return '\n' + '='.repeat(20) + ' Browser output: ' + '='.repeat(20) + '\n' + logs.join('\n');
    }
}
exports.helper = Helper;
//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 487:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Touchscreen = exports.Mouse = exports.Keyboard = exports.keypadLocation = void 0;
const utils_1 = __nccwpck_require__(6416);
const keyboardLayout = __importStar(__nccwpck_require__(3164));
exports.keypadLocation = keyboardLayout.keypadLocation;
const kModifiers = ['Alt', 'Control', 'Meta', 'Shift'];
class Keyboard {
    constructor(raw, page) {
        this._pressedModifiers = new Set();
        this._pressedKeys = new Set();
        this._raw = raw;
        this._page = page;
    }
    async down(key) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        if (kModifiers.includes(description.key))
            this._pressedModifiers.add(description.key);
        const text = description.text;
        await this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
        await this._page._doSlowMo();
    }
    _keyDescriptionForString(keyString) {
        let description = usKeyboardLayout.get(keyString);
        utils_1.assert(description, `Unknown key: "${keyString}"`);
        const shift = this._pressedModifiers.has('Shift');
        description = shift && description.shifted ? description.shifted : description;
        // if any modifiers besides shift are pressed, no text should be sent
        if (this._pressedModifiers.size > 1 || (!this._pressedModifiers.has('Shift') && this._pressedModifiers.size === 1))
            return { ...description, text: '' };
        return description;
    }
    async up(key) {
        const description = this._keyDescriptionForString(key);
        if (kModifiers.includes(description.key))
            this._pressedModifiers.delete(description.key);
        this._pressedKeys.delete(description.code);
        await this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
        await this._page._doSlowMo();
    }
    async insertText(text) {
        await this._raw.sendText(text);
        await this._page._doSlowMo();
    }
    async type(text, options) {
        const delay = (options && options.delay) || undefined;
        for (const char of text) {
            if (usKeyboardLayout.has(char)) {
                await this.press(char, { delay });
            }
            else {
                if (delay)
                    await new Promise(f => setTimeout(f, delay));
                await this.insertText(char);
            }
        }
    }
    async press(key, options = {}) {
        function split(keyString) {
            const keys = [];
            let building = '';
            for (const char of keyString) {
                if (char === '+' && building) {
                    keys.push(building);
                    building = '';
                }
                else {
                    building += char;
                }
            }
            keys.push(building);
            return keys;
        }
        const tokens = split(key);
        const promises = [];
        key = tokens[tokens.length - 1];
        for (let i = 0; i < tokens.length - 1; ++i)
            promises.push(this.down(tokens[i]));
        promises.push(this.down(key));
        if (options.delay) {
            await Promise.all(promises);
            await new Promise(f => setTimeout(f, options.delay));
        }
        promises.push(this.up(key));
        for (let i = tokens.length - 2; i >= 0; --i)
            promises.push(this.up(tokens[i]));
        await Promise.all(promises);
    }
    async _ensureModifiers(modifiers) {
        for (const modifier of modifiers) {
            if (!kModifiers.includes(modifier))
                throw new Error('Unknown modifier ' + modifier);
        }
        const restore = Array.from(this._pressedModifiers);
        const promises = [];
        for (const key of kModifiers) {
            const needDown = modifiers.includes(key);
            const isDown = this._pressedModifiers.has(key);
            if (needDown && !isDown)
                promises.push(this.down(key));
            else if (!needDown && isDown)
                promises.push(this.up(key));
        }
        await Promise.all(promises);
        return restore;
    }
    _modifiers() {
        return this._pressedModifiers;
    }
}
exports.Keyboard = Keyboard;
class Mouse {
    constructor(raw, page) {
        this._x = 0;
        this._y = 0;
        this._lastButton = 'none';
        this._buttons = new Set();
        this._raw = raw;
        this._page = page;
        this._keyboard = this._page.keyboard;
    }
    async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const fromX = this._x;
        const fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
            const middleX = fromX + (x - fromX) * (i / steps);
            const middleY = fromY + (y - fromY) * (i / steps);
            await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers());
            await this._page._doSlowMo();
        }
    }
    async down(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._lastButton = button;
        this._buttons.add(button);
        await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
        await this._page._doSlowMo();
    }
    async up(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._lastButton = 'none';
        this._buttons.delete(button);
        await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
        await this._page._doSlowMo();
    }
    async click(x, y, options = {}) {
        const { delay = null, clickCount = 1 } = options;
        if (delay) {
            this.move(x, y);
            for (let cc = 1; cc <= clickCount; ++cc) {
                await this.down({ ...options, clickCount: cc });
                await new Promise(f => setTimeout(f, delay));
                await this.up({ ...options, clickCount: cc });
                if (cc < clickCount)
                    await new Promise(f => setTimeout(f, delay));
            }
        }
        else {
            const promises = [];
            promises.push(this.move(x, y));
            for (let cc = 1; cc <= clickCount; ++cc) {
                promises.push(this.down({ ...options, clickCount: cc }));
                promises.push(this.up({ ...options, clickCount: cc }));
            }
            await Promise.all(promises);
        }
    }
    async dblclick(x, y, options = {}) {
        await this.click(x, y, { ...options, clickCount: 2 });
    }
}
exports.Mouse = Mouse;
const aliases = new Map([
    ['ShiftLeft', ['Shift']],
    ['ControlLeft', ['Control']],
    ['AltLeft', ['Alt']],
    ['MetaLeft', ['Meta']],
    ['Enter', ['\n', '\r']],
]);
const usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);
function buildLayoutClosure(layout) {
    const result = new Map();
    for (const code in layout) {
        const definition = layout[code];
        const description = {
            key: definition.key || '',
            keyCode: definition.keyCode || 0,
            keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
            code,
            text: definition.text || '',
            location: definition.location || 0,
        };
        if (definition.key.length === 1)
            description.text = description.key;
        // Generate shifted definition.
        let shiftedDescription;
        if (definition.shiftKey) {
            utils_1.assert(definition.shiftKey.length === 1);
            shiftedDescription = { ...description };
            shiftedDescription.key = definition.shiftKey;
            shiftedDescription.text = definition.shiftKey;
            if (definition.shiftKeyCode)
                shiftedDescription.keyCode = definition.shiftKeyCode;
        }
        // Map from code: Digit3 -> { ... descrption, shifted }
        result.set(code, { ...description, shifted: shiftedDescription });
        // Map from aliases: Shift -> non-shiftable definition
        if (aliases.has(code)) {
            for (const alias of aliases.get(code))
                result.set(alias, description);
        }
        // Do not use numpad when converting keys to codes.
        if (definition.location)
            continue;
        // Map from key, no shifted
        if (description.key.length === 1)
            result.set(description.key, description);
        // Map from shiftKey, no shifted
        if (shiftedDescription)
            result.set(shiftedDescription.key, { ...shiftedDescription, shifted: undefined });
    }
    return result;
}
class Touchscreen {
    constructor(raw, page) {
        this._raw = raw;
        this._page = page;
    }
    async tap(x, y) {
        if (!this._page._browserContext._options.hasTouch)
            throw new Error('hasTouch must be enabled on the browser context before using the touchscreen.');
        await this._raw.tap(x, y, this._page.keyboard._modifiers());
        await this._page._doSlowMo();
    }
}
exports.Touchscreen = Touchscreen;
//# sourceMappingURL=input.js.map

/***/ }),

/***/ 7490:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.internalCallMetadata = exports.createInstrumentation = exports.SdkObject = void 0;
const events_1 = __nccwpck_require__(8614);
const utils_1 = __nccwpck_require__(6416);
class SdkObject extends events_1.EventEmitter {
    constructor(parent, guidPrefix, guid) {
        super();
        this.guid = guid || `${guidPrefix || ''}@${utils_1.createGuid()}`;
        this.setMaxListeners(0);
        this.attribution = { ...parent.attribution };
        this.instrumentation = parent.instrumentation;
    }
}
exports.SdkObject = SdkObject;
function createInstrumentation() {
    const listeners = [];
    return new Proxy({}, {
        get: (obj, prop) => {
            if (prop === 'addListener')
                return (listener) => listeners.push(listener);
            if (prop === 'removeListener')
                return (listener) => listeners.splice(listeners.indexOf(listener), 1);
            if (!prop.startsWith('on'))
                return obj[prop];
            return async (...params) => {
                var _a, _b;
                for (const listener of listeners)
                    await ((_b = (_a = listener)[prop]) === null || _b === void 0 ? void 0 : _b.call(_a, ...params));
            };
        },
    });
}
exports.createInstrumentation = createInstrumentation;
function internalCallMetadata() {
    return {
        id: '',
        startTime: 0,
        endTime: 0,
        type: 'Internal',
        method: '',
        params: {},
        log: [],
        snapshots: []
    };
}
exports.internalCallMetadata = internalCallMetadata;
//# sourceMappingURL=instrumentation.js.map

/***/ }),

/***/ 1762:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isContextDestroyedError = exports.kSwappedOutErrorMessage = exports.normalizeEvaluationExpression = exports.parseUnserializableValue = exports.evaluateExpressionAndWaitForSignals = exports.evaluateExpression = exports.evaluate = exports.JSHandle = exports.ExecutionContext = void 0;
const utilityScriptSource = __importStar(__nccwpck_require__(6507));
const utilityScriptSerializers_1 = __nccwpck_require__(4734);
const instrumentation_1 = __nccwpck_require__(7490);
class ExecutionContext extends instrumentation_1.SdkObject {
    constructor(parent, delegate) {
        super(parent, 'execution-context');
        this._delegate = delegate;
    }
    async waitForSignalsCreatedBy(action) {
        return action();
    }
    adoptIfNeeded(handle) {
        return null;
    }
    utilityScript() {
        if (!this._utilityScriptPromise) {
            const source = `
      (() => {
        ${utilityScriptSource.source}
        return new pwExport();
      })();`;
            this._utilityScriptPromise = this._delegate.rawEvaluateHandle(source).then(objectId => new JSHandle(this, 'object', objectId));
        }
        return this._utilityScriptPromise;
    }
    createHandle(remoteObject) {
        return this._delegate.createHandle(this, remoteObject);
    }
    async rawEvaluateJSON(expression) {
        return await this._delegate.rawEvaluateJSON(expression);
    }
    async doSlowMo() {
        // overrided in FrameExecutionContext
    }
}
exports.ExecutionContext = ExecutionContext;
class JSHandle extends instrumentation_1.SdkObject {
    constructor(context, type, objectId, value) {
        super(context, 'handle');
        this._disposed = false;
        this._context = context;
        this._objectId = objectId;
        this._value = value;
        this._objectType = type;
        if (this._objectId)
            this._value = 'JSHandle@' + this._objectType;
        this._preview = 'JSHandle@' + String(this._objectId ? this._objectType : this._value);
    }
    callFunctionNoReply(func, arg) {
        this._context._delegate.rawCallFunctionNoReply(func, this, arg);
    }
    async evaluate(pageFunction, arg) {
        return evaluate(this._context, true /* returnByValue */, pageFunction, this, arg);
    }
    async evaluateHandle(pageFunction, arg) {
        return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
    }
    async evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {
        const value = await evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);
        await this._context.doSlowMo();
        return value;
    }
    async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName) => {
            const result = { __proto__: null };
            result[propertyName] = object[propertyName];
            return result;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName);
        objectHandle.dispose();
        return result;
    }
    async getProperties() {
        if (!this._objectId)
            return new Map();
        return this._context._delegate.getProperties(this._context, this._objectId);
    }
    rawValue() {
        return this._value;
    }
    async jsonValue() {
        if (!this._objectId)
            return this._value;
        const utilityScript = await this._context.utilityScript();
        const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
        return this._context._delegate.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
    }
    asElement() {
        return null;
    }
    dispose() {
        if (this._disposed)
            return;
        this._disposed = true;
        if (this._objectId)
            this._context._delegate.releaseHandle(this._objectId).catch(e => { });
    }
    toString() {
        return this._preview;
    }
    _setPreviewCallback(callback) {
        this._previewCallback = callback;
    }
    _setPreview(preview) {
        this._preview = preview;
        if (this._previewCallback)
            this._previewCallback(preview);
    }
}
exports.JSHandle = JSHandle;
async function evaluate(context, returnByValue, pageFunction, ...args) {
    return evaluateExpression(context, returnByValue, String(pageFunction), typeof pageFunction === 'function', ...args);
}
exports.evaluate = evaluate;
async function evaluateExpression(context, returnByValue, expression, isFunction, ...args) {
    const utilityScript = await context.utilityScript();
    expression = normalizeEvaluationExpression(expression, isFunction);
    const handles = [];
    const toDispose = [];
    const pushHandle = (handle) => {
        handles.push(handle);
        return handles.length - 1;
    };
    args = args.map(arg => utilityScriptSerializers_1.serializeAsCallArgument(arg, handle => {
        if (handle instanceof JSHandle) {
            if (!handle._objectId)
                return { fallThrough: handle._value };
            if (handle._disposed)
                throw new Error('JSHandle is disposed!');
            const adopted = context.adoptIfNeeded(handle);
            if (adopted === null)
                return { h: pushHandle(Promise.resolve(handle)) };
            toDispose.push(adopted);
            return { h: pushHandle(adopted) };
        }
        return { fallThrough: handle };
    }));
    const utilityScriptObjectIds = [];
    for (const handle of await Promise.all(handles)) {
        if (handle._context !== context)
            throw new Error('JSHandles can be evaluated only in the context they were created!');
        utilityScriptObjectIds.push(handle._objectId);
    }
    // See UtilityScript for arguments.
    const utilityScriptValues = [isFunction, returnByValue, expression, args.length, ...args];
    const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
    try {
        return await context._delegate.evaluateWithArguments(script, returnByValue, utilityScript, utilityScriptValues, utilityScriptObjectIds);
    }
    finally {
        toDispose.map(handlePromise => handlePromise.then(handle => handle.dispose()));
    }
}
exports.evaluateExpression = evaluateExpression;
async function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {
    return await context.waitForSignalsCreatedBy(() => evaluateExpression(context, returnByValue, expression, isFunction, ...args));
}
exports.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;
function parseUnserializableValue(unserializableValue) {
    if (unserializableValue === 'NaN')
        return NaN;
    if (unserializableValue === 'Infinity')
        return Infinity;
    if (unserializableValue === '-Infinity')
        return -Infinity;
    if (unserializableValue === '-0')
        return -0;
}
exports.parseUnserializableValue = parseUnserializableValue;
function normalizeEvaluationExpression(expression, isFunction) {
    expression = expression.trim();
    if (isFunction) {
        try {
            new Function('(' + expression + ')');
        }
        catch (e1) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (expression.startsWith('async '))
                expression = 'async function ' + expression.substring('async '.length);
            else
                expression = 'function ' + expression;
            try {
                new Function('(' + expression + ')');
            }
            catch (e2) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
    }
    if (/^(async)?\s*function(\s|\()/.test(expression))
        expression = '(' + expression + ')';
    return expression;
}
exports.normalizeEvaluationExpression = normalizeEvaluationExpression;
exports.kSwappedOutErrorMessage = 'Target was swapped out.';
function isContextDestroyedError(e) {
    if (!e || typeof e !== 'object' || typeof e.message !== 'string')
        return false;
    // Evaluating in a context which was already destroyed.
    if (e.message.includes('Cannot find context with specified id')
        || e.message.includes('Failed to find execution context with id')
        || e.message.includes('Missing injected script for given')
        || e.message.includes('Cannot find object with id'))
        return true;
    // Evaluation promise is rejected when context is gone.
    if (e.message.includes('Execution context was destroyed'))
        return true;
    // WebKit target swap.
    if (e.message.includes(exports.kSwappedOutErrorMessage))
        return true;
    return false;
}
exports.isContextDestroyedError = isContextDestroyedError;
//# sourceMappingURL=javascript.js.map

/***/ }),

/***/ 3377:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.macEditingCommands = void 0;
exports.macEditingCommands = {
    'Backspace': 'deleteBackward:',
    'Enter': 'insertNewline:',
    'NumpadEnter': 'insertNewline:',
    'Escape': 'cancelOperation:',
    'ArrowUp': 'moveUp:',
    'ArrowDown': 'moveDown:',
    'ArrowLeft': 'moveLeft:',
    'ArrowRight': 'moveRight:',
    'F5': 'complete:',
    'Delete': 'deleteForward:',
    'Home': 'scrollToBeginningOfDocument:',
    'End': 'scrollToEndOfDocument:',
    'PageUp': 'scrollPageUp:',
    'PageDown': 'scrollPageDown:',
    'Shift+Backspace': 'deleteBackward:',
    'Shift+Enter': 'insertNewline:',
    'Shift+NumpadEnter': 'insertNewline:',
    'Shift+Escape': 'cancelOperation:',
    'Shift+ArrowUp': 'moveUpAndModifySelection:',
    'Shift+ArrowDown': 'moveDownAndModifySelection:',
    'Shift+ArrowLeft': 'moveLeftAndModifySelection:',
    'Shift+ArrowRight': 'moveRightAndModifySelection:',
    'Shift+F5': 'complete:',
    'Shift+Delete': 'deleteForward:',
    'Shift+Home': 'moveToBeginningOfDocumentAndModifySelection:',
    'Shift+End': 'moveToEndOfDocumentAndModifySelection:',
    'Shift+PageUp': 'pageUpAndModifySelection:',
    'Shift+PageDown': 'pageDownAndModifySelection:',
    'Shift+Numpad5': 'delete:',
    'Control+Tab': 'selectNextKeyView:',
    'Control+Enter': 'insertLineBreak:',
    'Control+NumpadEnter': 'insertLineBreak:',
    'Control+Quote': 'insertSingleQuoteIgnoringSubstitution:',
    'Control+KeyA': 'moveToBeginningOfParagraph:',
    'Control+KeyB': 'moveBackward:',
    'Control+KeyD': 'deleteForward:',
    'Control+KeyE': 'moveToEndOfParagraph:',
    'Control+KeyF': 'moveForward:',
    'Control+KeyH': 'deleteBackward:',
    'Control+KeyK': 'deleteToEndOfParagraph:',
    'Control+KeyL': 'centerSelectionInVisibleArea:',
    'Control+KeyN': 'moveDown:',
    'Control+KeyO': ['insertNewlineIgnoringFieldEditor:', 'moveBackward:'],
    'Control+KeyP': 'moveUp:',
    'Control+KeyT': 'transpose:',
    'Control+KeyV': 'pageDown:',
    'Control+KeyY': 'yank:',
    'Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',
    'Control+ArrowUp': 'scrollPageUp:',
    'Control+ArrowDown': 'scrollPageDown:',
    'Control+ArrowLeft': 'moveToLeftEndOfLine:',
    'Control+ArrowRight': 'moveToRightEndOfLine:',
    'Shift+Control+Enter': 'insertLineBreak:',
    'Shift+Control+NumpadEnter': 'insertLineBreak:',
    'Shift+Control+Tab': 'selectPreviousKeyView:',
    'Shift+Control+Quote': 'insertDoubleQuoteIgnoringSubstitution:',
    'Shift+Control+KeyA': 'moveToBeginningOfParagraphAndModifySelection:',
    'Shift+Control+KeyB': 'moveBackwardAndModifySelection:',
    'Shift+Control+KeyE': 'moveToEndOfParagraphAndModifySelection:',
    'Shift+Control+KeyF': 'moveForwardAndModifySelection:',
    'Shift+Control+KeyN': 'moveDownAndModifySelection:',
    'Shift+Control+KeyP': 'moveUpAndModifySelection:',
    'Shift+Control+KeyV': 'pageDownAndModifySelection:',
    'Shift+Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',
    'Shift+Control+ArrowUp': 'scrollPageUp:',
    'Shift+Control+ArrowDown': 'scrollPageDown:',
    'Shift+Control+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',
    'Shift+Control+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',
    'Alt+Backspace': 'deleteWordBackward:',
    'Alt+Enter': 'insertNewlineIgnoringFieldEditor:',
    'Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',
    'Alt+Escape': 'complete:',
    'Alt+ArrowUp': ['moveBackward:', 'moveToBeginningOfParagraph:'],
    'Alt+ArrowDown': ['moveForward:', 'moveToEndOfParagraph:'],
    'Alt+ArrowLeft': 'moveWordLeft:',
    'Alt+ArrowRight': 'moveWordRight:',
    'Alt+Delete': 'deleteWordForward:',
    'Alt+PageUp': 'pageUp:',
    'Alt+PageDown': 'pageDown:',
    'Shift+Alt+Backspace': 'deleteWordBackward:',
    'Shift+Alt+Enter': 'insertNewlineIgnoringFieldEditor:',
    'Shift+Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',
    'Shift+Alt+Escape': 'complete:',
    'Shift+Alt+ArrowUp': 'moveParagraphBackwardAndModifySelection:',
    'Shift+Alt+ArrowDown': 'moveParagraphForwardAndModifySelection:',
    'Shift+Alt+ArrowLeft': 'moveWordLeftAndModifySelection:',
    'Shift+Alt+ArrowRight': 'moveWordRightAndModifySelection:',
    'Shift+Alt+Delete': 'deleteWordForward:',
    'Shift+Alt+PageUp': 'pageUp:',
    'Shift+Alt+PageDown': 'pageDown:',
    'Control+Alt+KeyB': 'moveWordBackward:',
    'Control+Alt+KeyF': 'moveWordForward:',
    'Control+Alt+Backspace': 'deleteWordBackward:',
    'Shift+Control+Alt+KeyB': 'moveWordBackwardAndModifySelection:',
    'Shift+Control+Alt+KeyF': 'moveWordForwardAndModifySelection:',
    'Shift+Control+Alt+Backspace': 'deleteWordBackward:',
    'Meta+NumpadSubtract': 'cancel:',
    'Meta+Backspace': 'deleteToBeginningOfLine:',
    'Meta+ArrowUp': 'moveToBeginningOfDocument:',
    'Meta+ArrowDown': 'moveToEndOfDocument:',
    'Meta+ArrowLeft': 'moveToLeftEndOfLine:',
    'Meta+ArrowRight': 'moveToRightEndOfLine:',
    'Shift+Meta+NumpadSubtract': 'cancel:',
    'Shift+Meta+Backspace': 'deleteToBeginningOfLine:',
    'Shift+Meta+ArrowUp': 'moveToBeginningOfDocumentAndModifySelection:',
    'Shift+Meta+ArrowDown': 'moveToEndOfDocumentAndModifySelection:',
    'Shift+Meta+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',
    'Shift+Meta+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',
    'Meta+KeyA': 'selectAll:',
};
//# sourceMappingURL=macEditingCommands.js.map

/***/ }),

/***/ 8781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeHeaders = exports.singleHeader = exports.STATUS_TEXTS = exports.WebSocket = exports.Response = exports.Route = exports.Request = exports.stripFragmentFromUrl = exports.parsedURL = exports.rewriteCookies = exports.filterCookies = void 0;
const utils_1 = __nccwpck_require__(6416);
const instrumentation_1 = __nccwpck_require__(7490);
function filterCookies(cookies, urls) {
    const parsedURLs = urls.map(s => new URL(s));
    // Chromiums's cookies are missing sameSite when it is 'None'
    return cookies.filter(c => {
        // Firefox and WebKit can return cookies with empty values.
        if (!c.value)
            return false;
        if (!parsedURLs.length)
            return true;
        for (const parsedURL of parsedURLs) {
            let domain = c.domain;
            if (!domain.startsWith('.'))
                domain = '.' + domain;
            if (!('.' + parsedURL.hostname).endsWith(domain))
                continue;
            if (!parsedURL.pathname.startsWith(c.path))
                continue;
            if (parsedURL.protocol !== 'https:' && c.secure)
                continue;
            return true;
        }
        return false;
    });
}
exports.filterCookies = filterCookies;
function rewriteCookies(cookies) {
    return cookies.map(c => {
        utils_1.assert(c.name, 'Cookie should have a name');
        utils_1.assert(c.value, 'Cookie should have a value');
        utils_1.assert(c.url || (c.domain && c.path), 'Cookie should have a url or a domain/path pair');
        utils_1.assert(!(c.url && c.domain), 'Cookie should have either url or domain');
        utils_1.assert(!(c.url && c.path), 'Cookie should have either url or domain');
        const copy = { ...c };
        if (copy.url) {
            utils_1.assert(copy.url !== 'about:blank', `Blank page can not have cookie "${c.name}"`);
            utils_1.assert(!copy.url.startsWith('data:'), `Data URL page can not have cookie "${c.name}"`);
            const url = new URL(copy.url);
            copy.domain = url.hostname;
            copy.path = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
            copy.secure = url.protocol === 'https:';
        }
        return copy;
    });
}
exports.rewriteCookies = rewriteCookies;
function parsedURL(url) {
    try {
        return new URL(url);
    }
    catch (e) {
        return null;
    }
}
exports.parsedURL = parsedURL;
function stripFragmentFromUrl(url) {
    if (!url.includes('#'))
        return url;
    return url.substring(0, url.indexOf('#'));
}
exports.stripFragmentFromUrl = stripFragmentFromUrl;
class Request extends instrumentation_1.SdkObject {
    constructor(routeDelegate, frame, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        super(frame, 'request');
        this._response = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._headersMap = new Map();
        this._waitForResponsePromiseCallback = () => { };
        this._responseEndTiming = -1;
        utils_1.assert(!url.startsWith('data:'), 'Data urls should not fire requests');
        utils_1.assert(!(routeDelegate && redirectedFrom), 'Should not be able to intercept redirects');
        this._routeDelegate = routeDelegate;
        this._frame = frame;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
            redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        for (const { name, value } of this._headers)
            this._headersMap.set(name.toLowerCase(), value);
        this._waitForResponsePromise = new Promise(f => this._waitForResponsePromiseCallback = f);
        this._isFavicon = url.endsWith('/favicon.ico');
    }
    _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromiseCallback(null);
    }
    url() {
        return this._url;
    }
    resourceType() {
        return this._resourceType;
    }
    method() {
        return this._method;
    }
    postDataBuffer() {
        return this._postData;
    }
    headers() {
        return this._headers;
    }
    headerValue(name) {
        return this._headersMap.get(name);
    }
    response() {
        return this._waitForResponsePromise;
    }
    _existingResponse() {
        return this._response;
    }
    _setResponse(response) {
        this._response = response;
        this._waitForResponsePromiseCallback(response);
    }
    _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
    }
    frame() {
        return this._frame;
    }
    isNavigationRequest() {
        return !!this._documentId;
    }
    redirectedFrom() {
        return this._redirectedFrom;
    }
    failure() {
        if (this._failureText === null)
            return null;
        return {
            errorText: this._failureText
        };
    }
    _route() {
        if (!this._routeDelegate)
            return null;
        return new Route(this, this._routeDelegate);
    }
    updateWithRawHeaders(headers) {
        this._headers = headers;
        this._headersMap.clear();
        for (const { name, value } of this._headers)
            this._headersMap.set(name.toLowerCase(), value);
        if (!this._headersMap.has('host')) {
            const host = new URL(this._url).host;
            this._headers.push({ name: 'host', value: host });
            this._headersMap.set('host', host);
        }
    }
}
exports.Request = Request;
class Route extends instrumentation_1.SdkObject {
    constructor(request, delegate) {
        super(request.frame(), 'route');
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
    }
    request() {
        return this._request;
    }
    async abort(errorCode = 'failed') {
        utils_1.assert(!this._handled, 'Route is already handled!');
        this._handled = true;
        await this._delegate.abort(errorCode);
    }
    async fulfill(response) {
        utils_1.assert(!this._handled, 'Route is already handled!');
        this._handled = true;
        await this._delegate.fulfill({
            status: response.status === undefined ? 200 : response.status,
            headers: response.headers || [],
            body: response.body || '',
            isBase64: response.isBase64 || false,
        });
    }
    async continue(overrides = {}) {
        utils_1.assert(!this._handled, 'Route is already handled!');
        if (overrides.url) {
            const newUrl = new URL(overrides.url);
            const oldUrl = new URL(this._request.url());
            if (oldUrl.protocol !== newUrl.protocol)
                throw new Error('New URL must have same protocol as overridden URL');
        }
        await this._delegate.continue(overrides);
    }
}
exports.Route = Route;
class Response extends instrumentation_1.SdkObject {
    constructor(request, status, statusText, headers, timing, getResponseBodyCallback) {
        super(request.frame(), 'response');
        this._contentPromise = null;
        this._finishedPromiseCallback = () => { };
        this._headersMap = new Map();
        this._request = request;
        this._timing = timing;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        for (const { name, value } of this._headers)
            this._headersMap.set(name.toLowerCase(), value);
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._finishedPromise = new Promise(f => {
            this._finishedPromiseCallback = f;
        });
        this._request._setResponse(this);
    }
    _requestFinished(responseEndTiming, error) {
        this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
        this._finishedPromiseCallback({ error });
    }
    url() {
        return this._url;
    }
    status() {
        return this._status;
    }
    statusText() {
        return this._statusText;
    }
    headers() {
        return this._headers;
    }
    headerValue(name) {
        return this._headersMap.get(name);
    }
    finished() {
        return this._finishedPromise.then(({ error }) => error ? new Error(error) : null);
    }
    timing() {
        return this._timing;
    }
    body() {
        if (!this._contentPromise) {
            this._contentPromise = this._finishedPromise.then(async ({ error }) => {
                if (error)
                    throw new Error(error);
                return this._getResponseBodyCallback();
            });
        }
        return this._contentPromise;
    }
    request() {
        return this._request;
    }
    frame() {
        return this._request.frame();
    }
}
exports.Response = Response;
class WebSocket extends instrumentation_1.SdkObject {
    constructor(parent, url) {
        super(parent, 'ws');
        this._url = url;
    }
    url() {
        return this._url;
    }
    frameSent(opcode, data) {
        this.emit(WebSocket.Events.FrameSent, { opcode, data });
    }
    frameReceived(opcode, data) {
        this.emit(WebSocket.Events.FrameReceived, { opcode, data });
    }
    error(errorMessage) {
        this.emit(WebSocket.Events.SocketError, errorMessage);
    }
    closed() {
        this.emit(WebSocket.Events.Close);
    }
}
exports.WebSocket = WebSocket;
WebSocket.Events = {
    Close: 'close',
    SocketError: 'socketerror',
    FrameReceived: 'framereceived',
    FrameSent: 'framesent',
};
// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.
exports.STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': 'I\'m a teapot',
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};
function singleHeader(name, value) {
    return [{ name, value }];
}
exports.singleHeader = singleHeader;
function mergeHeaders(headers) {
    const lowerCaseToValue = new Map();
    const lowerCaseToOriginalCase = new Map();
    for (const h of headers) {
        if (!h)
            continue;
        for (const { name, value } of h) {
            const lower = name.toLowerCase();
            lowerCaseToOriginalCase.set(lower, name);
            lowerCaseToValue.set(lower, value);
        }
    }
    const result = [];
    for (const [lower, value] of lowerCaseToValue)
        result.push({ name: lowerCaseToOriginalCase.get(lower), value });
    return result;
}
exports.mergeHeaders = mergeHeaders;
//# sourceMappingURL=network.js.map

/***/ }),

/***/ 9406:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PageBinding = exports.Worker = exports.Page = void 0;
const frames = __importStar(__nccwpck_require__(3735));
const input = __importStar(__nccwpck_require__(487));
const js = __importStar(__nccwpck_require__(1762));
const network = __importStar(__nccwpck_require__(8781));
const screenshotter_1 = __nccwpck_require__(123);
const timeoutSettings_1 = __nccwpck_require__(9255);
const browserContext_1 = __nccwpck_require__(7533);
const console_1 = __nccwpck_require__(381);
const accessibility = __importStar(__nccwpck_require__(6166));
const fileChooser_1 = __nccwpck_require__(3764);
const progress_1 = __nccwpck_require__(6707);
const utils_1 = __nccwpck_require__(6416);
const debugLogger_1 = __nccwpck_require__(5203);
const instrumentation_1 = __nccwpck_require__(7490);
class Page extends instrumentation_1.SdkObject {
    constructor(delegate, browserContext) {
        super(browserContext, 'page');
        this._closedState = 'open';
        this._disconnected = false;
        this._initialized = false;
        this._pageBindings = new Map();
        this._evaluateOnNewDocumentSources = [];
        this._workers = new Map();
        this._video = null;
        this.attribution.page = this;
        this._delegate = delegate;
        this._closedCallback = () => { };
        this._closedPromise = new Promise(f => this._closedCallback = f);
        this._disconnectedCallback = () => { };
        this._disconnectedPromise = new Promise(f => this._disconnectedCallback = f);
        this._crashedCallback = () => { };
        this._crashedPromise = new Promise(f => this._crashedCallback = f);
        this._browserContext = browserContext;
        this._state = {
            emulatedSize: browserContext._options.viewport ? { viewport: browserContext._options.viewport, screen: browserContext._options.screen || browserContext._options.viewport } : null,
            mediaType: null,
            colorScheme: browserContext._options.colorScheme !== undefined ? browserContext._options.colorScheme : 'light',
            reducedMotion: browserContext._options.reducedMotion !== undefined ? browserContext._options.reducedMotion : 'no-preference',
            extraHTTPHeaders: null,
        };
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
        this.mouse = new input.Mouse(delegate.rawMouse, this);
        this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new screenshotter_1.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
            this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
        this.selectors = browserContext.selectors();
    }
    async initOpener(opener) {
        if (!opener)
            return;
        const openerPage = await opener.pageOrError();
        if (openerPage instanceof Page && !openerPage.isClosed())
            this._opener = openerPage;
    }
    reportAsNew(error) {
        if (error) {
            // Initialization error could have happened because of
            // context/browser closure. Just ignore the page.
            if (this._browserContext.isClosingOrClosed())
                return;
            this._setIsError(error);
        }
        this._initialized = true;
        this._browserContext.emit(browserContext_1.BrowserContext.Events.Page, this);
        // I may happen that page iniatialization finishes after Close event has already been sent,
        // in that case we fire another Close event to ensure that each reported Page will have
        // corresponding Close event after it is reported on the context.
        if (this.isClosed())
            this.emit(Page.Events.Close);
    }
    initializedOrUndefined() {
        return this._initialized ? this : undefined;
    }
    async _doSlowMo() {
        const slowMo = this._browserContext._browser.options.slowMo;
        if (!slowMo)
            return;
        await new Promise(x => setTimeout(x, slowMo));
    }
    _didClose() {
        this._frameManager.dispose();
        utils_1.assert(this._closedState !== 'closed', 'Page closed twice');
        this._closedState = 'closed';
        this.emit(Page.Events.Close);
        this._closedCallback();
    }
    _didCrash() {
        this._frameManager.dispose();
        this.emit(Page.Events.Crash);
        this._crashedCallback(new Error('Page crashed'));
    }
    _didDisconnect() {
        this._frameManager.dispose();
        utils_1.assert(!this._disconnected, 'Page disconnected twice');
        this._disconnected = true;
        this._disconnectedCallback(new Error('Page closed'));
    }
    async _onFileChooserOpened(handle) {
        let multiple;
        try {
            multiple = await handle.evaluate(element => !!element.multiple);
        }
        catch (e) {
            // Frame/context may be gone during async processing. Do not throw.
            return;
        }
        if (!this.listenerCount(Page.Events.FileChooser)) {
            handle.dispose();
            return;
        }
        const fileChooser = new fileChooser_1.FileChooser(this, handle, multiple);
        this.emit(Page.Events.FileChooser, fileChooser);
    }
    context() {
        return this._browserContext;
    }
    opener() {
        return this._opener;
    }
    mainFrame() {
        return this._frameManager.mainFrame();
    }
    frames() {
        return this._frameManager.frames();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async exposeBinding(name, needsHandle, playwrightBinding, world = 'main') {
        const identifier = PageBinding.identifier(name, world);
        if (this._pageBindings.has(identifier))
            throw new Error(`Function "${name}" has been already registered`);
        if (this._browserContext._pageBindings.has(identifier))
            throw new Error(`Function "${name}" has been already registered in the browser context`);
        const binding = new PageBinding(name, playwrightBinding, needsHandle, world);
        this._pageBindings.set(identifier, binding);
        await this._delegate.exposeBinding(binding);
    }
    setExtraHTTPHeaders(headers) {
        this._state.extraHTTPHeaders = headers;
        return this._delegate.updateExtraHTTPHeaders();
    }
    async _onBindingCalled(payload, context) {
        if (this._disconnected || this._closedState === 'closed')
            return;
        await PageBinding.dispatch(this, payload, context);
    }
    _addConsoleMessage(type, args, location, text) {
        const message = new console_1.ConsoleMessage(this, type, text, args, location);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted || !this.listenerCount(Page.Events.Console))
            args.forEach(arg => arg.dispose());
        else
            this.emit(Page.Events.Console, message);
    }
    async reload(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this.mainFrame().raceNavigationAction(async () => {
            // Note: waitForNavigation may fail before we get response to reload(),
            // so we should await it immediately.
            const [response] = await Promise.all([
                this.mainFrame()._waitForNavigation(progress, options),
                this._delegate.reload(),
            ]);
            await this._doSlowMo();
            return response;
        }), this._timeoutSettings.navigationTimeout(options));
    }
    async goBack(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this.mainFrame().raceNavigationAction(async () => {
            // Note: waitForNavigation may fail before we get response to goBack,
            // so we should catch it immediately.
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch(e => {
                error = e;
                return null;
            });
            const result = await this._delegate.goBack();
            if (!result)
                return null;
            const response = await waitPromise;
            if (error)
                throw error;
            await this._doSlowMo();
            return response;
        }), this._timeoutSettings.navigationTimeout(options));
    }
    async goForward(metadata, options) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this.mainFrame().raceNavigationAction(async () => {
            // Note: waitForNavigation may fail before we get response to goForward,
            // so we should catch it immediately.
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch(e => {
                error = e;
                return null;
            });
            const result = await this._delegate.goForward();
            if (!result)
                return null;
            const response = await waitPromise;
            if (error)
                throw error;
            await this._doSlowMo();
            return response;
        }), this._timeoutSettings.navigationTimeout(options));
    }
    async emulateMedia(options) {
        if (options.media !== undefined)
            this._state.mediaType = options.media;
        if (options.colorScheme !== undefined)
            this._state.colorScheme = options.colorScheme;
        if (options.reducedMotion !== undefined)
            this._state.reducedMotion = options.reducedMotion;
        await this._delegate.updateEmulateMedia();
        await this._doSlowMo();
    }
    async setViewportSize(viewportSize) {
        this._state.emulatedSize = { viewport: { ...viewportSize }, screen: { ...viewportSize } };
        await this._delegate.setEmulatedSize(this._state.emulatedSize);
        await this._doSlowMo();
    }
    viewportSize() {
        var _a;
        return ((_a = this._state.emulatedSize) === null || _a === void 0 ? void 0 : _a.viewport) || null;
    }
    async bringToFront() {
        await this._delegate.bringToFront();
    }
    async _addInitScriptExpression(source) {
        this._evaluateOnNewDocumentSources.push(source);
        await this._delegate.evaluateOnNewDocument(source);
    }
    _needsRequestInterception() {
        return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
    }
    async _setClientRequestInterceptor(handler) {
        this._clientRequestInterceptor = handler;
        await this._delegate.updateRequestInterception();
    }
    async _setServerRequestInterceptor(handler) {
        this._serverRequestInterceptor = handler;
        await this._delegate.updateRequestInterception();
    }
    _requestStarted(request) {
        const route = request._route();
        if (!route)
            return;
        if (this._serverRequestInterceptor) {
            this._serverRequestInterceptor(route, request);
            return;
        }
        if (this._clientRequestInterceptor) {
            this._clientRequestInterceptor(route, request);
            return;
        }
        if (this._browserContext._requestInterceptor) {
            this._browserContext._requestInterceptor(route, request);
            return;
        }
        route.continue();
    }
    async screenshot(metadata, options = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(progress => this._screenshotter.screenshotPage(progress, options), this._timeoutSettings.timeout(options));
    }
    async close(metadata, options) {
        if (this._closedState === 'closed')
            return;
        const runBeforeUnload = !!options && !!options.runBeforeUnload;
        if (this._closedState !== 'closing') {
            this._closedState = 'closing';
            utils_1.assert(!this._disconnected, 'Protocol error: Connection closed. Most likely the page has been closed.');
            // This might throw if the browser context containing the page closes
            // while we are trying to close the page.
            await this._delegate.closePage(runBeforeUnload).catch(e => debugLogger_1.debugLogger.log('error', e));
        }
        if (!runBeforeUnload)
            await this._closedPromise;
        if (this._ownedContext)
            await this._ownedContext.close(metadata);
    }
    _setIsError(error) {
        this._pageIsError = error;
        if (!this._frameManager.mainFrame())
            this._frameManager.frameAttached('<dummy>', null);
    }
    isClosed() {
        return this._closedState === 'closed';
    }
    _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(Page.Events.Worker, worker);
    }
    _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
            return;
        worker.emit(Worker.Events.Close, worker);
        this._workers.delete(workerId);
    }
    _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
            worker.emit(Worker.Events.Close, worker);
            this._workers.delete(workerId);
        }
    }
    async _setFileChooserIntercepted(enabled) {
        await this._delegate.setFileChooserIntercepted(enabled);
    }
    frameNavigatedToNewDocument(frame) {
        this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
        const url = frame.url();
        if (!url.startsWith('http'))
            return;
        const purl = network.parsedURL(url);
        if (purl)
            this._browserContext.addVisitedOrigin(purl.origin);
    }
    allBindings() {
        return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
    }
    getBinding(name, world) {
        const identifier = PageBinding.identifier(name, world);
        return this._pageBindings.get(identifier) || this._browserContext._pageBindings.get(identifier);
    }
    setScreencastOptions(options) {
        this._delegate.setScreencastOptions(options).catch(e => debugLogger_1.debugLogger.log('error', e));
    }
}
exports.Page = Page;
Page.Events = {
    Close: 'close',
    Crash: 'crash',
    Console: 'console',
    Dialog: 'dialog',
    Download: 'download',
    FileChooser: 'filechooser',
    DOMContentLoaded: 'domcontentloaded',
    // Can't use just 'error' due to node.js special treatment of error events.
    // @see https://nodejs.org/api/events.html#events_error_events
    PageError: 'pageerror',
    FrameAttached: 'frameattached',
    FrameDetached: 'framedetached',
    InternalFrameNavigatedToNewDocument: 'internalframenavigatedtonewdocument',
    Load: 'load',
    ScreencastFrame: 'screencastframe',
    Video: 'video',
    WebSocket: 'websocket',
    Worker: 'worker',
};
class Worker extends instrumentation_1.SdkObject {
    constructor(parent, url) {
        super(parent, 'worker');
        this._existingExecutionContext = null;
        this._url = url;
        this._executionContextCallback = () => { };
        this._executionContextPromise = new Promise(x => this._executionContextCallback = x);
    }
    _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(this, delegate);
        this._executionContextCallback(this._existingExecutionContext);
    }
    url() {
        return this._url;
    }
    async evaluateExpression(expression, isFunction, arg) {
        return js.evaluateExpression(await this._executionContextPromise, true /* returnByValue */, expression, isFunction, arg);
    }
    async evaluateExpressionHandle(expression, isFunction, arg) {
        return js.evaluateExpression(await this._executionContextPromise, false /* returnByValue */, expression, isFunction, arg);
    }
}
exports.Worker = Worker;
Worker.Events = {
    Close: 'close',
};
class PageBinding {
    constructor(name, playwrightFunction, needsHandle, world) {
        this.name = name;
        this.playwrightFunction = playwrightFunction;
        this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle})`;
        this.needsHandle = needsHandle;
        this.world = world;
    }
    static identifier(name, world) {
        return world + ':' + name;
    }
    static async dispatch(page, payload, context) {
        const { name, seq, args } = JSON.parse(payload);
        try {
            utils_1.assert(context.world);
            const binding = page.getBinding(name, context.world);
            let result;
            if (binding.needsHandle) {
                const handle = await context.evaluateHandle(takeHandle, { name, seq }).catch(e => null);
                result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, handle);
            }
            else {
                result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, ...args);
            }
            context.evaluate(deliverResult, { name, seq, result }).catch(e => debugLogger_1.debugLogger.log('error', e));
        }
        catch (error) {
            if (utils_1.isError(error))
                context.evaluate(deliverError, { name, seq, message: error.message, stack: error.stack }).catch(e => debugLogger_1.debugLogger.log('error', e));
            else
                context.evaluate(deliverErrorValue, { name, seq, error }).catch(e => debugLogger_1.debugLogger.log('error', e));
        }
        function takeHandle(arg) {
            const handle = globalThis[arg.name]['handles'].get(arg.seq);
            globalThis[arg.name]['handles'].delete(arg.seq);
            return handle;
        }
        function deliverResult(arg) {
            globalThis[arg.name]['callbacks'].get(arg.seq).resolve(arg.result);
            globalThis[arg.name]['callbacks'].delete(arg.seq);
        }
        function deliverError(arg) {
            const error = new Error(arg.message);
            error.stack = arg.stack;
            globalThis[arg.name]['callbacks'].get(arg.seq).reject(error);
            globalThis[arg.name]['callbacks'].delete(arg.seq);
        }
        function deliverErrorValue(arg) {
            globalThis[arg.name]['callbacks'].get(arg.seq).reject(arg.error);
            globalThis[arg.name]['callbacks'].delete(arg.seq);
        }
    }
}
exports.PageBinding = PageBinding;
function addPageBinding(bindingName, needsHandle) {
    const binding = globalThis[bindingName];
    if (binding.__installed)
        return;
    globalThis[bindingName] = (...args) => {
        const me = globalThis[bindingName];
        if (needsHandle && args.slice(1).some(arg => arg !== undefined))
            throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
        let callbacks = me['callbacks'];
        if (!callbacks) {
            callbacks = new Map();
            me['callbacks'] = callbacks;
        }
        const seq = (me['lastSeq'] || 0) + 1;
        me['lastSeq'] = seq;
        let handles = me['handles'];
        if (!handles) {
            handles = new Map();
            me['handles'] = handles;
        }
        const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
        if (needsHandle) {
            handles.set(seq, args[0]);
            binding(JSON.stringify({ name: bindingName, seq }));
        }
        else {
            binding(JSON.stringify({ name: bindingName, seq, args }));
        }
        return promise;
    };
    globalThis[bindingName].__installed = true;
}
//# sourceMappingURL=page.js.map

/***/ }),

/***/ 8410:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PipeTransport = void 0;
const utils_1 = __nccwpck_require__(6416);
const debugLogger_1 = __nccwpck_require__(5203);
class PipeTransport {
    constructor(pipeWrite, pipeRead) {
        this._pendingMessage = '';
        this._waitForNextTask = utils_1.makeWaitForNextTask();
        this._closed = false;
        this._pipeWrite = pipeWrite;
        pipeRead.on('data', buffer => this._dispatch(buffer));
        pipeRead.on('close', () => {
            this._closed = true;
            if (this.onclose)
                this.onclose.call(null);
        });
        pipeRead.on('error', e => debugLogger_1.debugLogger.log('error', e));
        pipeWrite.on('error', e => debugLogger_1.debugLogger.log('error', e));
        this.onmessage = undefined;
        this.onclose = undefined;
    }
    send(message) {
        if (this._closed)
            throw new Error('Pipe has been closed');
        this._pipeWrite.write(JSON.stringify(message));
        this._pipeWrite.write('\0');
    }
    close() {
        throw new Error('unimplemented');
    }
    _dispatch(buffer) {
        let end = buffer.indexOf('\0');
        if (end === -1) {
            this._pendingMessage += buffer.toString();
            return;
        }
        const message = this._pendingMessage + buffer.toString(undefined, 0, end);
        this._waitForNextTask(() => {
            if (this.onmessage)
                this.onmessage.call(null, JSON.parse(message));
        });
        let start = end + 1;
        end = buffer.indexOf('\0', start);
        while (end !== -1) {
            const message = buffer.toString(undefined, start, end);
            this._waitForNextTask(() => {
                if (this.onmessage)
                    this.onmessage.call(null, JSON.parse(message));
            });
            start = end + 1;
            end = buffer.indexOf('\0', start);
        }
        this._pendingMessage = buffer.toString(undefined, start);
    }
}
exports.PipeTransport = PipeTransport;
//# sourceMappingURL=pipeTransport.js.map

/***/ }),

/***/ 8508:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPlaywright = exports.Playwright = void 0;
const path_1 = __importDefault(__nccwpck_require__(5622));
const android_1 = __nccwpck_require__(2184);
const backendAdb_1 = __nccwpck_require__(8194);
const chromium_1 = __nccwpck_require__(8974);
const electron_1 = __nccwpck_require__(8259);
const firefox_1 = __nccwpck_require__(6175);
const selectors_1 = __nccwpck_require__(5615);
const webkit_1 = __nccwpck_require__(6464);
const registry_1 = __nccwpck_require__(2981);
const instrumentation_1 = __nccwpck_require__(7490);
const debugLogger_1 = __nccwpck_require__(5203);
const socksSocket_1 = __nccwpck_require__(113);
const utils_1 = __nccwpck_require__(6416);
class Playwright extends instrumentation_1.SdkObject {
    constructor(isInternal) {
        super({ attribution: { isInternal }, instrumentation: instrumentation_1.createInstrumentation() }, undefined, 'Playwright');
        this.instrumentation.addListener({
            onCallLog: (logName, message, sdkObject, metadata) => {
                debugLogger_1.debugLogger.log(logName, message);
            }
        });
        this.options = {
            registry: new registry_1.Registry(path_1.default.join(__dirname, '..', '..')),
            rootSdkObject: this,
        };
        this.chromium = new chromium_1.Chromium(this.options);
        this.firefox = new firefox_1.Firefox(this.options);
        this.webkit = new webkit_1.WebKit(this.options);
        this.electron = new electron_1.Electron(this.options);
        this.android = new android_1.Android(new backendAdb_1.AdbBackend(), this.options);
        this.selectors = selectors_1.serverSelectors;
    }
    async _enablePortForwarding() {
        utils_1.assert(!this._portForwardingServer);
        this._portForwardingServer = await socksSocket_1.PortForwardingServer.create(this);
        this.options.loopbackProxyOverride = () => this._portForwardingServer.proxyServer();
        this._portForwardingServer.on('incomingSocksSocket', (socket) => {
            this.emit('incomingSocksSocket', socket);
        });
    }
    _disablePortForwarding() {
        if (!this._portForwardingServer)
            return;
        this._portForwardingServer.stop();
    }
    _setForwardedPorts(ports) {
        if (!this._portForwardingServer)
            throw new Error(`Port forwarding needs to be enabled when launching the server via BrowserType.launchServer.`);
        this._portForwardingServer.setForwardedPorts(ports);
    }
}
exports.Playwright = Playwright;
function createPlaywright(isInternal = false) {
    return new Playwright(isInternal);
}
exports.createPlaywright = createPlaywright;
//# sourceMappingURL=playwright.js.map

/***/ }),

/***/ 9690:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.envArrayToObject = exports.launchProcess = exports.gracefullyCloseAll = void 0;
const childProcess = __importStar(__nccwpck_require__(3129));
const readline = __importStar(__nccwpck_require__(1058));
const helper_1 = __nccwpck_require__(7951);
const utils_1 = __nccwpck_require__(6416);
const gracefullyCloseSet = new Set();
async function gracefullyCloseAll() {
    await Promise.all(Array.from(gracefullyCloseSet).map(gracefullyClose => gracefullyClose().catch(e => { })));
}
exports.gracefullyCloseAll = gracefullyCloseAll;
// We currently spawn a process per page when recording video in Chromium.
//  This triggers "too many listeners" on the process object once you have more than 10 pages open.
const maxListeners = process.getMaxListeners();
if (maxListeners !== 0)
    process.setMaxListeners(Math.max(maxListeners || 0, 100));
async function launchProcess(options) {
    const stdio = options.stdio === 'pipe' ? ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'] : ['pipe', 'pipe', 'pipe'];
    options.log(`<launching> ${options.executablePath} ${options.args.join(' ')}`);
    const spawnedProcess = childProcess.spawn(options.executablePath, options.args, {
        // On non-windows platforms, `detached: true` makes child process a leader of a new
        // process group, making it possible to kill child process tree with `.kill(-pid)` command.
        // @see https://nodejs.org/api/child_process.html#child_process_options_detached
        detached: process.platform !== 'win32',
        env: options.env,
        cwd: options.cwd,
        stdio,
    });
    const cleanup = async () => {
        options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);
        const errors = await utils_1.removeFolders(options.tempDirectories);
        for (let i = 0; i < options.tempDirectories.length; ++i) {
            if (errors[i])
                options.log(`[pid=${spawnedProcess.pid || 'N/A'}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);
        }
        options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);
    };
    // Prevent Unhandled 'error' event.
    spawnedProcess.on('error', () => { });
    if (!spawnedProcess.pid) {
        let failed;
        const failedPromise = new Promise((f, r) => failed = f);
        spawnedProcess.once('error', error => {
            failed(new Error('Failed to launch: ' + error));
        });
        return cleanup().then(() => failedPromise).then(e => Promise.reject(e));
    }
    options.log(`<launched> pid=${spawnedProcess.pid}`);
    const stdout = readline.createInterface({ input: spawnedProcess.stdout });
    stdout.on('line', (data) => {
        options.log(`[pid=${spawnedProcess.pid}][out] ` + data);
    });
    const stderr = readline.createInterface({ input: spawnedProcess.stderr });
    stderr.on('line', (data) => {
        options.log(`[pid=${spawnedProcess.pid}][err] ` + data);
    });
    let processClosed = false;
    let fulfillClose = () => { };
    const waitForClose = new Promise(f => fulfillClose = f);
    let fulfillCleanup = () => { };
    const waitForCleanup = new Promise(f => fulfillCleanup = f);
    spawnedProcess.once('exit', (exitCode, signal) => {
        options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
        processClosed = true;
        helper_1.helper.removeEventListeners(listeners);
        gracefullyCloseSet.delete(gracefullyClose);
        options.onExit(exitCode, signal);
        fulfillClose();
        // Cleanup as process exits.
        cleanup().then(fulfillCleanup);
    });
    const listeners = [helper_1.helper.addEventListener(process, 'exit', killProcess)];
    if (options.handleSIGINT) {
        listeners.push(helper_1.helper.addEventListener(process, 'SIGINT', () => {
            gracefullyClose().then(() => {
                // Give tests a chance to dispatch any async calls.
                if (utils_1.isUnderTest())
                    setTimeout(() => process.exit(130), 0);
                else
                    process.exit(130);
            });
        }));
    }
    if (options.handleSIGTERM)
        listeners.push(helper_1.helper.addEventListener(process, 'SIGTERM', gracefullyClose));
    if (options.handleSIGHUP)
        listeners.push(helper_1.helper.addEventListener(process, 'SIGHUP', gracefullyClose));
    gracefullyCloseSet.add(gracefullyClose);
    let gracefullyClosing = false;
    async function gracefullyClose() {
        gracefullyCloseSet.delete(gracefullyClose);
        // We keep listeners until we are done, to handle 'exit' and 'SIGINT' while
        // asynchronously closing to prevent zombie processes. This might introduce
        // reentrancy to this function, for example user sends SIGINT second time.
        // In this case, let's forcefully kill the process.
        if (gracefullyClosing) {
            options.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
            killProcess();
            await waitForClose; // Ensure the process is dead and we called options.onkill.
            return;
        }
        gracefullyClosing = true;
        options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
        await options.attemptToGracefullyClose().catch(() => killProcess());
        await waitForCleanup; // Ensure the process is dead and we have cleaned up.
        options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
    }
    // This method has to be sync to be used as 'exit' event handler.
    function killProcess() {
        options.log(`[pid=${spawnedProcess.pid}] <kill>`);
        helper_1.helper.removeEventListeners(listeners);
        if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
            options.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
            // Force kill the browser.
            try {
                if (process.platform === 'win32') {
                    const stdout = childProcess.execSync(`taskkill /pid ${spawnedProcess.pid} /T /F`);
                    options.log(`[pid=${spawnedProcess.pid}] taskkill output: ${stdout.toString()}`);
                }
                else {
                    process.kill(-spawnedProcess.pid, 'SIGKILL');
                }
            }
            catch (e) {
                options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
                // the process might have already stopped
            }
        }
        else {
            options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
        }
        cleanup();
    }
    function killAndWait() {
        killProcess();
        return waitForCleanup;
    }
    return { launchedProcess: spawnedProcess, gracefullyClose, kill: killAndWait };
}
exports.launchProcess = launchProcess;
function envArrayToObject(env) {
    const result = {};
    for (const { name, value } of env)
        result[name] = value;
    return result;
}
exports.envArrayToObject = envArrayToObject;
//# sourceMappingURL=processLauncher.js.map

/***/ }),

/***/ 6707:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressController = void 0;
const errors_1 = __nccwpck_require__(4949);
const utils_1 = __nccwpck_require__(6416);
class ProgressController {
    constructor(metadata, sdkObject) {
        // Promise and callback that forcefully abort the progress.
        // This promise always rejects.
        this._forceAbort = () => { };
        // Cleanups to be run only in the case of abort.
        this._cleanups = [];
        this._logName = 'api';
        this._state = 'before';
        this._deadline = 0;
        this._timeout = 0;
        this.metadata = metadata;
        this.sdkObject = sdkObject;
        this.instrumentation = sdkObject.instrumentation;
        this._forceAbortPromise = new Promise((resolve, reject) => this._forceAbort = reject);
        this._forceAbortPromise.catch(e => null); // Prevent unhandled promise rejection.
    }
    setLogName(logName) {
        this._logName = logName;
    }
    async run(task, timeout) {
        if (timeout) {
            this._timeout = timeout;
            this._deadline = timeout ? utils_1.monotonicTime() + timeout : 0;
        }
        utils_1.assert(this._state === 'before');
        this._state = 'running';
        const progress = {
            log: message => {
                if (this._state === 'running')
                    this.metadata.log.push(message);
                // Note: we might be sending logs after progress has finished, for example browser logs.
                this.instrumentation.onCallLog(this._logName, message, this.sdkObject, this.metadata);
            },
            timeUntilDeadline: () => this._deadline ? this._deadline - utils_1.monotonicTime() : 2147483647,
            isRunning: () => this._state === 'running',
            cleanupWhenAborted: (cleanup) => {
                if (this._state === 'running')
                    this._cleanups.push(cleanup);
                else
                    runCleanup(cleanup);
            },
            throwIfAborted: () => {
                if (this._state === 'aborted')
                    throw new AbortedError();
            },
            beforeInputAction: async (element) => {
                await this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
            },
            metadata: this.metadata
        };
        const timeoutError = new errors_1.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
        const timer = setTimeout(() => this._forceAbort(timeoutError), progress.timeUntilDeadline());
        try {
            const promise = task(progress);
            const result = await Promise.race([promise, this._forceAbortPromise]);
            this._state = 'finished';
            return result;
        }
        catch (e) {
            this._state = 'aborted';
            await Promise.all(this._cleanups.splice(0).map(runCleanup));
            throw e;
        }
        finally {
            clearTimeout(timer);
        }
    }
}
exports.ProgressController = ProgressController;
async function runCleanup(cleanup) {
    try {
        await cleanup();
    }
    catch (e) {
    }
}
class AbortedError extends Error {
}
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ 123:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Screenshotter = void 0;
const helper_1 = __nccwpck_require__(7951);
const utils_1 = __nccwpck_require__(6416);
class Screenshotter {
    constructor(page) {
        this._queue = new TaskQueue();
        this._page = page;
        this._queue = new TaskQueue();
    }
    async _originalViewportSize(progress) {
        const originalViewportSize = this._page.viewportSize();
        let viewportSize = originalViewportSize;
        if (!viewportSize)
            viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({ width: window.innerWidth, height: window.innerHeight }));
        return { viewportSize, originalViewportSize };
    }
    async _fullPageSize(progress) {
        const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {
            if (!document.body || !document.documentElement)
                return null;
            return {
                width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
                height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight),
            };
        });
        return fullPageSize;
    }
    async screenshotPage(progress, options) {
        const format = validateScreenshotOptions(options);
        return this._queue.postTask(async () => {
            const { viewportSize, originalViewportSize } = await this._originalViewportSize(progress);
            if (options.fullPage) {
                const fullPageSize = await this._fullPageSize(progress);
                let documentRect = { x: 0, y: 0, width: fullPageSize.width, height: fullPageSize.height };
                let overriddenViewportSize = null;
                const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
                if (!this._page._delegate.canScreenshotOutsideViewport() && !fitsViewport) {
                    overriddenViewportSize = fullPageSize;
                    progress.throwIfAborted(); // Avoid side effects.
                    await this._page.setViewportSize(overriddenViewportSize);
                    progress.cleanupWhenAborted(() => this._restoreViewport(originalViewportSize));
                }
                if (options.clip)
                    documentRect = trimClipToSize(options.clip, documentRect);
                const buffer = await this._screenshot(progress, format, documentRect, undefined, options);
                progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.
                if (overriddenViewportSize)
                    await this._restoreViewport(originalViewportSize);
                return buffer;
            }
            const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : { x: 0, y: 0, ...viewportSize };
            return await this._screenshot(progress, format, undefined, viewportRect, options);
        });
    }
    async screenshotElement(progress, handle, options = {}) {
        const format = validateScreenshotOptions(options);
        return this._queue.postTask(async () => {
            const { viewportSize, originalViewportSize } = await this._originalViewportSize(progress);
            await handle._waitAndScrollIntoViewIfNeeded(progress);
            progress.throwIfAborted(); // Do not do extra work.
            let boundingBox = await handle.boundingBox();
            utils_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');
            utils_1.assert(boundingBox.width !== 0, 'Node has 0 width.');
            utils_1.assert(boundingBox.height !== 0, 'Node has 0 height.');
            let overriddenViewportSize = null;
            const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
            if (!this._page._delegate.canScreenshotOutsideViewport() && !fitsViewport) {
                overriddenViewportSize = helper_1.helper.enclosingIntSize({
                    width: Math.max(viewportSize.width, boundingBox.width),
                    height: Math.max(viewportSize.height, boundingBox.height),
                });
                progress.throwIfAborted(); // Avoid side effects.
                await this._page.setViewportSize(overriddenViewportSize);
                progress.cleanupWhenAborted(() => this._restoreViewport(originalViewportSize));
                progress.throwIfAborted(); // Avoid extra work.
                await handle._waitAndScrollIntoViewIfNeeded(progress);
                boundingBox = await handle.boundingBox();
                utils_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');
                utils_1.assert(boundingBox.width !== 0, 'Node has 0 width.');
                utils_1.assert(boundingBox.height !== 0, 'Node has 0 height.');
            }
            progress.throwIfAborted(); // Avoid extra work.
            const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({ x: window.scrollX, y: window.scrollY }));
            const documentRect = { ...boundingBox };
            documentRect.x += scrollOffset.x;
            documentRect.y += scrollOffset.y;
            const buffer = await this._screenshot(progress, format, helper_1.helper.enclosingIntRect(documentRect), undefined, options);
            progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.
            if (overriddenViewportSize)
                await this._restoreViewport(originalViewportSize);
            return buffer;
        });
    }
    async _screenshot(progress, format, documentRect, viewportRect, options) {
        if (options.__testHookBeforeScreenshot)
            await options.__testHookBeforeScreenshot();
        progress.throwIfAborted(); // Screenshotting is expensive - avoid extra work.
        const shouldSetDefaultBackground = options.omitBackground && format === 'png';
        if (shouldSetDefaultBackground) {
            await this._page._delegate.setBackgroundColor({ r: 0, g: 0, b: 0, a: 0 });
            progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
        }
        progress.throwIfAborted(); // Avoid extra work.
        const buffer = await this._page._delegate.takeScreenshot(progress, format, documentRect, viewportRect, options.quality);
        progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.
        if (shouldSetDefaultBackground)
            await this._page._delegate.setBackgroundColor();
        progress.throwIfAborted(); // Avoid side effects.
        if (options.__testHookAfterScreenshot)
            await options.__testHookAfterScreenshot();
        return buffer;
    }
    async _restoreViewport(originalViewportSize) {
        utils_1.assert(!this._page._delegate.canScreenshotOutsideViewport());
        if (originalViewportSize)
            await this._page.setViewportSize(originalViewportSize);
        else
            await this._page._delegate.resetViewport();
    }
}
exports.Screenshotter = Screenshotter;
class TaskQueue {
    constructor() {
        this._chain = Promise.resolve();
    }
    postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => { });
        return result;
    }
}
function trimClipToSize(clip, size) {
    const p1 = {
        x: Math.max(0, Math.min(clip.x, size.width)),
        y: Math.max(0, Math.min(clip.y, size.height))
    };
    const p2 = {
        x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
        y: Math.max(0, Math.min(clip.y + clip.height, size.height))
    };
    const result = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
    utils_1.assert(result.width && result.height, 'Clipped area is either empty or outside the resulting image');
    return result;
}
function validateScreenshotOptions(options) {
    let format = null;
    // options.type takes precedence over inferring the type from options.path
    // because it may be a 0-length file with no extension created beforehand (i.e. as a temp file).
    if (options.type) {
        utils_1.assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);
        format = options.type;
    }
    if (!format)
        format = 'png';
    if (options.quality !== undefined) {
        utils_1.assert(format === 'jpeg', 'options.quality is unsupported for the ' + format + ' screenshots');
        utils_1.assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + (typeof options.quality));
        utils_1.assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');
        utils_1.assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);
    }
    if (options.clip) {
        utils_1.assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + (typeof options.clip.x));
        utils_1.assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + (typeof options.clip.y));
        utils_1.assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + (typeof options.clip.width));
        utils_1.assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + (typeof options.clip.height));
        utils_1.assert(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');
        utils_1.assert(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');
    }
    return format;
}
//# sourceMappingURL=screenshotter.js.map

/***/ }),

/***/ 5615:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serverSelectors = exports.Selectors = void 0;
const selectorParser_1 = __nccwpck_require__(8204);
const utils_1 = __nccwpck_require__(6416);
class Selectors {
    constructor() {
        this.guid = `selectors@${utils_1.createGuid()}`;
        // Note: keep in sync with InjectedScript class.
        this._builtinEngines = new Set([
            'css', 'css:light',
            'xpath', 'xpath:light',
            'text', 'text:light',
            'id', 'id:light',
            'data-testid', 'data-testid:light',
            'data-test-id', 'data-test-id:light',
            'data-test', 'data-test:light',
        ]);
        this._engines = new Map();
    }
    async register(name, source, contentScript = false) {
        if (!name.match(/^[a-zA-Z_0-9-]+$/))
            throw new Error('Selector engine name may only contain [a-zA-Z0-9_] characters');
        // Note: we keep 'zs' for future use.
        if (this._builtinEngines.has(name) || name === 'zs' || name === 'zs:light')
            throw new Error(`"${name}" is a predefined selector engine`);
        if (this._engines.has(name))
            throw new Error(`"${name}" selector engine has been already registered`);
        this._engines.set(name, { source, contentScript });
    }
    unregisterAll() {
        this._engines.clear();
    }
    async _query(frame, selector, scope) {
        const info = this._parseSelector(selector);
        const context = await frame._context(info.world);
        const injectedScript = await context.injectedScript();
        const handle = await injectedScript.evaluateHandle((injected, { parsed, scope }) => {
            return injected.querySelector(parsed, scope || document);
        }, { parsed: info.parsed, scope });
        const elementHandle = handle.asElement();
        if (!elementHandle) {
            handle.dispose();
            return null;
        }
        const mainContext = await frame._mainContext();
        return this._adoptIfNeeded(elementHandle, mainContext);
    }
    async _queryArray(frame, selector, scope) {
        const info = this._parseSelector(selector);
        const context = await frame._mainContext();
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, { parsed, scope }) => {
            return injected.querySelectorAll(parsed, scope || document);
        }, { parsed: info.parsed, scope });
        return arrayHandle;
    }
    async _queryAll(frame, selector, scope, adoptToMain) {
        const info = this._parseSelector(selector);
        const context = await frame._context(info.world);
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, { parsed, scope }) => {
            return injected.querySelectorAll(parsed, scope || document);
        }, { parsed: info.parsed, scope });
        const properties = await arrayHandle.getProperties();
        arrayHandle.dispose();
        // Note: adopting elements one by one may be slow. If we encounter the issue here,
        // we might introduce 'useMainContext' option or similar to speed things up.
        const targetContext = adoptToMain ? await frame._mainContext() : context;
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(this._adoptIfNeeded(elementHandle, targetContext));
            else
                property.dispose();
        }
        return Promise.all(result);
    }
    async _adoptIfNeeded(handle, context) {
        if (handle._context === context)
            return handle;
        const adopted = handle._page._delegate.adoptElementHandle(handle, context);
        handle.dispose();
        return adopted;
    }
    _parseSelector(selector) {
        const parsed = selectorParser_1.parseSelector(selector);
        let needsMainWorld = false;
        for (const part of parsed.parts) {
            if (!Array.isArray(part)) {
                const custom = this._engines.get(part.name);
                if (!custom && !this._builtinEngines.has(part.name))
                    throw new Error(`Unknown engine "${part.name}" while parsing selector ${selector}`);
                if (custom && !custom.contentScript)
                    needsMainWorld = true;
            }
        }
        return {
            parsed,
            selector,
            world: needsMainWorld ? 'main' : 'utility',
        };
    }
}
exports.Selectors = Selectors;
exports.serverSelectors = new Selectors();
//# sourceMappingURL=selectors.js.map

/***/ }),

/***/ 1442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Snapshotter = void 0;
const browserContext_1 = __nccwpck_require__(7533);
const page_1 = __nccwpck_require__(9406);
const helper_1 = __nccwpck_require__(7951);
const debugLogger_1 = __nccwpck_require__(5203);
const snapshotterInjected_1 = __nccwpck_require__(2572);
const utils_1 = __nccwpck_require__(6416);
class Snapshotter {
    constructor(context, delegate) {
        this._eventListeners = [];
        this._initialized = false;
        this._started = false;
        this._fetchedResponses = new Map();
        this._context = context;
        this._delegate = delegate;
        const guid = utils_1.createGuid();
        this._snapshotStreamer = '__playwright_snapshot_streamer_' + guid;
    }
    started() {
        return this._started;
    }
    async start() {
        this._started = true;
        if (!this._initialized) {
            this._initialized = true;
            await this._initialize();
        }
        await this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
        // Replay resources loaded in all pages.
        for (const page of this._context.pages()) {
            for (const response of page._frameManager._responses)
                this._saveResource(response).catch(e => debugLogger_1.debugLogger.log('error', e));
        }
    }
    async stop() {
        this._started = false;
    }
    async _initialize() {
        for (const page of this._context.pages())
            this._onPage(page);
        this._eventListeners = [
            helper_1.helper.addEventListener(this._context, browserContext_1.BrowserContext.Events.Page, this._onPage.bind(this)),
            helper_1.helper.addEventListener(this._context, browserContext_1.BrowserContext.Events.Response, (response) => {
                this._saveResource(response).catch(e => debugLogger_1.debugLogger.log('error', e));
            }),
        ];
        const initScript = `(${snapshotterInjected_1.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
        await this._context._doAddInitScript(initScript);
        await this._runInAllFrames(initScript);
    }
    async _runInAllFrames(expression) {
        const frames = [];
        for (const page of this._context.pages())
            frames.push(...page.frames());
        await Promise.all(frames.map(frame => {
            return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(e => debugLogger_1.debugLogger.log('error', e));
        }));
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
    }
    async captureSnapshot(page, snapshotName, element) {
        // Prepare expression synchronously.
        const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
        // In a best-effort manner, without waiting for it, mark target element.
        element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element, snapshotName) => {
            element.setAttribute('__playwright_target__', snapshotName);
        }, snapshotName);
        // In each frame, in a non-stalling manner, capture the snapshots.
        const snapshots = page.frames().map(async (frame) => {
            const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(e => debugLogger_1.debugLogger.log('error', e));
            // Something went wrong -> bail out, our snapshots are best-efforty.
            if (!data || !this._started)
                return;
            const snapshot = {
                snapshotName,
                pageId: page.guid,
                frameId: frame.guid,
                frameUrl: data.url,
                doctype: data.doctype,
                html: data.html,
                viewport: data.viewport,
                timestamp: utils_1.monotonicTime(),
                collectionTime: data.collectionTime,
                resourceOverrides: [],
                isMainFrame: page.mainFrame() === frame
            };
            for (const { url, content } of data.resourceOverrides) {
                if (typeof content === 'string') {
                    const buffer = Buffer.from(content);
                    const sha1 = utils_1.calculateSha1(buffer);
                    this._delegate.onBlob({ sha1, buffer });
                    snapshot.resourceOverrides.push({ url, sha1 });
                }
                else {
                    snapshot.resourceOverrides.push({ url, ref: content });
                }
            }
            this._delegate.onFrameSnapshot(snapshot);
        });
        await Promise.all(snapshots);
    }
    _onPage(page) {
        // Annotate frame hierarchy so that snapshots could include frame ids.
        for (const frame of page.frames())
            this._annotateFrameHierarchy(frame);
        this._eventListeners.push(helper_1.helper.addEventListener(page, page_1.Page.Events.FrameAttached, frame => this._annotateFrameHierarchy(frame)));
    }
    async _saveResource(response) {
        if (!this._started)
            return;
        const isRedirect = response.status() >= 300 && response.status() <= 399;
        if (isRedirect)
            return;
        // Shortcut all redirects - we cannot intercept them properly.
        let original = response.request();
        while (original.redirectedFrom())
            original = original.redirectedFrom();
        const url = original.url();
        let contentType = '';
        for (const { name, value } of response.headers()) {
            if (name.toLowerCase() === 'content-type')
                contentType = value;
        }
        const method = original.method();
        const status = response.status();
        const requestBody = original.postDataBuffer();
        const requestSha1 = requestBody ? utils_1.calculateSha1(requestBody) : '';
        if (requestBody)
            this._delegate.onBlob({ sha1: requestSha1, buffer: requestBody });
        const requestHeaders = original.headers();
        // Only fetch response bodies once.
        let responseSha1 = this._fetchedResponses.get(response);
        {
            if (responseSha1 === undefined) {
                const body = await response.body().catch(e => debugLogger_1.debugLogger.log('error', e));
                // Bail out after each async hop.
                if (!this._started)
                    return;
                responseSha1 = body ? utils_1.calculateSha1(body) : '';
                if (body)
                    this._delegate.onBlob({ sha1: responseSha1, buffer: body });
                this._fetchedResponses.set(response, responseSha1);
            }
        }
        const resource = {
            pageId: response.frame()._page.guid,
            frameId: response.frame().guid,
            resourceId: response.guid,
            url,
            type: response.request().resourceType(),
            contentType,
            responseHeaders: response.headers(),
            requestHeaders,
            method,
            status,
            requestSha1,
            responseSha1,
            timestamp: utils_1.monotonicTime()
        };
        this._delegate.onResourceSnapshot(resource);
    }
    async _annotateFrameHierarchy(frame) {
        try {
            const frameElement = await frame.frameElement();
            const parent = frame.parentFrame();
            if (!parent)
                return;
            const context = await parent._mainContext();
            await (context === null || context === void 0 ? void 0 : context.evaluate(({ snapshotStreamer, frameElement, frameId }) => {
                window[snapshotStreamer].markIframe(frameElement, frameId);
            }, { snapshotStreamer: this._snapshotStreamer, frameElement, frameId: frame.guid }));
            frameElement.dispose();
        }
        catch (e) {
        }
    }
}
exports.Snapshotter = Snapshotter;
//# sourceMappingURL=snapshotter.js.map

/***/ }),

/***/ 2572:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frameSnapshotStreamer = void 0;
function frameSnapshotStreamer(snapshotStreamer) {
    // Communication with Playwright.
    if (window[snapshotStreamer])
        return;
    // Attributes present in the snapshot.
    const kShadowAttribute = '__playwright_shadow_root_';
    const kScrollTopAttribute = '__playwright_scroll_top_';
    const kScrollLeftAttribute = '__playwright_scroll_left_';
    // Symbols for our own info on Nodes/StyleSheets.
    const kSnapshotFrameId = Symbol('__playwright_snapshot_frameid_');
    const kCachedData = Symbol('__playwright_snapshot_cache_');
    function resetCachedData(obj) {
        delete obj[kCachedData];
    }
    function ensureCachedData(obj) {
        if (!obj[kCachedData])
            obj[kCachedData] = {};
        return obj[kCachedData];
    }
    function removeHash(url) {
        try {
            const u = new URL(url);
            u.hash = '';
            return u.toString();
        }
        catch (e) {
            return url;
        }
    }
    class Streamer {
        constructor() {
            this._removeNoScript = true;
            this._lastSnapshotNumber = 0;
            this._staleStyleSheets = new Set();
            this._readingStyleSheet = false; // To avoid invalidating due to our own reads.
            this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'insertRule', (sheet) => this._invalidateStyleSheet(sheet));
            this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'deleteRule', (sheet) => this._invalidateStyleSheet(sheet));
            this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'addRule', (sheet) => this._invalidateStyleSheet(sheet));
            this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'removeRule', (sheet) => this._invalidateStyleSheet(sheet));
            this._interceptNativeGetter(window.CSSStyleSheet.prototype, 'rules', (sheet) => this._invalidateStyleSheet(sheet));
            this._interceptNativeGetter(window.CSSStyleSheet.prototype, 'cssRules', (sheet) => this._invalidateStyleSheet(sheet));
            this._fakeBase = document.createElement('base');
            this._observer = new MutationObserver(list => this._handleMutations(list));
            const observerConfig = { attributes: true, subtree: true };
            this._observer.observe(document, observerConfig);
        }
        _interceptNativeMethod(obj, method, cb) {
            const native = obj[method];
            if (!native)
                return;
            obj[method] = function (...args) {
                const result = native.call(this, ...args);
                cb(this, result);
                return result;
            };
        }
        _interceptNativeGetter(obj, prop, cb) {
            const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            Object.defineProperty(obj, prop, {
                ...descriptor,
                get: function () {
                    const result = descriptor.get.call(this);
                    cb(this, result);
                    return result;
                },
            });
        }
        _handleMutations(list) {
            for (const mutation of list)
                ensureCachedData(mutation.target).attributesCached = undefined;
        }
        _invalidateStyleSheet(sheet) {
            if (this._readingStyleSheet)
                return;
            this._staleStyleSheets.add(sheet);
        }
        _updateStyleElementStyleSheetTextIfNeeded(sheet) {
            const data = ensureCachedData(sheet);
            if (this._staleStyleSheets.has(sheet)) {
                this._staleStyleSheets.delete(sheet);
                try {
                    data.cssText = this._getSheetText(sheet);
                }
                catch (e) {
                    // Sometimes we cannot access cross-origin stylesheets.
                }
            }
            return data.cssText;
        }
        // Returns either content, ref, or no override.
        _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
            const data = ensureCachedData(sheet);
            if (this._staleStyleSheets.has(sheet)) {
                this._staleStyleSheets.delete(sheet);
                try {
                    data.cssText = this._getSheetText(sheet);
                    data.cssRef = snapshotNumber;
                    return data.cssText;
                }
                catch (e) {
                    // Sometimes we cannot access cross-origin stylesheets.
                }
            }
            return data.cssRef === undefined ? undefined : snapshotNumber - data.cssRef;
        }
        markIframe(iframeElement, frameId) {
            iframeElement[kSnapshotFrameId] = frameId;
        }
        reset() {
            this._staleStyleSheets.clear();
            const visitNode = (node) => {
                resetCachedData(node);
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    if (element.shadowRoot)
                        visitNode(element.shadowRoot);
                }
                for (let child = node.firstChild; child; child = child.nextSibling)
                    visitNode(child);
            };
            visitNode(document.documentElement);
        }
        _sanitizeUrl(url) {
            if (url.startsWith('javascript:'))
                return '';
            return url;
        }
        _sanitizeSrcSet(srcset) {
            return srcset.split(',').map(src => {
                src = src.trim();
                const spaceIndex = src.lastIndexOf(' ');
                if (spaceIndex === -1)
                    return this._sanitizeUrl(src);
                return this._sanitizeUrl(src.substring(0, spaceIndex).trim()) + src.substring(spaceIndex);
            }).join(', ');
        }
        _resolveUrl(base, url) {
            if (url === '')
                return '';
            try {
                return new URL(url, base).href;
            }
            catch (e) {
                return url;
            }
        }
        _getSheetBase(sheet) {
            let rootSheet = sheet;
            while (rootSheet.parentStyleSheet)
                rootSheet = rootSheet.parentStyleSheet;
            if (rootSheet.ownerNode)
                return rootSheet.ownerNode.baseURI;
            return document.baseURI;
        }
        _getSheetText(sheet) {
            this._readingStyleSheet = true;
            try {
                const rules = [];
                for (const rule of sheet.cssRules)
                    rules.push(rule.cssText);
                return rules.join('\n');
            }
            finally {
                this._readingStyleSheet = false;
            }
        }
        captureSnapshot() {
            const timestamp = performance.now();
            const snapshotNumber = ++this._lastSnapshotNumber;
            let nodeCounter = 0;
            let shadowDomNesting = 0;
            // Ensure we are up to date.
            this._handleMutations(this._observer.takeRecords());
            const visitNode = (node) => {
                const nodeType = node.nodeType;
                const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? 'template' : node.nodeName;
                if (nodeType !== Node.ELEMENT_NODE &&
                    nodeType !== Node.DOCUMENT_FRAGMENT_NODE &&
                    nodeType !== Node.TEXT_NODE)
                    return;
                if (nodeName === 'SCRIPT')
                    return;
                if (this._removeNoScript && nodeName === 'NOSCRIPT')
                    return;
                const data = ensureCachedData(node);
                const values = [];
                let equals = !!data.cached;
                let extraNodes = 0;
                const expectValue = (value) => {
                    equals = equals && data.cached[values.length] === value;
                    values.push(value);
                };
                const checkAndReturn = (n) => {
                    data.attributesCached = true;
                    if (equals)
                        return { equals: true, n: [[snapshotNumber - data.ref[0], data.ref[1]]] };
                    nodeCounter += extraNodes;
                    data.ref = [snapshotNumber, nodeCounter++];
                    data.cached = values;
                    return { equals: false, n };
                };
                if (nodeType === Node.TEXT_NODE) {
                    const value = node.nodeValue || '';
                    expectValue(value);
                    return checkAndReturn(value);
                }
                if (nodeName === 'STYLE') {
                    const sheet = node.sheet;
                    let cssText;
                    if (sheet)
                        cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
                    cssText = cssText || node.textContent || '';
                    expectValue(cssText);
                    // Compensate for the extra 'cssText' text node.
                    extraNodes++;
                    return checkAndReturn(['style', {}, cssText]);
                }
                const attrs = {};
                const result = [nodeName, attrs];
                const visitChild = (child) => {
                    const snapshot = visitNode(child);
                    if (snapshot) {
                        result.push(snapshot.n);
                        expectValue(child);
                        equals = equals && snapshot.equals;
                    }
                };
                if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
                    attrs[kShadowAttribute] = 'open';
                if (nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    if (nodeName === 'INPUT') {
                        const value = element.value;
                        expectValue('value');
                        expectValue(value);
                        attrs['value'] = value;
                        if (element.checked) {
                            expectValue('checked');
                            attrs['checked'] = '';
                        }
                    }
                    if (element === document.scrollingElement) {
                        // TODO: restoring scroll positions of all elements
                        // is somewhat expensive. Figure this out.
                        if (element.scrollTop) {
                            expectValue(kScrollTopAttribute);
                            expectValue(element.scrollTop);
                            attrs[kScrollTopAttribute] = '' + element.scrollTop;
                        }
                        if (element.scrollLeft) {
                            expectValue(kScrollLeftAttribute);
                            expectValue(element.scrollLeft);
                            attrs[kScrollLeftAttribute] = '' + element.scrollLeft;
                        }
                    }
                    if (element.shadowRoot) {
                        ++shadowDomNesting;
                        visitChild(element.shadowRoot);
                        --shadowDomNesting;
                    }
                }
                if (nodeName === 'TEXTAREA') {
                    const value = node.value;
                    expectValue(value);
                    extraNodes++; // Compensate for the extra text node.
                    result.push(value);
                }
                else {
                    if (nodeName === 'HEAD') {
                        // Insert fake <base> first, to ensure all <link> elements use the proper base uri.
                        this._fakeBase.setAttribute('href', document.baseURI);
                        visitChild(this._fakeBase);
                    }
                    for (let child = node.firstChild; child; child = child.nextSibling)
                        visitChild(child);
                }
                // Process iframe src attribute before bailing out since it depends on a symbol, not the DOM.
                if (nodeName === 'IFRAME' || nodeName === 'FRAME') {
                    const element = node;
                    for (let i = 0; i < element.attributes.length; i++) {
                        const frameId = element[kSnapshotFrameId];
                        const name = 'src';
                        const value = frameId ? `/snapshot/${frameId}` : '';
                        expectValue(name);
                        expectValue(value);
                        attrs[name] = value;
                    }
                }
                // We can skip attributes comparison because nothing else has changed,
                // and mutation observer didn't tell us about the attributes.
                if (equals && data.attributesCached && !shadowDomNesting)
                    return checkAndReturn(result);
                if (nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    for (let i = 0; i < element.attributes.length; i++) {
                        const name = element.attributes[i].name;
                        if (name === 'value' && (nodeName === 'INPUT' || nodeName === 'TEXTAREA'))
                            continue;
                        if (nodeName === 'LINK' && name === 'integrity')
                            continue;
                        if (nodeName === 'IFRAME' && name === 'src')
                            continue;
                        let value = element.attributes[i].value;
                        if (name === 'src' && (nodeName === 'IMG'))
                            value = this._sanitizeUrl(value);
                        else if (name === 'srcset' && (nodeName === 'IMG'))
                            value = this._sanitizeSrcSet(value);
                        else if (name === 'srcset' && (nodeName === 'SOURCE'))
                            value = this._sanitizeSrcSet(value);
                        else if (name === 'href' && (nodeName === 'LINK'))
                            value = this._sanitizeUrl(value);
                        else if (name.startsWith('on'))
                            value = '';
                        expectValue(name);
                        expectValue(value);
                        attrs[name] = value;
                    }
                }
                if (result.length === 2 && !Object.keys(attrs).length)
                    result.pop(); // Remove empty attrs when there are no children.
                return checkAndReturn(result);
            };
            let html;
            if (document.documentElement) {
                const { n } = visitNode(document.documentElement);
                html = n;
            }
            else {
                html = ['html'];
            }
            const result = {
                html,
                doctype: document.doctype ? document.doctype.name : undefined,
                resourceOverrides: [],
                viewport: {
                    width: Math.max(document.body ? document.body.offsetWidth : 0, document.documentElement ? document.documentElement.offsetWidth : 0),
                    height: Math.max(document.body ? document.body.offsetHeight : 0, document.documentElement ? document.documentElement.offsetHeight : 0),
                },
                url: location.href,
                timestamp,
                collectionTime: 0,
            };
            for (const sheet of this._staleStyleSheets) {
                if (sheet.href === null)
                    continue;
                const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
                if (content === undefined) {
                    // Unable to capture stylesheet contents.
                    continue;
                }
                const base = this._getSheetBase(sheet);
                const url = removeHash(this._resolveUrl(base, sheet.href));
                result.resourceOverrides.push({ url, content });
            }
            result.collectionTime = performance.now() - result.timestamp;
            return result;
        }
    }
    window[snapshotStreamer] = new Streamer();
}
exports.frameSnapshotStreamer = frameSnapshotStreamer;
//# sourceMappingURL=snapshotterInjected.js.map

/***/ }),

/***/ 187:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocksProxyServer = exports.SocksInterceptedSocketHandler = void 0;
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const net_1 = __importDefault(__nccwpck_require__(1631));
const debugLogger_1 = __nccwpck_require__(5203);
const instrumentation_1 = __nccwpck_require__(7490);
var ConnectionPhases;
(function (ConnectionPhases) {
    ConnectionPhases[ConnectionPhases["VERSION"] = 0] = "VERSION";
    ConnectionPhases[ConnectionPhases["NMETHODS"] = 1] = "NMETHODS";
    ConnectionPhases[ConnectionPhases["METHODS"] = 2] = "METHODS";
    ConnectionPhases[ConnectionPhases["REQ_CMD"] = 3] = "REQ_CMD";
    ConnectionPhases[ConnectionPhases["REQ_RSV"] = 4] = "REQ_RSV";
    ConnectionPhases[ConnectionPhases["REQ_ATYP"] = 5] = "REQ_ATYP";
    ConnectionPhases[ConnectionPhases["REQ_DSTADDR"] = 6] = "REQ_DSTADDR";
    ConnectionPhases[ConnectionPhases["REQ_DSTADDR_VARLEN"] = 7] = "REQ_DSTADDR_VARLEN";
    ConnectionPhases[ConnectionPhases["REQ_DSTPORT"] = 8] = "REQ_DSTPORT";
    ConnectionPhases[ConnectionPhases["DONE"] = 9] = "DONE";
})(ConnectionPhases || (ConnectionPhases = {}));
var SOCKS_AUTH_METHOD;
(function (SOCKS_AUTH_METHOD) {
    SOCKS_AUTH_METHOD[SOCKS_AUTH_METHOD["NO_AUTH"] = 0] = "NO_AUTH";
})(SOCKS_AUTH_METHOD || (SOCKS_AUTH_METHOD = {}));
var SOCKS_CMD;
(function (SOCKS_CMD) {
    SOCKS_CMD[SOCKS_CMD["CONNECT"] = 1] = "CONNECT";
    SOCKS_CMD[SOCKS_CMD["BIND"] = 2] = "BIND";
    SOCKS_CMD[SOCKS_CMD["UDP"] = 3] = "UDP";
})(SOCKS_CMD || (SOCKS_CMD = {}));
var SOCKS_ATYP;
(function (SOCKS_ATYP) {
    SOCKS_ATYP[SOCKS_ATYP["IPv4"] = 1] = "IPv4";
    SOCKS_ATYP[SOCKS_ATYP["NAME"] = 3] = "NAME";
    SOCKS_ATYP[SOCKS_ATYP["IPv6"] = 4] = "IPv6";
})(SOCKS_ATYP || (SOCKS_ATYP = {}));
var SOCKS_REPLY;
(function (SOCKS_REPLY) {
    SOCKS_REPLY[SOCKS_REPLY["SUCCESS"] = 0] = "SUCCESS";
})(SOCKS_REPLY || (SOCKS_REPLY = {}));
const SOCKS_VERSION = 0x5;
const BUF_REP_INTR_SUCCESS = Buffer.from([
    0x05,
    SOCKS_REPLY.SUCCESS,
    0x00,
    0x01,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
]);
/**
 * https://tools.ietf.org/html/rfc1928
 */
class SocksV5ServerParser {
    constructor(socket) {
        this._dstAddrp = 0;
        this._phase = ConnectionPhases.VERSION;
        this._methodsp = 0;
        this._socket = socket;
        this._info = { srcAddr: socket.remoteAddress, srcPort: socket.remotePort, dstAddr: '', dstPort: 0 };
        this._parsingFinished = new Promise((resolve, reject) => {
            this._parsingFinishedResolve = resolve;
            this._parsingFinishedReject = reject;
        });
        socket.on('data', this._onData.bind(this));
        socket.on('error', () => { });
    }
    _onData(chunk) {
        const socket = this._socket;
        let i = 0;
        const readByte = () => chunk[i++];
        const closeSocketOnError = () => {
            socket.end();
            this._parsingFinishedReject(new Error('Parsing aborted'));
        };
        while (i < chunk.length && this._phase !== ConnectionPhases.DONE) {
            switch (this._phase) {
                case ConnectionPhases.VERSION:
                    if (readByte() !== SOCKS_VERSION)
                        return closeSocketOnError();
                    this._phase = ConnectionPhases.NMETHODS;
                    break;
                case ConnectionPhases.NMETHODS:
                    this._authMethods = Buffer.alloc(readByte());
                    this._phase = ConnectionPhases.METHODS;
                    break;
                case ConnectionPhases.METHODS: {
                    if (!this._authMethods)
                        return closeSocketOnError();
                    chunk.copy(this._authMethods, 0, i, i + chunk.length);
                    if (!this._authMethods.includes(SOCKS_AUTH_METHOD.NO_AUTH))
                        return closeSocketOnError();
                    const left = this._authMethods.length - this._methodsp;
                    const chunkLeft = chunk.length - i;
                    const minLen = (left < chunkLeft ? left : chunkLeft);
                    chunk.copy(this._authMethods, this._methodsp, i, i + minLen);
                    this._methodsp += minLen;
                    i += minLen;
                    if (this._methodsp !== this._authMethods.length)
                        return closeSocketOnError();
                    if (i < chunk.length)
                        this._socket.unshift(chunk.slice(i));
                    this._authWithoutPassword(socket);
                    this._phase = ConnectionPhases.REQ_CMD;
                    break;
                }
                case ConnectionPhases.REQ_CMD:
                    if (readByte() !== SOCKS_VERSION)
                        return closeSocketOnError();
                    const cmd = readByte();
                    if (cmd !== SOCKS_CMD.CONNECT)
                        return closeSocketOnError();
                    this._phase = ConnectionPhases.REQ_RSV;
                    break;
                case ConnectionPhases.REQ_RSV:
                    readByte();
                    this._phase = ConnectionPhases.REQ_ATYP;
                    break;
                case ConnectionPhases.REQ_ATYP:
                    this._phase = ConnectionPhases.REQ_DSTADDR;
                    this._addressType = readByte();
                    if (!(this._addressType in SOCKS_ATYP))
                        return closeSocketOnError();
                    if (this._addressType === SOCKS_ATYP.IPv4)
                        this._dstAddr = Buffer.alloc(4);
                    else if (this._addressType === SOCKS_ATYP.IPv6)
                        this._dstAddr = Buffer.alloc(16);
                    else if (this._addressType === SOCKS_ATYP.NAME)
                        this._phase = ConnectionPhases.REQ_DSTADDR_VARLEN;
                    break;
                case ConnectionPhases.REQ_DSTADDR: {
                    if (!this._dstAddr)
                        return closeSocketOnError();
                    const left = this._dstAddr.length - this._dstAddrp;
                    const chunkLeft = chunk.length - i;
                    const minLen = (left < chunkLeft ? left : chunkLeft);
                    chunk.copy(this._dstAddr, this._dstAddrp, i, i + minLen);
                    this._dstAddrp += minLen;
                    i += minLen;
                    if (this._dstAddrp === this._dstAddr.length)
                        this._phase = ConnectionPhases.REQ_DSTPORT;
                    break;
                }
                case ConnectionPhases.REQ_DSTADDR_VARLEN:
                    this._dstAddr = Buffer.alloc(readByte());
                    this._phase = ConnectionPhases.REQ_DSTADDR;
                    break;
                case ConnectionPhases.REQ_DSTPORT:
                    if (!this._dstAddr)
                        return closeSocketOnError();
                    if (this._dstPort === undefined) {
                        this._dstPort = readByte();
                        break;
                    }
                    this._dstPort <<= 8;
                    this._dstPort += readByte();
                    this._socket.removeListener('data', this._onData);
                    if (i < chunk.length)
                        this._socket.unshift(chunk.slice(i));
                    if (this._addressType === SOCKS_ATYP.IPv4) {
                        this._info.dstAddr = [...this._dstAddr].join('.');
                    }
                    else if (this._addressType === SOCKS_ATYP.IPv6) {
                        let ipv6str = '';
                        const addr = this._dstAddr;
                        for (let b = 0; b < 16; ++b) {
                            if (b % 2 === 0 && b > 0)
                                ipv6str += ':';
                            ipv6str += (addr[b] < 16 ? '0' : '') + addr[b].toString(16);
                        }
                        this._info.dstAddr = ipv6str;
                    }
                    else {
                        this._info.dstAddr = this._dstAddr.toString();
                    }
                    this._info.dstPort = this._dstPort;
                    this._phase = ConnectionPhases.DONE;
                    this._parsingFinishedResolve();
                    return;
                default:
                    return closeSocketOnError();
            }
        }
    }
    _authWithoutPassword(socket) {
        socket.write(Buffer.from([0x05, 0x00]));
    }
    async ready() {
        await this._parsingFinished;
        return {
            info: this._info,
            forward: () => {
                const dstSocket = new net_1.default.Socket();
                this._socket.on('close', () => dstSocket.end());
                this._socket.on('end', () => dstSocket.end());
                dstSocket.setKeepAlive(false);
                dstSocket.on('error', (err) => writeSocksSocketError(this._socket, String(err)));
                dstSocket.on('connect', () => {
                    this._socket.write(BUF_REP_INTR_SUCCESS);
                    this._socket.pipe(dstSocket).pipe(this._socket);
                    this._socket.resume();
                }).connect(this._info.dstPort, this._info.dstAddr);
            },
            intercept: (parent) => {
                return new SocksInterceptedSocketHandler(parent, this._socket, this._info.dstAddr, this._info.dstPort);
            },
        };
    }
}
class SocksInterceptedSocketHandler extends instrumentation_1.SdkObject {
    constructor(parent, socket, dstAddr, dstPort) {
        super(parent, 'SocksSocket');
        this.socket = socket;
        this.dstAddr = dstAddr;
        this.dstPort = dstPort;
        socket.on('data', data => this.emit('data', data));
        socket.on('close', data => this.emit('close', data));
    }
    connected() {
        this.socket.write(BUF_REP_INTR_SUCCESS);
        this.socket.resume();
    }
    error(error) {
        this.socket.resume();
        writeSocksSocketError(this.socket, error);
    }
    write(data) {
        this.socket.write(data);
    }
    end() {
        this.socket.end();
    }
}
exports.SocksInterceptedSocketHandler = SocksInterceptedSocketHandler;
function writeSocksSocketError(socket, error) {
    if (!socket.writable)
        return;
    socket.write(BUF_REP_INTR_SUCCESS);
    const body = `Connection error: ${error}`;
    socket.end([
        'HTTP/1.1 502 OK',
        'Connection: close',
        'Content-Type: text/plain',
        'Content-Length: ' + Buffer.byteLength(body),
        '',
        body
    ].join('\r\n'));
}
class SocksProxyServer {
    constructor(incomingMessageHandler) {
        this.server = net_1.default.createServer(this._handleConnection.bind(this, incomingMessageHandler));
    }
    async listen(port, host) {
        await new Promise(resolve => this.server.listen(port, host, resolve));
    }
    async _handleConnection(incomingMessageHandler, socket) {
        const parser = new SocksV5ServerParser(socket);
        let parsedSocket;
        try {
            parsedSocket = await parser.ready();
        }
        catch (error) {
            debugLogger_1.debugLogger.log('proxy', `Could not parse: ${error} ${error === null || error === void 0 ? void 0 : error.stack}`);
            return;
        }
        incomingMessageHandler(parsedSocket.info, parsedSocket.forward, parsedSocket.intercept);
    }
    close() {
        this.server.close();
    }
}
exports.SocksProxyServer = SocksProxyServer;
//# sourceMappingURL=socksServer.js.map

/***/ }),

/***/ 113:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PortForwardingServer = void 0;
const events_1 = __nccwpck_require__(8614);
const debugLogger_1 = __nccwpck_require__(5203);
const utils_1 = __nccwpck_require__(6416);
const socksServer_1 = __nccwpck_require__(187);
class PortForwardingServer extends events_1.EventEmitter {
    constructor(parent) {
        super();
        this._forwardPorts = [];
        this.setMaxListeners(0);
        this._parent = parent;
        this._server = new socksServer_1.SocksProxyServer(this._handler.bind(this));
    }
    static async create(parent) {
        const server = new PortForwardingServer(parent);
        await server._server.listen(0);
        debugLogger_1.debugLogger.log('proxy', `starting server on port ${server._port()})`);
        return server;
    }
    _port() {
        return this._server.server.address().port;
    }
    proxyServer() {
        return `socks5://127.0.0.1:${this._port()}`;
    }
    _handler(info, forward, intercept) {
        const shouldProxyRequestToClient = utils_1.isLocalIpAddress(info.dstAddr) && this._forwardPorts.includes(info.dstPort);
        debugLogger_1.debugLogger.log('proxy', `incoming connection from ${info.srcAddr}:${info.srcPort} to ${info.dstAddr}:${info.dstPort} shouldProxyRequestToClient=${shouldProxyRequestToClient}`);
        if (!shouldProxyRequestToClient) {
            forward();
            return;
        }
        const socket = intercept(this._parent);
        this.emit('incomingSocksSocket', socket);
    }
    setForwardedPorts(ports) {
        debugLogger_1.debugLogger.log('proxy', `enable port forwarding on ports: ${ports}`);
        this._forwardPorts = ports;
    }
    stop() {
        debugLogger_1.debugLogger.log('proxy', 'stopping server');
        this._server.close();
    }
}
exports.PortForwardingServer = PortForwardingServer;
//# sourceMappingURL=socksSocket.js.map

/***/ }),

/***/ 2407:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Debugger = void 0;
const events_1 = __nccwpck_require__(8614);
const utils_1 = __nccwpck_require__(6416);
const debugLogger_1 = __nccwpck_require__(5203);
const symbol = Symbol('Debugger');
class Debugger extends events_1.EventEmitter {
    constructor(context) {
        super();
        this._pauseOnNextStatement = false;
        this._pausedCallsMetadata = new Map();
        this._muted = false;
        this._context = context;
        this._context[symbol] = this;
        this._enabled = utils_1.debugMode() === 'inspector';
        if (this._enabled)
            this.pauseOnNextStatement();
    }
    static lookup(context) {
        if (!context)
            return;
        return context[symbol];
    }
    async setMuted(muted) {
        this._muted = muted;
    }
    async onBeforeCall(sdkObject, metadata) {
        if (this._muted)
            return;
        if (shouldPauseOnCall(sdkObject, metadata) || (this._pauseOnNextStatement && shouldPauseOnNonInputStep(sdkObject, metadata)))
            await this.pause(sdkObject, metadata);
    }
    async onBeforeInputAction(sdkObject, metadata) {
        if (this._muted)
            return;
        if (this._enabled && this._pauseOnNextStatement)
            await this.pause(sdkObject, metadata);
    }
    async onCallLog(logName, message, sdkObject, metadata) {
        debugLogger_1.debugLogger.log(logName, message);
    }
    async pause(sdkObject, metadata) {
        if (this._muted)
            return;
        this._enabled = true;
        metadata.pauseStartTime = utils_1.monotonicTime();
        const result = new Promise(resolve => {
            this._pausedCallsMetadata.set(metadata, { resolve, sdkObject });
        });
        this.emit(Debugger.Events.PausedStateChanged);
        return result;
    }
    resume(step) {
        this._pauseOnNextStatement = step;
        const endTime = utils_1.monotonicTime();
        for (const [metadata, { resolve }] of this._pausedCallsMetadata) {
            metadata.pauseEndTime = endTime;
            resolve();
        }
        this._pausedCallsMetadata.clear();
        this.emit(Debugger.Events.PausedStateChanged);
    }
    pauseOnNextStatement() {
        this._pauseOnNextStatement = true;
    }
    isPaused(metadata) {
        if (metadata)
            return this._pausedCallsMetadata.has(metadata);
        return !!this._pausedCallsMetadata.size;
    }
    pausedDetails() {
        const result = [];
        for (const [metadata, { sdkObject }] of this._pausedCallsMetadata)
            result.push({ metadata, sdkObject });
        return result;
    }
}
exports.Debugger = Debugger;
Debugger.Events = {
    PausedStateChanged: 'pausedstatechanged'
};
function shouldPauseOnCall(sdkObject, metadata) {
    var _a;
    if (!((_a = sdkObject.attribution.browser) === null || _a === void 0 ? void 0 : _a.options.headful) && !utils_1.isUnderTest())
        return false;
    return metadata.method === 'pause';
}
const nonInputActionsToStep = new Set(['close', 'evaluate', 'evaluateHandle', 'goto', 'setContent']);
function shouldPauseOnNonInputStep(sdkObject, metadata) {
    return nonInputActionsToStep.has(metadata.method);
}
//# sourceMappingURL=debugger.js.map

/***/ }),

/***/ 3134:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HarTracer = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const browserContext_1 = __nccwpck_require__(7533);
const helper_1 = __nccwpck_require__(7951);
const network = __importStar(__nccwpck_require__(8781));
const page_1 = __nccwpck_require__(9406);
class HarTracer {
    constructor(context, options) {
        this._pageEntries = new Map();
        this._entries = new Map();
        this._lastPage = 0;
        this._barrierPromises = new Set();
        this._options = options;
        this._log = {
            version: '1.2',
            creator: {
                name: 'Playwright',
                version: __nccwpck_require__(5101).version,
            },
            browser: {
                name: context._browser.options.name,
                version: context._browser.version()
            },
            pages: [],
            entries: []
        };
        context.on(browserContext_1.BrowserContext.Events.Page, (page) => this._ensurePageEntry(page));
        context.on(browserContext_1.BrowserContext.Events.Request, (request) => this._onRequest(request));
        context.on(browserContext_1.BrowserContext.Events.Response, (response) => this._onResponse(response));
    }
    _ensurePageEntry(page) {
        let pageEntry = this._pageEntries.get(page);
        if (!pageEntry) {
            page.on(page_1.Page.Events.DOMContentLoaded, () => this._onDOMContentLoaded(page));
            page.on(page_1.Page.Events.Load, () => this._onLoad(page));
            pageEntry = {
                startedDateTime: new Date(),
                id: `page_${this._lastPage++}`,
                title: '',
                pageTimings: {
                    onContentLoad: -1,
                    onLoad: -1,
                },
            };
            this._pageEntries.set(page, pageEntry);
            this._log.pages.push(pageEntry);
        }
        return pageEntry;
    }
    _onDOMContentLoaded(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
            return {
                title: document.title,
                domContentLoaded: performance.timing.domContentLoadedEventStart,
            };
        }), true, undefined, 'utility').then(result => {
            pageEntry.title = result.title;
            pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
        }).catch(() => { });
        this._addBarrier(page, promise);
    }
    _onLoad(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
            return {
                title: document.title,
                loaded: performance.timing.loadEventStart,
            };
        }), true, undefined, 'utility').then(result => {
            pageEntry.title = result.title;
            pageEntry.pageTimings.onLoad = result.loaded;
        }).catch(() => { });
        this._addBarrier(page, promise);
    }
    _addBarrier(page, promise) {
        const race = Promise.race([
            new Promise(f => page.on('close', () => {
                this._barrierPromises.delete(race);
                f();
            })),
            promise
        ]);
        this._barrierPromises.add(race);
    }
    _onRequest(request) {
        const page = request.frame()._page;
        const url = network.parsedURL(request.url());
        if (!url)
            return;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = {
            pageref: pageEntry.id,
            startedDateTime: new Date(),
            time: -1,
            request: {
                method: request.method(),
                url: request.url(),
                httpVersion: 'HTTP/1.1',
                cookies: [],
                headers: [],
                queryString: [...url.searchParams].map(e => ({ name: e[0], value: e[1] })),
                postData: undefined,
                headersSize: -1,
                bodySize: -1,
            },
            response: {
                status: -1,
                statusText: '',
                httpVersion: 'HTTP/1.1',
                cookies: [],
                headers: [],
                content: {
                    size: -1,
                    mimeType: request.headerValue('content-type') || 'application/octet-stream',
                },
                headersSize: -1,
                bodySize: -1,
                redirectURL: ''
            },
            cache: {
                beforeRequest: null,
                afterRequest: null,
            },
            timings: {
                send: -1,
                wait: -1,
                receive: -1
            },
        };
        if (request.redirectedFrom()) {
            const fromEntry = this._entries.get(request.redirectedFrom());
            fromEntry.response.redirectURL = request.url();
        }
        this._log.entries.push(harEntry);
        this._entries.set(request, harEntry);
    }
    _onResponse(response) {
        const page = response.frame()._page;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = this._entries.get(response.request());
        // Rewrite provisional headers with actual
        const request = response.request();
        harEntry.request.headers = request.headers().map(header => ({ name: header.name, value: header.value }));
        harEntry.request.cookies = cookiesForHar(request.headerValue('cookie'), ';');
        harEntry.request.postData = postDataForHar(request) || undefined;
        harEntry.response = {
            status: response.status(),
            statusText: response.statusText(),
            httpVersion: 'HTTP/1.1',
            cookies: cookiesForHar(response.headerValue('set-cookie'), '\n'),
            headers: response.headers().map(header => ({ name: header.name, value: header.value })),
            content: {
                size: -1,
                mimeType: response.headerValue('content-type') || 'application/octet-stream',
            },
            headersSize: -1,
            bodySize: -1,
            redirectURL: ''
        };
        const timing = response.timing();
        if (pageEntry.startedDateTime.valueOf() > timing.startTime)
            pageEntry.startedDateTime = new Date(timing.startTime);
        const dns = timing.domainLookupEnd !== -1 ? helper_1.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
        const connect = timing.connectEnd !== -1 ? helper_1.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
        const ssl = timing.connectEnd !== -1 ? helper_1.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
        const wait = timing.responseStart !== -1 ? helper_1.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
        const receive = response.request()._responseEndTiming !== -1 ? helper_1.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
        harEntry.timings = {
            dns,
            connect,
            ssl,
            send: 0,
            wait,
            receive,
        };
        harEntry.time = [dns, connect, ssl, wait, receive].reduce((pre, cur) => cur > 0 ? cur + pre : pre, 0);
        if (!this._options.omitContent && response.status() === 200) {
            const promise = response.body().then(buffer => {
                harEntry.response.content.text = buffer.toString('base64');
                harEntry.response.content.encoding = 'base64';
            }).catch(() => { });
            this._addBarrier(page, promise);
        }
    }
    async flush() {
        await Promise.all(this._barrierPromises);
        for (const pageEntry of this._log.pages) {
            if (pageEntry.pageTimings.onContentLoad >= 0)
                pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();
            else
                pageEntry.pageTimings.onContentLoad = -1;
            if (pageEntry.pageTimings.onLoad >= 0)
                pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();
            else
                pageEntry.pageTimings.onLoad = -1;
        }
        await fs_1.default.promises.writeFile(this._options.path, JSON.stringify({ log: this._log }, undefined, 2));
    }
}
exports.HarTracer = HarTracer;
function postDataForHar(request) {
    const postData = request.postDataBuffer();
    if (!postData)
        return null;
    const contentType = request.headerValue('content-type') || 'application/octet-stream';
    const result = {
        mimeType: contentType,
        text: contentType === 'application/octet-stream' ? '' : postData.toString(),
        params: []
    };
    if (contentType === 'application/x-www-form-urlencoded') {
        const parsed = new URLSearchParams(postData.toString());
        for (const [name, value] of parsed.entries())
            result.params.push({ name, value });
    }
    return result;
}
function cookiesForHar(header, separator) {
    if (!header)
        return [];
    return header.split(separator).map(c => parseCookie(c));
}
function parseCookie(c) {
    const cookie = {
        name: '',
        value: ''
    };
    let first = true;
    for (const pair of c.split(/; */)) {
        const indexOfEquals = pair.indexOf('=');
        const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
        const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : '';
        if (first) {
            first = false;
            cookie.name = name;
            cookie.value = value;
            continue;
        }
        if (name === 'Domain')
            cookie.domain = value;
        if (name === 'Expires')
            cookie.expires = new Date(value);
        if (name === 'HttpOnly')
            cookie.httpOnly = true;
        if (name === 'Max-Age')
            cookie.expires = new Date(Date.now() + (+value) * 1000);
        if (name === 'Path')
            cookie.path = value;
        if (name === 'SameSite')
            cookie.sameSite = value;
        if (name === 'Secure')
            cookie.secure = true;
    }
    return cookie;
}
//# sourceMappingURL=harTracer.js.map

/***/ }),

/***/ 3585:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeGenerator = void 0;
const events_1 = __nccwpck_require__(8614);
const utils_1 = __nccwpck_require__(649);
class CodeGenerator extends events_1.EventEmitter {
    constructor(browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage) {
        super();
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        // Make a copy of options to modify them later.
        launchOptions = { headless: false, ...launchOptions };
        contextOptions = { ...contextOptions };
        this._enabled = generateHeaders;
        this._options = { browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage };
        this.restart();
    }
    restart() {
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this.emit('change');
    }
    setEnabled(enabled) {
        this._enabled = enabled;
    }
    addAction(action) {
        if (!this._enabled)
            return;
        this.willPerformAction(action);
        this.didPerformAction(action);
    }
    willPerformAction(action) {
        if (!this._enabled)
            return;
        this._currentAction = action;
    }
    performedActionFailed(action) {
        if (!this._enabled)
            return;
        if (this._currentAction === action)
            this._currentAction = null;
    }
    didPerformAction(actionInContext) {
        if (!this._enabled)
            return;
        const { action, pageAlias } = actionInContext;
        let eraseLastAction = false;
        if (this._lastAction && this._lastAction.pageAlias === pageAlias) {
            const { action: lastAction } = this._lastAction;
            // We augment last action based on the type.
            if (this._lastAction && action.name === 'fill' && lastAction.name === 'fill') {
                if (action.selector === lastAction.selector)
                    eraseLastAction = true;
            }
            if (lastAction && action.name === 'click' && lastAction.name === 'click') {
                if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount)
                    eraseLastAction = true;
            }
            if (lastAction && action.name === 'navigate' && lastAction.name === 'navigate') {
                if (action.url === lastAction.url) {
                    // Already at a target URL.
                    this._currentAction = null;
                    return;
                }
            }
            // Check and uncheck erase click.
            if (lastAction && (action.name === 'check' || action.name === 'uncheck') && lastAction.name === 'click') {
                if (action.selector === lastAction.selector)
                    eraseLastAction = true;
            }
        }
        this._lastAction = actionInContext;
        this._currentAction = null;
        if (eraseLastAction)
            this._actions.pop();
        this._actions.push(actionInContext);
        this.emit('change');
    }
    commitLastAction() {
        if (!this._enabled)
            return;
        const action = this._lastAction;
        if (action)
            action.committed = true;
    }
    signal(pageAlias, frame, signal) {
        if (!this._enabled)
            return;
        // We'll need to pass acceptDownloads for any generated downloads code to work.
        if (signal.name === 'download')
            this._options.contextOptions.acceptDownloads = true;
        // Signal either arrives while action is being performed or shortly after.
        if (this._currentAction) {
            this._currentAction.action.signals.push(signal);
            return;
        }
        if (this._lastAction && !this._lastAction.committed) {
            const signals = this._lastAction.action.signals;
            if (signal.name === 'navigation' && signals.length && signals[signals.length - 1].name === 'download')
                return;
            if (signal.name === 'download' && signals.length && signals[signals.length - 1].name === 'navigation')
                signals.length = signals.length - 1;
            signal.isAsync = true;
            this._lastAction.action.signals.push(signal);
            this.emit('change');
            return;
        }
        if (signal.name === 'navigation') {
            this.addAction({
                pageAlias,
                ...utils_1.describeFrame(frame),
                committed: true,
                action: {
                    name: 'navigate',
                    url: frame.url(),
                    signals: [],
                },
            });
        }
    }
    generateText(languageGenerator) {
        const text = [];
        if (this._options.generateHeaders)
            text.push(languageGenerator.generateHeader(this._options));
        for (const action of this._actions)
            text.push(languageGenerator.generateAction(action));
        if (this._options.generateHeaders)
            text.push(languageGenerator.generateFooter(this._options.saveStorage));
        return text.join('\n');
    }
}
exports.CodeGenerator = CodeGenerator;
//# sourceMappingURL=codeGenerator.js.map

/***/ }),

/***/ 7522:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CSharpLanguageGenerator = void 0;
const language_1 = __nccwpck_require__(8905);
const recorderActions_1 = __nccwpck_require__(3217);
const utils_1 = __nccwpck_require__(649);
const deviceDescriptors_1 = __importDefault(__nccwpck_require__(5));
class CSharpLanguageGenerator {
    constructor() {
        this.id = 'csharp';
        this.fileName = '<csharp>';
        this.highlighter = 'csharp';
    }
    generateAction(actionInContext) {
        const { action, pageAlias } = actionInContext;
        const formatter = new CSharpFormatter(8);
        formatter.newLine();
        formatter.add('// ' + recorderActions_1.actionTitle(action));
        if (action.name === 'openPage') {
            formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
            if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/')
                formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
            return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias :
            (actionInContext.frameName ?
                `${pageAlias}.Frame(${quote(actionInContext.frameName)})` :
                `${pageAlias}.FrameByUrl(${quote(actionInContext.frameUrl)})`);
        const signals = language_1.toSignalMap(action);
        if (signals.dialog) {
            formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
        }
        const lines = [];
        const actionCall = this._generateActionCall(action, actionInContext.isMainFrame);
        if (signals.waitForNavigation) {
            lines.push(`await ${pageAlias}.RunAndWaitForNavigationAsync(async () =>`);
            lines.push(`{`);
            lines.push(`    await ${subject}.${actionCall};`);
            lines.push(`}/*, new ${actionInContext.isMainFrame ? 'Page' : 'Frame'}WaitForNavigationOptions`);
            lines.push(`{`);
            lines.push(`    UrlString = ${quote(signals.waitForNavigation.url)}`);
            lines.push(`}*/);`);
        }
        else {
            lines.push(`await ${subject}.${actionCall};`);
        }
        if (signals.download) {
            lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>\n{`);
            lines.push(`});`);
        }
        if (signals.popup) {
            lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>\n{`);
            lines.push(`});`);
        }
        for (const line of lines)
            formatter.add(line);
        if (signals.assertNavigation)
            formatter.add(`  // Assert.Equal(${quote(signals.assertNavigation.url)}, ${pageAlias}.Url);`);
        return formatter.format();
    }
    _generateActionCall(action, isPage) {
        switch (action.name) {
            case 'openPage':
                throw Error('Not reached');
            case 'closePage':
                return 'CloseAsync()';
            case 'click': {
                let method = 'Click';
                if (action.clickCount === 2)
                    method = 'DblClick';
                const modifiers = utils_1.toModifiers(action.modifiers);
                const options = {};
                if (action.button !== 'left')
                    options.button = action.button;
                if (modifiers.length)
                    options.modifiers = modifiers;
                if (action.clickCount > 2)
                    options.clickCount = action.clickCount;
                if (!Object.entries(options).length)
                    return `${method}Async(${quote(action.selector)})`;
                const optionsString = formatObject(options, '    ', (isPage ? 'Page' : 'Frame') + method + 'Options');
                return `${method}Async(${quote(action.selector)}, ${optionsString})`;
            }
            case 'check':
                return `CheckAsync(${quote(action.selector)})`;
            case 'uncheck':
                return `UncheckAsync(${quote(action.selector)})`;
            case 'fill':
                return `FillAsync(${quote(action.selector)}, ${quote(action.text)})`;
            case 'setInputFiles':
                return `SetInputFilesAsync(${quote(action.selector)}, ${formatObject(action.files)})`;
            case 'press': {
                const modifiers = utils_1.toModifiers(action.modifiers);
                const shortcut = [...modifiers, action.key].join('+');
                return `PressAsync(${quote(action.selector)}, ${quote(shortcut)})`;
            }
            case 'navigate':
                return `GotoAsync(${quote(action.url)})`;
            case 'select':
                return `SelectOptionAsync(${quote(action.selector)}, ${formatObject(action.options)})`;
        }
    }
    generateHeader(options) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      class Program
      {
          public static async Task Main()
          {
              using var playwright = await Playwright.CreateAsync();
              await using var browser = await playwright.${toPascal(options.browserName)}.LaunchAsync(${formatObject(options.launchOptions, '    ', 'BrowserTypeLaunchOptions')});
              var context = await browser.NewContextAsync(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
    }
    generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `\n        await context.StorageStateAsync(new BrowserContextStorageStateOptions\n        {\n            Path = ${quote(saveStorage)}\n        });\n` : '';
        return `${storageStateLine}    }
}\n`;
    }
}
exports.CSharpLanguageGenerator = CSharpLanguageGenerator;
function formatObject(value, indent = '    ', name = '') {
    if (typeof value === 'string') {
        if (['permissions', 'colorScheme', 'modifiers', 'button'].includes(name))
            return `${getClassName(name)}.${toPascal(value)}`;
        return quote(value);
    }
    if (Array.isArray(value))
        return `new[] { ${value.map(o => formatObject(o, indent, name)).join(', ')} }`;
    if (typeof value === 'object') {
        const keys = Object.keys(value);
        if (!keys.length)
            return name ? `new ${getClassName(name)}` : '';
        const tokens = [];
        for (const key of keys) {
            const property = getPropertyName(key);
            tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
        }
        if (name)
            return `new ${getClassName(name)}\n{\n${indent}${tokens.join(`\n${indent}`)}\n${indent}}`;
        return `{\n${indent}${tokens.join(`\n${indent}`)}\n${indent}}`;
    }
    if (name === 'latitude' || name === 'longitude')
        return String(value) + 'm';
    return String(value);
}
function getClassName(value) {
    switch (value) {
        case 'viewport': return 'ViewportSize';
        case 'proxy': return 'ProxySettings';
        case 'permissions': return 'ContextPermission';
        case 'modifiers': return 'KeyboardModifier';
        case 'button': return 'MouseButton';
        default: return toPascal(value);
    }
}
function getPropertyName(key) {
    switch (key) {
        case 'storageState': return 'StorageStatePath';
        case 'viewport': return 'ViewportSize';
        default: return toPascal(key);
    }
}
function toPascal(value) {
    return value[0].toUpperCase() + value.slice(1);
}
function formatContextOptions(options, deviceName) {
    const device = deviceName && deviceDescriptors_1.default[deviceName];
    if (!device) {
        if (!Object.entries(options).length)
            return '';
        return formatObject(options, '    ', 'BrowserNewContextOptions');
    }
    options = language_1.sanitizeDeviceOptions(device, options);
    if (!Object.entries(options).length)
        return `playwright.Devices[${quote(deviceName)}]`;
    return formatObject(options, '    ', `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
}
class CSharpFormatter {
    constructor(offset = 0) {
        this._lines = [];
        this._baseIndent = ' '.repeat(4);
        this._baseOffset = ' '.repeat(offset);
    }
    prepend(text) {
        this._lines = text.trim().split('\n').map(line => line.trim()).concat(this._lines);
    }
    add(text) {
        this._lines.push(...text.trim().split('\n').map(line => line.trim()));
    }
    newLine() {
        this._lines.push('');
    }
    format() {
        let spaces = '';
        let previousLine = '';
        return this._lines.map((line) => {
            if (line === '')
                return line;
            if (line.startsWith('}') || line.startsWith(']') || line.includes('});') || line === ');')
                spaces = spaces.substring(this._baseIndent.length);
            const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : '';
            previousLine = line;
            line = spaces + extraSpaces + line;
            if (line.endsWith('{') || line.endsWith('[') || line.endsWith('('))
                spaces += this._baseIndent;
            if (line.endsWith('));'))
                spaces = spaces.substring(this._baseIndent.length);
            return this._baseOffset + line;
        }).join('\n');
    }
}
function quote(text) {
    return `"${text.replace(/["]/g, '\\"')}"`;
}
//# sourceMappingURL=csharp.js.map

/***/ }),

/***/ 1143:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JavaLanguageGenerator = void 0;
const language_1 = __nccwpck_require__(8905);
const recorderActions_1 = __nccwpck_require__(3217);
const utils_1 = __nccwpck_require__(649);
const deviceDescriptors_1 = __importDefault(__nccwpck_require__(5));
const javascript_1 = __nccwpck_require__(6283);
class JavaLanguageGenerator {
    constructor() {
        this.id = 'java';
        this.fileName = '<java>';
        this.highlighter = 'java';
    }
    generateAction(actionInContext) {
        const { action, pageAlias } = actionInContext;
        const formatter = new javascript_1.JavaScriptFormatter(6);
        formatter.newLine();
        formatter.add('// ' + recorderActions_1.actionTitle(action));
        if (action.name === 'openPage') {
            formatter.add(`Page ${pageAlias} = context.newPage();`);
            if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/')
                formatter.add(`${pageAlias}.navigate("${action.url}");`);
            return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias :
            (actionInContext.frameName ?
                `${pageAlias}.frame(${quote(actionInContext.frameName)})` :
                `${pageAlias}.frameByUrl(${quote(actionInContext.frameUrl)})`);
        const signals = language_1.toSignalMap(action);
        if (signals.dialog) {
            formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
        }
        const actionCall = this._generateActionCall(action, actionInContext.isMainFrame);
        let code = `${subject}.${actionCall};`;
        if (signals.popup) {
            code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
        }
        if (signals.download) {
            code = `Download download = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
        }
        if (signals.waitForNavigation) {
            code = `
      // ${pageAlias}.waitForNavigation(new Page.WaitForNavigationOptions().setUrl(${quote(signals.waitForNavigation.url)}), () ->
      ${pageAlias}.waitForNavigation(() -> {
        ${code}
      });`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
            formatter.add(`// assert ${pageAlias}.url().equals(${quote(signals.assertNavigation.url)});`);
        return formatter.format();
    }
    _generateActionCall(action, isPage) {
        switch (action.name) {
            case 'openPage':
                throw Error('Not reached');
            case 'closePage':
                return 'close()';
            case 'click': {
                let method = 'click';
                if (action.clickCount === 2)
                    method = 'dblclick';
                const modifiers = utils_1.toModifiers(action.modifiers);
                const options = {};
                if (action.button !== 'left')
                    options.button = action.button;
                if (modifiers.length)
                    options.modifiers = modifiers;
                if (action.clickCount > 2)
                    options.clickCount = action.clickCount;
                const optionsText = formatClickOptions(options, isPage);
                return `${method}(${quote(action.selector)}${optionsText ? ', ' : ''}${optionsText})`;
            }
            case 'check':
                return `check(${quote(action.selector)})`;
            case 'uncheck':
                return `uncheck(${quote(action.selector)})`;
            case 'fill':
                return `fill(${quote(action.selector)}, ${quote(action.text)})`;
            case 'setInputFiles':
                return `setInputFiles(${quote(action.selector)}, ${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;
            case 'press': {
                const modifiers = utils_1.toModifiers(action.modifiers);
                const shortcut = [...modifiers, action.key].join('+');
                return `press(${quote(action.selector)}, ${quote(shortcut)})`;
            }
            case 'navigate':
                return `navigate(${quote(action.url)})`;
            case 'select':
                return `selectOption(${quote(action.selector)}, ${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
        }
    }
    generateHeader(options) {
        const formatter = new javascript_1.JavaScriptFormatter();
        formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options.browserName}().launch(${formatLaunchOptions(options.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
    }
    generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `\n      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));\n` : '';
        return `${storageStateLine}    }
  }
}`;
    }
}
exports.JavaLanguageGenerator = JavaLanguageGenerator;
function formatPath(files) {
    if (Array.isArray(files)) {
        if (files.length === 0)
            return 'new Path[0]';
        return `new Path[] {${files.map(s => 'Paths.get(' + quote(s) + ')').join(', ')}}`;
    }
    return `Paths.get(${quote(files)})`;
}
function formatSelectOption(options) {
    if (Array.isArray(options)) {
        if (options.length === 0)
            return 'new String[0]';
        return `new String[] {${options.map(s => quote(s)).join(', ')}}`;
    }
    return quote(options);
}
function formatLaunchOptions(options) {
    const lines = [];
    if (!Object.keys(options).length)
        return '';
    lines.push('new BrowserType.LaunchOptions()');
    if (typeof options.headless === 'boolean')
        lines.push(`  .setHeadless(false)`);
    if (options.channel)
        lines.push(`  .setChannel("${options.channel}")`);
    return lines.join('\n');
}
function formatContextOptions(contextOptions, deviceName) {
    const lines = [];
    if (!Object.keys(contextOptions).length && !deviceName)
        return '';
    const device = deviceName ? deviceDescriptors_1.default[deviceName] : {};
    const options = { ...device, ...contextOptions };
    lines.push('new Browser.NewContextOptions()');
    if (options.acceptDownloads)
        lines.push(`  .setAcceptDownloads(true)`);
    if (options.bypassCSP)
        lines.push(`  .setBypassCSP(true)`);
    if (options.colorScheme)
        lines.push(`  .setColorScheme(ColorScheme.${options.colorScheme.toUpperCase()})`);
    if (options.deviceScaleFactor)
        lines.push(`  .setDeviceScaleFactor(${options.deviceScaleFactor})`);
    if (options.geolocation)
        lines.push(`  .setGeolocation(${options.geolocation.latitude}, ${options.geolocation.longitude})`);
    if (options.hasTouch)
        lines.push(`  .setHasTouch(${options.hasTouch})`);
    if (options.isMobile)
        lines.push(`  .setIsMobile(${options.isMobile})`);
    if (options.locale)
        lines.push(`  .setLocale("${options.locale}")`);
    if (options.proxy)
        lines.push(`  .setProxy(new Proxy("${options.proxy.server}"))`);
    if (options.storageState)
        lines.push(`  .setStorageStatePath(Paths.get(${quote(options.storageState)}))`);
    if (options.timezoneId)
        lines.push(`  .setTimezoneId("${options.timezoneId}")`);
    if (options.userAgent)
        lines.push(`  .setUserAgent("${options.userAgent}")`);
    if (options.viewport)
        lines.push(`  .setViewportSize(${options.viewport.width}, ${options.viewport.height})`);
    return lines.join('\n');
}
function formatClickOptions(options, isPage) {
    const lines = [];
    if (options.button)
        lines.push(`  .setButton(MouseButton.${options.button.toUpperCase()})`);
    if (options.modifiers)
        lines.push(`  .setModifiers(Arrays.asList(${options.modifiers.map(m => `KeyboardModifier.${m.toUpperCase()}`).join(', ')}))`);
    if (options.clickCount)
        lines.push(`  .setClickCount(${options.clickCount})`);
    if (!lines.length)
        return '';
    lines.unshift(`new ${isPage ? 'Page' : 'Frame'}.ClickOptions()`);
    return lines.join('\n');
}
function quote(text, char = '\"') {
    if (char === '\'')
        return char + text.replace(/[']/g, '\\\'') + char;
    if (char === '"')
        return char + text.replace(/["]/g, '\\"') + char;
    if (char === '`')
        return char + text.replace(/[`]/g, '\\`') + char;
    throw new Error('Invalid escape char');
}
//# sourceMappingURL=java.js.map

/***/ }),

/***/ 6283:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JavaScriptFormatter = exports.JavaScriptLanguageGenerator = void 0;
const language_1 = __nccwpck_require__(8905);
const recorderActions_1 = __nccwpck_require__(3217);
const utils_1 = __nccwpck_require__(649);
const deviceDescriptors_1 = __importDefault(__nccwpck_require__(5));
class JavaScriptLanguageGenerator {
    constructor() {
        this.id = 'javascript';
        this.fileName = '<javascript>';
        this.highlighter = 'javascript';
    }
    generateAction(actionInContext) {
        const { action, pageAlias } = actionInContext;
        const formatter = new JavaScriptFormatter(2);
        formatter.newLine();
        formatter.add('// ' + recorderActions_1.actionTitle(action));
        if (action.name === 'openPage') {
            formatter.add(`const ${pageAlias} = await context.newPage();`);
            if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/')
                formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
            return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias :
            (actionInContext.frameName ?
                `${pageAlias}.frame(${formatObject({ name: actionInContext.frameName })})` :
                `${pageAlias}.frame(${formatObject({ url: actionInContext.frameUrl })})`);
        const signals = language_1.toSignalMap(action);
        if (signals.dialog) {
            formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: $\{dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
        }
        const emitPromiseAll = signals.waitForNavigation || signals.popup || signals.download;
        if (emitPromiseAll) {
            // Generate either await Promise.all([]) or
            // const [popup1] = await Promise.all([]).
            let leftHandSide = '';
            if (signals.popup)
                leftHandSide = `const [${signals.popup.popupAlias}] = `;
            else if (signals.download)
                leftHandSide = `const [download] = `;
            formatter.add(`${leftHandSide}await Promise.all([`);
        }
        // Popup signals.
        if (signals.popup)
            formatter.add(`${pageAlias}.waitForEvent('popup'),`);
        // Navigation signal.
        if (signals.waitForNavigation)
            formatter.add(`${pageAlias}.waitForNavigation(/*{ url: ${quote(signals.waitForNavigation.url)} }*/),`);
        // Download signals.
        if (signals.download)
            formatter.add(`${pageAlias}.waitForEvent('download'),`);
        const prefix = (signals.popup || signals.waitForNavigation || signals.download) ? '' : 'await ';
        const actionCall = this._generateActionCall(action);
        const suffix = (signals.waitForNavigation || emitPromiseAll) ? '' : ';';
        formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);
        if (emitPromiseAll)
            formatter.add(`]);`);
        else if (signals.assertNavigation)
            formatter.add(`  // assert.equal(${pageAlias}.url(), ${quote(signals.assertNavigation.url)});`);
        return formatter.format();
    }
    _generateActionCall(action) {
        switch (action.name) {
            case 'openPage':
                throw Error('Not reached');
            case 'closePage':
                return 'close()';
            case 'click': {
                let method = 'click';
                if (action.clickCount === 2)
                    method = 'dblclick';
                const modifiers = utils_1.toModifiers(action.modifiers);
                const options = {};
                if (action.button !== 'left')
                    options.button = action.button;
                if (modifiers.length)
                    options.modifiers = modifiers;
                if (action.clickCount > 2)
                    options.clickCount = action.clickCount;
                const optionsString = formatOptions(options);
                return `${method}(${quote(action.selector)}${optionsString})`;
            }
            case 'check':
                return `check(${quote(action.selector)})`;
            case 'uncheck':
                return `uncheck(${quote(action.selector)})`;
            case 'fill':
                return `fill(${quote(action.selector)}, ${quote(action.text)})`;
            case 'setInputFiles':
                return `setInputFiles(${quote(action.selector)}, ${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
            case 'press': {
                const modifiers = utils_1.toModifiers(action.modifiers);
                const shortcut = [...modifiers, action.key].join('+');
                return `press(${quote(action.selector)}, ${quote(shortcut)})`;
            }
            case 'navigate':
                return `goto(${quote(action.url)})`;
            case 'select':
                return `selectOption(${quote(action.selector)}, ${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
    }
    generateHeader(options) {
        const formatter = new JavaScriptFormatter();
        formatter.add(`
      const { ${options.browserName}${options.deviceName ? ', devices' : ''} } = require('playwright');

      (async () => {
        const browser = await ${options.browserName}.launch(${formatObjectOrVoid(options.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
    }
    generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `\n  await context.storageState({ path: '${saveStorage}' });` : '';
        return `\n  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
    }
}
exports.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;
function formatOptions(value) {
    const keys = Object.keys(value);
    if (!keys.length)
        return '';
    return ', ' + formatObject(value);
}
function formatObject(value, indent = '  ') {
    if (typeof value === 'string')
        return quote(value);
    if (Array.isArray(value))
        return `[${value.map(o => formatObject(o)).join(', ')}]`;
    if (typeof value === 'object') {
        const keys = Object.keys(value);
        if (!keys.length)
            return '{}';
        const tokens = [];
        for (const key of keys)
            tokens.push(`${key}: ${formatObject(value[key])}`);
        return `{\n${indent}${tokens.join(`,\n${indent}`)}\n}`;
    }
    return String(value);
}
function formatObjectOrVoid(value, indent = '  ') {
    const result = formatObject(value, indent);
    return result === '{}' ? '' : result;
}
function formatContextOptions(options, deviceName) {
    const device = deviceName && deviceDescriptors_1.default[deviceName];
    if (!device)
        return formatObjectOrVoid(options);
    // Filter out all the properties from the device descriptor.
    let serializedObject = formatObjectOrVoid(language_1.sanitizeDeviceOptions(device, options));
    // When there are no additional context options, we still want to spread the device inside.
    if (!serializedObject)
        serializedObject = '{\n}';
    const lines = serializedObject.split('\n');
    lines.splice(1, 0, `...devices['${deviceName}'],`);
    return lines.join('\n');
}
class JavaScriptFormatter {
    constructor(offset = 0) {
        this._lines = [];
        this._baseIndent = ' '.repeat(2);
        this._baseOffset = ' '.repeat(offset);
    }
    prepend(text) {
        this._lines = text.trim().split('\n').map(line => line.trim()).concat(this._lines);
    }
    add(text) {
        this._lines.push(...text.trim().split('\n').map(line => line.trim()));
    }
    newLine() {
        this._lines.push('');
    }
    format() {
        let spaces = '';
        let previousLine = '';
        return this._lines.map((line) => {
            if (line === '')
                return line;
            if (line.startsWith('}') || line.startsWith(']'))
                spaces = spaces.substring(this._baseIndent.length);
            const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : '';
            previousLine = line;
            const callCarryOver = line.startsWith('.set');
            line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : '') + line;
            if (line.endsWith('{') || line.endsWith('['))
                spaces += this._baseIndent;
            return this._baseOffset + line;
        }).join('\n');
    }
}
exports.JavaScriptFormatter = JavaScriptFormatter;
function quote(text, char = '\'') {
    if (char === '\'')
        return char + text.replace(/[']/g, '\\\'') + char;
    if (char === '"')
        return char + text.replace(/["]/g, '\\"') + char;
    if (char === '`')
        return char + text.replace(/[`]/g, '\\`') + char;
    throw new Error('Invalid escape char');
}
//# sourceMappingURL=javascript.js.map

/***/ }),

/***/ 8905:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toSignalMap = exports.sanitizeDeviceOptions = void 0;
function sanitizeDeviceOptions(device, options) {
    // Filter out all the properties from the device descriptor.
    const cleanedOptions = {};
    for (const property in options) {
        if (JSON.stringify(device[property]) !== JSON.stringify(options[property]))
            cleanedOptions[property] = options[property];
    }
    return cleanedOptions;
}
exports.sanitizeDeviceOptions = sanitizeDeviceOptions;
function toSignalMap(action) {
    let waitForNavigation;
    let assertNavigation;
    let popup;
    let download;
    let dialog;
    for (const signal of action.signals) {
        if (signal.name === 'navigation' && signal.isAsync)
            waitForNavigation = signal;
        else if (signal.name === 'navigation' && !signal.isAsync)
            assertNavigation = signal;
        else if (signal.name === 'popup')
            popup = signal;
        else if (signal.name === 'download')
            download = signal;
        else if (signal.name === 'dialog')
            dialog = signal;
    }
    return {
        waitForNavigation,
        assertNavigation,
        popup,
        download,
        dialog,
    };
}
exports.toSignalMap = toSignalMap;
//# sourceMappingURL=language.js.map

/***/ }),

/***/ 5056:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PythonLanguageGenerator = void 0;
const language_1 = __nccwpck_require__(8905);
const recorderActions_1 = __nccwpck_require__(3217);
const utils_1 = __nccwpck_require__(649);
const deviceDescriptors_1 = __importDefault(__nccwpck_require__(5));
class PythonLanguageGenerator {
    constructor(isAsync) {
        this.id = 'python';
        this.fileName = '<python>';
        this.highlighter = 'python';
        this.id = isAsync ? 'python-async' : 'python';
        this.fileName = isAsync ? '<async python>' : '<python>';
        this._isAsync = isAsync;
        this._awaitPrefix = isAsync ? 'await ' : '';
        this._asyncPrefix = isAsync ? 'async ' : '';
    }
    generateAction(actionInContext) {
        const { action, pageAlias } = actionInContext;
        const formatter = new PythonFormatter(4);
        formatter.newLine();
        formatter.add('# ' + recorderActions_1.actionTitle(action));
        if (action.name === 'openPage') {
            formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
            if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/')
                formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
            return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias :
            (actionInContext.frameName ?
                `${pageAlias}.frame(${formatOptions({ name: actionInContext.frameName }, false)})` :
                `${pageAlias}.frame(${formatOptions({ url: actionInContext.frameUrl }, false)})`);
        const signals = language_1.toSignalMap(action);
        if (signals.dialog)
            formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
        const actionCall = this._generateActionCall(action);
        let code = `${this._awaitPrefix}${subject}.${actionCall}`;
        if (signals.popup) {
            code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as popup_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}popup_info.value`;
        }
        if (signals.download) {
            code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download_info {
        ${code}
      }
      download = ${this._awaitPrefix}download_info.value`;
        }
        if (signals.waitForNavigation) {
            code = `
      # ${this._asyncPrefix}with ${pageAlias}.expect_navigation(url=${quote(signals.waitForNavigation.url)}):
      ${this._asyncPrefix}with ${pageAlias}.expect_navigation() {
        ${code}
      }`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
            formatter.add(`  # assert ${pageAlias}.url == ${quote(signals.assertNavigation.url)}`);
        return formatter.format();
    }
    _generateActionCall(action) {
        switch (action.name) {
            case 'openPage':
                throw Error('Not reached');
            case 'closePage':
                return 'close()';
            case 'click': {
                let method = 'click';
                if (action.clickCount === 2)
                    method = 'dblclick';
                const modifiers = utils_1.toModifiers(action.modifiers);
                const options = {};
                if (action.button !== 'left')
                    options.button = action.button;
                if (modifiers.length)
                    options.modifiers = modifiers;
                if (action.clickCount > 2)
                    options.clickCount = action.clickCount;
                const optionsString = formatOptions(options, true);
                return `${method}(${quote(action.selector)}${optionsString})`;
            }
            case 'check':
                return `check(${quote(action.selector)})`;
            case 'uncheck':
                return `uncheck(${quote(action.selector)})`;
            case 'fill':
                return `fill(${quote(action.selector)}, ${quote(action.text)})`;
            case 'setInputFiles':
                return `set_input_files(${quote(action.selector)}, ${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
            case 'press': {
                const modifiers = utils_1.toModifiers(action.modifiers);
                const shortcut = [...modifiers, action.key].join('+');
                return `press(${quote(action.selector)}, ${quote(shortcut)})`;
            }
            case 'navigate':
                return `goto(${quote(action.url)})`;
            case 'select':
                return `select_option(${quote(action.selector)}, ${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
        }
    }
    generateHeader(options) {
        const formatter = new PythonFormatter();
        if (this._isAsync) {
            formatter.add(`
import asyncio
from playwright.async_api import async_playwright

async def run(playwright) {
    browser = await playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        }
        else {
            formatter.add(`
from playwright.sync_api import sync_playwright

def run(playwright) {
    browser = playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        }
        return formatter.format();
    }
    generateFooter(saveStorage) {
        if (this._isAsync) {
            const storageStateLine = saveStorage ? `\n    await context.storage_state(path="${saveStorage}")` : '';
            return `\n    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())`;
        }
        else {
            const storageStateLine = saveStorage ? `\n    context.storage_state(path="${saveStorage}")` : '';
            return `\n    # ---------------------${storageStateLine}
    context.close()
    browser.close()

with sync_playwright() as playwright:
    run(playwright)`;
        }
    }
}
exports.PythonLanguageGenerator = PythonLanguageGenerator;
function formatValue(value) {
    if (value === false)
        return 'False';
    if (value === true)
        return 'True';
    if (value === undefined)
        return 'None';
    if (Array.isArray(value))
        return `[${value.map(formatValue).join(', ')}]`;
    if (typeof value === 'string')
        return quote(value);
    return String(value);
}
function toSnakeCase(name) {
    const toSnakeCaseRegex = /((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))/g;
    return name.replace(toSnakeCaseRegex, `_$1`).toLowerCase();
}
function formatOptions(value, hasArguments) {
    const keys = Object.keys(value);
    if (!keys.length)
        return '';
    return (hasArguments ? ', ' : '') + keys.map(key => `${toSnakeCase(key)}=${formatValue(value[key])}`).join(', ');
}
function formatContextOptions(options, deviceName) {
    const device = deviceName && deviceDescriptors_1.default[deviceName];
    if (!device)
        return formatOptions(options, false);
    return `**playwright.devices["${deviceName}"]` + formatOptions(language_1.sanitizeDeviceOptions(device, options), true);
}
class PythonFormatter {
    constructor(offset = 0) {
        this._lines = [];
        this._baseIndent = ' '.repeat(4);
        this._baseOffset = ' '.repeat(offset);
    }
    prepend(text) {
        this._lines = text.trim().split('\n').map(line => line.trim()).concat(this._lines);
    }
    add(text) {
        this._lines.push(...text.trim().split('\n').map(line => line.trim()));
    }
    newLine() {
        this._lines.push('');
    }
    format() {
        let spaces = '';
        const lines = [];
        this._lines.forEach((line) => {
            if (line === '')
                return lines.push(line);
            if (line === '}') {
                spaces = spaces.substring(this._baseIndent.length);
                return;
            }
            line = spaces + line;
            if (line.endsWith('{')) {
                spaces += this._baseIndent;
                line = line.substring(0, line.length - 1).trimEnd() + ':';
            }
            return lines.push(this._baseOffset + line);
        });
        return lines.join('\n');
    }
}
function quote(text, char = '\"') {
    if (char === '\'')
        return char + text.replace(/[']/g, '\\\'') + char;
    if (char === '"')
        return char + text.replace(/["]/g, '\\"') + char;
    if (char === '`')
        return char + text.replace(/[`]/g, '\\`') + char;
    throw new Error('Invalid escape char');
}
//# sourceMappingURL=python.js.map

/***/ }),

/***/ 3217:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.actionTitle = void 0;
function actionTitle(action) {
    switch (action.name) {
        case 'openPage':
            return `Open new page`;
        case 'closePage':
            return `Close page`;
        case 'check':
            return `Check ${action.selector}`;
        case 'uncheck':
            return `Uncheck ${action.selector}`;
        case 'click': {
            if (action.clickCount === 1)
                return `Click ${action.selector}`;
            if (action.clickCount === 2)
                return `Double click ${action.selector}`;
            if (action.clickCount === 3)
                return `Triple click ${action.selector}`;
            return `${action.clickCount}× click`;
        }
        case 'fill':
            return `Fill ${action.selector}`;
        case 'setInputFiles':
            if (action.files.length === 0)
                return `Clear selected files`;
            else
                return `Upload ${action.files.join(', ')}`;
        case 'navigate':
            return `Go to ${action.url}`;
        case 'press':
            return `Press ${action.key}` + (action.modifiers ? ' with modifiers' : '');
        case 'select':
            return `Select ${action.options.join(', ')}`;
    }
}
exports.actionTitle = actionTitle;
//# sourceMappingURL=recorderActions.js.map

/***/ }),

/***/ 686:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecorderApp = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
const progress_1 = __nccwpck_require__(6707);
const events_1 = __nccwpck_require__(8614);
const instrumentation_1 = __nccwpck_require__(7490);
const utils_1 = __nccwpck_require__(6416);
class RecorderApp extends events_1.EventEmitter {
    constructor(page, wsEndpoint) {
        super();
        this.setMaxListeners(0);
        this._page = page;
        this.wsEndpoint = wsEndpoint;
    }
    async close() {
        await this._page.context().close(instrumentation_1.internalCallMetadata());
    }
    async _init() {
        const icon = await fs_1.default.promises.readFile(__nccwpck_require__.ab + "app_icon.png");
        const crPopup = this._page._delegate;
        await crPopup._mainFrameSession._client.send('Browser.setDockTile', {
            image: icon.toString('base64')
        });
        await this._page._setServerRequestInterceptor(async (route) => {
            if (route.request().url().startsWith('https://playwright/')) {
                const uri = route.request().url().substring('https://playwright/'.length);
                const file = require.resolve('../../../web/recorder/' + uri);
                const buffer = await fs_1.default.promises.readFile(file);
                await route.fulfill({
                    status: 200,
                    headers: [
                        { name: 'Content-Type', value: extensionToMime[path_1.default.extname(file)] }
                    ],
                    body: buffer.toString('base64'),
                    isBase64: true
                });
                return;
            }
            await route.continue();
        });
        await this._page.exposeBinding('dispatch', false, (_, data) => this.emit('event', data));
        this._page.once('close', () => {
            this.emit('close');
            this._page.context().close(instrumentation_1.internalCallMetadata()).catch(e => console.error(e));
        });
        const mainFrame = this._page.mainFrame();
        await mainFrame.goto(instrumentation_1.internalCallMetadata(), 'https://playwright/index.html');
    }
    static async open(inspectedContext) {
        const recorderPlaywright = __nccwpck_require__(8508).createPlaywright(true);
        const args = [
            '--app=data:text/html,',
            '--window-size=600,600',
            '--window-position=1280,10',
        ];
        if (process.env.PWTEST_RECORDER_PORT)
            args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
        let channel;
        let executablePath;
        if (inspectedContext._browser.options.isChromium) {
            channel = inspectedContext._browser.options.channel;
            const defaultExecutablePath = recorderPlaywright.chromium.executablePath(channel);
            if (!(await utils_1.existsAsync(defaultExecutablePath)))
                executablePath = inspectedContext._browser.options.customExecutablePath;
        }
        const context = await recorderPlaywright.chromium.launchPersistentContext(instrumentation_1.internalCallMetadata(), '', {
            channel,
            executablePath,
            sdkLanguage: inspectedContext._options.sdkLanguage,
            args,
            noDefaultViewport: true,
            headless: !!process.env.PWTEST_CLI_HEADLESS || (utils_1.isUnderTest() && !inspectedContext._browser.options.headful),
            useWebSocket: !!process.env.PWTEST_RECORDER_PORT
        });
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), context._browser);
        await controller.run(async (progress) => {
            await context._browser._defaultContext._loadDefaultContextAsIs(progress);
        });
        const [page] = context.pages();
        const result = new RecorderApp(page, context._browser.options.wsEndpoint);
        await result._init();
        return result;
    }
    async setMode(mode) {
        await this._page.mainFrame().evaluateExpression(((mode) => {
            window.playwrightSetMode(mode);
        }).toString(), true, mode, 'main').catch(() => { });
    }
    async setFile(file) {
        await this._page.mainFrame().evaluateExpression(((file) => {
            window.playwrightSetFile(file);
        }).toString(), true, file, 'main').catch(() => { });
    }
    async setPaused(paused) {
        await this._page.mainFrame().evaluateExpression(((paused) => {
            window.playwrightSetPaused(paused);
        }).toString(), true, paused, 'main').catch(() => { });
    }
    async setSources(sources) {
        await this._page.mainFrame().evaluateExpression(((sources) => {
            window.playwrightSetSources(sources);
        }).toString(), true, sources, 'main').catch(() => { });
        // Testing harness for runCLI mode.
        {
            if (process.env.PWTEST_CLI_EXIT && sources.length) {
                process.stdout.write('\n-------------8<-------------\n');
                process.stdout.write(sources[0].text);
                process.stdout.write('\n-------------8<-------------\n');
            }
        }
    }
    async setSelector(selector, focus) {
        await this._page.mainFrame().evaluateExpression(((arg) => {
            window.playwrightSetSelector(arg.selector, arg.focus);
        }).toString(), true, { selector, focus }, 'main').catch(() => { });
    }
    async updateCallLogs(callLogs) {
        await this._page.mainFrame().evaluateExpression(((callLogs) => {
            window.playwrightUpdateLogs(callLogs);
        }).toString(), true, callLogs, 'main').catch(() => { });
    }
    async bringToFront() {
        await this._page.bringToFront();
    }
}
exports.RecorderApp = RecorderApp;
const extensionToMime = {
    '.css': 'text/css',
    '.html': 'text/html',
    '.jpeg': 'image/jpeg',
    '.js': 'application/javascript',
    '.png': 'image/png',
    '.ttf': 'font/ttf',
    '.svg': 'image/svg+xml',
    '.webp': 'image/webp',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
};
//# sourceMappingURL=recorderApp.js.map

/***/ }),

/***/ 4142:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.metadataToCallLog = void 0;
function metadataToCallLog(metadata, status) {
    var _a, _b;
    const title = metadata.apiName || metadata.method;
    if (metadata.error)
        status = 'error';
    const params = {
        url: (_a = metadata.params) === null || _a === void 0 ? void 0 : _a.url,
        selector: (_b = metadata.params) === null || _b === void 0 ? void 0 : _b.selector,
    };
    let duration = metadata.endTime ? metadata.endTime - metadata.startTime : undefined;
    if (typeof duration === 'number' && metadata.pauseStartTime && metadata.pauseEndTime) {
        duration -= (metadata.pauseEndTime - metadata.pauseStartTime);
        duration = Math.max(duration, 0);
    }
    const callLog = {
        id: metadata.id,
        messages: metadata.log,
        title,
        status,
        error: metadata.error,
        params,
        duration,
    };
    return callLog;
}
exports.metadataToCallLog = metadataToCallLog;
//# sourceMappingURL=recorderUtils.js.map

/***/ }),

/***/ 649:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.describeFrame = exports.toModifiers = exports.toClickOptions = void 0;
function toClickOptions(action) {
    let method = 'click';
    if (action.clickCount === 2)
        method = 'dblclick';
    const modifiers = toModifiers(action.modifiers);
    const options = {};
    if (action.button !== 'left')
        options.button = action.button;
    if (modifiers.length)
        options.modifiers = modifiers;
    if (action.clickCount > 2)
        options.clickCount = action.clickCount;
    return { method, options };
}
exports.toClickOptions = toClickOptions;
function toModifiers(modifiers) {
    const result = [];
    if (modifiers & 1)
        result.push('Alt');
    if (modifiers & 2)
        result.push('Control');
    if (modifiers & 4)
        result.push('Meta');
    if (modifiers & 8)
        result.push('Shift');
    return result;
}
exports.toModifiers = toModifiers;
function describeFrame(frame) {
    const page = frame._page;
    if (page.mainFrame() === frame)
        return { isMainFrame: true, frameUrl: frame.url() };
    const frames = page.frames().filter(f => f.name() === frame.name());
    if (frames.length === 1 && frames[0] === frame)
        return { isMainFrame: false, frameUrl: frame.url(), frameName: frame.name() };
    return { isMainFrame: false, frameUrl: frame.url() };
}
exports.describeFrame = describeFrame;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 1865:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecorderSupplement = void 0;
const fs = __importStar(__nccwpck_require__(5747));
const codeGenerator_1 = __nccwpck_require__(3585);
const utils_1 = __nccwpck_require__(649);
const page_1 = __nccwpck_require__(9406);
const frames_1 = __nccwpck_require__(3735);
const browserContext_1 = __nccwpck_require__(7533);
const java_1 = __nccwpck_require__(1143);
const javascript_1 = __nccwpck_require__(6283);
const csharp_1 = __nccwpck_require__(7522);
const python_1 = __nccwpck_require__(5056);
const recorderSource = __importStar(__nccwpck_require__(2476));
const consoleApiSource = __importStar(__nccwpck_require__(5698));
const recorderApp_1 = __nccwpck_require__(686);
const instrumentation_1 = __nccwpck_require__(7490);
const utils_2 = __nccwpck_require__(6416);
const recorderUtils_1 = __nccwpck_require__(4142);
const debugger_1 = __nccwpck_require__(2407);
const symbol = Symbol('RecorderSupplement');
class RecorderSupplement {
    constructor(context, params) {
        this._pageAliases = new Map();
        this._lastPopupOrdinal = 0;
        this._lastDialogOrdinal = 0;
        this._lastDownloadOrdinal = 0;
        this._timers = new Set();
        this._highlightedSelector = '';
        this._recorderApp = null;
        this._currentCallsMetadata = new Map();
        this._userSources = new Map();
        this._allMetadatas = new Map();
        this._context = context;
        this._debugger = debugger_1.Debugger.lookup(context);
        context.instrumentation.addListener(this);
        this._params = params;
        this._mode = params.startRecording ? 'recording' : 'none';
        const language = params.language || context._options.sdkLanguage;
        const languages = new Set([
            new java_1.JavaLanguageGenerator(),
            new javascript_1.JavaScriptLanguageGenerator(),
            new python_1.PythonLanguageGenerator(false),
            new python_1.PythonLanguageGenerator(true),
            new csharp_1.CSharpLanguageGenerator(),
        ]);
        const primaryLanguage = [...languages].find(l => l.id === language);
        if (!primaryLanguage)
            throw new Error(`\n===============================\nUnsupported language: '${language}'\n===============================\n`);
        languages.delete(primaryLanguage);
        const orderedLanguages = [primaryLanguage, ...languages];
        this._recorderSources = [];
        const generator = new codeGenerator_1.CodeGenerator(context._browser.options.name, !!params.startRecording, params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
        let text = '';
        generator.on('change', () => {
            var _a;
            this._recorderSources = [];
            for (const languageGenerator of orderedLanguages) {
                const source = {
                    file: languageGenerator.fileName,
                    text: generator.generateText(languageGenerator),
                    language: languageGenerator.highlighter,
                    highlight: []
                };
                source.revealLine = source.text.split('\n').length - 1;
                this._recorderSources.push(source);
                if (languageGenerator === orderedLanguages[0])
                    text = source.text;
            }
            this._pushAllSources();
            (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setFile(primaryLanguage.fileName);
        });
        if (params.outputFile) {
            context.on(browserContext_1.BrowserContext.Events.BeforeClose, () => {
                fs.writeFileSync(params.outputFile, text);
                text = '';
            });
            process.on('exit', () => {
                if (text)
                    fs.writeFileSync(params.outputFile, text);
            });
        }
        this._generator = generator;
    }
    static showInspector(context) {
        RecorderSupplement.show(context, {}).catch(() => { });
    }
    static show(context, params = {}) {
        let recorderPromise = context[symbol];
        if (!recorderPromise) {
            const recorder = new RecorderSupplement(context, params);
            recorderPromise = recorder.install().then(() => recorder);
            context[symbol] = recorderPromise;
        }
        return recorderPromise;
    }
    async install() {
        const recorderApp = await recorderApp_1.RecorderApp.open(this._context);
        this._recorderApp = recorderApp;
        recorderApp.once('close', () => {
            this._debugger.resume(false);
            this._recorderApp = null;
        });
        recorderApp.on('event', (data) => {
            if (data.event === 'setMode') {
                this._setMode(data.params.mode);
                this._refreshOverlay();
                return;
            }
            if (data.event === 'selectorUpdated') {
                this._highlightedSelector = data.params.selector;
                this._refreshOverlay();
                return;
            }
            if (data.event === 'step') {
                this._debugger.resume(true);
                return;
            }
            if (data.event === 'resume') {
                this._debugger.resume(false);
                return;
            }
            if (data.event === 'pause') {
                this._debugger.pauseOnNextStatement();
                return;
            }
            if (data.event === 'clear') {
                this._clearScript();
                return;
            }
        });
        await Promise.all([
            recorderApp.setMode(this._mode),
            recorderApp.setPaused(this._debugger.isPaused()),
            this._pushAllSources()
        ]);
        this._context.on(browserContext_1.BrowserContext.Events.Page, page => this._onPage(page));
        for (const page of this._context.pages())
            this._onPage(page);
        this._context.once(browserContext_1.BrowserContext.Events.Close, () => {
            for (const timer of this._timers)
                clearTimeout(timer);
            this._timers.clear();
            recorderApp.close().catch(() => { });
        });
        // Input actions that potentially lead to navigation are intercepted on the page and are
        // performed by the Playwright.
        await this._context.exposeBinding('_playwrightRecorderPerformAction', false, (source, action) => this._performAction(source.frame, action), 'utility');
        // Other non-essential actions are simply being recorded.
        await this._context.exposeBinding('_playwrightRecorderRecordAction', false, (source, action) => this._recordAction(source.frame, action), 'utility');
        await this._context.exposeBinding('_playwrightRecorderState', false, source => {
            let actionSelector = this._highlightedSelector;
            let actionPoint;
            for (const [metadata, sdkObject] of this._currentCallsMetadata) {
                if (source.page === sdkObject.attribution.page) {
                    actionPoint = metadata.point || actionPoint;
                    actionSelector = actionSelector || metadata.params.selector;
                }
            }
            const uiState = {
                mode: this._mode,
                actionPoint,
                actionSelector,
            };
            return uiState;
        }, 'utility');
        await this._context.exposeBinding('_playwrightRecorderSetSelector', false, async (_, selector) => {
            var _a, _b;
            this._setMode('none');
            await ((_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setSelector(selector, true));
            await ((_b = this._recorderApp) === null || _b === void 0 ? void 0 : _b.bringToFront());
        }, 'utility');
        await this._context.exposeBinding('_playwrightResume', false, () => {
            this._debugger.resume(false);
        }, 'main');
        await this._context.extendInjectedScript('utility', recorderSource.source, { isUnderTest: utils_2.isUnderTest() });
        await this._context.extendInjectedScript('main', consoleApiSource.source);
        if (this._debugger.isPaused())
            this._pausedStateChanged();
        this._debugger.on(debugger_1.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
        this._context.recorderAppForTest = recorderApp;
    }
    _pausedStateChanged() {
        var _a;
        // If we are called upon page.pause, we don't have metadatas, populate them.
        for (const { metadata, sdkObject } of this._debugger.pausedDetails()) {
            if (!this._currentCallsMetadata.has(metadata))
                this.onBeforeCall(sdkObject, metadata);
        }
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setPaused(this._debugger.isPaused());
        this._updateUserSources();
        this.updateCallLog([...this._currentCallsMetadata.keys()]);
    }
    _setMode(mode) {
        var _a;
        this._mode = mode;
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setMode(this._mode);
        this._generator.setEnabled(this._mode === 'recording');
        debugger_1.Debugger.lookup(this._context).setMuted(this._mode === 'recording');
        if (this._mode !== 'none')
            this._context.pages()[0].bringToFront().catch(() => { });
    }
    _refreshOverlay() {
        for (const page of this._context.pages())
            page.mainFrame().evaluateExpression('window._playwrightRefreshOverlay()', false, undefined, 'main').catch(() => { });
    }
    async _onPage(page) {
        // First page is called page, others are called popup1, popup2, etc.
        const frame = page.mainFrame();
        page.on('close', () => {
            this._pageAliases.delete(page);
            this._generator.addAction({
                pageAlias,
                ...utils_1.describeFrame(page.mainFrame()),
                committed: true,
                action: {
                    name: 'closePage',
                    signals: [],
                }
            });
        });
        frame.on(frames_1.Frame.Events.Navigation, () => this._onFrameNavigated(frame, page));
        page.on(page_1.Page.Events.Download, () => this._onDownload(page));
        page.on(page_1.Page.Events.Dialog, () => this._onDialog(page));
        const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : '';
        const pageAlias = 'page' + suffix;
        this._pageAliases.set(page, pageAlias);
        if (page.opener()) {
            this._onPopup(page.opener(), page);
        }
        else {
            this._generator.addAction({
                pageAlias,
                ...utils_1.describeFrame(page.mainFrame()),
                committed: true,
                action: {
                    name: 'openPage',
                    url: page.mainFrame().url(),
                    signals: [],
                }
            });
        }
    }
    _clearScript() {
        this._generator.restart();
        if (!!this._params.startRecording) {
            for (const page of this._context.pages())
                this._onFrameNavigated(page.mainFrame(), page);
        }
    }
    async _performAction(frame, action) {
        // Commit last action so that no further signals are added to it.
        this._generator.commitLastAction();
        const page = frame._page;
        const actionInContext = {
            pageAlias: this._pageAliases.get(page),
            ...utils_1.describeFrame(frame),
            action
        };
        this._generator.willPerformAction(actionInContext);
        const noCallMetadata = instrumentation_1.internalCallMetadata();
        try {
            const kActionTimeout = 5000;
            if (action.name === 'click') {
                const { options } = utils_1.toClickOptions(action);
                await frame.click(noCallMetadata, action.selector, { ...options, timeout: kActionTimeout });
            }
            if (action.name === 'press') {
                const modifiers = utils_1.toModifiers(action.modifiers);
                const shortcut = [...modifiers, action.key].join('+');
                await frame.press(noCallMetadata, action.selector, shortcut, { timeout: kActionTimeout });
            }
            if (action.name === 'check')
                await frame.check(noCallMetadata, action.selector, { timeout: kActionTimeout });
            if (action.name === 'uncheck')
                await frame.uncheck(noCallMetadata, action.selector, { timeout: kActionTimeout });
            if (action.name === 'select')
                await frame.selectOption(noCallMetadata, action.selector, [], action.options.map(value => ({ value })), { timeout: kActionTimeout });
        }
        catch (e) {
            this._generator.performedActionFailed(actionInContext);
            return;
        }
        const timer = setTimeout(() => {
            // Commit the action after 5 seconds so that no further signals are added to it.
            actionInContext.committed = true;
            this._timers.delete(timer);
        }, 5000);
        this._generator.didPerformAction(actionInContext);
        this._timers.add(timer);
    }
    async _recordAction(frame, action) {
        // Commit last action so that no further signals are added to it.
        this._generator.commitLastAction();
        this._generator.addAction({
            pageAlias: this._pageAliases.get(frame._page),
            ...utils_1.describeFrame(frame),
            action
        });
    }
    _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, { name: 'navigation', url: frame.url() });
    }
    _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), { name: 'popup', popupAlias });
    }
    _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), { name: 'download', downloadAlias: String(++this._lastDownloadOrdinal) });
    }
    _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), { name: 'dialog', dialogAlias: String(++this._lastDialogOrdinal) });
    }
    async onBeforeCall(sdkObject, metadata) {
        var _a;
        if (this._mode === 'recording')
            return;
        this._currentCallsMetadata.set(metadata, sdkObject);
        this._allMetadatas.set(metadata.id, metadata);
        this._updateUserSources();
        this.updateCallLog([metadata]);
        if (metadata.params && metadata.params.selector) {
            this._highlightedSelector = metadata.params.selector;
            (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setSelector(this._highlightedSelector).catch(() => { });
        }
    }
    async onAfterCall(sdkObject, metadata) {
        if (this._mode === 'recording')
            return;
        if (!metadata.error)
            this._currentCallsMetadata.delete(metadata);
        this._updateUserSources();
        this.updateCallLog([metadata]);
    }
    _updateUserSources() {
        var _a;
        // Remove old decorations.
        for (const source of this._userSources.values()) {
            source.highlight = [];
            source.revealLine = undefined;
        }
        // Apply new decorations.
        let fileToSelect = undefined;
        for (const metadata of this._currentCallsMetadata.keys()) {
            if (!metadata.stack || !metadata.stack[0])
                continue;
            const { file, line } = metadata.stack[0];
            let source = this._userSources.get(file);
            if (!source) {
                source = { file, text: this._readSource(file), highlight: [], language: languageForFile(file) };
                this._userSources.set(file, source);
            }
            if (line) {
                const paused = this._debugger.isPaused(metadata);
                source.highlight.push({ line, type: metadata.error ? 'error' : (paused ? 'paused' : 'running') });
                source.revealLine = line;
                fileToSelect = source.file;
            }
        }
        this._pushAllSources();
        if (fileToSelect)
            (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setFile(fileToSelect);
    }
    _pushAllSources() {
        var _a;
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setSources([...this._recorderSources, ...this._userSources.values()]);
    }
    async onBeforeInputAction(sdkObject, metadata) {
    }
    async onCallLog(logName, message, sdkObject, metadata) {
        this.updateCallLog([metadata]);
    }
    updateCallLog(metadatas) {
        var _a;
        if (this._mode === 'recording')
            return;
        const logs = [];
        for (const metadata of metadatas) {
            if (!metadata.method)
                continue;
            let status = 'done';
            if (this._currentCallsMetadata.has(metadata))
                status = 'in-progress';
            if (this._debugger.isPaused(metadata))
                status = 'paused';
            logs.push(recorderUtils_1.metadataToCallLog(metadata, status));
        }
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.updateCallLogs(logs);
    }
    _readSource(fileName) {
        try {
            return fs.readFileSync(fileName, 'utf-8');
        }
        catch (e) {
            return '// No source available';
        }
    }
}
exports.RecorderSupplement = RecorderSupplement;
function languageForFile(file) {
    if (file.endsWith('.py'))
        return 'python';
    if (file.endsWith('.java'))
        return 'java';
    if (file.endsWith('.cs'))
        return 'csharp';
    return 'javascript';
}
//# sourceMappingURL=recorderSupplement.js.map

/***/ }),

/***/ 8381:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceSnapshotter = void 0;
const events_1 = __nccwpck_require__(8614);
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
const snapshotter_1 = __nccwpck_require__(1442);
class TraceSnapshotter extends events_1.EventEmitter {
    constructor(context, resourcesDir, appendTraceEvent) {
        super();
        this._writeArtifactChain = Promise.resolve();
        this._resourcesDir = resourcesDir;
        this._snapshotter = new snapshotter_1.Snapshotter(context, this);
        this._appendTraceEvent = appendTraceEvent;
        this._writeArtifactChain = Promise.resolve();
    }
    started() {
        return this._snapshotter.started();
    }
    async start() {
        await this._snapshotter.start();
    }
    async stop() {
        await this._snapshotter.stop();
        await this._writeArtifactChain;
    }
    async dispose() {
        this._snapshotter.dispose();
        await this._writeArtifactChain;
    }
    async captureSnapshot(page, snapshotName, element) {
        await this._snapshotter.captureSnapshot(page, snapshotName, element).catch(() => { });
    }
    onBlob(blob) {
        this._writeArtifactChain = this._writeArtifactChain.then(async () => {
            await fs_1.default.promises.writeFile(path_1.default.join(this._resourcesDir, blob.sha1), blob.buffer).catch(() => { });
        });
    }
    onResourceSnapshot(snapshot) {
        this._appendTraceEvent({ type: 'resource-snapshot', snapshot });
    }
    onFrameSnapshot(snapshot) {
        this._appendTraceEvent({ type: 'frame-snapshot', snapshot });
    }
}
exports.TraceSnapshotter = TraceSnapshotter;
//# sourceMappingURL=traceSnapshotter.js.map

/***/ }),

/***/ 8852:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tracing = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
const yazl_1 = __importDefault(__nccwpck_require__(3959));
const utils_1 = __nccwpck_require__(6416);
const artifact_1 = __nccwpck_require__(3293);
const browserContext_1 = __nccwpck_require__(7533);
const helper_1 = __nccwpck_require__(7951);
const page_1 = __nccwpck_require__(9406);
const traceSnapshotter_1 = __nccwpck_require__(8381);
class Tracing {
    constructor(context) {
        this._appendEventChain = Promise.resolve();
        this._eventListeners = [];
        this._pendingCalls = new Map();
        this._sha1s = [];
        this._started = false;
        this._context = context;
        this._tracesDir = context._browser.options.tracesDir;
        this._resourcesDir = path_1.default.join(this._tracesDir, 'resources');
        this._snapshotter = new traceSnapshotter_1.TraceSnapshotter(this._context, this._resourcesDir, traceEvent => this._appendTraceEvent(traceEvent));
    }
    async start(options) {
        // context + page must be the first events added, this method can't have awaits before them.
        if (this._started)
            throw new Error('Tracing has already been started');
        this._started = true;
        this._traceFile = path_1.default.join(this._tracesDir, (options.name || utils_1.createGuid()) + '.trace');
        this._appendEventChain = utils_1.mkdirIfNeeded(this._traceFile);
        const event = {
            type: 'context-options',
            browserName: this._context._browser.options.name,
            options: this._context._options
        };
        this._appendTraceEvent(event);
        for (const page of this._context.pages())
            this._onPage(options.screenshots, page);
        this._eventListeners.push(helper_1.helper.addEventListener(this._context, browserContext_1.BrowserContext.Events.Page, this._onPage.bind(this, options.screenshots)));
        // context + page must be the first events added, no awaits above this line.
        await fs_1.default.promises.mkdir(this._resourcesDir, { recursive: true });
        this._context.instrumentation.addListener(this);
        if (options.snapshots)
            await this._snapshotter.start();
    }
    async stop() {
        if (!this._started)
            return;
        this._started = false;
        this._context.instrumentation.removeListener(this);
        helper_1.helper.removeEventListeners(this._eventListeners);
        for (const { sdkObject, metadata } of this._pendingCalls.values())
            await this.onAfterCall(sdkObject, metadata);
        for (const page of this._context.pages())
            page.setScreencastOptions(null);
        await this._snapshotter.stop();
        // Ensure all writes are finished.
        await this._appendEventChain;
    }
    async dispose() {
        await this._snapshotter.dispose();
    }
    async export() {
        if (!this._traceFile || this._started)
            throw new Error('Must start and stop tracing before exporting');
        const zipFile = new yazl_1.default.ZipFile();
        const failedPromise = new Promise((_, reject) => zipFile.on('error', reject));
        const succeededPromise = new Promise(async (fulfill) => {
            zipFile.addFile(this._traceFile, 'trace.trace');
            const zipFileName = this._traceFile + '.zip';
            for (const sha1 of this._sha1s)
                zipFile.addFile(path_1.default.join(this._resourcesDir, sha1), path_1.default.join('resources', sha1));
            zipFile.end();
            await new Promise(f => {
                zipFile.outputStream.pipe(fs_1.default.createWriteStream(zipFileName)).on('close', f);
            });
            const artifact = new artifact_1.Artifact(this._context, zipFileName);
            artifact.reportFinished();
            fulfill(artifact);
        });
        return Promise.race([failedPromise, succeededPromise]);
    }
    async _captureSnapshot(name, sdkObject, metadata, element) {
        if (!sdkObject.attribution.page)
            return;
        if (!this._snapshotter.started())
            return;
        const snapshotName = `${name}@${metadata.id}`;
        metadata.snapshots.push({ title: name, snapshotName });
        await this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element);
    }
    async onBeforeCall(sdkObject, metadata) {
        await this._captureSnapshot('before', sdkObject, metadata);
        this._pendingCalls.set(metadata.id, { sdkObject, metadata });
    }
    async onBeforeInputAction(sdkObject, metadata, element) {
        await this._captureSnapshot('action', sdkObject, metadata, element);
    }
    async onAfterCall(sdkObject, metadata) {
        if (!this._pendingCalls.has(metadata.id))
            return;
        this._pendingCalls.delete(metadata.id);
        if (!sdkObject.attribution.page)
            return;
        await this._captureSnapshot('after', sdkObject, metadata);
        const event = { type: 'action', metadata };
        this._appendTraceEvent(event);
    }
    onEvent(sdkObject, metadata) {
        if (!sdkObject.attribution.page)
            return;
        const event = { type: 'event', metadata };
        this._appendTraceEvent(event);
    }
    _onPage(screenshots, page) {
        if (screenshots)
            page.setScreencastOptions({ width: 800, height: 600, quality: 90 });
        this._eventListeners.push(helper_1.helper.addEventListener(page, page_1.Page.Events.ScreencastFrame, params => {
            const sha1 = utils_1.calculateSha1(utils_1.createGuid()); // no need to compute sha1 for screenshots
            const event = {
                type: 'screencast-frame',
                pageId: page.guid,
                sha1,
                width: params.width,
                height: params.height,
                timestamp: utils_1.monotonicTime()
            };
            this._appendTraceEvent(event);
            this._appendEventChain = this._appendEventChain.then(async () => {
                await fs_1.default.promises.writeFile(path_1.default.join(this._resourcesDir, sha1), params.buffer).catch(() => { });
            });
        }));
    }
    _appendTraceEvent(event) {
        if (!this._started)
            return;
        const visit = (object) => {
            if (Array.isArray(object)) {
                object.forEach(visit);
                return;
            }
            if (typeof object === 'object') {
                for (const key in object) {
                    if (key === 'sha1' || key.endsWith('Sha1')) {
                        const sha1 = object[key];
                        if (sha1)
                            this._sha1s.push(sha1);
                    }
                    visit(object[key]);
                }
                return;
            }
        };
        visit(event);
        // Serialize all writes to the trace file.
        this._appendEventChain = this._appendEventChain.then(async () => {
            await fs_1.default.promises.appendFile(this._traceFile, JSON.stringify(event) + '\n');
        });
    }
}
exports.Tracing = Tracing;
//# sourceMappingURL=tracing.js.map

/***/ }),

/***/ 3581:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketTransport = void 0;
const ws_1 = __importDefault(__nccwpck_require__(7550));
const utils_1 = __nccwpck_require__(6416);
class WebSocketTransport {
    constructor(progress, url, headers) {
        this.wsEndpoint = url;
        this._ws = new ws_1.default(url, [], {
            perMessageDeflate: false,
            maxPayload: 256 * 1024 * 1024,
            handshakeTimeout: progress.timeUntilDeadline(),
            headers
        });
        this._progress = progress;
        // The 'ws' module in node sometimes sends us multiple messages in a single task.
        // In Web, all IO callbacks (e.g. WebSocket callbacks)
        // are dispatched into separate tasks, so there's no need
        // to do anything extra.
        const messageWrap = utils_1.makeWaitForNextTask();
        this._ws.addEventListener('message', event => {
            messageWrap(() => {
                try {
                    if (this.onmessage)
                        this.onmessage.call(null, JSON.parse(event.data));
                }
                catch (e) {
                    this._ws.close();
                }
            });
        });
        this._ws.addEventListener('close', event => {
            this._progress && this._progress.log(`<ws disconnected> ${url}`);
            if (this.onclose)
                this.onclose.call(null);
        });
        // Prevent Error: read ECONNRESET.
        this._ws.addEventListener('error', () => { });
    }
    static async connect(progress, url, headers) {
        progress.log(`<ws connecting> ${url}`);
        const transport = new WebSocketTransport(progress, url, headers);
        let success = false;
        progress.cleanupWhenAborted(async () => {
            if (!success)
                await transport.closeAndWait().catch(e => null);
        });
        await new Promise((fulfill, reject) => {
            transport._ws.addEventListener('open', async () => {
                progress.log(`<ws connected> ${url}`);
                fulfill(transport);
            });
            transport._ws.addEventListener('error', event => {
                progress.log(`<ws connect error> ${url} ${event.message}`);
                reject(new Error('WebSocket error: ' + event.message));
                transport._ws.close();
            });
        });
        success = true;
        return transport;
    }
    send(message) {
        this._ws.send(JSON.stringify(message));
    }
    close() {
        this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);
        this._ws.close();
    }
    async closeAndWait() {
        const promise = new Promise(f => this._ws.once('close', f));
        this.close();
        await promise; // Make sure to await the actual disconnect.
    }
}
exports.WebSocketTransport = WebSocketTransport;
//# sourceMappingURL=transport.js.map

/***/ }),

/***/ 6581:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reducedMotions = exports.colorSchemes = exports.mediaTypes = exports.kLifecycleEvents = void 0;
exports.kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle']);
exports.mediaTypes = new Set(['screen', 'print']);
exports.colorSchemes = new Set(['dark', 'light', 'no-preference']);
exports.reducedMotions = new Set(['no-preference', 'reduce']);
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 3164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.USKeyboardLayout = exports.keypadLocation = void 0;
exports.keypadLocation = 3;
exports.USKeyboardLayout = {
    // Functions row
    'Escape': { 'keyCode': 27, 'key': 'Escape' },
    'F1': { 'keyCode': 112, 'key': 'F1' },
    'F2': { 'keyCode': 113, 'key': 'F2' },
    'F3': { 'keyCode': 114, 'key': 'F3' },
    'F4': { 'keyCode': 115, 'key': 'F4' },
    'F5': { 'keyCode': 116, 'key': 'F5' },
    'F6': { 'keyCode': 117, 'key': 'F6' },
    'F7': { 'keyCode': 118, 'key': 'F7' },
    'F8': { 'keyCode': 119, 'key': 'F8' },
    'F9': { 'keyCode': 120, 'key': 'F9' },
    'F10': { 'keyCode': 121, 'key': 'F10' },
    'F11': { 'keyCode': 122, 'key': 'F11' },
    'F12': { 'keyCode': 123, 'key': 'F12' },
    // Numbers row
    'Backquote': { 'keyCode': 192, 'shiftKey': '~', 'key': '`' },
    'Digit1': { 'keyCode': 49, 'shiftKey': '!', 'key': '1' },
    'Digit2': { 'keyCode': 50, 'shiftKey': '@', 'key': '2' },
    'Digit3': { 'keyCode': 51, 'shiftKey': '#', 'key': '3' },
    'Digit4': { 'keyCode': 52, 'shiftKey': '$', 'key': '4' },
    'Digit5': { 'keyCode': 53, 'shiftKey': '%', 'key': '5' },
    'Digit6': { 'keyCode': 54, 'shiftKey': '^', 'key': '6' },
    'Digit7': { 'keyCode': 55, 'shiftKey': '&', 'key': '7' },
    'Digit8': { 'keyCode': 56, 'shiftKey': '*', 'key': '8' },
    'Digit9': { 'keyCode': 57, 'shiftKey': '\(', 'key': '9' },
    'Digit0': { 'keyCode': 48, 'shiftKey': ')', 'key': '0' },
    'Minus': { 'keyCode': 189, 'shiftKey': '_', 'key': '-' },
    'Equal': { 'keyCode': 187, 'shiftKey': '+', 'key': '=' },
    'Backslash': { 'keyCode': 220, 'shiftKey': '|', 'key': '\\' },
    'Backspace': { 'keyCode': 8, 'key': 'Backspace' },
    // First row
    'Tab': { 'keyCode': 9, 'key': 'Tab' },
    'KeyQ': { 'keyCode': 81, 'shiftKey': 'Q', 'key': 'q' },
    'KeyW': { 'keyCode': 87, 'shiftKey': 'W', 'key': 'w' },
    'KeyE': { 'keyCode': 69, 'shiftKey': 'E', 'key': 'e' },
    'KeyR': { 'keyCode': 82, 'shiftKey': 'R', 'key': 'r' },
    'KeyT': { 'keyCode': 84, 'shiftKey': 'T', 'key': 't' },
    'KeyY': { 'keyCode': 89, 'shiftKey': 'Y', 'key': 'y' },
    'KeyU': { 'keyCode': 85, 'shiftKey': 'U', 'key': 'u' },
    'KeyI': { 'keyCode': 73, 'shiftKey': 'I', 'key': 'i' },
    'KeyO': { 'keyCode': 79, 'shiftKey': 'O', 'key': 'o' },
    'KeyP': { 'keyCode': 80, 'shiftKey': 'P', 'key': 'p' },
    'BracketLeft': { 'keyCode': 219, 'shiftKey': '{', 'key': '[' },
    'BracketRight': { 'keyCode': 221, 'shiftKey': '}', 'key': ']' },
    // Second row
    'CapsLock': { 'keyCode': 20, 'key': 'CapsLock' },
    'KeyA': { 'keyCode': 65, 'shiftKey': 'A', 'key': 'a' },
    'KeyS': { 'keyCode': 83, 'shiftKey': 'S', 'key': 's' },
    'KeyD': { 'keyCode': 68, 'shiftKey': 'D', 'key': 'd' },
    'KeyF': { 'keyCode': 70, 'shiftKey': 'F', 'key': 'f' },
    'KeyG': { 'keyCode': 71, 'shiftKey': 'G', 'key': 'g' },
    'KeyH': { 'keyCode': 72, 'shiftKey': 'H', 'key': 'h' },
    'KeyJ': { 'keyCode': 74, 'shiftKey': 'J', 'key': 'j' },
    'KeyK': { 'keyCode': 75, 'shiftKey': 'K', 'key': 'k' },
    'KeyL': { 'keyCode': 76, 'shiftKey': 'L', 'key': 'l' },
    'Semicolon': { 'keyCode': 186, 'shiftKey': ':', 'key': ';' },
    'Quote': { 'keyCode': 222, 'shiftKey': '"', 'key': '\'' },
    'Enter': { 'keyCode': 13, 'key': 'Enter', 'text': '\r' },
    // Third row
    'ShiftLeft': { 'keyCode': 160, 'keyCodeWithoutLocation': 16, 'key': 'Shift', 'location': 1 },
    'KeyZ': { 'keyCode': 90, 'shiftKey': 'Z', 'key': 'z' },
    'KeyX': { 'keyCode': 88, 'shiftKey': 'X', 'key': 'x' },
    'KeyC': { 'keyCode': 67, 'shiftKey': 'C', 'key': 'c' },
    'KeyV': { 'keyCode': 86, 'shiftKey': 'V', 'key': 'v' },
    'KeyB': { 'keyCode': 66, 'shiftKey': 'B', 'key': 'b' },
    'KeyN': { 'keyCode': 78, 'shiftKey': 'N', 'key': 'n' },
    'KeyM': { 'keyCode': 77, 'shiftKey': 'M', 'key': 'm' },
    'Comma': { 'keyCode': 188, 'shiftKey': '\<', 'key': ',' },
    'Period': { 'keyCode': 190, 'shiftKey': '>', 'key': '.' },
    'Slash': { 'keyCode': 191, 'shiftKey': '?', 'key': '/' },
    'ShiftRight': { 'keyCode': 161, 'keyCodeWithoutLocation': 16, 'key': 'Shift', 'location': 2 },
    // Last row
    'ControlLeft': { 'keyCode': 162, 'keyCodeWithoutLocation': 17, 'key': 'Control', 'location': 1 },
    'MetaLeft': { 'keyCode': 91, 'key': 'Meta', 'location': 1 },
    'AltLeft': { 'keyCode': 164, 'keyCodeWithoutLocation': 18, 'key': 'Alt', 'location': 1 },
    'Space': { 'keyCode': 32, 'key': ' ' },
    'AltRight': { 'keyCode': 165, 'keyCodeWithoutLocation': 18, 'key': 'Alt', 'location': 2 },
    'AltGraph': { 'keyCode': 225, 'key': 'AltGraph' },
    'MetaRight': { 'keyCode': 92, 'key': 'Meta', 'location': 2 },
    'ContextMenu': { 'keyCode': 93, 'key': 'ContextMenu' },
    'ControlRight': { 'keyCode': 163, 'keyCodeWithoutLocation': 17, 'key': 'Control', 'location': 2 },
    // Center block
    'PrintScreen': { 'keyCode': 44, 'key': 'PrintScreen' },
    'ScrollLock': { 'keyCode': 145, 'key': 'ScrollLock' },
    'Pause': { 'keyCode': 19, 'key': 'Pause' },
    'PageUp': { 'keyCode': 33, 'key': 'PageUp' },
    'PageDown': { 'keyCode': 34, 'key': 'PageDown' },
    'Insert': { 'keyCode': 45, 'key': 'Insert' },
    'Delete': { 'keyCode': 46, 'key': 'Delete' },
    'Home': { 'keyCode': 36, 'key': 'Home' },
    'End': { 'keyCode': 35, 'key': 'End' },
    'ArrowLeft': { 'keyCode': 37, 'key': 'ArrowLeft' },
    'ArrowUp': { 'keyCode': 38, 'key': 'ArrowUp' },
    'ArrowRight': { 'keyCode': 39, 'key': 'ArrowRight' },
    'ArrowDown': { 'keyCode': 40, 'key': 'ArrowDown' },
    // Numpad
    'NumLock': { 'keyCode': 144, 'key': 'NumLock' },
    'NumpadDivide': { 'keyCode': 111, 'key': '/', 'location': 3 },
    'NumpadMultiply': { 'keyCode': 106, 'key': '*', 'location': 3 },
    'NumpadSubtract': { 'keyCode': 109, 'key': '-', 'location': 3 },
    'Numpad7': { 'keyCode': 36, 'shiftKeyCode': 103, 'key': 'Home', 'shiftKey': '7', 'location': 3 },
    'Numpad8': { 'keyCode': 38, 'shiftKeyCode': 104, 'key': 'ArrowUp', 'shiftKey': '8', 'location': 3 },
    'Numpad9': { 'keyCode': 33, 'shiftKeyCode': 105, 'key': 'PageUp', 'shiftKey': '9', 'location': 3 },
    'Numpad4': { 'keyCode': 37, 'shiftKeyCode': 100, 'key': 'ArrowLeft', 'shiftKey': '4', 'location': 3 },
    'Numpad5': { 'keyCode': 12, 'shiftKeyCode': 101, 'key': 'Clear', 'shiftKey': '5', 'location': 3 },
    'Numpad6': { 'keyCode': 39, 'shiftKeyCode': 102, 'key': 'ArrowRight', 'shiftKey': '6', 'location': 3 },
    'NumpadAdd': { 'keyCode': 107, 'key': '+', 'location': 3 },
    'Numpad1': { 'keyCode': 35, 'shiftKeyCode': 97, 'key': 'End', 'shiftKey': '1', 'location': 3 },
    'Numpad2': { 'keyCode': 40, 'shiftKeyCode': 98, 'key': 'ArrowDown', 'shiftKey': '2', 'location': 3 },
    'Numpad3': { 'keyCode': 34, 'shiftKeyCode': 99, 'key': 'PageDown', 'shiftKey': '3', 'location': 3 },
    'Numpad0': { 'keyCode': 45, 'shiftKeyCode': 96, 'key': 'Insert', 'shiftKey': '0', 'location': 3 },
    'NumpadDecimal': { 'keyCode': 46, 'shiftKeyCode': 110, 'key': '\u0000', 'shiftKey': '.', 'location': 3 },
    'NumpadEnter': { 'keyCode': 13, 'key': 'Enter', 'text': '\r', 'location': 3 },
};
//# sourceMappingURL=usKeyboardLayout.js.map

/***/ }),

/***/ 6342:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateHostRequirements = void 0;
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
const os = __importStar(__nccwpck_require__(2087));
const ubuntuVersion_1 = __nccwpck_require__(9048);
const utils = __importStar(__nccwpck_require__(6416));
const binaryPaths_1 = __nccwpck_require__(1232);
const checkExecutable = (filePath) => fs_1.default.promises.access(filePath, fs_1.default.constants.X_OK).then(() => true).catch(e => false);
async function validateHostRequirements(registry, browserName) {
    if (utils.getAsBooleanFromENV('PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS')) {
        process.stdout.write('Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n');
        return;
    }
    const ubuntuVersion = await ubuntuVersion_1.getUbuntuVersion();
    if (browserName === 'firefox' && ubuntuVersion === '16.04')
        throw new Error(`Cannot launch firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 18.04`);
    if (os.platform() === 'linux')
        return await validateDependenciesLinux(registry, browserName);
    if (os.platform() === 'win32' && os.arch() === 'x64')
        return await validateDependenciesWindows(registry, browserName);
}
exports.validateHostRequirements = validateHostRequirements;
const DL_OPEN_LIBRARIES = {
    'chromium': [],
    'webkit': ['libGLESv2.so.2', 'libx264.so'],
    'webkit-technology-preview': ['libGLESv2.so.2', 'libx264.so'],
    'firefox': [],
    'firefox-beta': [],
    'clank': [],
    'ffmpeg': [],
};
function isSupportedWindowsVersion() {
    if (os.platform() !== 'win32' || os.arch() !== 'x64')
        return false;
    const [major, minor] = os.release().split('.').map(token => parseInt(token, 10));
    // This is based on: https://stackoverflow.com/questions/42524606/how-to-get-windows-version-using-node-js/44916050#44916050
    // The table with versions is taken from: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoexw#remarks
    // Windows 7 is not supported and is encoded as `6.1`.
    return major > 6 || (major === 6 && minor > 1);
}
async function validateDependenciesWindows(registry, browserName) {
    const directoryPaths = registry.windowsExeAndDllDirectories(browserName);
    const lddPaths = [];
    for (const directoryPath of directoryPaths)
        lddPaths.push(...(await executablesOrSharedLibraries(directoryPath)));
    const allMissingDeps = await Promise.all(lddPaths.map(lddPath => missingFileDependenciesWindows(lddPath)));
    const missingDeps = new Set();
    for (const deps of allMissingDeps) {
        for (const dep of deps)
            missingDeps.add(dep);
    }
    if (!missingDeps.size)
        return;
    let isCrtMissing = false;
    let isMediaFoundationMissing = false;
    for (const dep of missingDeps) {
        if (dep.startsWith('api-ms-win-crt') || dep === 'vcruntime140.dll' || dep === 'vcruntime140_1.dll' || dep === 'msvcp140.dll')
            isCrtMissing = true;
        else if (dep === 'mf.dll' || dep === 'mfplat.dll' || dep === 'msmpeg2vdec.dll' || dep === 'evr.dll' || dep === 'avrt.dll')
            isMediaFoundationMissing = true;
    }
    const details = [];
    if (isCrtMissing) {
        details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
    }
    if (isMediaFoundationMissing) {
        details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
    }
    details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join('\n    ')}`, ``);
    const message = `Host system is missing dependencies!\n\n${details.join('\n')}`;
    if (isSupportedWindowsVersion()) {
        throw new Error(message);
    }
    else {
        console.warn(`WARNING: running on unsupported windows version!`);
        console.warn(message);
    }
}
async function validateDependenciesLinux(registry, browserName) {
    const directoryPaths = registry.linuxLddDirectories(browserName);
    const lddPaths = [];
    for (const directoryPath of directoryPaths)
        lddPaths.push(...(await executablesOrSharedLibraries(directoryPath)));
    const allMissingDeps = await Promise.all(lddPaths.map(lddPath => missingFileDependencies(lddPath, directoryPaths)));
    const missingDeps = new Set();
    for (const deps of allMissingDeps) {
        for (const dep of deps)
            missingDeps.add(dep);
    }
    for (const dep of (await missingDLOPENLibraries(browserName)))
        missingDeps.add(dep);
    if (!missingDeps.size)
        return;
    // Check Ubuntu version.
    const missingPackages = new Set();
    const ubuntuVersion = await ubuntuVersion_1.getUbuntuVersion();
    let libraryToPackageNameMapping = null;
    if (ubuntuVersion === '18.04')
        libraryToPackageNameMapping = LIBRARY_TO_PACKAGE_NAME_UBUNTU_18_04;
    else if (ubuntuVersion === '20.04')
        libraryToPackageNameMapping = LIBRARY_TO_PACKAGE_NAME_UBUNTU_20_04;
    else if (ubuntuVersion === '21.04')
        libraryToPackageNameMapping = LIBRARY_TO_PACKAGE_NAME_UBUNTU_21_04;
    libraryToPackageNameMapping = Object.assign({}, libraryToPackageNameMapping, MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU);
    if (libraryToPackageNameMapping) {
        // Translate missing dependencies to package names to install with apt.
        for (const missingDep of missingDeps) {
            const packageName = libraryToPackageNameMapping[missingDep];
            if (packageName) {
                missingPackages.add(packageName);
                missingDeps.delete(missingDep);
            }
        }
    }
    let missingPackagesMessage = '';
    if (missingPackages.size) {
        missingPackagesMessage = [
            `  Install missing packages with:`,
            `      sudo apt-get install ${[...missingPackages].join('\\\n          ')}`,
            ``,
            ``,
        ].join('\n');
    }
    let missingDependenciesMessage = '';
    if (missingDeps.size) {
        const header = missingPackages.size ? `Missing libraries we didn't find packages for:` : `Missing libraries are:`;
        missingDependenciesMessage = [
            `  ${header}`,
            `      ${[...missingDeps].join('\n      ')}`,
            ``,
        ].join('\n');
    }
    throw new Error('Host system is missing dependencies!\n\n' + missingPackagesMessage + missingDependenciesMessage);
}
function isSharedLib(basename) {
    switch (os.platform()) {
        case 'linux':
            return basename.endsWith('.so') || basename.includes('.so.');
        case 'win32':
            return basename.endsWith('.dll');
        default:
            return false;
    }
}
async function executablesOrSharedLibraries(directoryPath) {
    const allPaths = (await fs_1.default.promises.readdir(directoryPath)).map(file => path_1.default.resolve(directoryPath, file));
    const allStats = await Promise.all(allPaths.map(aPath => fs_1.default.promises.stat(aPath)));
    const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());
    const executablersOrLibraries = (await Promise.all(filePaths.map(async (filePath) => {
        const basename = path_1.default.basename(filePath).toLowerCase();
        if (isSharedLib(basename))
            return filePath;
        if (await checkExecutable(filePath))
            return filePath;
        return false;
    }))).filter(Boolean);
    return executablersOrLibraries;
}
async function missingFileDependenciesWindows(filePath) {
    const executable = binaryPaths_1.printDepsWindowsExecutable();
    if (!executable)
        return [];
    const dirname = path_1.default.dirname(filePath);
    const { stdout, code } = await utils.spawnAsync(executable, [filePath], {
        cwd: dirname,
        env: {
            ...process.env,
            LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname,
        },
    });
    if (code !== 0)
        return [];
    const missingDeps = stdout.split('\n').map(line => line.trim()).filter(line => line.endsWith('not found') && line.includes('=>')).map(line => line.split('=>')[0].trim().toLowerCase());
    return missingDeps;
}
async function missingFileDependencies(filePath, extraLDPaths) {
    const dirname = path_1.default.dirname(filePath);
    let LD_LIBRARY_PATH = extraLDPaths.join(':');
    if (process.env.LD_LIBRARY_PATH)
        LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
    const { stdout, code } = await utils.spawnAsync('ldd', [filePath], {
        cwd: dirname,
        env: {
            ...process.env,
            LD_LIBRARY_PATH,
        },
    });
    if (code !== 0)
        return [];
    const missingDeps = stdout.split('\n').map(line => line.trim()).filter(line => line.endsWith('not found') && line.includes('=>')).map(line => line.split('=>')[0].trim());
    return missingDeps;
}
async function missingDLOPENLibraries(browserName) {
    const libraries = DL_OPEN_LIBRARIES[browserName];
    if (!libraries.length)
        return [];
    // NOTE: Using full-qualified path to `ldconfig` since `/sbin` is not part of the
    // default PATH in CRON.
    // @see https://github.com/microsoft/playwright/issues/3397
    const { stdout, code, error } = await utils.spawnAsync('/sbin/ldconfig', ['-p'], {});
    if (code !== 0 || error)
        return [];
    const isLibraryAvailable = (library) => stdout.toLowerCase().includes(library.toLowerCase());
    return libraries.filter(library => !isLibraryAvailable(library));
}
// This list is generted with the following program:
// ./utils/linux-browser-dependencies/run.sh ubuntu:18.04
const LIBRARY_TO_PACKAGE_NAME_UBUNTU_18_04 = {
    'libasound.so.2': 'libasound2',
    'libatk-1.0.so.0': 'libatk1.0-0',
    'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
    'libatspi.so.0': 'libatspi2.0-0',
    'libbrotlidec.so.1': 'libbrotli1',
    'libcairo-gobject.so.2': 'libcairo-gobject2',
    'libcairo.so.2': 'libcairo2',
    'libcups.so.2': 'libcups2',
    'libdbus-1.so.3': 'libdbus-1-3',
    'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
    'libdrm.so.2': 'libdrm2',
    'libEGL.so.1': 'libegl1',
    'libenchant.so.1': 'libenchant1c2a',
    'libepoxy.so.0': 'libepoxy0',
    'libevent-2.1.so.6': 'libevent-2.1-6',
    'libfontconfig.so.1': 'libfontconfig1',
    'libfreetype.so.6': 'libfreetype6',
    'libgbm.so.1': 'libgbm1',
    'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf2.0-0',
    'libgdk-3.so.0': 'libgtk-3-0',
    'libgdk-x11-2.0.so.0': 'libgtk2.0-0',
    'libgio-2.0.so.0': 'libglib2.0-0',
    'libGL.so.1': 'libgl1',
    'libGLESv2.so.2': 'libgles2',
    'libglib-2.0.so.0': 'libglib2.0-0',
    'libgmodule-2.0.so.0': 'libglib2.0-0',
    'libgobject-2.0.so.0': 'libglib2.0-0',
    'libgstapp-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstaudio-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
    'libgstcodecparsers-1.0.so.0': 'gstreamer1.0-plugins-bad',
    'libgstfft-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
    'libgstpbutils-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
    'libgsttag-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstvideo-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgthread-2.0.so.0': 'libglib2.0-0',
    'libgtk-3.so.0': 'libgtk-3-0',
    'libgtk-x11-2.0.so.0': 'libgtk2.0-0',
    'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
    'libharfbuzz.so.0': 'libharfbuzz0b',
    'libhyphen.so.0': 'libhyphen0',
    'libicudata.so.60': 'libicu60',
    'libicui18n.so.60': 'libicu60',
    'libicuuc.so.60': 'libicu60',
    'libjpeg.so.8': 'libjpeg-turbo8',
    'libnotify.so.4': 'libnotify4',
    'libnspr4.so': 'libnspr4',
    'libnss3.so': 'libnss3',
    'libnssutil3.so': 'libnss3',
    'libopenjp2.so.7': 'libopenjp2-7',
    'libopus.so.0': 'libopus0',
    'libpango-1.0.so.0': 'libpango-1.0-0',
    'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
    'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',
    'libpng16.so.16': 'libpng16-16',
    'libsecret-1.so.0': 'libsecret-1-0',
    'libsmime3.so': 'libnss3',
    'libvpx.so.5': 'libvpx5',
    'libwayland-client.so.0': 'libwayland-client0',
    'libwayland-egl.so.1': 'libwayland-egl1',
    'libwayland-server.so.0': 'libwayland-server0',
    'libwebp.so.6': 'libwebp6',
    'libwebpdemux.so.2': 'libwebpdemux2',
    'libwoff2dec.so.1.0.2': 'libwoff1',
    'libX11-xcb.so.1': 'libx11-xcb1',
    'libX11.so.6': 'libx11-6',
    'libxcb-dri3.so.0': 'libxcb-dri3-0',
    'libxcb-shm.so.0': 'libxcb-shm0',
    'libxcb.so.1': 'libxcb1',
    'libXcomposite.so.1': 'libxcomposite1',
    'libXcursor.so.1': 'libxcursor1',
    'libXdamage.so.1': 'libxdamage1',
    'libXext.so.6': 'libxext6',
    'libXfixes.so.3': 'libxfixes3',
    'libXi.so.6': 'libxi6',
    'libxkbcommon.so.0': 'libxkbcommon0',
    'libxml2.so.2': 'libxml2',
    'libXrandr.so.2': 'libxrandr2',
    'libXrender.so.1': 'libxrender1',
    'libxslt.so.1': 'libxslt1.1',
    'libXt.so.6': 'libxt6',
    'libXtst.so.6': 'libxtst6',
};
// This list is generted with the following program:
// ./utils/linux-browser-dependencies/run.sh ubuntu:20.04
const LIBRARY_TO_PACKAGE_NAME_UBUNTU_20_04 = {
    'libasound.so.2': 'libasound2',
    'libatk-1.0.so.0': 'libatk1.0-0',
    'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
    'libatspi.so.0': 'libatspi2.0-0',
    'libcairo-gobject.so.2': 'libcairo-gobject2',
    'libcairo.so.2': 'libcairo2',
    'libcups.so.2': 'libcups2',
    'libdbus-1.so.3': 'libdbus-1-3',
    'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
    'libdrm.so.2': 'libdrm2',
    'libEGL.so.1': 'libegl1',
    'libenchant.so.1': 'libenchant1c2a',
    'libepoxy.so.0': 'libepoxy0',
    'libfontconfig.so.1': 'libfontconfig1',
    'libfreetype.so.6': 'libfreetype6',
    'libgbm.so.1': 'libgbm1',
    'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf2.0-0',
    'libgdk-3.so.0': 'libgtk-3-0',
    'libgdk-x11-2.0.so.0': 'libgtk2.0-0',
    'libgio-2.0.so.0': 'libglib2.0-0',
    'libGL.so.1': 'libgl1',
    'libGLESv2.so.2': 'libgles2',
    'libglib-2.0.so.0': 'libglib2.0-0',
    'libgmodule-2.0.so.0': 'libglib2.0-0',
    'libgobject-2.0.so.0': 'libglib2.0-0',
    'libgstapp-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstaudio-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
    'libgstcodecparsers-1.0.so.0': 'gstreamer1.0-plugins-bad',
    'libgstfft-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
    'libgstpbutils-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
    'libgsttag-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgstvideo-1.0.so.0': 'gstreamer1.0-plugins-base',
    'libgthread-2.0.so.0': 'libglib2.0-0',
    'libgtk-3.so.0': 'libgtk-3-0',
    'libgtk-x11-2.0.so.0': 'libgtk2.0-0',
    'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
    'libharfbuzz.so.0': 'libharfbuzz0b',
    'libhyphen.so.0': 'libhyphen0',
    'libicui18n.so.66': 'libicu66',
    'libicuuc.so.66': 'libicu66',
    'libjpeg.so.8': 'libjpeg-turbo8',
    'libnotify.so.4': 'libnotify4',
    'libnspr4.so': 'libnspr4',
    'libnss3.so': 'libnss3',
    'libnssutil3.so': 'libnss3',
    'libopenjp2.so.7': 'libopenjp2-7',
    'libopus.so.0': 'libopus0',
    'libpango-1.0.so.0': 'libpango-1.0-0',
    'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
    'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',
    'libpng16.so.16': 'libpng16-16',
    'libsecret-1.so.0': 'libsecret-1-0',
    'libsmime3.so': 'libnss3',
    'libsoup-2.4.so.1': 'libsoup2.4-1',
    'libvpx.so.6': 'libvpx6',
    'libwayland-client.so.0': 'libwayland-client0',
    'libwayland-egl.so.1': 'libwayland-egl1',
    'libwayland-server.so.0': 'libwayland-server0',
    'libwebp.so.6': 'libwebp6',
    'libwebpdemux.so.2': 'libwebpdemux2',
    'libwoff2dec.so.1.0.2': 'libwoff1',
    'libX11-xcb.so.1': 'libx11-xcb1',
    'libX11.so.6': 'libx11-6',
    'libxcb-dri3.so.0': 'libxcb-dri3-0',
    'libxcb-shm.so.0': 'libxcb-shm0',
    'libxcb.so.1': 'libxcb1',
    'libXcomposite.so.1': 'libxcomposite1',
    'libXcursor.so.1': 'libxcursor1',
    'libXdamage.so.1': 'libxdamage1',
    'libXext.so.6': 'libxext6',
    'libXfixes.so.3': 'libxfixes3',
    'libXi.so.6': 'libxi6',
    'libxkbcommon.so.0': 'libxkbcommon0',
    'libxml2.so.2': 'libxml2',
    'libXrandr.so.2': 'libxrandr2',
    'libXrender.so.1': 'libxrender1',
    'libxslt.so.1': 'libxslt1.1',
    'libXt.so.6': 'libxt6',
    'libXtst.so.6': 'libxtst6',
};
const LIBRARY_TO_PACKAGE_NAME_UBUNTU_21_04 = {
    'libasound.so.2': 'libasound2',
    'libatk-1.0.so.0': 'libatk1.0-0',
    'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
    'libatspi.so.0': 'libatspi2.0-0',
    'libcairo-gobject.so.2': 'libcairo-gobject2',
    'libcairo.so.2': 'libcairo2',
    'libcups.so.2': 'libcups2',
    'libdbus-1.so.3': 'libdbus-1-3',
    'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
    'libdrm.so.2': 'libdrm2',
    'libEGL.so.1': 'libegl1',
    'libepoxy.so.0': 'libepoxy0',
    'libfontconfig.so.1': 'libfontconfig1',
    'libfreetype.so.6': 'libfreetype6',
    'libgbm.so.1': 'libgbm1',
    'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf-2.0-0',
    'libgdk-3.so.0': 'libgtk-3-0',
    'libgdk-x11-2.0.so.0': 'libgtk2.0-0',
    'libgio-2.0.so.0': 'libglib2.0-0',
    'libGL.so.1': 'libgl1',
    'libGLESv2.so.2': 'libgles2',
    'libglib-2.0.so.0': 'libglib2.0-0',
    'libgmodule-2.0.so.0': 'libglib2.0-0',
    'libgobject-2.0.so.0': 'libglib2.0-0',
    'libgstapp-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
    'libgstaudio-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
    'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
    'libgstcodecparsers-1.0.so.0': 'libgstreamer-plugins-bad1.0-0',
    'libgstfft-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
    'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
    'libgstpbutils-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
    'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
    'libgsttag-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
    'libgstvideo-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
    'libgthread-2.0.so.0': 'libglib2.0-0',
    'libgtk-3.so.0': 'libgtk-3-0',
    'libgtk-x11-2.0.so.0': 'libgtk2.0-0',
    'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
    'libharfbuzz.so.0': 'libharfbuzz0b',
    'libhyphen.so.0': 'libhyphen0',
    'libjavascriptcoregtk-4.0.so.18': 'libjavascriptcoregtk-4.0-18',
    'libjpeg.so.8': 'libjpeg-turbo8',
    'liblcms2.so.2': 'liblcms2-2',
    'libnotify.so.4': 'libnotify4',
    'libnspr4.so': 'libnspr4',
    'libnss3.so': 'libnss3',
    'libnssutil3.so': 'libnss3',
    'libopenjp2.so.7': 'libopenjp2-7',
    'libopus.so.0': 'libopus0',
    'libpango-1.0.so.0': 'libpango-1.0-0',
    'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
    'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',
    'libpng16.so.16': 'libpng16-16',
    'libsecret-1.so.0': 'libsecret-1-0',
    'libsmime3.so': 'libnss3',
    'libsoup-2.4.so.1': 'libsoup2.4-1',
    'libvpx.so.6': 'libvpx6',
    'libwayland-client.so.0': 'libwayland-client0',
    'libwayland-egl.so.1': 'libwayland-egl1',
    'libwayland-server.so.0': 'libwayland-server0',
    'libwebkit2gtk-4.0.so.37': 'libwebkit2gtk-4.0-37',
    'libwebp.so.6': 'libwebp6',
    'libwebpdemux.so.2': 'libwebpdemux2',
    'libwoff2dec.so.1.0.2': 'libwoff1',
    'libwpe-1.0.so.1': 'libwpe-1.0-1',
    'libWPEBackend-fdo-1.0.so.1': 'libwpebackend-fdo-1.0-1',
    'libWPEWebKit-1.0.so.3': 'libwpewebkit-1.0-3',
    'libX11-xcb.so.1': 'libx11-xcb1',
    'libX11.so.6': 'libx11-6',
    'libxcb-shm.so.0': 'libxcb-shm0',
    'libxcb.so.1': 'libxcb1',
    'libXcomposite.so.1': 'libxcomposite1',
    'libXcursor.so.1': 'libxcursor1',
    'libXdamage.so.1': 'libxdamage1',
    'libXext.so.6': 'libxext6',
    'libXfixes.so.3': 'libxfixes3',
    'libXi.so.6': 'libxi6',
    'libxkbcommon.so.0': 'libxkbcommon0',
    'libxml2.so.2': 'libxml2',
    'libXrandr.so.2': 'libxrandr2',
    'libXrender.so.1': 'libxrender1',
    'libxshmfence.so.1': 'libxshmfence1',
    'libxslt.so.1': 'libxslt1.1',
    'libXt.so.6': 'libxt6',
};
const MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
    // libgstlibav.so (the only actual library provided by gstreamer1.0-libav) is not
    // in the ldconfig cache, so we detect the actual library required for playing h.264
    // and if it's missing recommend installing missing gstreamer lib.
    // gstreamer1.0-libav -> libavcodec57 -> libx264-152
    'libx264.so': 'gstreamer1.0-libav',
};
//# sourceMappingURL=validateDependencies.js.map

/***/ }),

/***/ 6464:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebKit = void 0;
const wkBrowser_1 = __nccwpck_require__(9597);
const path_1 = __importDefault(__nccwpck_require__(5622));
const wkConnection_1 = __nccwpck_require__(8380);
const browserType_1 = __nccwpck_require__(3783);
const fs = __importStar(__nccwpck_require__(5747));
const utils_1 = __nccwpck_require__(6416);
class WebKit extends browserType_1.BrowserType {
    constructor(playwrightOptions) {
        super('webkit', playwrightOptions);
    }
    executablePath(channel) {
        if (channel) {
            let executablePath = undefined;
            if (channel === 'technology-preview')
                executablePath = this._registry.executablePath('webkit-technology-preview');
            utils_1.assert(executablePath, `unsupported webkit channel "${channel}"`);
            utils_1.assert(fs.existsSync(executablePath), `webkit channel "${channel}" is not installed. Try running 'npx playwright install webkit-technology-preview'`);
            return executablePath;
        }
        return super.executablePath(channel);
    }
    _connectToTransport(transport, options) {
        return wkBrowser_1.WKBrowser.connect(transport, options);
    }
    _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return { ...env, CURL_COOKIE_JAR_PATH: path_1.default.join(userDataDir, 'cookiejar.db') };
    }
    _rewriteStartupError(error) {
        return error;
    }
    _attemptToGracefullyCloseBrowser(transport) {
        transport.send({ method: 'Playwright.close', params: {}, id: wkConnection_1.kBrowserCloseMessageId });
    }
    _defaultArgs(options, isPersistent, userDataDir) {
        const { args = [], proxy, devtools, headless } = options;
        if (devtools)
            console.warn('devtools parameter as a launch argument in WebKit is not supported. Also starting Web Inspector manually will terminate the execution in WebKit.');
        const userDataDirArg = args.find(arg => arg.startsWith('--user-data-dir'));
        if (userDataDirArg)
            throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument');
        if (args.find(arg => !arg.startsWith('-')))
            throw new Error('Arguments can not specify page to be opened');
        const webkitArguments = ['--inspector-pipe'];
        if (headless)
            webkitArguments.push('--headless');
        if (isPersistent)
            webkitArguments.push(`--user-data-dir=${userDataDir}`);
        else
            webkitArguments.push(`--no-startup-window`);
        if (proxy) {
            if (process.platform === 'darwin') {
                webkitArguments.push(`--proxy=${proxy.server}`);
                if (proxy.bypass)
                    webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
            }
            else if (process.platform === 'linux') {
                webkitArguments.push(`--proxy=${proxy.server}`);
                if (proxy.bypass)
                    webkitArguments.push(...proxy.bypass.split(',').map(t => `--ignore-host=${t}`));
            }
            else if (process.platform === 'win32') {
                webkitArguments.push(`--curl-proxy=${proxy.server}`);
                if (proxy.bypass)
                    webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
            }
        }
        webkitArguments.push(...args);
        if (isPersistent)
            webkitArguments.push('about:blank');
        return webkitArguments;
    }
}
exports.WebKit = WebKit;
//# sourceMappingURL=webkit.js.map

/***/ }),

/***/ 8819:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAccessibilityTree = void 0;
async function getAccessibilityTree(session, needle) {
    const objectId = needle ? needle._objectId : undefined;
    const { axNode } = await session.send('Page.accessibilitySnapshot', { objectId });
    const tree = new WKAXNode(axNode);
    return {
        tree,
        needle: needle ? tree._findNeedle() : null
    };
}
exports.getAccessibilityTree = getAccessibilityTree;
const WKRoleToARIARole = new Map(Object.entries({
    'TextField': 'textbox',
}));
// WebKit localizes role descriptions on mac, but the english versions only add noise.
const WKUnhelpfulRoleDescriptions = new Map(Object.entries({
    'WebArea': 'HTML content',
    'Summary': 'summary',
    'DescriptionList': 'description list',
    'ImageMap': 'image map',
    'ListMarker': 'list marker',
    'Video': 'video playback',
    'Mark': 'highlighted',
    'contentinfo': 'content information',
    'Details': 'details',
    'DescriptionListDetail': 'description',
    'DescriptionListTerm': 'term',
    'alertdialog': 'web alert dialog',
    'dialog': 'web dialog',
    'status': 'application status',
    'tabpanel': 'tab panel',
    'application': 'web application',
}));
class WKAXNode {
    constructor(payload) {
        this._payload = payload;
        this._children = [];
        for (const payload of this._payload.children || [])
            this._children.push(new WKAXNode(payload));
    }
    children() {
        return this._children;
    }
    _findNeedle() {
        if (this._payload.found)
            return this;
        for (const child of this._children) {
            const found = child._findNeedle();
            if (found)
                return found;
        }
        return null;
    }
    isControl() {
        switch (this._payload.role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'TextField':
            case 'tree':
                return true;
            default:
                return false;
        }
    }
    _isTextControl() {
        switch (this._payload.role) {
            case 'combobox':
            case 'searchfield':
            case 'textbox':
            case 'TextField':
                return true;
        }
        return false;
    }
    _name() {
        if (this._payload.role === 'text')
            return this._payload.value || '';
        return this._payload.name || '';
    }
    isInteresting(insideControl) {
        const { role, focusable } = this._payload;
        const name = this._name();
        if (role === 'ScrollArea')
            return false;
        if (role === 'WebArea')
            return true;
        if (focusable || role === 'MenuListOption')
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!name;
    }
    _hasRendundantTextChild() {
        if (this._children.length !== 1)
            return false;
        const child = this._children[0];
        return child._payload.role === 'text' && this._payload.name === child._payload.value;
    }
    isLeafNode() {
        if (!this._children.length)
            return true;
        // WebKit on Linux ignores everything inside text controls, normalize this behavior
        if (this._isTextControl())
            return true;
        // WebKit for mac has text nodes inside heading, li, menuitem, a, and p nodes
        if (this._hasRendundantTextChild())
            return true;
        return false;
    }
    serialize() {
        const node = {
            role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
            name: this._name(),
        };
        if ('description' in this._payload && this._payload.description !== node.name)
            node.description = this._payload.description;
        if ('roledescription' in this._payload) {
            const roledescription = this._payload.roledescription;
            if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
                node.roledescription = roledescription;
        }
        if ('value' in this._payload && this._payload.role !== 'text') {
            if (typeof this._payload.value === 'string')
                node.valueString = this._payload.value;
            else if (typeof this._payload.value === 'number')
                node.valueNumber = this._payload.value;
        }
        if ('checked' in this._payload)
            node.checked = this._payload.checked === 'true' ? 'checked' : this._payload.checked === 'false' ? 'unchecked' : 'mixed';
        if ('pressed' in this._payload)
            node.pressed = this._payload.pressed === 'true' ? 'pressed' : this._payload.pressed === 'false' ? 'released' : 'mixed';
        const userStringProperties = [
            'keyshortcuts',
            'valuetext'
        ];
        for (const userStringProperty of userStringProperties) {
            if (!(userStringProperty in this._payload))
                continue;
            node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        for (const booleanProperty of booleanProperties) {
            // WebArea and ScorllArea treat focus differently than other nodes. They report whether their frame  has focus,
            // not whether focus is specifically on the root node.
            if (booleanProperty === 'focused' && (this._payload.role === 'WebArea' || this._payload.role === 'ScrollArea'))
                continue;
            const value = this._payload[booleanProperty];
            if (!value)
                continue;
            node[booleanProperty] = value;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        for (const numericalProperty of numericalProperties) {
            if (!(numericalProperty in this._payload))
                continue;
            node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
        ];
        for (const tokenProperty of tokenProperties) {
            const value = this._payload[tokenProperty];
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = value;
        }
        const orientationIsApplicable = new Set([
            'ScrollArea',
            'scrollbar',
            'listbox',
            'combobox',
            'menu',
            'tree',
            'separator',
            'slider',
            'tablist',
            'toolbar',
        ]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
            node.orientation = this._payload.orientation;
        return node;
    }
}
//# sourceMappingURL=wkAccessibility.js.map

/***/ }),

/***/ 9597:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WKBrowserContext = exports.WKBrowser = void 0;
const browser_1 = __nccwpck_require__(6169);
const browserContext_1 = __nccwpck_require__(7533);
const helper_1 = __nccwpck_require__(7951);
const utils_1 = __nccwpck_require__(6416);
const network = __importStar(__nccwpck_require__(8781));
const wkConnection_1 = __nccwpck_require__(8380);
const wkPage_1 = __nccwpck_require__(6458);
const errors_1 = __nccwpck_require__(4949);
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.2 Safari/605.1.15';
const BROWSER_VERSION = '14.2';
class WKBrowser extends browser_1.Browser {
    constructor(transport, options) {
        super(options);
        this._contexts = new Map();
        this._wkPages = new Map();
        this._connection = new wkConnection_1.WKConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
        this._browserSession = this._connection.browserSession;
        this._eventListeners = [
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.pageProxyCreated', this._onPageProxyCreated.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.pageProxyDestroyed', this._onPageProxyDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.provisionalLoadFailed', event => this._onProvisionalLoadFailed(event)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.windowOpen', event => this._onWindowOpen(event)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.downloadCreated', this._onDownloadCreated.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.downloadFilenameSuggested', this._onDownloadFilenameSuggested.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.downloadFinished', this._onDownloadFinished.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.screencastFinished', this._onScreencastFinished.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, wkConnection_1.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this)),
        ];
    }
    static async connect(transport, options) {
        const browser = new WKBrowser(transport, options);
        if (options.__testHookOnConnectToBrowser)
            await options.__testHookOnConnectToBrowser();
        const promises = [
            browser._browserSession.send('Playwright.enable'),
        ];
        if (options.persistent) {
            browser._defaultContext = new WKBrowserContext(browser, undefined, options.persistent);
            promises.push(browser._defaultContext._initialize());
        }
        await Promise.all(promises);
        return browser;
    }
    _onDisconnect() {
        for (const wkPage of this._wkPages.values())
            wkPage.dispose(true);
        for (const video of this._idToVideo.values())
            video.artifact.reportFinished(errors_1.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
    }
    async newContext(options) {
        browserContext_1.validateBrowserContextOptions(options, this.options);
        const createOptions = options.proxy ? {
            proxyServer: options.proxy.server,
            proxyBypassList: options.proxy.bypass
        } : undefined;
        const { browserContextId } = await this._browserSession.send('Playwright.createContext', createOptions);
        options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
        const context = new WKBrowserContext(this, browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    version() {
        return BROWSER_VERSION;
    }
    _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
            return;
        // In some cases, e.g. blob url download, we receive only frameScheduledNavigation
        // but no signals that the navigation was canceled and replaced by download. Fix it
        // here by simulating cancelled provisional load which matches downloads from network.
        //
        // TODO: this is racy, because download might be unrelated any navigation, and we will
        // abort navgitation that is still running. We should be able to fix this by
        // instrumenting policy decision start/proceed/cancel.
        page._page._frameManager.frameAbortedNavigation(payload.frameId, 'Download is starting');
        let originPage = page._initializedPage;
        // If it's a new window download, report it on the opener page.
        if (!originPage) {
            // Resume the page creation with an error. The page will automatically close right
            // after the download begins.
            page._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));
            if (page._opener)
                originPage = page._opener._initializedPage;
        }
        if (!originPage)
            return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
    }
    _onDownloadFilenameSuggested(payload) {
        this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
    }
    _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
    }
    _onScreencastFinished(payload) {
        var _a;
        (_a = this._takeVideo(payload.screencastId)) === null || _a === void 0 ? void 0 : _a.reportFinished();
    }
    _onPageProxyCreated(event) {
        const pageProxyId = event.pageProxyId;
        let context = null;
        if (event.browserContextId) {
            // FIXME: we don't know about the default context id, so assume that all targets from
            // unknown contexts are created in the 'default' context which can in practice be represented
            // by multiple actual contexts in WebKit. Solving this properly will require adding context
            // lifecycle events.
            context = this._contexts.get(event.browserContextId) || null;
        }
        if (!context)
            context = this._defaultContext;
        if (!context)
            return;
        const pageProxySession = new wkConnection_1.WKSession(this._connection, pageProxyId, `The page has been closed.`, (message) => {
            this._connection.rawSend({ ...message, pageProxyId });
        });
        const opener = event.openerId ? this._wkPages.get(event.openerId) : undefined;
        const wkPage = new wkPage_1.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
    }
    _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
            return;
        wkPage.didClose();
        wkPage.dispose(false);
        this._wkPages.delete(pageProxyId);
    }
    _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
            return;
        wkPage.dispatchMessageToSession(event.message);
    }
    _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
            return;
        wkPage.handleProvisionalLoadFailed(event);
    }
    _onWindowOpen(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
            return;
        wkPage.handleWindowOpen(event);
    }
    isConnected() {
        return !this._connection.isClosed();
    }
}
exports.WKBrowser = WKBrowser;
class WKBrowserContext extends browserContext_1.BrowserContext {
    constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._browser = browser;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaHeader();
    }
    async _initialize() {
        utils_1.assert(!this._wkPages().length);
        const browserContextId = this._browserContextId;
        const promises = [super._initialize()];
        promises.push(this._browser._browserSession.send('Playwright.setDownloadBehavior', {
            behavior: this._options.acceptDownloads ? 'allow' : 'deny',
            downloadPath: this._browser.options.downloadsPath,
            browserContextId
        }));
        if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._browserSession.send('Playwright.setIgnoreCertificateErrors', { browserContextId, ignore: true }));
        if (this._options.locale)
            promises.push(this._browser._browserSession.send('Playwright.setLanguages', { browserContextId, languages: [this._options.locale] }));
        if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
        if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        await Promise.all(promises);
    }
    _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter(wkPage => wkPage._browserContext === this);
    }
    pages() {
        return this._wkPages().map(wkPage => wkPage._initializedPage).filter(pageOrNull => !!pageOrNull);
    }
    async newPageDelegate() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const { pageProxyId } = await this._browser._browserSession.send('Playwright.createPage', { browserContextId: this._browserContextId });
        return this._browser._wkPages.get(pageProxyId);
    }
    async _doCookies(urls) {
        const { cookies } = await this._browser._browserSession.send('Playwright.getAllCookies', { browserContextId: this._browserContextId });
        return network.filterCookies(cookies.map((c) => {
            const copy = { ...c };
            copy.expires = c.expires === -1 ? -1 : c.expires / 1000;
            delete copy.session;
            return copy;
        }), urls);
    }
    async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map(c => ({
            ...c,
            session: c.expires === -1 || c.expires === undefined,
            expires: c.expires && c.expires !== -1 ? c.expires * 1000 : c.expires
        }));
        await this._browser._browserSession.send('Playwright.setCookies', { cookies: cc, browserContextId: this._browserContextId });
    }
    async clearCookies() {
        await this._browser._browserSession.send('Playwright.deleteAllCookies', { browserContextId: this._browserContextId });
    }
    async _doGrantPermissions(origin, permissions) {
        await Promise.all(this.pages().map(page => page._delegate._grantPermissions(origin, permissions)));
    }
    async _doClearPermissions() {
        await Promise.all(this.pages().map(page => page._delegate._clearPermissions()));
    }
    async setGeolocation(geolocation) {
        browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation;
        const payload = geolocation ? { ...geolocation, timestamp: Date.now() } : undefined;
        await this._browser._browserSession.send('Playwright.setGeolocationOverride', { browserContextId: this._browserContextId, geolocation: payload });
    }
    async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        for (const page of this.pages())
            await page._delegate.updateExtraHTTPHeaders();
    }
    async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
            await page._delegate.updateOffline();
    }
    async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        for (const page of this.pages())
            await page._delegate.updateHttpCredentials();
    }
    async _doAddInitScript(source) {
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
            await page._delegate._updateBootstrapScript('main');
    }
    async _doExposeBinding(binding) {
        for (const page of this.pages())
            await page._delegate.exposeBinding(binding);
    }
    async _doUpdateRequestInterception() {
        for (const page of this.pages())
            await page._delegate.updateRequestInterception();
    }
    async _onClosePersistent() { }
    async _doClose() {
        utils_1.assert(this._browserContextId);
        await this._browser._browserSession.send('Playwright.deleteContext', { browserContextId: this._browserContextId });
        this._browser._contexts.delete(this._browserContextId);
    }
}
exports.WKBrowserContext = WKBrowserContext;
//# sourceMappingURL=wkBrowser.js.map

/***/ }),

/***/ 8380:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolError = exports.WKSession = exports.WKConnection = exports.kPageProxyMessageReceived = exports.kBrowserCloseMessageId = void 0;
const events_1 = __nccwpck_require__(8614);
const utils_1 = __nccwpck_require__(6416);
const stackTrace_1 = __nccwpck_require__(6010);
const debugLogger_1 = __nccwpck_require__(5203);
const helper_1 = __nccwpck_require__(7951);
const errors_1 = __nccwpck_require__(4949);
// WKPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
// We emulate kPageProxyMessageReceived message to unify it with Browser.pageProxyCreated
// and Browser.pageProxyDestroyed for easier management.
exports.kPageProxyMessageReceived = 'kPageProxyMessageReceived';
class WKConnection {
    constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
        this._lastId = 0;
        this._closed = false;
        this._transport = transport;
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._onDisconnect = onDisconnect;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.browserSession = new WKSession(this, '', errors_1.kBrowserClosedError, (message) => {
            this.rawSend(message);
        });
    }
    nextMessageId() {
        return ++this._lastId;
    }
    rawSend(message) {
        this._protocolLogger('send', message);
        this._transport.send(message);
    }
    _dispatchMessage(message) {
        this._protocolLogger('receive', message);
        if (message.id === exports.kBrowserCloseMessageId)
            return;
        if (message.pageProxyId) {
            const payload = { message: message, pageProxyId: message.pageProxyId };
            this.browserSession.dispatchMessage({ method: exports.kPageProxyMessageReceived, params: payload });
            return;
        }
        this.browserSession.dispatchMessage(message);
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        this.browserSession.dispose(true);
        this._onDisconnect();
    }
    isClosed() {
        return this._closed;
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
}
exports.WKConnection = WKConnection;
class WKSession extends events_1.EventEmitter {
    constructor(connection, sessionId, errorText, rawSend) {
        super();
        this._disposed = false;
        this._callbacks = new Map();
        this._crashed = false;
        this.setMaxListeners(0);
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    async send(method, params) {
        if (this._crashed)
            throw new Error('Target crashed');
        if (this._disposed)
            throw new Error(`Protocol error (${method}): ${this.errorText}`);
        const id = this.connection.nextMessageId();
        const messageObj = { id, method, params };
        this._rawSend(messageObj);
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    sendMayFail(method, params) {
        return this.send(method, params).catch(error => debugLogger_1.debugLogger.log('error', error));
    }
    markAsCrashed() {
        this._crashed = true;
    }
    isDisposed() {
        return this._disposed;
    }
    dispose(disconnected) {
        if (disconnected)
            this.errorText = 'Browser closed.' + helper_1.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());
        for (const callback of this._callbacks.values())
            callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): ${this.errorText}`));
        this._callbacks.clear();
        this._disposed = true;
    }
    dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object.error));
            else
                callback.resolve(object.result);
        }
        else if (object.id && !object.error) {
            // Response might come after session has been disposed and rejected all callbacks.
            utils_1.assert(this.isDisposed());
        }
        else {
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
}
exports.WKSession = WKSession;
function createProtocolError(error, method, protocolError) {
    let message = `Protocol error (${method}): ${protocolError.message}`;
    if ('data' in protocolError)
        message += ` ${JSON.stringify(protocolError.data)}`;
    return stackTrace_1.rewriteErrorMessage(error, message);
}
exports.createProtocolError = createProtocolError;
//# sourceMappingURL=wkConnection.js.map

/***/ }),

/***/ 7569:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WKExecutionContext = void 0;
const js = __importStar(__nccwpck_require__(1762));
const utilityScriptSerializers_1 = __nccwpck_require__(4734);
class WKExecutionContext {
    constructor(session, contextId) {
        this._contextDestroyedCallback = () => { };
        this._session = session;
        this._contextId = contextId;
        this._executionContextDestroyedPromise = new Promise((resolve, reject) => {
            this._contextDestroyedCallback = resolve;
        });
    }
    _dispose() {
        this._contextDestroyedCallback();
    }
    async rawEvaluateJSON(expression) {
        try {
            const response = await this._session.send('Runtime.evaluate', {
                expression,
                contextId: this._contextId,
                returnByValue: true
            });
            if (response.wasThrown)
                throw new Error('Evaluation failed: ' + response.result.description);
            return response.result.value;
        }
        catch (error) {
            throw rewriteError(error);
        }
    }
    async rawEvaluateHandle(expression) {
        try {
            const response = await this._session.send('Runtime.evaluate', {
                expression,
                contextId: this._contextId,
                returnByValue: false
            });
            if (response.wasThrown)
                throw new Error('Evaluation failed: ' + response.result.description);
            return response.result.objectId;
        }
        catch (error) {
            throw rewriteError(error);
        }
    }
    rawCallFunctionNoReply(func, ...args) {
        this._session.send('Runtime.callFunctionOn', {
            functionDeclaration: func.toString(),
            objectId: args.find(a => a instanceof js.JSHandle)._objectId,
            arguments: args.map(a => a instanceof js.JSHandle ? { objectId: a._objectId } : { value: a }),
            returnByValue: true,
            emulateUserGesture: true
        }).catch(() => { });
    }
    async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        try {
            const response = await Promise.race([
                this._executionContextDestroyedPromise.then(() => contextDestroyedResult),
                this._session.send('Runtime.callFunctionOn', {
                    functionDeclaration: expression,
                    objectId: utilityScript._objectId,
                    arguments: [
                        { objectId: utilityScript._objectId },
                        ...values.map(value => ({ value })),
                        ...objectIds.map(objectId => ({ objectId })),
                    ],
                    returnByValue,
                    emulateUserGesture: true,
                    awaitPromise: true
                })
            ]);
            if (response.wasThrown)
                throw new Error('Evaluation failed: ' + response.result.description);
            if (returnByValue)
                return utilityScriptSerializers_1.parseEvaluationResultValue(response.result.value);
            return utilityScript._context.createHandle(response.result);
        }
        catch (error) {
            throw rewriteError(error);
        }
    }
    async getProperties(context, objectId) {
        const response = await this._session.send('Runtime.getProperties', {
            objectId,
            ownProperties: true
        });
        const result = new Map();
        for (const property of response.properties) {
            if (!property.enumerable || !property.value)
                continue;
            result.set(property.name, context.createHandle(property.value));
        }
        return result;
    }
    createHandle(context, remoteObject) {
        const isPromise = remoteObject.className === 'Promise';
        return new js.JSHandle(context, isPromise ? 'promise' : remoteObject.subtype || remoteObject.type, remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
    }
    async releaseHandle(objectId) {
        await this._session.send('Runtime.releaseObject', { objectId });
    }
}
exports.WKExecutionContext = WKExecutionContext;
const contextDestroyedResult = {
    wasThrown: true,
    result: {
        description: 'Protocol error: Execution context was destroyed, most likely because of a navigation.'
    }
};
function potentiallyUnserializableValue(remoteObject) {
    const value = remoteObject.value;
    const isUnserializable = remoteObject.type === 'number' && ['NaN', '-Infinity', 'Infinity', '-0'].includes(remoteObject.description);
    return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
}
function rewriteError(error) {
    if (js.isContextDestroyedError(error))
        return new Error('Execution context was destroyed, most likely because of a navigation.');
    return error;
}
//# sourceMappingURL=wkExecutionContext.js.map

/***/ }),

/***/ 2927:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;
const input = __importStar(__nccwpck_require__(487));
const macEditingCommands_1 = __nccwpck_require__(3377);
const utils_1 = __nccwpck_require__(6416);
function toModifiersMask(modifiers) {
    // From Source/WebKit/Shared/WebEvent.h
    let mask = 0;
    if (modifiers.has('Shift'))
        mask |= 1;
    if (modifiers.has('Control'))
        mask |= 2;
    if (modifiers.has('Alt'))
        mask |= 4;
    if (modifiers.has('Meta'))
        mask |= 8;
    return mask;
}
class RawKeyboardImpl {
    constructor(session) {
        this._pageProxySession = session;
    }
    setSession(session) {
        this._session = session;
    }
    async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
        const parts = [];
        for (const modifier of (['Shift', 'Control', 'Alt', 'Meta'])) {
            if (modifiers.has(modifier))
                parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join('+');
        let commands = macEditingCommands_1.macEditingCommands[shortcut];
        if (utils_1.isString(commands))
            commands = [commands];
        await this._pageProxySession.send('Input.dispatchKeyEvent', {
            type: 'keyDown',
            modifiers: toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCode,
            code,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            macCommands: commands,
            isKeypad: location === input.keypadLocation
        });
    }
    async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
        await this._pageProxySession.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCode,
            code,
            isKeypad: location === input.keypadLocation
        });
    }
    async sendText(text) {
        await this._session.send('Page.insertText', { text });
    }
}
exports.RawKeyboardImpl = RawKeyboardImpl;
class RawMouseImpl {
    constructor(session) {
        this._pageProxySession = session;
    }
    async move(x, y, button, buttons, modifiers) {
        await this._pageProxySession.send('Input.dispatchMouseEvent', {
            type: 'move',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers)
        });
    }
    async down(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send('Input.dispatchMouseEvent', {
            type: 'down',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
    async up(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send('Input.dispatchMouseEvent', {
            type: 'up',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
}
exports.RawMouseImpl = RawMouseImpl;
class RawTouchscreenImpl {
    constructor(session) {
        this._pageProxySession = session;
    }
    async tap(x, y, modifiers) {
        await this._pageProxySession.send('Input.dispatchTapEvent', {
            x,
            y,
            modifiers: toModifiersMask(modifiers),
        });
    }
}
exports.RawTouchscreenImpl = RawTouchscreenImpl;
//# sourceMappingURL=wkInput.js.map

/***/ }),

/***/ 4716:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WKInterceptableRequest = void 0;
const network = __importStar(__nccwpck_require__(8781));
const utils_1 = __nccwpck_require__(6416);
const errorReasons = {
    'aborted': 'Cancellation',
    'accessdenied': 'AccessControl',
    'addressunreachable': 'General',
    'blockedbyclient': 'Cancellation',
    'blockedbyresponse': 'General',
    'connectionaborted': 'General',
    'connectionclosed': 'General',
    'connectionfailed': 'General',
    'connectionrefused': 'General',
    'connectionreset': 'General',
    'internetdisconnected': 'General',
    'namenotresolved': 'General',
    'timedout': 'Timeout',
    'failed': 'General',
};
class WKInterceptableRequest {
    constructor(session, allowInterception, frame, event, redirectedFrom, documentId) {
        this._interceptedCallback = () => { };
        this._session = session;
        this._requestId = event.requestId;
        this._allowInterception = allowInterception;
        const resourceType = event.type ? event.type.toLowerCase() : (redirectedFrom ? redirectedFrom.resourceType() : 'other');
        let postDataBuffer = null;
        this._timestamp = event.timestamp;
        this._wallTime = event.walltime * 1000;
        if (event.request.postData)
            postDataBuffer = Buffer.from(event.request.postData, 'base64');
        this.request = new network.Request(allowInterception ? this : null, frame, redirectedFrom, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, utils_1.headersObjectToArray(event.request.headers));
        this._interceptedPromise = new Promise(f => this._interceptedCallback = f);
    }
    async abort(errorCode) {
        const errorType = errorReasons[errorCode];
        utils_1.assert(errorType, 'Unknown error code: ' + errorCode);
        await this._interceptedPromise;
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._session.sendMayFail('Network.interceptRequestWithError', { requestId: this._requestId, errorType });
    }
    async fulfill(response) {
        if (300 <= response.status && response.status < 400)
            throw new Error('Cannot fulfill with redirect status: ' + response.status);
        await this._interceptedPromise;
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        let mimeType = response.isBase64 ? 'application/octet-stream' : 'text/plain';
        const headers = utils_1.headersArrayToObject(response.headers, false /* lowerCase */);
        const contentType = headers['content-type'];
        if (contentType)
            mimeType = contentType.split(';')[0].trim();
        await this._session.sendMayFail('Network.interceptRequestWithResponse', {
            requestId: this._requestId,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)],
            mimeType,
            headers,
            base64Encoded: response.isBase64,
            content: response.body
        });
    }
    async continue(overrides) {
        await this._interceptedPromise;
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._session.sendMayFail('Network.interceptWithRequest', {
            requestId: this._requestId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers ? utils_1.headersArrayToObject(overrides.headers, false /* lowerCase */) : undefined,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
        });
    }
    createResponse(responsePayload) {
        const getResponseBody = async () => {
            const response = await this._session.send('Network.getResponseBody', { requestId: this._requestId });
            return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
        };
        const timingPayload = responsePayload.timing;
        const timing = {
            startTime: this._wallTime,
            domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
            domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
            connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
            secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
            connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
            requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
            responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1,
        };
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, utils_1.headersObjectToArray(responsePayload.headers), timing, getResponseBody);
    }
}
exports.WKInterceptableRequest = WKInterceptableRequest;
function wkMillisToRoundishMillis(value) {
    // WebKit uses -1000 for unavailable.
    if (value === -1000)
        return -1;
    // WebKit has a bug, instead of -1 it sends -1000 to be in ms.
    if (value <= 0) {
        // DNS can start before request start on Mac Network Stack
        return -1;
    }
    return ((value * 1000) | 0) / 1000;
}
//# sourceMappingURL=wkInterceptableRequest.js.map

/***/ }),

/***/ 6458:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WKPage = void 0;
const jpeg = __importStar(__nccwpck_require__(2816));
const path_1 = __importDefault(__nccwpck_require__(5622));
const png = __importStar(__nccwpck_require__(5076));
const stackTrace_1 = __nccwpck_require__(6010);
const registry_1 = __nccwpck_require__(2981);
const utils_1 = __nccwpck_require__(6416);
const dialog = __importStar(__nccwpck_require__(7639));
const dom = __importStar(__nccwpck_require__(9418));
const helper_1 = __nccwpck_require__(7951);
const javascript_1 = __nccwpck_require__(1762);
const network = __importStar(__nccwpck_require__(8781));
const page_1 = __nccwpck_require__(9406);
const wkAccessibility_1 = __nccwpck_require__(8819);
const wkConnection_1 = __nccwpck_require__(8380);
const wkExecutionContext_1 = __nccwpck_require__(7569);
const wkInput_1 = __nccwpck_require__(2927);
const wkInterceptableRequest_1 = __nccwpck_require__(4716);
const wkProvisionalPage_1 = __nccwpck_require__(7763);
const wkWorkers_1 = __nccwpck_require__(3038);
const debugLogger_1 = __nccwpck_require__(5203);
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
const BINDING_CALL_MESSAGE = '__playwright_binding_call__';
class WKPage {
    constructor(browserContext, pageProxySession, opener) {
        this._provisionalPage = null;
        this._pagePromiseCallback = () => { };
        this._requestIdToRequest = new Map();
        this._sessionListeners = [];
        this._initializedPage = null;
        this._firstNonInitialNavigationCommittedFulfill = () => { };
        this._firstNonInitialNavigationCommittedReject = (e) => { };
        this._lastConsoleMessage = null;
        this._recordingVideoFile = null;
        this._screencastGeneration = 0;
        this._pageProxySession = pageProxySession;
        this._opener = opener;
        this.rawKeyboard = new wkInput_1.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new wkInput_1.RawMouseImpl(pageProxySession);
        this.rawTouchscreen = new wkInput_1.RawTouchscreenImpl(pageProxySession);
        this._contextIdToContext = new Map();
        this._page = new page_1.Page(this, browserContext);
        this._workers = new wkWorkers_1.WKWorkers(this._page);
        this._session = undefined;
        this._browserContext = browserContext;
        this._page.on(page_1.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
        this._eventListeners = [
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.targetCreated', this._onTargetCreated.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.dispatchMessageFromTarget', this._onDispatchMessageFromTarget.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.didCommitProvisionalTarget', this._onDidCommitProvisionalTarget.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Screencast.screencastFrame', this._onScreencastFrame.bind(this)),
        ];
        this._pagePromise = new Promise(f => this._pagePromiseCallback = f);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
            this._firstNonInitialNavigationCommittedFulfill = f;
            this._firstNonInitialNavigationCommittedReject = r;
        });
        if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
            const viewportSize = helper_1.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
            opener._nextWindowOpenPopupFeatures = undefined;
            if (viewportSize)
                this._page._state.emulatedSize = { viewport: viewportSize, screen: viewportSize };
        }
    }
    async _initializePageProxySession() {
        const promises = [
            this._pageProxySession.send('Dialog.enable'),
            this._pageProxySession.send('Emulation.setActiveAndFocused', { active: true }),
        ];
        const contextOptions = this._browserContext._options;
        if (contextOptions.javaScriptEnabled === false)
            promises.push(this._pageProxySession.send('Emulation.setJavaScriptEnabled', { enabled: false }));
        promises.push(this._updateViewport());
        promises.push(this.updateHttpCredentials());
        if (this._browserContext._permissions.size) {
            for (const [key, value] of this._browserContext._permissions)
                promises.push(this._grantPermissions(key, value));
        }
        if (this._browserContext._options.recordVideo) {
            const outputFile = path_1.default.join(this._browserContext._options.recordVideo.dir, utils_1.createGuid() + '.webm');
            promises.push(this._browserContext._ensureVideosPath().then(() => {
                return this._startVideo({
                    // validateBrowserContextOptions ensures correct video size.
                    ...this._browserContext._options.recordVideo.size,
                    outputFile,
                });
            }));
        }
        await Promise.all(promises);
    }
    _setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
    }
    // This method is called for provisional targets as well. The session passed as the parameter
    // may be different from the current session and may be destroyed without becoming current.
    async _initializeSession(session, provisional, resourceTreeHandler) {
        await this._initializeSessionMayThrow(session, resourceTreeHandler).catch(e => {
            // Provisional session can be disposed at any time, for example due to new navigation initiating
            // a new provisional page.
            if (provisional && session.isDisposed())
                return;
            // Swallow initialization errors due to newer target swap in,
            // since we will reinitialize again.
            if (this._session === session)
                throw e;
        });
    }
    async _initializeSessionMayThrow(session, resourceTreeHandler) {
        const [, frameTree] = await Promise.all([
            // Page agent must be enabled before Runtime.
            session.send('Page.enable'),
            session.send('Page.getResourceTree'),
        ]);
        resourceTreeHandler(frameTree);
        const promises = [
            // Resource tree should be received before first execution context.
            session.send('Runtime.enable'),
            session.send('Page.createUserWorld', { name: UTILITY_WORLD_NAME }).catch(_ => { }),
            session.send('Console.enable'),
            session.send('Network.enable'),
            this._workers.initializeSession(session)
        ];
        if (this._page._needsRequestInterception()) {
            promises.push(session.send('Network.setInterceptionEnabled', { enabled: true }));
            promises.push(session.send('Network.addInterception', { url: '.*', stage: 'request', isRegex: true }));
        }
        const contextOptions = this._browserContext._options;
        if (contextOptions.userAgent)
            promises.push(session.send('Page.overrideUserAgent', { value: contextOptions.userAgent }));
        if (this._page._state.mediaType || this._page._state.colorScheme || this._page._state.reducedMotion)
            promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme, this._page._state.reducedMotion));
        for (const world of ['main', 'utility']) {
            const bootstrapScript = this._calculateBootstrapScript(world);
            if (bootstrapScript.length)
                promises.push(session.send('Page.setBootstrapScript', { source: bootstrapScript, worldName: webkitWorldName(world) }));
            this._page.frames().map(frame => frame.evaluateExpression(bootstrapScript, false, undefined, world).catch(e => { }));
        }
        if (contextOptions.bypassCSP)
            promises.push(session.send('Page.setBypassCSP', { enabled: true }));
        if (this._page._state.emulatedSize) {
            promises.push(session.send('Page.setScreenSizeOverride', {
                width: this._page._state.emulatedSize.screen.width,
                height: this._page._state.emulatedSize.screen.height,
            }));
        }
        promises.push(this.updateEmulateMedia());
        promises.push(session.send('Network.setExtraHTTPHeaders', { headers: utils_1.headersArrayToObject(this._calculateExtraHTTPHeaders(), false /* lowerCase */) }));
        if (contextOptions.offline)
            promises.push(session.send('Network.setEmulateOfflineState', { offline: true }));
        promises.push(session.send('Page.setTouchEmulationEnabled', { enabled: !!contextOptions.hasTouch }));
        if (contextOptions.timezoneId) {
            promises.push(session.send('Page.setTimeZone', { timeZone: contextOptions.timezoneId }).
                catch(e => { throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`); }));
        }
        await Promise.all(promises);
    }
    _onDidCommitProvisionalTarget(event) {
        const { oldTargetId, newTargetId } = event;
        utils_1.assert(this._provisionalPage);
        utils_1.assert(this._provisionalPage._session.sessionId === newTargetId, 'Unknown new target: ' + newTargetId);
        utils_1.assert(this._session.sessionId === oldTargetId, 'Unknown old target: ' + oldTargetId);
        this._session.errorText = javascript_1.kSwappedOutErrorMessage;
        const newSession = this._provisionalPage._session;
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(newSession);
    }
    _onTargetDestroyed(event) {
        const { targetId, crashed } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
            this._provisionalPage._session.dispose(false);
            this._provisionalPage.dispose();
            this._provisionalPage = null;
        }
        else if (this._session.sessionId === targetId) {
            this._session.dispose(false);
            helper_1.helper.removeEventListeners(this._sessionListeners);
            if (crashed) {
                this._session.markAsCrashed();
                this._page._didCrash();
            }
        }
    }
    didClose() {
        this._page._didClose();
    }
    dispose(disconnected) {
        this._pageProxySession.dispose(disconnected);
        helper_1.helper.removeEventListeners(this._sessionListeners);
        helper_1.helper.removeEventListeners(this._eventListeners);
        if (this._session)
            this._session.dispose(disconnected);
        if (this._provisionalPage) {
            this._provisionalPage._session.dispose(disconnected);
            this._provisionalPage.dispose();
            this._provisionalPage = null;
        }
        this._page._didDisconnect();
        this._firstNonInitialNavigationCommittedReject(new Error('Page closed'));
    }
    dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
    }
    handleProvisionalLoadFailed(event) {
        if (!this._initializedPage) {
            this._firstNonInitialNavigationCommittedReject(new Error('Initial load failed'));
            return;
        }
        if (!this._provisionalPage)
            return;
        let errorText = event.error;
        if (errorText.includes('cancelled'))
            errorText += '; maybe frame was detached?';
        this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
    }
    handleWindowOpen(event) {
        utils_1.debugAssert(!this._nextWindowOpenPopupFeatures);
        this._nextWindowOpenPopupFeatures = event.windowFeatures;
    }
    async pageOrError() {
        return this._pagePromise;
    }
    async _onTargetCreated(event) {
        const { targetInfo } = event;
        const session = new wkConnection_1.WKSession(this._pageProxySession.connection, targetInfo.targetId, `The ${targetInfo.type} has been closed.`, (message) => {
            this._pageProxySession.send('Target.sendMessageToTarget', {
                message: JSON.stringify(message), targetId: targetInfo.targetId
            }).catch(e => {
                session.dispatchMessage({ id: message.id, error: { message: e.message } });
            });
        });
        utils_1.assert(targetInfo.type === 'page', 'Only page targets are expected in WebKit, received: ' + targetInfo.type);
        if (!targetInfo.isProvisional) {
            utils_1.assert(!this._initializedPage);
            let pageOrError;
            try {
                this._setSession(session);
                await Promise.all([
                    this._initializePageProxySession(),
                    this._initializeSession(session, false, ({ frameTree }) => this._handleFrameTree(frameTree)),
                ]);
                pageOrError = this._page;
            }
            catch (e) {
                pageOrError = e;
            }
            if (targetInfo.isPaused)
                this._pageProxySession.sendMayFail('Target.resume', { targetId: targetInfo.targetId });
            if ((pageOrError instanceof page_1.Page) && this._page.mainFrame().url() === '') {
                try {
                    // Initial empty page has an empty url. We should wait until the first real url has been loaded,
                    // even if that url is about:blank. This is especially important for popups, where we need the
                    // actual url before interacting with it.
                    await this._firstNonInitialNavigationCommittedPromise;
                }
                catch (e) {
                    pageOrError = e;
                }
            }
            else {
                // Avoid rejection on disconnect.
                this._firstNonInitialNavigationCommittedPromise.catch(() => { });
            }
            await this._page.initOpener(this._opener);
            // Note: it is important to call |reportAsNew| before resolving pageOrError promise,
            // so that anyone who awaits pageOrError got a ready and reported page.
            this._initializedPage = pageOrError instanceof page_1.Page ? pageOrError : null;
            this._page.reportAsNew(pageOrError instanceof page_1.Page ? undefined : pageOrError);
            this._pagePromiseCallback(pageOrError);
        }
        else {
            utils_1.assert(targetInfo.isProvisional);
            utils_1.assert(!this._provisionalPage);
            this._provisionalPage = new wkProvisionalPage_1.WKProvisionalPage(session, this);
            if (targetInfo.isPaused) {
                this._provisionalPage.initializationPromise.then(() => {
                    this._pageProxySession.sendMayFail('Target.resume', { targetId: targetInfo.targetId });
                });
            }
        }
    }
    _onDispatchMessageFromTarget(event) {
        const { targetId, message } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
            this._provisionalPage._session.dispatchMessage(JSON.parse(message));
        else if (this._session.sessionId === targetId)
            this._session.dispatchMessage(JSON.parse(message));
        else
            throw new Error('Unknown target: ' + targetId);
    }
    _addSessionListeners() {
        // TODO: remove Page.willRequestOpenWindow and Page.didRequestOpenWindow from the protocol.
        this._sessionListeners = [
            helper_1.helper.addEventListener(this._session, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)),
            helper_1.helper.addEventListener(this._session, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
            helper_1.helper.addEventListener(this._session, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameScheduledNavigation', event => this._onFrameScheduledNavigation(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.loadEventFired', event => this._onLifecycleEvent(event.frameId, 'load')),
            helper_1.helper.addEventListener(this._session, 'Page.domContentEventFired', event => this._onLifecycleEvent(event.frameId, 'domcontentloaded')),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)),
            helper_1.helper.addEventListener(this._session, 'Console.messageAdded', event => this._onConsoleMessage(event)),
            helper_1.helper.addEventListener(this._session, 'Console.messageRepeatCountUpdated', event => this._onConsoleRepeatCountUpdated(event)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Dialog.javascriptDialogOpening', event => this._onDialog(event)),
            helper_1.helper.addEventListener(this._session, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)),
            helper_1.helper.addEventListener(this._session, 'Network.requestWillBeSent', e => this._onRequestWillBeSent(this._session, e)),
            helper_1.helper.addEventListener(this._session, 'Network.requestIntercepted', e => this._onRequestIntercepted(e)),
            helper_1.helper.addEventListener(this._session, 'Network.responseReceived', e => this._onResponseReceived(e)),
            helper_1.helper.addEventListener(this._session, 'Network.loadingFinished', e => this._onLoadingFinished(e)),
            helper_1.helper.addEventListener(this._session, 'Network.loadingFailed', e => this._onLoadingFailed(e)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketCreated', e => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketWillSendHandshakeRequest', e => this._page._frameManager.onWebSocketRequest(e.requestId)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketHandshakeResponseReceived', e => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketClosed', e => this._page._frameManager.webSocketClosed(e.requestId)),
            helper_1.helper.addEventListener(this._session, 'Network.webSocketFrameError', e => this._page._frameManager.webSocketError(e.requestId, e.errorMessage)),
        ];
    }
    async _updateState(method, params) {
        await this._forAllSessions(session => session.send(method, params).then());
    }
    async _forAllSessions(callback) {
        const sessions = [
            this._session
        ];
        // If the state changes during provisional load, push it to the provisional page
        // as well to always be in sync with the backend.
        if (this._provisionalPage)
            sessions.push(this._provisionalPage._session);
        await Promise.all(sessions.map(session => callback(session).catch(e => { })));
    }
    _onFrameScheduledNavigation(frameId) {
        this._page._frameManager.frameRequestedNavigation(frameId);
    }
    _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
    }
    _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
    }
    _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, 'domcontentloaded');
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, 'load');
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
    }
    _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        utils_1.assert(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
            this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);
        if (!initial)
            this._firstNonInitialNavigationCommittedFulfill();
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
    }
    _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
    }
    _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
            if (context.frame === frame) {
                context._delegate._dispose();
                this._contextIdToContext.delete(contextId);
                if (notifyFrame)
                    frame._contextDestroyed(context);
            }
        }
    }
    _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
            return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
            return;
        const delegate = new wkExecutionContext_1.WKExecutionContext(this._session, contextPayload.id);
        let worldName = null;
        if (contextPayload.type === 'normal')
            worldName = 'main';
        else if (contextPayload.type === 'user' && contextPayload.name === UTILITY_WORLD_NAME)
            worldName = 'utility';
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        if (worldName)
            frame._contextCreated(worldName, context);
        if (contextPayload.type === 'normal' && frame === this._page.mainFrame())
            this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
    }
    async navigateFrame(frame, url, referrer) {
        if (this._pageProxySession.isDisposed())
            throw new Error('Target closed');
        const pageProxyId = this._pageProxySession.sessionId;
        const result = await this._pageProxySession.connection.browserSession.send('Playwright.navigate', { url, pageProxyId, frameId: frame._id, referrer });
        return { newDocumentId: result.loaderId };
    }
    _onConsoleMessage(event) {
        // Note: do no introduce await in this function, otherwise we lose the ordering.
        // For example, frame.setContent relies on this.
        const { type, level, text, parameters, url, line: lineNumber, column: columnNumber, source } = event.message;
        if (level === 'debug' && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
            const parsedObjectId = JSON.parse(parameters[1].objectId);
            const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
            this.pageOrError().then(pageOrError => {
                if (!(pageOrError instanceof Error))
                    this._page._onBindingCalled(parameters[2].value, context);
            });
            return;
        }
        if (level === 'error' && source === 'javascript') {
            const { name, message } = stackTrace_1.splitErrorMessage(text);
            const error = new Error(message);
            if (event.message.stackTrace) {
                error.stack = event.message.stackTrace.map(callFrame => {
                    return `${callFrame.functionName}@${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber}`;
                }).join('\n');
            }
            else {
                error.stack = '';
            }
            error.name = name;
            this._page.emit(page_1.Page.Events.PageError, error);
            return;
        }
        let derivedType = type || '';
        if (type === 'log')
            derivedType = level;
        else if (type === 'timing')
            derivedType = 'timeEnd';
        const handles = (parameters || []).map(p => {
            let context = null;
            if (p.objectId) {
                const objectId = JSON.parse(p.objectId);
                context = this._contextIdToContext.get(objectId.injectedScriptId);
            }
            else {
                context = this._contextIdToContext.get(this._mainFrameContextId);
            }
            return context.createHandle(p);
        });
        this._lastConsoleMessage = {
            derivedType,
            text,
            handles,
            count: 0,
            location: {
                url: url || '',
                lineNumber: (lineNumber || 1) - 1,
                columnNumber: (columnNumber || 1) - 1,
            }
        };
        this._onConsoleRepeatCountUpdated({ count: 1 });
    }
    _onConsoleRepeatCountUpdated(event) {
        if (this._lastConsoleMessage) {
            const { derivedType, text, handles, count, location } = this._lastConsoleMessage;
            for (let i = count; i < event.count; ++i)
                this._page._addConsoleMessage(derivedType, handles, location, handles.length ? undefined : text);
            this._lastConsoleMessage.count = event.count;
        }
    }
    _onDialog(event) {
        this._page.emit(page_1.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
            await this._pageProxySession.send('Dialog.handleJavaScriptDialog', { accept, promptText });
        }, event.defaultPrompt));
    }
    async _onFileChooserOpened(event) {
        let handle;
        try {
            const context = await this._page._frameManager.frame(event.frameId)._mainContext();
            handle = context.createHandle(event.element).asElement();
        }
        catch (e) {
            // During async processing, frame/context may go away. We should not throw.
            return;
        }
        await this._page._onFileChooserOpened(handle);
    }
    static async _setEmulateMedia(session, mediaType, colorScheme, reducedMotion) {
        const promises = [];
        promises.push(session.send('Page.setEmulatedMedia', { media: mediaType || '' }));
        let appearance = undefined;
        switch (colorScheme) {
            case 'light':
                appearance = 'Light';
                break;
            case 'dark':
                appearance = 'Dark';
                break;
        }
        promises.push(session.send('Page.setForcedAppearance', { appearance }));
        let reducedMotionWk = undefined;
        switch (reducedMotion) {
            case 'reduce':
                reducedMotionWk = 'Reduce';
                break;
            case 'no-preference':
                reducedMotionWk = 'NoPreference';
                break;
        }
        promises.push(session.send('Page.setForcedReducedMotion', { reducedMotion: reducedMotionWk }));
        await Promise.all(promises);
    }
    async updateExtraHTTPHeaders() {
        await this._updateState('Network.setExtraHTTPHeaders', { headers: utils_1.headersArrayToObject(this._calculateExtraHTTPHeaders(), false /* lowerCase */) });
    }
    _calculateExtraHTTPHeaders() {
        const locale = this._browserContext._options.locale;
        const headers = network.mergeHeaders([
            this._browserContext._options.extraHTTPHeaders,
            this._page._state.extraHTTPHeaders,
            locale ? network.singleHeader('Accept-Language', locale) : undefined,
        ]);
        return headers;
    }
    async updateEmulateMedia() {
        const colorScheme = this._page._state.colorScheme;
        const reducedMotion = this._page._state.reducedMotion;
        await this._forAllSessions(session => WKPage._setEmulateMedia(session, this._page._state.mediaType, colorScheme, reducedMotion));
    }
    async setEmulatedSize(emulatedSize) {
        utils_1.assert(this._page._state.emulatedSize === emulatedSize);
        await this._updateViewport();
    }
    async bringToFront() {
        this._pageProxySession.send('Target.activate', {
            targetId: this._session.sessionId
        });
    }
    async _updateViewport() {
        const options = this._browserContext._options;
        const deviceSize = this._page._state.emulatedSize;
        if (deviceSize === null)
            return;
        const viewportSize = deviceSize.viewport;
        const screenSize = deviceSize.screen;
        const promises = [
            this._pageProxySession.send('Emulation.setDeviceMetricsOverride', {
                width: viewportSize.width,
                height: viewportSize.height,
                fixedLayout: !!options.isMobile,
                deviceScaleFactor: options.deviceScaleFactor || 1
            }),
            this._session.send('Page.setScreenSizeOverride', {
                width: screenSize.width,
                height: screenSize.height,
            }),
        ];
        if (options.isMobile) {
            const angle = viewportSize.width > viewportSize.height ? 90 : 0;
            promises.push(this._session.send('Page.setOrientationOverride', { angle }));
        }
        await Promise.all(promises);
    }
    async updateRequestInterception() {
        const enabled = this._page._needsRequestInterception();
        await Promise.all([
            this._updateState('Network.setInterceptionEnabled', { enabled }),
            this._updateState('Network.addInterception', { url: '.*', stage: 'request', isRegex: true })
        ]);
    }
    async updateOffline() {
        await this._updateState('Network.setEmulateOfflineState', { offline: !!this._browserContext._options.offline });
    }
    async updateHttpCredentials() {
        const credentials = this._browserContext._options.httpCredentials || { username: '', password: '' };
        await this._pageProxySession.send('Emulation.setAuthCredentials', { username: credentials.username, password: credentials.password });
    }
    async setFileChooserIntercepted(enabled) {
        await this._session.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async reload() {
        await this._session.send('Page.reload');
    }
    goBack() {
        return this._session.send('Page.goBack').then(() => true).catch(error => {
            if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`))
                return false;
            throw error;
        });
    }
    goForward() {
        return this._session.send('Page.goForward').then(() => true).catch(error => {
            if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`))
                return false;
            throw error;
        });
    }
    async exposeBinding(binding) {
        await this._updateBootstrapScript(binding.world);
        await this._evaluateBindingScript(binding);
    }
    async _evaluateBindingScript(binding) {
        const script = this._bindingToScript(binding);
        await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(script, false, {}, binding.world).catch(e => { })));
    }
    async evaluateOnNewDocument(script) {
        await this._updateBootstrapScript('main');
    }
    _bindingToScript(binding) {
        return `self.${binding.name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${binding.source}`;
    }
    _calculateBootstrapScript(world) {
        const scripts = [];
        for (const binding of this._page.allBindings()) {
            if (binding.world === world)
                scripts.push(this._bindingToScript(binding));
        }
        if (world === 'main') {
            scripts.push(...this._browserContext._evaluateOnNewDocumentSources);
            scripts.push(...this._page._evaluateOnNewDocumentSources);
        }
        return scripts.join(';');
    }
    async _updateBootstrapScript(world) {
        await this._updateState('Page.setBootstrapScript', { source: this._calculateBootstrapScript(world), worldName: webkitWorldName(world) });
    }
    async closePage(runBeforeUnload) {
        await this._stopVideo();
        await this._pageProxySession.sendMayFail('Target.close', {
            targetId: this._session.sessionId,
            runBeforeUnload
        });
    }
    canScreenshotOutsideViewport() {
        return true;
    }
    async setBackgroundColor(color) {
        await this._session.send('Page.setDefaultBackgroundColorOverride', { color });
    }
    _toolbarHeight() {
        var _a;
        if ((_a = this._page._browserContext._browser) === null || _a === void 0 ? void 0 : _a.options.headful)
            return registry_1.hostPlatform.startsWith('10.15') ? 55 : 59;
        return 0;
    }
    async _startVideo(options) {
        utils_1.assert(!this._recordingVideoFile);
        const START_VIDEO_PROTOCOL_COMMAND = registry_1.hostPlatform === 'mac10.14' ? 'Screencast.start' : 'Screencast.startVideo';
        const { screencastId } = await this._pageProxySession.send(START_VIDEO_PROTOCOL_COMMAND, {
            file: options.outputFile,
            width: options.width,
            height: options.height,
            toolbarHeight: this._toolbarHeight()
        });
        this._recordingVideoFile = options.outputFile;
        this._browserContext._browser._videoStarted(this._browserContext, screencastId, options.outputFile, this.pageOrError());
    }
    async _stopVideo() {
        if (!this._recordingVideoFile)
            return;
        const STOP_VIDEO_PROTOCOL_COMMAND = registry_1.hostPlatform === 'mac10.14' ? 'Screencast.stop' : 'Screencast.stopVideo';
        await this._pageProxySession.sendMayFail(STOP_VIDEO_PROTOCOL_COMMAND);
        this._recordingVideoFile = null;
    }
    async takeScreenshot(progress, format, documentRect, viewportRect, quality) {
        const rect = (documentRect || viewportRect);
        const result = await this._session.send('Page.snapshotRect', { ...rect, coordinateSystem: documentRect ? 'Page' : 'Viewport' });
        const prefix = 'data:image/png;base64,';
        let buffer = Buffer.from(result.dataURL.substr(prefix.length), 'base64');
        if (format === 'jpeg')
            buffer = jpeg.encode(png.PNG.sync.read(buffer), quality).data;
        return buffer;
    }
    async resetViewport() {
        utils_1.assert(false, 'Should not be called');
    }
    async getContentFrame(handle) {
        const nodeInfo = await this._session.send('DOM.describeNode', {
            objectId: handle._objectId
        });
        if (!nodeInfo.contentFrameId)
            return null;
        return this._page._frameManager.frame(nodeInfo.contentFrameId);
    }
    async getOwnerFrame(handle) {
        if (!handle._objectId)
            return null;
        const nodeInfo = await this._session.send('DOM.describeNode', {
            objectId: handle._objectId
        });
        return nodeInfo.ownerFrameId || null;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
            return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
            for (const point of quad) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._session.send('DOM.scrollIntoViewIfNeeded', {
            objectId: handle._objectId,
            rect,
        }).then(() => 'done').catch(e => {
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                return 'error:notvisible';
            if (e instanceof Error && e.message.includes('Node is detached from document'))
                return 'error:notconnected';
            throw e;
        });
    }
    async setScreencastOptions(options) {
        if (options) {
            const so = { ...options, toolbarHeight: this._toolbarHeight() };
            const { generation } = await this._pageProxySession.send('Screencast.startScreencast', so);
            this._screencastGeneration = generation;
        }
        else {
            await this._pageProxySession.send('Screencast.stopScreencast');
        }
    }
    _onScreencastFrame(event) {
        this._pageProxySession.send('Screencast.screencastFrameAck', { generation: this._screencastGeneration }).catch(e => debugLogger_1.debugLogger.log('error', e));
        const buffer = Buffer.from(event.data, 'base64');
        this._page.emit(page_1.Page.Events.ScreencastFrame, {
            buffer,
            width: event.deviceWidth,
            height: event.deviceHeight,
        });
    }
    rafCountForStablePosition() {
        return process.platform === 'win32' ? 5 : 1;
    }
    async getContentQuads(handle) {
        const result = await this._session.sendMayFail('DOM.getContentQuads', {
            objectId: handle._objectId
        });
        if (!result)
            return null;
        return result.quads.map(quad => [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] }
        ]);
    }
    async setInputFiles(handle, files) {
        const objectId = handle._objectId;
        const protocolFiles = files.map(file => ({
            name: file.name,
            type: file.mimeType,
            data: file.buffer,
        }));
        await this._session.send('DOM.setInputFiles', { objectId, files: protocolFiles });
    }
    async adoptElementHandle(handle, to) {
        const result = await this._session.sendMayFail('DOM.resolveNode', {
            objectId: handle._objectId,
            executionContextId: to._delegate._contextId
        });
        if (!result || result.object.subtype === 'null')
            throw new Error(dom.kUnableToAdoptErrorMessage);
        return to.createHandle(result.object);
    }
    async getAccessibilityTree(needle) {
        return wkAccessibility_1.getAccessibilityTree(this._session, needle);
    }
    async inputActionEpilogue() {
    }
    async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const handles = await this._page.selectors._queryAll(parent, 'frame,iframe', undefined);
        const items = await Promise.all(handles.map(async (handle) => {
            const frame = await handle.contentFrame().catch(e => null);
            return { handle, frame };
        }));
        const result = items.find(item => item.frame === frame);
        items.map(item => item === result ? Promise.resolve() : item.handle.dispose());
        if (!result)
            throw new Error('Frame has been detached.');
        return result.handle;
    }
    _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith('data:'))
            return;
        let redirectedFrom = null;
        if (event.redirectResponse) {
            const request = this._requestIdToRequest.get(event.requestId);
            // If we connect late to the target, we could have missed the requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, event.redirectResponse, event.timestamp);
                redirectedFrom = request.request;
            }
        }
        const frame = redirectedFrom ? redirectedFrom.frame() : this._page._frameManager.frame(event.frameId);
        // sometimes we get stray network events for detached frames
        // TODO(einbinder) why?
        if (!frame)
            return;
        // TODO(einbinder) this will fail if we are an XHR document request
        const isNavigationRequest = event.type === 'Document';
        const documentId = isNavigationRequest ? event.loaderId : undefined;
        // We do not support intercepting redirects.
        const allowInterception = this._page._needsRequestInterception() && !redirectedFrom;
        const request = new wkInterceptableRequest_1.WKInterceptableRequest(session, allowInterception, frame, event, redirectedFrom, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = request.createResponse(responsePayload);
        response._requestFinished(responsePayload.timing ? helper_1.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1, 'Response body is unavailable for redirect responses');
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
    }
    _onRequestIntercepted(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request) {
            this._session.sendMayFail('Network.interceptRequestWithError', { errorType: 'Cancellation', requestId: event.requestId });
            return;
        }
        if (!request._allowInterception) {
            // Intercepted, although we do not intend to allow interception.
            // Just continue.
            this._session.sendMayFail('Network.interceptWithRequest', { requestId: request._requestId });
        }
        else {
            request._interceptedCallback();
        }
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = request.createResponse(event.response);
        if (event.response.requestHeaders && Object.keys(event.response.requestHeaders).length)
            request.request.updateWithRawHeaders(utils_1.headersObjectToArray(event.response.requestHeaders));
        this._page._frameManager.requestReceivedResponse(response);
        if (response.status() === 204) {
            this._onLoadingFailed({
                requestId: event.requestId,
                errorText: 'Aborted: 204 No Content',
                timestamp: event.timestamp
            });
        }
    }
    _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        const response = request.request._existingResponse();
        if (response)
            response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestFinished(request.request);
    }
    _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        const response = request.request._existingResponse();
        if (response)
            response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes('cancelled'));
    }
    async _grantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
            ['geolocation', 'geolocation'],
        ]);
        const filtered = permissions.map(permission => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._pageProxySession.send('Emulation.grantPermissions', { origin, permissions: filtered });
    }
    async _clearPermissions() {
        await this._pageProxySession.send('Emulation.resetPermissions', {});
    }
}
exports.WKPage = WKPage;
function webkitWorldName(world) {
    switch (world) {
        case 'main': return undefined;
        case 'utility': return UTILITY_WORLD_NAME;
    }
}
//# sourceMappingURL=wkPage.js.map

/***/ }),

/***/ 7763:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WKProvisionalPage = void 0;
const helper_1 = __nccwpck_require__(7951);
const utils_1 = __nccwpck_require__(6416);
class WKProvisionalPage {
    constructor(session, page) {
        this._sessionListeners = [];
        this._mainFrameId = null;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler) => {
            return (payload) => {
                // Pretend that the events happened in the same process.
                if (payload.frameId)
                    payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
                handler(payload);
            };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSent', overrideFrameId(e => wkPage._onRequestWillBeSent(session, e))),
            helper_1.helper.addEventListener(session, 'Network.requestIntercepted', overrideFrameId(e => wkPage._onRequestIntercepted(e))),
            helper_1.helper.addEventListener(session, 'Network.responseReceived', overrideFrameId(e => wkPage._onResponseReceived(e))),
            helper_1.helper.addEventListener(session, 'Network.loadingFinished', overrideFrameId(e => wkPage._onLoadingFinished(e))),
            helper_1.helper.addEventListener(session, 'Network.loadingFailed', overrideFrameId(e => wkPage._onLoadingFailed(e))),
        ];
        this.initializationPromise = this._wkPage._initializeSession(session, true, ({ frameTree }) => this._handleFrameTree(frameTree));
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._sessionListeners);
    }
    commit() {
        utils_1.assert(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
    }
    _handleFrameTree(frameTree) {
        utils_1.assert(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
    }
}
exports.WKProvisionalPage = WKProvisionalPage;
//# sourceMappingURL=wkProvisionalPage.js.map

/***/ }),

/***/ 3038:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2019 Microsoft Corporation All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WKWorkers = void 0;
const helper_1 = __nccwpck_require__(7951);
const page_1 = __nccwpck_require__(9406);
const wkConnection_1 = __nccwpck_require__(8380);
const wkExecutionContext_1 = __nccwpck_require__(7569);
class WKWorkers {
    constructor(page) {
        this._sessionListeners = [];
        this._workerSessions = new Map();
        this._page = page;
    }
    setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [
            helper_1.helper.addEventListener(session, 'Worker.workerCreated', (event) => {
                const worker = new page_1.Worker(this._page, event.url);
                const workerSession = new wkConnection_1.WKSession(session.connection, event.workerId, 'Most likely the worker has been closed.', (message) => {
                    session.send('Worker.sendMessageToWorker', {
                        workerId: event.workerId,
                        message: JSON.stringify(message)
                    }).catch(e => {
                        workerSession.dispatchMessage({ id: message.id, error: { message: e.message } });
                    });
                });
                this._workerSessions.set(event.workerId, workerSession);
                worker._createExecutionContext(new wkExecutionContext_1.WKExecutionContext(workerSession, undefined));
                this._page._addWorker(event.workerId, worker);
                workerSession.on('Console.messageAdded', event => this._onConsoleMessage(worker, event));
                Promise.all([
                    workerSession.send('Runtime.enable'),
                    workerSession.send('Console.enable'),
                    session.send('Worker.initialized', { workerId: event.workerId })
                ]).catch(e => {
                    // Worker can go as we are initializing it.
                    this._page._removeWorker(event.workerId);
                });
            }),
            helper_1.helper.addEventListener(session, 'Worker.dispatchMessageFromWorker', (event) => {
                const workerSession = this._workerSessions.get(event.workerId);
                if (!workerSession)
                    return;
                workerSession.dispatchMessage(JSON.parse(event.message));
            }),
            helper_1.helper.addEventListener(session, 'Worker.workerTerminated', (event) => {
                const workerSession = this._workerSessions.get(event.workerId);
                if (!workerSession)
                    return;
                workerSession.dispose(false);
                this._workerSessions.delete(event.workerId);
                this._page._removeWorker(event.workerId);
            })
        ];
    }
    clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
    }
    async initializeSession(session) {
        await session.send('Worker.enable');
    }
    async _onConsoleMessage(worker, event) {
        const { type, level, text, parameters, url, line: lineNumber, column: columnNumber } = event.message;
        let derivedType = type || '';
        if (type === 'log')
            derivedType = level;
        else if (type === 'timing')
            derivedType = 'timeEnd';
        const handles = (parameters || []).map(p => {
            return worker._existingExecutionContext.createHandle(p);
        });
        const location = {
            url: url || '',
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
        };
        this._page._addConsoleMessage(derivedType, handles, location, handles.length ? undefined : text);
    }
}
exports.WKWorkers = WKWorkers;
//# sourceMappingURL=wkWorkers.js.map

/***/ }),

/***/ 1232:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.printDepsWindowsExecutable = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const path_1 = __importDefault(__nccwpck_require__(5622));
function printDepsWindowsExecutable() {
    return pathToExecutable(['bin', 'PrintDeps.exe']);
}
exports.printDepsWindowsExecutable = printDepsWindowsExecutable;
function pathToExecutable(relative) {
    try {
        const defaultPath = path_1.default.join(__dirname, '..', '..', ...relative);
        if (fs_1.default.existsSync(defaultPath))
            return defaultPath;
    }
    catch (e) {
    }
}
//# sourceMappingURL=binaryPaths.js.map

/***/ }),

/***/ 5203:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecentLogsCollector = exports.debugLogger = void 0;
const debug_1 = __importDefault(__nccwpck_require__(2423));
const fs_1 = __importDefault(__nccwpck_require__(5747));
const debugLoggerColorMap = {
    'api': 45,
    'protocol': 34,
    'install': 34,
    'browser': 0,
    'proxy': 92,
    'error': 160,
    'channel:command': 33,
    'channel:response': 202,
    'channel:event': 207, // magenta
};
class DebugLogger {
    constructor() {
        this._debuggers = new Map();
        if (process.env.DEBUG_FILE) {
            const ansiRegex = new RegExp([
                '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
                '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
            ].join('|'), 'g');
            const stream = fs_1.default.createWriteStream(process.env.DEBUG_FILE);
            debug_1.default.log = (data) => {
                stream.write(data.replace(ansiRegex, ''));
                stream.write('\n');
            };
        }
    }
    log(name, message) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
            cachedDebugger = debug_1.default(`pw:${name}`);
            this._debuggers.set(name, cachedDebugger);
            cachedDebugger.color = debugLoggerColorMap[name];
        }
        cachedDebugger(message);
    }
    isEnabled(name) {
        return debug_1.default.enabled(`pw:${name}`);
    }
}
exports.debugLogger = new DebugLogger();
const kLogCount = 50;
class RecentLogsCollector {
    constructor() {
        this._logs = [];
    }
    log(message) {
        this._logs.push(message);
        if (this._logs.length === kLogCount * 2)
            this._logs.splice(0, kLogCount);
    }
    recentLogs() {
        if (this._logs.length > kLogCount)
            return this._logs.slice(-kLogCount);
        return this._logs;
    }
}
exports.RecentLogsCollector = RecentLogsCollector;
//# sourceMappingURL=debugLogger.js.map

/***/ }),

/***/ 4949:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSafeCloseError = exports.kBrowserOrContextClosedError = exports.kBrowserClosedError = exports.TimeoutError = void 0;
class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
class TimeoutError extends CustomError {
}
exports.TimeoutError = TimeoutError;
exports.kBrowserClosedError = 'Browser has been closed';
exports.kBrowserOrContextClosedError = 'Target page, context or browser has been closed';
function isSafeCloseError(error) {
    return error.message.endsWith(exports.kBrowserClosedError) || error.message.endsWith(exports.kBrowserOrContextClosedError);
}
exports.isSafeCloseError = isSafeCloseError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Registry = exports.isBrowserDirectory = exports.registryDirectory = exports.hostPlatform = exports.allBrowserNames = void 0;
const child_process_1 = __nccwpck_require__(3129);
const os = __importStar(__nccwpck_require__(2087));
const path_1 = __importDefault(__nccwpck_require__(5622));
const util = __importStar(__nccwpck_require__(1669));
const ubuntuVersion_1 = __nccwpck_require__(9048);
const utils_1 = __nccwpck_require__(6416);
exports.allBrowserNames = new Set(['chromium', 'webkit', 'firefox', 'ffmpeg', 'webkit-technology-preview', 'firefox-beta']);
const PACKAGE_PATH = path_1.default.join(__dirname, '..', '..');
const EXECUTABLE_PATHS = {
    'chromium': {
        'ubuntu18.04': ['chrome-linux', 'chrome'],
        'ubuntu20.04': ['chrome-linux', 'chrome'],
        'mac10.13': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],
        'mac10.14': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],
        'mac10.15': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],
        'mac11': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],
        'mac11-arm64': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],
        'win32': ['chrome-win', 'chrome.exe'],
        'win64': ['chrome-win', 'chrome.exe'],
    },
    'firefox': {
        'ubuntu18.04': ['firefox', 'firefox'],
        'ubuntu20.04': ['firefox', 'firefox'],
        'mac10.13': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac10.14': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac10.15': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac11': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac11-arm64': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'win32': ['firefox', 'firefox.exe'],
        'win64': ['firefox', 'firefox.exe'],
    },
    'firefox-beta': {
        'ubuntu18.04': ['firefox', 'firefox'],
        'ubuntu20.04': ['firefox', 'firefox'],
        'mac10.13': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac10.14': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac10.15': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac11': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'mac11-arm64': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
        'win32': ['firefox', 'firefox.exe'],
        'win64': ['firefox', 'firefox.exe'],
    },
    'webkit': {
        'ubuntu18.04': ['pw_run.sh'],
        'ubuntu20.04': ['pw_run.sh'],
        'mac10.13': undefined,
        'mac10.14': ['pw_run.sh'],
        'mac10.15': ['pw_run.sh'],
        'mac11': ['pw_run.sh'],
        'mac11-arm64': ['pw_run.sh'],
        'win32': ['Playwright.exe'],
        'win64': ['Playwright.exe'],
    },
    'webkit-technology-preview': {
        'ubuntu18.04': ['pw_run.sh'],
        'ubuntu20.04': ['pw_run.sh'],
        'mac10.13': undefined,
        'mac10.14': ['pw_run.sh'],
        'mac10.15': ['pw_run.sh'],
        'mac11': ['pw_run.sh'],
        'mac11-arm64': ['pw_run.sh'],
        'win32': ['Playwright.exe'],
        'win64': ['Playwright.exe'],
    },
    'ffmpeg': {
        'ubuntu18.04': ['ffmpeg-linux'],
        'ubuntu20.04': ['ffmpeg-linux'],
        'mac10.13': ['ffmpeg-mac'],
        'mac10.14': ['ffmpeg-mac'],
        'mac10.15': ['ffmpeg-mac'],
        'mac11': ['ffmpeg-mac'],
        'mac11-arm64': ['ffmpeg-mac'],
        'win32': ['ffmpeg-win32.exe'],
        'win64': ['ffmpeg-win64.exe'],
    },
};
const DOWNLOAD_URLS = {
    'chromium': {
        'ubuntu18.04': '%s/builds/chromium/%s/chromium-linux.zip',
        'ubuntu20.04': '%s/builds/chromium/%s/chromium-linux.zip',
        'mac10.13': '%s/builds/chromium/%s/chromium-mac.zip',
        'mac10.14': '%s/builds/chromium/%s/chromium-mac.zip',
        'mac10.15': '%s/builds/chromium/%s/chromium-mac.zip',
        'mac11': '%s/builds/chromium/%s/chromium-mac.zip',
        'mac11-arm64': '%s/builds/chromium/%s/chromium-mac-arm64.zip',
        'win32': '%s/builds/chromium/%s/chromium-win32.zip',
        'win64': '%s/builds/chromium/%s/chromium-win64.zip',
    },
    'firefox': {
        'ubuntu18.04': '%s/builds/firefox/%s/firefox-ubuntu-18.04.zip',
        'ubuntu20.04': '%s/builds/firefox/%s/firefox-ubuntu-20.04.zip',
        'mac10.13': '%s/builds/firefox/%s/firefox-mac-10.14.zip',
        'mac10.14': '%s/builds/firefox/%s/firefox-mac-10.14.zip',
        'mac10.15': '%s/builds/firefox/%s/firefox-mac-10.14.zip',
        'mac11': '%s/builds/firefox/%s/firefox-mac-10.14.zip',
        'mac11-arm64': '%s/builds/firefox/%s/firefox-mac-11.0-arm64.zip',
        'win32': '%s/builds/firefox/%s/firefox-win32.zip',
        'win64': '%s/builds/firefox/%s/firefox-win64.zip',
    },
    'firefox-beta': {
        'ubuntu18.04': '%s/builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip',
        'ubuntu20.04': '%s/builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip',
        'mac10.13': '%s/builds/firefox-beta/%s/firefox-beta-mac-10.14.zip',
        'mac10.14': '%s/builds/firefox-beta/%s/firefox-beta-mac-10.14.zip',
        'mac10.15': '%s/builds/firefox-beta/%s/firefox-beta-mac-10.14.zip',
        'mac11': '%s/builds/firefox-beta/%s/firefox-beta-mac-10.14.zip',
        'mac11-arm64': '%s/builds/firefox-beta/%s/firefox-beta-mac-11.0-arm64.zip',
        'win32': '%s/builds/firefox-beta/%s/firefox-beta-win32.zip',
        'win64': '%s/builds/firefox-beta/%s/firefox-beta-win64.zip',
    },
    'webkit': {
        'ubuntu18.04': '%s/builds/webkit/%s/webkit-ubuntu-18.04.zip',
        'ubuntu20.04': '%s/builds/webkit/%s/webkit-ubuntu-20.04.zip',
        'mac10.13': undefined,
        'mac10.14': '%s/builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip',
        'mac10.15': '%s/builds/webkit/%s/webkit-mac-10.15.zip',
        'mac11': '%s/builds/webkit/%s/webkit-mac-10.15.zip',
        'mac11-arm64': '%s/builds/webkit/%s/webkit-mac-11.0-arm64.zip',
        'win32': '%s/builds/webkit/%s/webkit-win64.zip',
        'win64': '%s/builds/webkit/%s/webkit-win64.zip',
    },
    'webkit-technology-preview': {
        'ubuntu18.04': '%s/builds/webkit/%s/webkit-ubuntu-18.04.zip',
        'ubuntu20.04': '%s/builds/webkit/%s/webkit-ubuntu-20.04.zip',
        'mac10.13': undefined,
        'mac10.14': undefined,
        'mac10.15': '%s/builds/webkit/%s/webkit-mac-10.15.zip',
        'mac11': '%s/builds/webkit/%s/webkit-mac-10.15.zip',
        'mac11-arm64': '%s/builds/webkit/%s/webkit-mac-11.0-arm64.zip',
        'win32': '%s/builds/webkit/%s/webkit-win64.zip',
        'win64': '%s/builds/webkit/%s/webkit-win64.zip',
    },
    'ffmpeg': {
        'ubuntu18.04': '%s/builds/ffmpeg/%s/ffmpeg-linux.zip',
        'ubuntu20.04': '%s/builds/ffmpeg/%s/ffmpeg-linux.zip',
        'mac10.13': '%s/builds/ffmpeg/%s/ffmpeg-mac.zip',
        'mac10.14': '%s/builds/ffmpeg/%s/ffmpeg-mac.zip',
        'mac10.15': '%s/builds/ffmpeg/%s/ffmpeg-mac.zip',
        'mac11': '%s/builds/ffmpeg/%s/ffmpeg-mac.zip',
        'mac11-arm64': '%s/builds/ffmpeg/%s/ffmpeg-mac.zip',
        'win32': '%s/builds/ffmpeg/%s/ffmpeg-win32.zip',
        'win64': '%s/builds/ffmpeg/%s/ffmpeg-win64.zip',
    },
};
exports.hostPlatform = (() => {
    const platform = os.platform();
    if (platform === 'darwin') {
        const [major, minor] = child_process_1.execSync('sw_vers -productVersion', {
            stdio: ['ignore', 'pipe', 'ignore']
        }).toString('utf8').trim().split('.').map(x => parseInt(x, 10));
        let arm64 = false;
        // BigSur is the first version that might run on Apple Silicon.
        if (major >= 11) {
            arm64 = child_process_1.execSync('/usr/sbin/sysctl -in hw.optional.arm64', {
                stdio: ['ignore', 'pipe', 'ignore']
            }).toString().trim() === '1';
        }
        // We do not want to differentiate between minor big sur releases
        // since they don't change core APIs so far.
        const macVersion = major === 10 ? `${major}.${minor}` : `${major}`;
        const archSuffix = arm64 ? '-arm64' : '';
        return `mac${macVersion}${archSuffix}`;
    }
    if (platform === 'linux') {
        const ubuntuVersion = ubuntuVersion_1.getUbuntuVersionSync();
        if (parseInt(ubuntuVersion, 10) <= 19)
            return 'ubuntu18.04';
        return 'ubuntu20.04';
    }
    if (platform === 'win32')
        return os.arch() === 'x64' ? 'win64' : 'win32';
    return platform;
})();
exports.registryDirectory = (() => {
    let result;
    const envDefined = utils_1.getFromENV('PLAYWRIGHT_BROWSERS_PATH');
    if (envDefined === '0') {
        result = path_1.default.join(__dirname, '..', '..', '.local-browsers');
    }
    else if (envDefined) {
        result = envDefined;
    }
    else {
        let cacheDirectory;
        if (process.platform === 'linux')
            cacheDirectory = process.env.XDG_CACHE_HOME || path_1.default.join(os.homedir(), '.cache');
        else if (process.platform === 'darwin')
            cacheDirectory = path_1.default.join(os.homedir(), 'Library', 'Caches');
        else if (process.platform === 'win32')
            cacheDirectory = process.env.LOCALAPPDATA || path_1.default.join(os.homedir(), 'AppData', 'Local');
        else
            throw new Error('Unsupported platform: ' + process.platform);
        result = path_1.default.join(cacheDirectory, 'ms-playwright');
    }
    if (!path_1.default.isAbsolute(result)) {
        // It is important to resolve to the absolute path:
        //   - for unzipping to work correctly;
        //   - so that registry directory matches between installation and execution.
        // INIT_CWD points to the root of `npm/yarn install` and is probably what
        // the user meant when typing the relative path.
        result = path_1.default.resolve(utils_1.getFromENV('INIT_CWD') || process.cwd(), result);
    }
    return result;
})();
function isBrowserDirectory(browserDirectory) {
    const baseName = path_1.default.basename(browserDirectory);
    for (const browserName of exports.allBrowserNames) {
        if (baseName.startsWith(browserName + '-'))
            return true;
    }
    return false;
}
exports.isBrowserDirectory = isBrowserDirectory;
let currentPackageRegistry = undefined;
class Registry {
    constructor(packagePath) {
        // require() needs to be used there otherwise it breaks on Vercel serverless
        // functions. See https://github.com/microsoft/playwright/pull/6186
        const browsersJSON = require(path_1.default.join(packagePath, 'browsers.json'));
        this._descriptors = browsersJSON['browsers'].map((obj) => {
            const name = obj.name;
            const revisionOverride = (obj.revisionOverrides || {})[exports.hostPlatform];
            const revision = revisionOverride || obj.revision;
            const browserDirectoryPrefix = revisionOverride ? `${name}_${exports.hostPlatform}_special` : `${name}`;
            return {
                name,
                revision,
                installByDefault: !!obj.installByDefault,
                // Method `isBrowserDirectory` determines directory to be browser iff
                // it starts with some browser name followed by '-'. Some browser names
                // are prefixes of others, e.g. 'webkit' is a prefix of `webkit-technology-preview`.
                // To avoid older registries erroneously removing 'webkit-technology-preview', we have to
                // ensure that browser folders to never include dashes inside.
                browserDirectory: browserDirectoryPrefix.replace(/-/g, '_') + '-' + revision,
            };
        });
    }
    static currentPackageRegistry() {
        if (!currentPackageRegistry)
            currentPackageRegistry = new Registry(PACKAGE_PATH);
        return currentPackageRegistry;
    }
    browserDirectory(browserName) {
        const browser = this._descriptors.find(browser => browser.name === browserName);
        utils_1.assert(browser, `ERROR: Playwright does not support ${browserName}`);
        return path_1.default.join(exports.registryDirectory, browser.browserDirectory);
    }
    revision(browserName) {
        const browser = this._descriptors.find(browser => browser.name === browserName);
        utils_1.assert(browser, `ERROR: Playwright does not support ${browserName}`);
        return parseInt(browser.revision, 10);
    }
    linuxLddDirectories(browserName) {
        const browserDirectory = this.browserDirectory(browserName);
        switch (browserName) {
            case 'chromium':
                return [path_1.default.join(browserDirectory, 'chrome-linux')];
            case 'webkit':
            case 'webkit-technology-preview':
                return [
                    path_1.default.join(browserDirectory, 'minibrowser-gtk'),
                    path_1.default.join(browserDirectory, 'minibrowser-gtk', 'bin'),
                    path_1.default.join(browserDirectory, 'minibrowser-gtk', 'lib'),
                    path_1.default.join(browserDirectory, 'minibrowser-wpe'),
                    path_1.default.join(browserDirectory, 'minibrowser-wpe', 'bin'),
                    path_1.default.join(browserDirectory, 'minibrowser-wpe', 'lib'),
                ];
            case 'firefox':
            case 'firefox-beta':
                return [path_1.default.join(browserDirectory, 'firefox')];
            default:
                return [];
        }
    }
    windowsExeAndDllDirectories(browserName) {
        const browserDirectory = this.browserDirectory(browserName);
        if (browserName === 'chromium')
            return [path_1.default.join(browserDirectory, 'chrome-win')];
        if (browserName === 'firefox')
            return [path_1.default.join(browserDirectory, 'firefox')];
        if (browserName === 'webkit')
            return [browserDirectory];
        return [];
    }
    executablePath(browserName) {
        const browserDirectory = this.browserDirectory(browserName);
        const tokens = EXECUTABLE_PATHS[browserName][exports.hostPlatform];
        return tokens ? path_1.default.join(browserDirectory, ...tokens) : undefined;
    }
    downloadURL(browserName) {
        const browser = this._descriptors.find(browser => browser.name === browserName);
        utils_1.assert(browser, `ERROR: Playwright does not support ${browserName}`);
        const envDownloadHost = {
            'chromium': 'PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST',
            'firefox': 'PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST',
            'firefox-beta': 'PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST',
            'webkit': 'PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST',
            'webkit-technology-preview': 'PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST',
            'ffmpeg': 'PLAYWRIGHT_FFMPEG_DOWNLOAD_HOST',
        };
        const downloadHost = utils_1.getFromENV(envDownloadHost[browserName]) ||
            utils_1.getFromENV('PLAYWRIGHT_DOWNLOAD_HOST') ||
            'https://playwright.azureedge.net';
        const urlTemplate = DOWNLOAD_URLS[browserName][exports.hostPlatform];
        utils_1.assert(urlTemplate, `ERROR: Playwright does not support ${browserName} on ${exports.hostPlatform}`);
        return util.format(urlTemplate, downloadHost, browser.revision);
    }
    isSupportedBrowser(browserName) {
        // We retain browsers if they are found in the descriptor.
        // Note, however, that there are older versions out in the wild that rely on
        // the "download" field in the browser descriptor and use its value
        // to retain and download browsers.
        // As of v1.10, we decided to abandon "download" field.
        return this._descriptors.some(browser => browser.name === browserName);
    }
    installByDefault() {
        return this._descriptors.filter(browser => browser.installByDefault).map(browser => browser.name);
    }
}
exports.Registry = Registry;
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ 6010:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitErrorMessage = exports.captureStackTrace = exports.rewriteErrorMessage = exports.getCallerFilePath = void 0;
const path_1 = __importDefault(__nccwpck_require__(5622));
const stack_utils_1 = __importDefault(__nccwpck_require__(7240));
const utils_1 = __nccwpck_require__(6416);
const stackUtils = new stack_utils_1.default();
function getCallerFilePath(ignorePrefix) {
    const frame = captureStackTrace().frames.find(f => !f.file.startsWith(ignorePrefix));
    return frame ? frame.file : null;
}
exports.getCallerFilePath = getCallerFilePath;
function rewriteErrorMessage(e, newMessage) {
    if (e.stack) {
        const index = e.stack.indexOf(e.message);
        if (index !== -1)
            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
    }
    e.message = newMessage;
    return e;
}
exports.rewriteErrorMessage = rewriteErrorMessage;
const PW_LIB_DIRS = [
    'playwright',
    'playwright-chromium',
    'playwright-firefox',
    'playwright-webkit',
    path_1.default.join('@playwright', 'test'),
].map(packageName => path_1.default.sep + path_1.default.join(packageName, 'lib'));
function captureStackTrace() {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 30;
    const stack = new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    const frames = [];
    for (const line of stack.split('\n')) {
        const frame = stackUtils.parseLine(line);
        if (!frame || !frame.file)
            continue;
        if (frame.file.startsWith('internal'))
            continue;
        const fileName = path_1.default.resolve(process.cwd(), frame.file);
        if (PW_LIB_DIRS.some(libDir => fileName.includes(libDir)))
            continue;
        // for tests.
        if (utils_1.isUnderTest() && fileName.includes(path_1.default.join('playwright', 'src')))
            continue;
        if (utils_1.isUnderTest() && fileName.includes(path_1.default.join('playwright', 'tests', 'config', 'coverage.js')))
            continue;
        frames.push({
            file: fileName,
            line: frame.line,
            column: frame.column,
            function: frame.function,
        });
    }
    return { stack, frames };
}
exports.captureStackTrace = captureStackTrace;
function splitErrorMessage(message) {
    const separationIdx = message.indexOf(':');
    return {
        name: separationIdx !== -1 ? message.slice(0, separationIdx) : '',
        message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message,
    };
}
exports.splitErrorMessage = splitErrorMessage;
//# sourceMappingURL=stackTrace.js.map

/***/ }),

/***/ 9255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutSettings = exports.DEFAULT_TIMEOUT = void 0;
const utils_1 = __nccwpck_require__(6416);
exports.DEFAULT_TIMEOUT = 30000;
const TIMEOUT = utils_1.debugMode() ? 0 : exports.DEFAULT_TIMEOUT;
class TimeoutSettings {
    constructor(parent) {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
        this._parent = parent;
    }
    setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
    }
    setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
    }
    navigationTimeout(options) {
        if (typeof options.timeout === 'number')
            return options.timeout;
        if (this._defaultNavigationTimeout !== null)
            return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        if (this._parent)
            return this._parent.navigationTimeout(options);
        return TIMEOUT;
    }
    timeout(options) {
        if (typeof options.timeout === 'number')
            return options.timeout;
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        if (this._parent)
            return this._parent.timeout(options);
        return TIMEOUT;
    }
    static timeout(options) {
        if (typeof options.timeout === 'number')
            return options.timeout;
        return TIMEOUT;
    }
}
exports.TimeoutSettings = TimeoutSettings;
//# sourceMappingURL=timeoutSettings.js.map

/***/ }),

/***/ 9048:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUbuntuVersionSync = exports.getUbuntuVersion = void 0;
const fs_1 = __importDefault(__nccwpck_require__(5747));
const os = __importStar(__nccwpck_require__(2087));
async function getUbuntuVersion() {
    if (os.platform() !== 'linux')
        return '';
    let osReleaseText = await fs_1.default.promises.readFile('/etc/upstream-release/lsb-release', 'utf8').catch(e => '');
    if (!osReleaseText)
        osReleaseText = await fs_1.default.promises.readFile('/etc/os-release', 'utf8').catch(e => '');
    if (!osReleaseText)
        return '';
    return getUbuntuVersionInternal(osReleaseText);
}
exports.getUbuntuVersion = getUbuntuVersion;
function getUbuntuVersionSync() {
    if (os.platform() !== 'linux')
        return '';
    try {
        let osReleaseText;
        if (fs_1.default.existsSync('/etc/upstream-release/lsb-release'))
            osReleaseText = fs_1.default.readFileSync('/etc/upstream-release/lsb-release', 'utf8');
        else
            osReleaseText = fs_1.default.readFileSync('/etc/os-release', 'utf8');
        if (!osReleaseText)
            return '';
        return getUbuntuVersionInternal(osReleaseText);
    }
    catch (e) {
        return '';
    }
}
exports.getUbuntuVersionSync = getUbuntuVersionSync;
function getUbuntuVersionInternal(osReleaseText) {
    const fields = new Map();
    for (const line of osReleaseText.split('\n')) {
        const tokens = line.split('=');
        const name = tokens.shift();
        let value = tokens.join('=').trim();
        if (value.startsWith('"') && value.endsWith('"'))
            value = value.substring(1, value.length - 1);
        if (!name)
            continue;
        fields.set(name.toLowerCase(), value);
    }
    // For Linux mint
    if (fields.get('distrib_id') && fields.get('distrib_id').toLowerCase() === 'ubuntu')
        return fields.get('distrib_release') || '';
    if (!fields.get('name') || fields.get('name').toLowerCase() !== 'ubuntu')
        return '';
    return fields.get('version_id') || '';
}
//# sourceMappingURL=ubuntuVersion.js.map

/***/ }),

/***/ 6416:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserAgent = exports.isLocalIpAddress = exports.canAccessFile = exports.removeFolders = exports.createGuid = exports.calculateSha1 = exports.monotonicTime = exports.headersArrayToObject = exports.headersObjectToArray = exports.mkdirIfNeeded = exports.getAsBooleanFromENV = exports.getFromENV = exports.isUnderTest = exports.setUnderTest = exports.debugMode = exports.isError = exports.isObject = exports.isRegExp = exports.isString = exports.debugAssert = exports.assert = exports.makeWaitForNextTask = exports.spawnAsync = exports.downloadFile = exports.fetchData = exports.existsAsync = void 0;
const path_1 = __importDefault(__nccwpck_require__(5622));
const fs_1 = __importDefault(__nccwpck_require__(5747));
const rimraf_1 = __importDefault(__nccwpck_require__(9859));
const crypto = __importStar(__nccwpck_require__(6417));
const os_1 = __importDefault(__nccwpck_require__(2087));
const child_process_1 = __nccwpck_require__(3129);
const proxy_from_env_1 = __nccwpck_require__(625);
const URL = __importStar(__nccwpck_require__(8835));
// `https-proxy-agent` v5 is written in TypeScript and exposes generated types.
// However, as of June 2020, its types are generated with tsconfig that enables
// `esModuleInterop` option.
//
// As a result, we can't depend on the package unless we enable the option
// for our codebase. Instead of doing this, we abuse "require" to import module
// without types.
const ProxyAgent = __nccwpck_require__(7562);
const existsAsync = (path) => new Promise(resolve => fs_1.default.stat(path, err => resolve(!err)));
exports.existsAsync = existsAsync;
function httpRequest(url, method, response) {
    let options = URL.parse(url);
    options.method = method;
    const proxyURL = proxy_from_env_1.getProxyForUrl(url);
    if (proxyURL) {
        if (url.startsWith('http:')) {
            const proxy = URL.parse(proxyURL);
            options = {
                path: options.href,
                host: proxy.hostname,
                port: proxy.port,
            };
        }
        else {
            const parsedProxyURL = URL.parse(proxyURL);
            parsedProxyURL.secureProxy = parsedProxyURL.protocol === 'https:';
            options.agent = new ProxyAgent(parsedProxyURL);
            options.rejectUnauthorized = false;
        }
    }
    const requestCallback = (res) => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)
            httpRequest(res.headers.location, method, response);
        else
            response(res);
    };
    const request = options.protocol === 'https:' ?
        __nccwpck_require__(7211).request(options, requestCallback) :
        __nccwpck_require__(8605).request(options, requestCallback);
    request.end();
    return request;
}
function fetchData(url) {
    return new Promise((resolve, reject) => {
        httpRequest(url, 'GET', function (response) {
            if (response.statusCode !== 200) {
                reject(new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${url}`));
                return;
            }
            let body = '';
            response.on('data', (chunk) => body += chunk);
            response.on('error', (error) => reject(error));
            response.on('end', () => resolve(body));
        }).on('error', (error) => reject(error));
    });
}
exports.fetchData = fetchData;
function downloadFile(url, destinationPath, options = {}) {
    const { progressCallback, log = () => { }, } = options;
    log(`running download:`);
    log(`-- from url: ${url}`);
    log(`-- to location: ${destinationPath}`);
    let fulfill = ({ error }) => { };
    let downloadedBytes = 0;
    let totalBytes = 0;
    const promise = new Promise(x => { fulfill = x; });
    const request = httpRequest(url, 'GET', response => {
        log(`-- response status code: ${response.statusCode}`);
        if (response.statusCode !== 200) {
            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
            // consume response data to free up memory
            response.resume();
            fulfill({ error });
            return;
        }
        const file = fs_1.default.createWriteStream(destinationPath);
        file.on('finish', () => fulfill({ error: null }));
        file.on('error', error => fulfill({ error }));
        response.pipe(file);
        totalBytes = parseInt(response.headers['content-length'], 10);
        log(`-- total bytes: ${totalBytes}`);
        if (progressCallback)
            response.on('data', onData);
    });
    request.on('error', (error) => fulfill({ error }));
    return promise;
    function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
    }
}
exports.downloadFile = downloadFile;
function spawnAsync(cmd, args, options) {
    const process = child_process_1.spawn(cmd, args, options);
    return new Promise(resolve => {
        let stdout = '';
        let stderr = '';
        if (process.stdout)
            process.stdout.on('data', data => stdout += data);
        if (process.stderr)
            process.stderr.on('data', data => stderr += data);
        process.on('close', code => resolve({ stdout, stderr, code }));
        process.on('error', error => resolve({ stdout, stderr, code: 0, error }));
    });
}
exports.spawnAsync = spawnAsync;
// See https://joel.tools/microtasks/
function makeWaitForNextTask() {
    // As of Mar 2021, Electorn v12 doesn't create new task with `setImmediate` despite
    // using Node 14 internally, so we fallback to `setTimeout(0)` instead.
    // @see https://github.com/electron/electron/issues/28261
    if (process.versions.electron)
        return (callback) => setTimeout(callback, 0);
    if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
    // Unlike Node 11, Node 10 and less have a bug with Task and MicroTask execution order:
    // - https://github.com/nodejs/node/issues/22257
    //
    // So we can't simply run setImmediate to dispatch code in a following task.
    // However, we can run setImmediate from-inside setImmediate to make sure we're getting
    // in the following task.
    let spinning = false;
    const callbacks = [];
    const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
            spinning = false;
            return;
        }
        setImmediate(loop);
        // Make sure to call callback() as the last thing since it's
        // untrusted code that might throw.
        callback();
    };
    return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
            spinning = true;
            setImmediate(loop);
        }
    };
}
exports.makeWaitForNextTask = makeWaitForNextTask;
function assert(value, message) {
    if (!value)
        throw new Error(message);
}
exports.assert = assert;
function debugAssert(value, message) {
    if (isUnderTest() && !value)
        throw new Error(message);
}
exports.debugAssert = debugAssert;
function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}
exports.isString = isString;
function isRegExp(obj) {
    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isObject = isObject;
function isError(obj) {
    return obj instanceof Error || (obj && obj.__proto__ && obj.__proto__.name === 'Error');
}
exports.isError = isError;
const debugEnv = getFromENV('PWDEBUG') || '';
function debugMode() {
    if (debugEnv === 'console')
        return 'console';
    return debugEnv ? 'inspector' : '';
}
exports.debugMode = debugMode;
let _isUnderTest = false;
function setUnderTest() {
    _isUnderTest = true;
}
exports.setUnderTest = setUnderTest;
function isUnderTest() {
    return _isUnderTest;
}
exports.isUnderTest = isUnderTest;
function getFromENV(name) {
    let value = process.env[name];
    value = value === undefined ? process.env[`npm_config_${name.toLowerCase()}`] : value;
    value = value === undefined ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
    return value;
}
exports.getFromENV = getFromENV;
function getAsBooleanFromENV(name) {
    const value = getFromENV(name);
    return !!value && value !== 'false' && value !== '0';
}
exports.getAsBooleanFromENV = getAsBooleanFromENV;
async function mkdirIfNeeded(filePath) {
    // This will harmlessly throw on windows if the dirname is the root directory.
    await fs_1.default.promises.mkdir(path_1.default.dirname(filePath), { recursive: true }).catch(() => { });
}
exports.mkdirIfNeeded = mkdirIfNeeded;
function headersObjectToArray(headers) {
    const result = [];
    for (const name in headers) {
        if (!Object.is(headers[name], undefined))
            result.push({ name, value: headers[name] });
    }
    return result;
}
exports.headersObjectToArray = headersObjectToArray;
function headersArrayToObject(headers, lowerCase) {
    const result = {};
    for (const { name, value } of headers)
        result[lowerCase ? name.toLowerCase() : name] = value;
    return result;
}
exports.headersArrayToObject = headersArrayToObject;
function monotonicTime() {
    const [seconds, nanoseconds] = process.hrtime();
    return seconds * 1000 + (nanoseconds / 1000 | 0) / 1000;
}
exports.monotonicTime = monotonicTime;
function calculateSha1(buffer) {
    const hash = crypto.createHash('sha1');
    hash.update(buffer);
    return hash.digest('hex');
}
exports.calculateSha1 = calculateSha1;
function createGuid() {
    return crypto.randomBytes(16).toString('hex');
}
exports.createGuid = createGuid;
async function removeFolders(dirs) {
    return await Promise.all(dirs.map((dir) => {
        return new Promise(fulfill => {
            rimraf_1.default(dir, { maxBusyTries: 10 }, error => {
                fulfill(error);
            });
        });
    }));
}
exports.removeFolders = removeFolders;
function canAccessFile(file) {
    if (!file)
        return false;
    try {
        fs_1.default.accessSync(file);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.canAccessFile = canAccessFile;
const localIpAddresses = [
    'localhost',
    '127.0.0.1',
    '::ffff:127.0.0.1',
    '::1',
    '0000:0000:0000:0000:0000:0000:0000:0001', // WebKit (Windows)
];
function isLocalIpAddress(ipAdress) {
    return localIpAddresses.includes(ipAdress);
}
exports.isLocalIpAddress = isLocalIpAddress;
function getUserAgent() {
    const packageJson = __nccwpck_require__(5101);
    return `Playwright/${packageJson.version} (${os_1.default.arch()}/${os_1.default.platform()}/${os_1.default.release()})`;
}
exports.getUserAgent = getUserAgent;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 2470:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


let interlaceUtils = __nccwpck_require__(5375);

let pixelBppMapper = [
  // 0 - dummy entry
  function () {},

  // 1 - L
  // 0: 0, 1: 0, 2: 0, 3: 0xff
  function (pxData, data, pxPos, rawPos) {
    if (rawPos === data.length) {
      throw new Error("Ran out of data");
    }

    let pixel = data[rawPos];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = 0xff;
  },

  // 2 - LA
  // 0: 0, 1: 0, 2: 0, 3: 1
  function (pxData, data, pxPos, rawPos) {
    if (rawPos + 1 >= data.length) {
      throw new Error("Ran out of data");
    }

    let pixel = data[rawPos];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = data[rawPos + 1];
  },

  // 3 - RGB
  // 0: 0, 1: 1, 2: 2, 3: 0xff
  function (pxData, data, pxPos, rawPos) {
    if (rawPos + 2 >= data.length) {
      throw new Error("Ran out of data");
    }

    pxData[pxPos] = data[rawPos];
    pxData[pxPos + 1] = data[rawPos + 1];
    pxData[pxPos + 2] = data[rawPos + 2];
    pxData[pxPos + 3] = 0xff;
  },

  // 4 - RGBA
  // 0: 0, 1: 1, 2: 2, 3: 3
  function (pxData, data, pxPos, rawPos) {
    if (rawPos + 3 >= data.length) {
      throw new Error("Ran out of data");
    }

    pxData[pxPos] = data[rawPos];
    pxData[pxPos + 1] = data[rawPos + 1];
    pxData[pxPos + 2] = data[rawPos + 2];
    pxData[pxPos + 3] = data[rawPos + 3];
  },
];

let pixelBppCustomMapper = [
  // 0 - dummy entry
  function () {},

  // 1 - L
  // 0: 0, 1: 0, 2: 0, 3: 0xff
  function (pxData, pixelData, pxPos, maxBit) {
    let pixel = pixelData[0];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = maxBit;
  },

  // 2 - LA
  // 0: 0, 1: 0, 2: 0, 3: 1
  function (pxData, pixelData, pxPos) {
    let pixel = pixelData[0];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = pixelData[1];
  },

  // 3 - RGB
  // 0: 0, 1: 1, 2: 2, 3: 0xff
  function (pxData, pixelData, pxPos, maxBit) {
    pxData[pxPos] = pixelData[0];
    pxData[pxPos + 1] = pixelData[1];
    pxData[pxPos + 2] = pixelData[2];
    pxData[pxPos + 3] = maxBit;
  },

  // 4 - RGBA
  // 0: 0, 1: 1, 2: 2, 3: 3
  function (pxData, pixelData, pxPos) {
    pxData[pxPos] = pixelData[0];
    pxData[pxPos + 1] = pixelData[1];
    pxData[pxPos + 2] = pixelData[2];
    pxData[pxPos + 3] = pixelData[3];
  },
];

function bitRetriever(data, depth) {
  let leftOver = [];
  let i = 0;

  function split() {
    if (i === data.length) {
      throw new Error("Ran out of data");
    }
    let byte = data[i];
    i++;
    let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
    switch (depth) {
      default:
        throw new Error("unrecognised depth");
      case 16:
        byte2 = data[i];
        i++;
        leftOver.push((byte << 8) + byte2);
        break;
      case 4:
        byte2 = byte & 0x0f;
        byte1 = byte >> 4;
        leftOver.push(byte1, byte2);
        break;
      case 2:
        byte4 = byte & 3;
        byte3 = (byte >> 2) & 3;
        byte2 = (byte >> 4) & 3;
        byte1 = (byte >> 6) & 3;
        leftOver.push(byte1, byte2, byte3, byte4);
        break;
      case 1:
        byte8 = byte & 1;
        byte7 = (byte >> 1) & 1;
        byte6 = (byte >> 2) & 1;
        byte5 = (byte >> 3) & 1;
        byte4 = (byte >> 4) & 1;
        byte3 = (byte >> 5) & 1;
        byte2 = (byte >> 6) & 1;
        byte1 = (byte >> 7) & 1;
        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
        break;
    }
  }

  return {
    get: function (count) {
      while (leftOver.length < count) {
        split();
      }
      let returner = leftOver.slice(0, count);
      leftOver = leftOver.slice(count);
      return returner;
    },
    resetAfterLine: function () {
      leftOver.length = 0;
    },
    end: function () {
      if (i !== data.length) {
        throw new Error("extra data found");
      }
    },
  };
}

function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
  // eslint-disable-line max-params
  let imageWidth = image.width;
  let imageHeight = image.height;
  let imagePass = image.index;
  for (let y = 0; y < imageHeight; y++) {
    for (let x = 0; x < imageWidth; x++) {
      let pxPos = getPxPos(x, y, imagePass);
      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
      rawPos += bpp; //eslint-disable-line no-param-reassign
    }
  }
  return rawPos;
}

function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
  // eslint-disable-line max-params
  let imageWidth = image.width;
  let imageHeight = image.height;
  let imagePass = image.index;
  for (let y = 0; y < imageHeight; y++) {
    for (let x = 0; x < imageWidth; x++) {
      let pixelData = bits.get(bpp);
      let pxPos = getPxPos(x, y, imagePass);
      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
    }
    bits.resetAfterLine();
  }
}

exports.dataToBitMap = function (data, bitmapInfo) {
  let width = bitmapInfo.width;
  let height = bitmapInfo.height;
  let depth = bitmapInfo.depth;
  let bpp = bitmapInfo.bpp;
  let interlace = bitmapInfo.interlace;
  let bits;

  if (depth !== 8) {
    bits = bitRetriever(data, depth);
  }
  let pxData;
  if (depth <= 8) {
    pxData = Buffer.alloc(width * height * 4);
  } else {
    pxData = new Uint16Array(width * height * 4);
  }
  let maxBit = Math.pow(2, depth) - 1;
  let rawPos = 0;
  let images;
  let getPxPos;

  if (interlace) {
    images = interlaceUtils.getImagePasses(width, height);
    getPxPos = interlaceUtils.getInterlaceIterator(width, height);
  } else {
    let nonInterlacedPxPos = 0;
    getPxPos = function () {
      let returner = nonInterlacedPxPos;
      nonInterlacedPxPos += 4;
      return returner;
    };
    images = [{ width: width, height: height }];
  }

  for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
    if (depth === 8) {
      rawPos = mapImage8Bit(
        images[imageIndex],
        pxData,
        getPxPos,
        bpp,
        data,
        rawPos
      );
    } else {
      mapImageCustomBit(
        images[imageIndex],
        pxData,
        getPxPos,
        bpp,
        bits,
        maxBit
      );
    }
  }
  if (depth === 8) {
    if (rawPos !== data.length) {
      throw new Error("extra data found");
    }
  } else {
    bits.end();
  }

  return pxData;
};


/***/ }),

/***/ 5711:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let constants = __nccwpck_require__(7946);

module.exports = function (dataIn, width, height, options) {
  let outHasAlpha =
    [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(
      options.colorType
    ) !== -1;
  if (options.colorType === options.inputColorType) {
    let bigEndian = (function () {
      let buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
      // Int16Array uses the platform's endianness.
      return new Int16Array(buffer)[0] !== 256;
    })();
    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route
    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {
      return dataIn;
    }
  }

  // map to a UInt16 array if data is 16bit, fix endianness below
  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);

  let maxValue = 255;
  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
  if (inBpp === 4 && !options.inputHasAlpha) {
    inBpp = 3;
  }
  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
  if (options.bitDepth === 16) {
    maxValue = 65535;
    outBpp *= 2;
  }
  let outData = Buffer.alloc(width * height * outBpp);

  let inIndex = 0;
  let outIndex = 0;

  let bgColor = options.bgColor || {};
  if (bgColor.red === undefined) {
    bgColor.red = maxValue;
  }
  if (bgColor.green === undefined) {
    bgColor.green = maxValue;
  }
  if (bgColor.blue === undefined) {
    bgColor.blue = maxValue;
  }

  function getRGBA() {
    let red;
    let green;
    let blue;
    let alpha = maxValue;
    switch (options.inputColorType) {
      case constants.COLORTYPE_COLOR_ALPHA:
        alpha = data[inIndex + 3];
        red = data[inIndex];
        green = data[inIndex + 1];
        blue = data[inIndex + 2];
        break;
      case constants.COLORTYPE_COLOR:
        red = data[inIndex];
        green = data[inIndex + 1];
        blue = data[inIndex + 2];
        break;
      case constants.COLORTYPE_ALPHA:
        alpha = data[inIndex + 1];
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      case constants.COLORTYPE_GRAYSCALE:
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      default:
        throw new Error(
          "input color type:" +
            options.inputColorType +
            " is not supported at present"
        );
    }

    if (options.inputHasAlpha) {
      if (!outHasAlpha) {
        alpha /= maxValue;
        red = Math.min(
          Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
          maxValue
        );
        green = Math.min(
          Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
          maxValue
        );
        blue = Math.min(
          Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
          maxValue
        );
      }
    }
    return { red: red, green: green, blue: blue, alpha: alpha };
  }

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let rgba = getRGBA(data, inIndex);

      switch (options.colorType) {
        case constants.COLORTYPE_COLOR_ALPHA:
        case constants.COLORTYPE_COLOR:
          if (options.bitDepth === 8) {
            outData[outIndex] = rgba.red;
            outData[outIndex + 1] = rgba.green;
            outData[outIndex + 2] = rgba.blue;
            if (outHasAlpha) {
              outData[outIndex + 3] = rgba.alpha;
            }
          } else {
            outData.writeUInt16BE(rgba.red, outIndex);
            outData.writeUInt16BE(rgba.green, outIndex + 2);
            outData.writeUInt16BE(rgba.blue, outIndex + 4);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 6);
            }
          }
          break;
        case constants.COLORTYPE_ALPHA:
        case constants.COLORTYPE_GRAYSCALE: {
          // Convert to grayscale and alpha
          let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
          if (options.bitDepth === 8) {
            outData[outIndex] = grayscale;
            if (outHasAlpha) {
              outData[outIndex + 1] = rgba.alpha;
            }
          } else {
            outData.writeUInt16BE(grayscale, outIndex);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 2);
            }
          }
          break;
        }
        default:
          throw new Error("unrecognised color Type " + options.colorType);
      }

      inIndex += inBpp;
      outIndex += outBpp;
    }
  }

  return outData;
};


/***/ }),

/***/ 9035:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let util = __nccwpck_require__(1669);
let Stream = __nccwpck_require__(2413);

let ChunkStream = (module.exports = function () {
  Stream.call(this);

  this._buffers = [];
  this._buffered = 0;

  this._reads = [];
  this._paused = false;

  this._encoding = "utf8";
  this.writable = true;
});
util.inherits(ChunkStream, Stream);

ChunkStream.prototype.read = function (length, callback) {
  this._reads.push({
    length: Math.abs(length), // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback,
  });

  process.nextTick(
    function () {
      this._process();

      // its paused and there is not enought data then ask for more
      if (this._paused && this._reads && this._reads.length > 0) {
        this._paused = false;

        this.emit("drain");
      }
    }.bind(this)
  );
};

ChunkStream.prototype.write = function (data, encoding) {
  if (!this.writable) {
    this.emit("error", new Error("Stream not writable"));
    return false;
  }

  let dataBuffer;
  if (Buffer.isBuffer(data)) {
    dataBuffer = data;
  } else {
    dataBuffer = Buffer.from(data, encoding || this._encoding);
  }

  this._buffers.push(dataBuffer);
  this._buffered += dataBuffer.length;

  this._process();

  // ok if there are no more read requests
  if (this._reads && this._reads.length === 0) {
    this._paused = true;
  }

  return this.writable && !this._paused;
};

ChunkStream.prototype.end = function (data, encoding) {
  if (data) {
    this.write(data, encoding);
  }

  this.writable = false;

  // already destroyed
  if (!this._buffers) {
    return;
  }

  // enqueue or handle end
  if (this._buffers.length === 0) {
    this._end();
  } else {
    this._buffers.push(null);
    this._process();
  }
};

ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;

ChunkStream.prototype._end = function () {
  if (this._reads.length > 0) {
    this.emit("error", new Error("Unexpected end of input"));
  }

  this.destroy();
};

ChunkStream.prototype.destroy = function () {
  if (!this._buffers) {
    return;
  }

  this.writable = false;
  this._reads = null;
  this._buffers = null;

  this.emit("close");
};

ChunkStream.prototype._processReadAllowingLess = function (read) {
  // ok there is any data so that we can satisfy this request
  this._reads.shift(); // == read

  // first we need to peek into first buffer
  let smallerBuf = this._buffers[0];

  // ok there is more data than we need
  if (smallerBuf.length > read.length) {
    this._buffered -= read.length;
    this._buffers[0] = smallerBuf.slice(read.length);

    read.func.call(this, smallerBuf.slice(0, read.length));
  } else {
    // ok this is less than maximum length so use it all
    this._buffered -= smallerBuf.length;
    this._buffers.shift(); // == smallerBuf

    read.func.call(this, smallerBuf);
  }
};

ChunkStream.prototype._processRead = function (read) {
  this._reads.shift(); // == read

  let pos = 0;
  let count = 0;
  let data = Buffer.alloc(read.length);

  // create buffer for all data
  while (pos < read.length) {
    let buf = this._buffers[count++];
    let len = Math.min(buf.length, read.length - pos);

    buf.copy(data, pos, 0, len);
    pos += len;

    // last buffer wasn't used all so just slice it and leave
    if (len !== buf.length) {
      this._buffers[--count] = buf.slice(len);
    }
  }

  // remove all used buffers
  if (count > 0) {
    this._buffers.splice(0, count);
  }

  this._buffered -= read.length;

  read.func.call(this, data);
};

ChunkStream.prototype._process = function () {
  try {
    // as long as there is any data and read requests
    while (this._buffered > 0 && this._reads && this._reads.length > 0) {
      let read = this._reads[0];

      // read any data (but no more than length)
      if (read.allowLess) {
        this._processReadAllowingLess(read);
      } else if (this._buffered >= read.length) {
        // ok we can meet some expectations

        this._processRead(read);
      } else {
        // not enought data to satisfy first request in queue
        // so we need to wait for more
        break;
      }
    }

    if (this._buffers && !this.writable) {
      this._end();
    }
  } catch (ex) {
    this.emit("error", ex);
  }
};


/***/ }),

/***/ 7946:
/***/ ((module) => {

"use strict";


module.exports = {
  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],

  TYPE_IHDR: 0x49484452,
  TYPE_IEND: 0x49454e44,
  TYPE_IDAT: 0x49444154,
  TYPE_PLTE: 0x504c5445,
  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase
  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase

  // color-type bits
  COLORTYPE_GRAYSCALE: 0,
  COLORTYPE_PALETTE: 1,
  COLORTYPE_COLOR: 2,
  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha

  // color-type combinations
  COLORTYPE_PALETTE_COLOR: 3,
  COLORTYPE_COLOR_ALPHA: 6,

  COLORTYPE_TO_BPP_MAP: {
    0: 1,
    2: 3,
    3: 1,
    4: 2,
    6: 4,
  },

  GAMMA_DIVISION: 100000,
};


/***/ }),

/***/ 6210:
/***/ ((module) => {

"use strict";


let crcTable = [];

(function () {
  for (let i = 0; i < 256; i++) {
    let currentCrc = i;
    for (let j = 0; j < 8; j++) {
      if (currentCrc & 1) {
        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);
      } else {
        currentCrc = currentCrc >>> 1;
      }
    }
    crcTable[i] = currentCrc;
  }
})();

let CrcCalculator = (module.exports = function () {
  this._crc = -1;
});

CrcCalculator.prototype.write = function (data) {
  for (let i = 0; i < data.length; i++) {
    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
  }
  return true;
};

CrcCalculator.prototype.crc32 = function () {
  return this._crc ^ -1;
};

CrcCalculator.crc32 = function (buf) {
  let crc = -1;
  for (let i = 0; i < buf.length; i++) {
    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
  }
  return crc ^ -1;
};


/***/ }),

/***/ 3672:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let paethPredictor = __nccwpck_require__(1317);

function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
  for (let x = 0; x < byteWidth; x++) {
    rawData[rawPos + x] = pxData[pxPos + x];
  }
}

function filterSumNone(pxData, pxPos, byteWidth) {
  let sum = 0;
  let length = pxPos + byteWidth;

  for (let i = pxPos; i < length; i++) {
    sum += Math.abs(pxData[i]);
  }
  return sum;
}

function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
  for (let x = 0; x < byteWidth; x++) {
    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    let val = pxData[pxPos + x] - left;

    rawData[rawPos + x] = val;
  }
}

function filterSumSub(pxData, pxPos, byteWidth, bpp) {
  let sum = 0;
  for (let x = 0; x < byteWidth; x++) {
    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    let val = pxData[pxPos + x] - left;

    sum += Math.abs(val);
  }

  return sum;
}

function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
  for (let x = 0; x < byteWidth; x++) {
    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    let val = pxData[pxPos + x] - up;

    rawData[rawPos + x] = val;
  }
}

function filterSumUp(pxData, pxPos, byteWidth) {
  let sum = 0;
  let length = pxPos + byteWidth;
  for (let x = pxPos; x < length; x++) {
    let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
    let val = pxData[x] - up;

    sum += Math.abs(val);
  }

  return sum;
}

function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
  for (let x = 0; x < byteWidth; x++) {
    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    let val = pxData[pxPos + x] - ((left + up) >> 1);

    rawData[rawPos + x] = val;
  }
}

function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
  let sum = 0;
  for (let x = 0; x < byteWidth; x++) {
    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    let val = pxData[pxPos + x] - ((left + up) >> 1);

    sum += Math.abs(val);
  }

  return sum;
}

function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
  for (let x = 0; x < byteWidth; x++) {
    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    let upleft =
      pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
    let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

    rawData[rawPos + x] = val;
  }
}

function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
  let sum = 0;
  for (let x = 0; x < byteWidth; x++) {
    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    let upleft =
      pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
    let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

    sum += Math.abs(val);
  }

  return sum;
}

let filters = {
  0: filterNone,
  1: filterSub,
  2: filterUp,
  3: filterAvg,
  4: filterPaeth,
};

let filterSums = {
  0: filterSumNone,
  1: filterSumSub,
  2: filterSumUp,
  3: filterSumAvg,
  4: filterSumPaeth,
};

module.exports = function (pxData, width, height, options, bpp) {
  let filterTypes;
  if (!("filterType" in options) || options.filterType === -1) {
    filterTypes = [0, 1, 2, 3, 4];
  } else if (typeof options.filterType === "number") {
    filterTypes = [options.filterType];
  } else {
    throw new Error("unrecognised filter types");
  }

  if (options.bitDepth === 16) {
    bpp *= 2;
  }
  let byteWidth = width * bpp;
  let rawPos = 0;
  let pxPos = 0;
  let rawData = Buffer.alloc((byteWidth + 1) * height);

  let sel = filterTypes[0];

  for (let y = 0; y < height; y++) {
    if (filterTypes.length > 1) {
      // find best filter for this line (with lowest sum of values)
      let min = Infinity;

      for (let i = 0; i < filterTypes.length; i++) {
        let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
        if (sum < min) {
          sel = filterTypes[i];
          min = sum;
        }
      }
    }

    rawData[rawPos] = sel;
    rawPos++;
    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
    rawPos += byteWidth;
    pxPos += byteWidth;
  }
  return rawData;
};


/***/ }),

/***/ 1940:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let util = __nccwpck_require__(1669);
let ChunkStream = __nccwpck_require__(9035);
let Filter = __nccwpck_require__(6833);

let FilterAsync = (module.exports = function (bitmapInfo) {
  ChunkStream.call(this);

  let buffers = [];
  let that = this;
  this._filter = new Filter(bitmapInfo, {
    read: this.read.bind(this),
    write: function (buffer) {
      buffers.push(buffer);
    },
    complete: function () {
      that.emit("complete", Buffer.concat(buffers));
    },
  });

  this._filter.start();
});
util.inherits(FilterAsync, ChunkStream);


/***/ }),

/***/ 3248:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


let SyncReader = __nccwpck_require__(5872);
let Filter = __nccwpck_require__(6833);

exports.process = function (inBuffer, bitmapInfo) {
  let outBuffers = [];
  let reader = new SyncReader(inBuffer);
  let filter = new Filter(bitmapInfo, {
    read: reader.read.bind(reader),
    write: function (bufferPart) {
      outBuffers.push(bufferPart);
    },
    complete: function () {},
  });

  filter.start();
  reader.process();

  return Buffer.concat(outBuffers);
};


/***/ }),

/***/ 6833:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let interlaceUtils = __nccwpck_require__(5375);
let paethPredictor = __nccwpck_require__(1317);

function getByteWidth(width, bpp, depth) {
  let byteWidth = width * bpp;
  if (depth !== 8) {
    byteWidth = Math.ceil(byteWidth / (8 / depth));
  }
  return byteWidth;
}

let Filter = (module.exports = function (bitmapInfo, dependencies) {
  let width = bitmapInfo.width;
  let height = bitmapInfo.height;
  let interlace = bitmapInfo.interlace;
  let bpp = bitmapInfo.bpp;
  let depth = bitmapInfo.depth;

  this.read = dependencies.read;
  this.write = dependencies.write;
  this.complete = dependencies.complete;

  this._imageIndex = 0;
  this._images = [];
  if (interlace) {
    let passes = interlaceUtils.getImagePasses(width, height);
    for (let i = 0; i < passes.length; i++) {
      this._images.push({
        byteWidth: getByteWidth(passes[i].width, bpp, depth),
        height: passes[i].height,
        lineIndex: 0,
      });
    }
  } else {
    this._images.push({
      byteWidth: getByteWidth(width, bpp, depth),
      height: height,
      lineIndex: 0,
    });
  }

  // when filtering the line we look at the pixel to the left
  // the spec also says it is done on a byte level regardless of the number of pixels
  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back
  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.
  if (depth === 8) {
    this._xComparison = bpp;
  } else if (depth === 16) {
    this._xComparison = bpp * 2;
  } else {
    this._xComparison = 1;
  }
});

Filter.prototype.start = function () {
  this.read(
    this._images[this._imageIndex].byteWidth + 1,
    this._reverseFilterLine.bind(this)
  );
};

Filter.prototype._unFilterType1 = function (
  rawData,
  unfilteredLine,
  byteWidth
) {
  let xComparison = this._xComparison;
  let xBiggerThan = xComparison - 1;

  for (let x = 0; x < byteWidth; x++) {
    let rawByte = rawData[1 + x];
    let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    unfilteredLine[x] = rawByte + f1Left;
  }
};

Filter.prototype._unFilterType2 = function (
  rawData,
  unfilteredLine,
  byteWidth
) {
  let lastLine = this._lastLine;

  for (let x = 0; x < byteWidth; x++) {
    let rawByte = rawData[1 + x];
    let f2Up = lastLine ? lastLine[x] : 0;
    unfilteredLine[x] = rawByte + f2Up;
  }
};

Filter.prototype._unFilterType3 = function (
  rawData,
  unfilteredLine,
  byteWidth
) {
  let xComparison = this._xComparison;
  let xBiggerThan = xComparison - 1;
  let lastLine = this._lastLine;

  for (let x = 0; x < byteWidth; x++) {
    let rawByte = rawData[1 + x];
    let f3Up = lastLine ? lastLine[x] : 0;
    let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    let f3Add = Math.floor((f3Left + f3Up) / 2);
    unfilteredLine[x] = rawByte + f3Add;
  }
};

Filter.prototype._unFilterType4 = function (
  rawData,
  unfilteredLine,
  byteWidth
) {
  let xComparison = this._xComparison;
  let xBiggerThan = xComparison - 1;
  let lastLine = this._lastLine;

  for (let x = 0; x < byteWidth; x++) {
    let rawByte = rawData[1 + x];
    let f4Up = lastLine ? lastLine[x] : 0;
    let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
    let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
    unfilteredLine[x] = rawByte + f4Add;
  }
};

Filter.prototype._reverseFilterLine = function (rawData) {
  let filter = rawData[0];
  let unfilteredLine;
  let currentImage = this._images[this._imageIndex];
  let byteWidth = currentImage.byteWidth;

  if (filter === 0) {
    unfilteredLine = rawData.slice(1, byteWidth + 1);
  } else {
    unfilteredLine = Buffer.alloc(byteWidth);

    switch (filter) {
      case 1:
        this._unFilterType1(rawData, unfilteredLine, byteWidth);
        break;
      case 2:
        this._unFilterType2(rawData, unfilteredLine, byteWidth);
        break;
      case 3:
        this._unFilterType3(rawData, unfilteredLine, byteWidth);
        break;
      case 4:
        this._unFilterType4(rawData, unfilteredLine, byteWidth);
        break;
      default:
        throw new Error("Unrecognised filter type - " + filter);
    }
  }

  this.write(unfilteredLine);

  currentImage.lineIndex++;
  if (currentImage.lineIndex >= currentImage.height) {
    this._lastLine = null;
    this._imageIndex++;
    currentImage = this._images[this._imageIndex];
  } else {
    this._lastLine = unfilteredLine;
  }

  if (currentImage) {
    // read, using the byte width that may be from the new current image
    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
  } else {
    this._lastLine = null;
    this.complete();
  }
};


/***/ }),

/***/ 9884:
/***/ ((module) => {

"use strict";


function dePalette(indata, outdata, width, height, palette) {
  let pxPos = 0;
  // use values from palette
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let color = palette[indata[pxPos]];

      if (!color) {
        throw new Error("index " + indata[pxPos] + " not in palette");
      }

      for (let i = 0; i < 4; i++) {
        outdata[pxPos + i] = color[i];
      }
      pxPos += 4;
    }
  }
}

function replaceTransparentColor(indata, outdata, width, height, transColor) {
  let pxPos = 0;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let makeTrans = false;

      if (transColor.length === 1) {
        if (transColor[0] === indata[pxPos]) {
          makeTrans = true;
        }
      } else if (
        transColor[0] === indata[pxPos] &&
        transColor[1] === indata[pxPos + 1] &&
        transColor[2] === indata[pxPos + 2]
      ) {
        makeTrans = true;
      }
      if (makeTrans) {
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = 0;
        }
      }
      pxPos += 4;
    }
  }
}

function scaleDepth(indata, outdata, width, height, depth) {
  let maxOutSample = 255;
  let maxInSample = Math.pow(2, depth) - 1;
  let pxPos = 0;

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let i = 0; i < 4; i++) {
        outdata[pxPos + i] = Math.floor(
          (indata[pxPos + i] * maxOutSample) / maxInSample + 0.5
        );
      }
      pxPos += 4;
    }
  }
}

module.exports = function (indata, imageData) {
  let depth = imageData.depth;
  let width = imageData.width;
  let height = imageData.height;
  let colorType = imageData.colorType;
  let transColor = imageData.transColor;
  let palette = imageData.palette;

  let outdata = indata; // only different for 16 bits

  if (colorType === 3) {
    // paletted
    dePalette(indata, outdata, width, height, palette);
  } else {
    if (transColor) {
      replaceTransparentColor(indata, outdata, width, height, transColor);
    }
    // if it needs scaling
    if (depth !== 8) {
      // if we need to change the buffer size
      if (depth === 16) {
        outdata = Buffer.alloc(width * height * 4);
      }
      scaleDepth(indata, outdata, width, height, depth);
    }
  }
  return outdata;
};


/***/ }),

/***/ 5375:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Adam 7
//   0 1 2 3 4 5 6 7
// 0 x 6 4 6 x 6 4 6
// 1 7 7 7 7 7 7 7 7
// 2 5 6 5 6 5 6 5 6
// 3 7 7 7 7 7 7 7 7
// 4 3 6 4 6 3 6 4 6
// 5 7 7 7 7 7 7 7 7
// 6 5 6 5 6 5 6 5 6
// 7 7 7 7 7 7 7 7 7

let imagePasses = [
  {
    // pass 1 - 1px
    x: [0],
    y: [0],
  },
  {
    // pass 2 - 1px
    x: [4],
    y: [0],
  },
  {
    // pass 3 - 2px
    x: [0, 4],
    y: [4],
  },
  {
    // pass 4 - 4px
    x: [2, 6],
    y: [0, 4],
  },
  {
    // pass 5 - 8px
    x: [0, 2, 4, 6],
    y: [2, 6],
  },
  {
    // pass 6 - 16px
    x: [1, 3, 5, 7],
    y: [0, 2, 4, 6],
  },
  {
    // pass 7 - 32px
    x: [0, 1, 2, 3, 4, 5, 6, 7],
    y: [1, 3, 5, 7],
  },
];

exports.getImagePasses = function (width, height) {
  let images = [];
  let xLeftOver = width % 8;
  let yLeftOver = height % 8;
  let xRepeats = (width - xLeftOver) / 8;
  let yRepeats = (height - yLeftOver) / 8;
  for (let i = 0; i < imagePasses.length; i++) {
    let pass = imagePasses[i];
    let passWidth = xRepeats * pass.x.length;
    let passHeight = yRepeats * pass.y.length;
    for (let j = 0; j < pass.x.length; j++) {
      if (pass.x[j] < xLeftOver) {
        passWidth++;
      } else {
        break;
      }
    }
    for (let j = 0; j < pass.y.length; j++) {
      if (pass.y[j] < yLeftOver) {
        passHeight++;
      } else {
        break;
      }
    }
    if (passWidth > 0 && passHeight > 0) {
      images.push({ width: passWidth, height: passHeight, index: i });
    }
  }
  return images;
};

exports.getInterlaceIterator = function (width) {
  return function (x, y, pass) {
    let outerXLeftOver = x % imagePasses[pass].x.length;
    let outerX =
      ((x - outerXLeftOver) / imagePasses[pass].x.length) * 8 +
      imagePasses[pass].x[outerXLeftOver];
    let outerYLeftOver = y % imagePasses[pass].y.length;
    let outerY =
      ((y - outerYLeftOver) / imagePasses[pass].y.length) * 8 +
      imagePasses[pass].y[outerYLeftOver];
    return outerX * 4 + outerY * width * 4;
  };
};


/***/ }),

/***/ 261:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let util = __nccwpck_require__(1669);
let Stream = __nccwpck_require__(2413);
let constants = __nccwpck_require__(7946);
let Packer = __nccwpck_require__(9794);

let PackerAsync = (module.exports = function (opt) {
  Stream.call(this);

  let options = opt || {};

  this._packer = new Packer(options);
  this._deflate = this._packer.createDeflate();

  this.readable = true;
});
util.inherits(PackerAsync, Stream);

PackerAsync.prototype.pack = function (data, width, height, gamma) {
  // Signature
  this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
  this.emit("data", this._packer.packIHDR(width, height));

  if (gamma) {
    this.emit("data", this._packer.packGAMA(gamma));
  }

  let filteredData = this._packer.filterData(data, width, height);

  // compress it
  this._deflate.on("error", this.emit.bind(this, "error"));

  this._deflate.on(
    "data",
    function (compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this)
  );

  this._deflate.on(
    "end",
    function () {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }.bind(this)
  );

  this._deflate.end(filteredData);
};


/***/ }),

/***/ 1541:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let hasSyncZlib = true;
let zlib = __nccwpck_require__(8761);
if (!zlib.deflateSync) {
  hasSyncZlib = false;
}
let constants = __nccwpck_require__(7946);
let Packer = __nccwpck_require__(9794);

module.exports = function (metaData, opt) {
  if (!hasSyncZlib) {
    throw new Error(
      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
    );
  }

  let options = opt || {};

  let packer = new Packer(options);

  let chunks = [];

  // Signature
  chunks.push(Buffer.from(constants.PNG_SIGNATURE));

  // Header
  chunks.push(packer.packIHDR(metaData.width, metaData.height));

  if (metaData.gamma) {
    chunks.push(packer.packGAMA(metaData.gamma));
  }

  let filteredData = packer.filterData(
    metaData.data,
    metaData.width,
    metaData.height
  );

  // compress it
  let compressedData = zlib.deflateSync(
    filteredData,
    packer.getDeflateOptions()
  );
  filteredData = null;

  if (!compressedData || !compressedData.length) {
    throw new Error("bad png - invalid compressed data response");
  }
  chunks.push(packer.packIDAT(compressedData));

  // End
  chunks.push(packer.packIEND());

  return Buffer.concat(chunks);
};


/***/ }),

/***/ 9794:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let constants = __nccwpck_require__(7946);
let CrcStream = __nccwpck_require__(6210);
let bitPacker = __nccwpck_require__(5711);
let filter = __nccwpck_require__(3672);
let zlib = __nccwpck_require__(8761);

let Packer = (module.exports = function (options) {
  this._options = options;

  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
  options.deflateLevel =
    options.deflateLevel != null ? options.deflateLevel : 9;
  options.deflateStrategy =
    options.deflateStrategy != null ? options.deflateStrategy : 3;
  options.inputHasAlpha =
    options.inputHasAlpha != null ? options.inputHasAlpha : true;
  options.deflateFactory = options.deflateFactory || zlib.createDeflate;
  options.bitDepth = options.bitDepth || 8;
  // This is outputColorType
  options.colorType =
    typeof options.colorType === "number"
      ? options.colorType
      : constants.COLORTYPE_COLOR_ALPHA;
  options.inputColorType =
    typeof options.inputColorType === "number"
      ? options.inputColorType
      : constants.COLORTYPE_COLOR_ALPHA;

  if (
    [
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA,
    ].indexOf(options.colorType) === -1
  ) {
    throw new Error(
      "option color type:" + options.colorType + " is not supported at present"
    );
  }
  if (
    [
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA,
    ].indexOf(options.inputColorType) === -1
  ) {
    throw new Error(
      "option input color type:" +
        options.inputColorType +
        " is not supported at present"
    );
  }
  if (options.bitDepth !== 8 && options.bitDepth !== 16) {
    throw new Error(
      "option bit depth:" + options.bitDepth + " is not supported at present"
    );
  }
});

Packer.prototype.getDeflateOptions = function () {
  return {
    chunkSize: this._options.deflateChunkSize,
    level: this._options.deflateLevel,
    strategy: this._options.deflateStrategy,
  };
};

Packer.prototype.createDeflate = function () {
  return this._options.deflateFactory(this.getDeflateOptions());
};

Packer.prototype.filterData = function (data, width, height) {
  // convert to correct format for filtering (e.g. right bpp and bit depth)
  let packedData = bitPacker(data, width, height, this._options);

  // filter pixel data
  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
  let filteredData = filter(packedData, width, height, this._options, bpp);
  return filteredData;
};

Packer.prototype._packChunk = function (type, data) {
  let len = data ? data.length : 0;
  let buf = Buffer.alloc(len + 12);

  buf.writeUInt32BE(len, 0);
  buf.writeUInt32BE(type, 4);

  if (data) {
    data.copy(buf, 8);
  }

  buf.writeInt32BE(
    CrcStream.crc32(buf.slice(4, buf.length - 4)),
    buf.length - 4
  );
  return buf;
};

Packer.prototype.packGAMA = function (gamma) {
  let buf = Buffer.alloc(4);
  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
  return this._packChunk(constants.TYPE_gAMA, buf);
};

Packer.prototype.packIHDR = function (width, height) {
  let buf = Buffer.alloc(13);
  buf.writeUInt32BE(width, 0);
  buf.writeUInt32BE(height, 4);
  buf[8] = this._options.bitDepth; // Bit depth
  buf[9] = this._options.colorType; // colorType
  buf[10] = 0; // compression
  buf[11] = 0; // filter
  buf[12] = 0; // interlace

  return this._packChunk(constants.TYPE_IHDR, buf);
};

Packer.prototype.packIDAT = function (data) {
  return this._packChunk(constants.TYPE_IDAT, data);
};

Packer.prototype.packIEND = function () {
  return this._packChunk(constants.TYPE_IEND, null);
};


/***/ }),

/***/ 1317:
/***/ ((module) => {

"use strict";


module.exports = function paethPredictor(left, above, upLeft) {
  let paeth = left + above - upLeft;
  let pLeft = Math.abs(paeth - left);
  let pAbove = Math.abs(paeth - above);
  let pUpLeft = Math.abs(paeth - upLeft);

  if (pLeft <= pAbove && pLeft <= pUpLeft) {
    return left;
  }
  if (pAbove <= pUpLeft) {
    return above;
  }
  return upLeft;
};


/***/ }),

/***/ 6029:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let util = __nccwpck_require__(1669);
let zlib = __nccwpck_require__(8761);
let ChunkStream = __nccwpck_require__(9035);
let FilterAsync = __nccwpck_require__(1940);
let Parser = __nccwpck_require__(5639);
let bitmapper = __nccwpck_require__(2470);
let formatNormaliser = __nccwpck_require__(9884);

let ParserAsync = (module.exports = function (options) {
  ChunkStream.call(this);

  this._parser = new Parser(options, {
    read: this.read.bind(this),
    error: this._handleError.bind(this),
    metadata: this._handleMetaData.bind(this),
    gamma: this.emit.bind(this, "gamma"),
    palette: this._handlePalette.bind(this),
    transColor: this._handleTransColor.bind(this),
    finished: this._finished.bind(this),
    inflateData: this._inflateData.bind(this),
    simpleTransparency: this._simpleTransparency.bind(this),
    headersFinished: this._headersFinished.bind(this),
  });
  this._options = options;
  this.writable = true;

  this._parser.start();
});
util.inherits(ParserAsync, ChunkStream);

ParserAsync.prototype._handleError = function (err) {
  this.emit("error", err);

  this.writable = false;

  this.destroy();

  if (this._inflate && this._inflate.destroy) {
    this._inflate.destroy();
  }

  if (this._filter) {
    this._filter.destroy();
    // For backward compatibility with Node 7 and below.
    // Suppress errors due to _inflate calling write() even after
    // it's destroy()'ed.
    this._filter.on("error", function () {});
  }

  this.errord = true;
};

ParserAsync.prototype._inflateData = function (data) {
  if (!this._inflate) {
    if (this._bitmapInfo.interlace) {
      this._inflate = zlib.createInflate();

      this._inflate.on("error", this.emit.bind(this, "error"));
      this._filter.on("complete", this._complete.bind(this));

      this._inflate.pipe(this._filter);
    } else {
      let rowSize =
        ((this._bitmapInfo.width *
          this._bitmapInfo.bpp *
          this._bitmapInfo.depth +
          7) >>
          3) +
        1;
      let imageSize = rowSize * this._bitmapInfo.height;
      let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);

      this._inflate = zlib.createInflate({ chunkSize: chunkSize });
      let leftToInflate = imageSize;

      let emitError = this.emit.bind(this, "error");
      this._inflate.on("error", function (err) {
        if (!leftToInflate) {
          return;
        }

        emitError(err);
      });
      this._filter.on("complete", this._complete.bind(this));

      let filterWrite = this._filter.write.bind(this._filter);
      this._inflate.on("data", function (chunk) {
        if (!leftToInflate) {
          return;
        }

        if (chunk.length > leftToInflate) {
          chunk = chunk.slice(0, leftToInflate);
        }

        leftToInflate -= chunk.length;

        filterWrite(chunk);
      });

      this._inflate.on("end", this._filter.end.bind(this._filter));
    }
  }
  this._inflate.write(data);
};

ParserAsync.prototype._handleMetaData = function (metaData) {
  this._metaData = metaData;
  this._bitmapInfo = Object.create(metaData);

  this._filter = new FilterAsync(this._bitmapInfo);
};

ParserAsync.prototype._handleTransColor = function (transColor) {
  this._bitmapInfo.transColor = transColor;
};

ParserAsync.prototype._handlePalette = function (palette) {
  this._bitmapInfo.palette = palette;
};

ParserAsync.prototype._simpleTransparency = function () {
  this._metaData.alpha = true;
};

ParserAsync.prototype._headersFinished = function () {
  // Up until this point, we don't know if we have a tRNS chunk (alpha)
  // so we can't emit metadata any earlier
  this.emit("metadata", this._metaData);
};

ParserAsync.prototype._finished = function () {
  if (this.errord) {
    return;
  }

  if (!this._inflate) {
    this.emit("error", "No Inflate block");
  } else {
    // no more data to inflate
    this._inflate.end();
  }
};

ParserAsync.prototype._complete = function (filteredData) {
  if (this.errord) {
    return;
  }

  let normalisedBitmapData;

  try {
    let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);

    normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
    bitmapData = null;
  } catch (ex) {
    this._handleError(ex);
    return;
  }

  this.emit("parsed", normalisedBitmapData);
};


/***/ }),

/***/ 8308:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let hasSyncZlib = true;
let zlib = __nccwpck_require__(8761);
let inflateSync = __nccwpck_require__(1365);
if (!zlib.deflateSync) {
  hasSyncZlib = false;
}
let SyncReader = __nccwpck_require__(5872);
let FilterSync = __nccwpck_require__(3248);
let Parser = __nccwpck_require__(5639);
let bitmapper = __nccwpck_require__(2470);
let formatNormaliser = __nccwpck_require__(9884);

module.exports = function (buffer, options) {
  if (!hasSyncZlib) {
    throw new Error(
      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
    );
  }

  let err;
  function handleError(_err_) {
    err = _err_;
  }

  let metaData;
  function handleMetaData(_metaData_) {
    metaData = _metaData_;
  }

  function handleTransColor(transColor) {
    metaData.transColor = transColor;
  }

  function handlePalette(palette) {
    metaData.palette = palette;
  }

  function handleSimpleTransparency() {
    metaData.alpha = true;
  }

  let gamma;
  function handleGamma(_gamma_) {
    gamma = _gamma_;
  }

  let inflateDataList = [];
  function handleInflateData(inflatedData) {
    inflateDataList.push(inflatedData);
  }

  let reader = new SyncReader(buffer);

  let parser = new Parser(options, {
    read: reader.read.bind(reader),
    error: handleError,
    metadata: handleMetaData,
    gamma: handleGamma,
    palette: handlePalette,
    transColor: handleTransColor,
    inflateData: handleInflateData,
    simpleTransparency: handleSimpleTransparency,
  });

  parser.start();
  reader.process();

  if (err) {
    throw err;
  }

  //join together the inflate datas
  let inflateData = Buffer.concat(inflateDataList);
  inflateDataList.length = 0;

  let inflatedData;
  if (metaData.interlace) {
    inflatedData = zlib.inflateSync(inflateData);
  } else {
    let rowSize =
      ((metaData.width * metaData.bpp * metaData.depth + 7) >> 3) + 1;
    let imageSize = rowSize * metaData.height;
    inflatedData = inflateSync(inflateData, {
      chunkSize: imageSize,
      maxLength: imageSize,
    });
  }
  inflateData = null;

  if (!inflatedData || !inflatedData.length) {
    throw new Error("bad png - invalid inflate data response");
  }

  let unfilteredData = FilterSync.process(inflatedData, metaData);
  inflateData = null;

  let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
  unfilteredData = null;

  let normalisedBitmapData = formatNormaliser(bitmapData, metaData);

  metaData.data = normalisedBitmapData;
  metaData.gamma = gamma || 0;

  return metaData;
};


/***/ }),

/***/ 5639:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let constants = __nccwpck_require__(7946);
let CrcCalculator = __nccwpck_require__(6210);

let Parser = (module.exports = function (options, dependencies) {
  this._options = options;
  options.checkCRC = options.checkCRC !== false;

  this._hasIHDR = false;
  this._hasIEND = false;
  this._emittedHeadersFinished = false;

  // input flags/metadata
  this._palette = [];
  this._colorType = 0;

  this._chunks = {};
  this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
  this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
  this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
  this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
  this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
  this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);

  this.read = dependencies.read;
  this.error = dependencies.error;
  this.metadata = dependencies.metadata;
  this.gamma = dependencies.gamma;
  this.transColor = dependencies.transColor;
  this.palette = dependencies.palette;
  this.parsed = dependencies.parsed;
  this.inflateData = dependencies.inflateData;
  this.finished = dependencies.finished;
  this.simpleTransparency = dependencies.simpleTransparency;
  this.headersFinished = dependencies.headersFinished || function () {};
});

Parser.prototype.start = function () {
  this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
};

Parser.prototype._parseSignature = function (data) {
  let signature = constants.PNG_SIGNATURE;

  for (let i = 0; i < signature.length; i++) {
    if (data[i] !== signature[i]) {
      this.error(new Error("Invalid file signature"));
      return;
    }
  }
  this.read(8, this._parseChunkBegin.bind(this));
};

Parser.prototype._parseChunkBegin = function (data) {
  // chunk content length
  let length = data.readUInt32BE(0);

  // chunk type
  let type = data.readUInt32BE(4);
  let name = "";
  for (let i = 4; i < 8; i++) {
    name += String.fromCharCode(data[i]);
  }

  //console.log('chunk ', name, length);

  // chunk flags
  let ancillary = Boolean(data[4] & 0x20); // or critical
  //    priv = Boolean(data[5] & 0x20), // or public
  //    safeToCopy = Boolean(data[7] & 0x20); // or unsafe

  if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
    this.error(new Error("Expected IHDR on beggining"));
    return;
  }

  this._crc = new CrcCalculator();
  this._crc.write(Buffer.from(name));

  if (this._chunks[type]) {
    return this._chunks[type](length);
  }

  if (!ancillary) {
    this.error(new Error("Unsupported critical chunk type " + name));
    return;
  }

  this.read(length + 4, this._skipChunk.bind(this));
};

Parser.prototype._skipChunk = function (/*data*/) {
  this.read(8, this._parseChunkBegin.bind(this));
};

Parser.prototype._handleChunkEnd = function () {
  this.read(4, this._parseChunkEnd.bind(this));
};

Parser.prototype._parseChunkEnd = function (data) {
  let fileCrc = data.readInt32BE(0);
  let calcCrc = this._crc.crc32();

  // check CRC
  if (this._options.checkCRC && calcCrc !== fileCrc) {
    this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
    return;
  }

  if (!this._hasIEND) {
    this.read(8, this._parseChunkBegin.bind(this));
  }
};

Parser.prototype._handleIHDR = function (length) {
  this.read(length, this._parseIHDR.bind(this));
};
Parser.prototype._parseIHDR = function (data) {
  this._crc.write(data);

  let width = data.readUInt32BE(0);
  let height = data.readUInt32BE(4);
  let depth = data[8];
  let colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
  let compr = data[10];
  let filter = data[11];
  let interlace = data[12];

  // console.log('    width', width, 'height', height,
  //     'depth', depth, 'colorType', colorType,
  //     'compr', compr, 'filter', filter, 'interlace', interlace
  // );

  if (
    depth !== 8 &&
    depth !== 4 &&
    depth !== 2 &&
    depth !== 1 &&
    depth !== 16
  ) {
    this.error(new Error("Unsupported bit depth " + depth));
    return;
  }
  if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
    this.error(new Error("Unsupported color type"));
    return;
  }
  if (compr !== 0) {
    this.error(new Error("Unsupported compression method"));
    return;
  }
  if (filter !== 0) {
    this.error(new Error("Unsupported filter method"));
    return;
  }
  if (interlace !== 0 && interlace !== 1) {
    this.error(new Error("Unsupported interlace method"));
    return;
  }

  this._colorType = colorType;

  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];

  this._hasIHDR = true;

  this.metadata({
    width: width,
    height: height,
    depth: depth,
    interlace: Boolean(interlace),
    palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
    color: Boolean(colorType & constants.COLORTYPE_COLOR),
    alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
    bpp: bpp,
    colorType: colorType,
  });

  this._handleChunkEnd();
};

Parser.prototype._handlePLTE = function (length) {
  this.read(length, this._parsePLTE.bind(this));
};
Parser.prototype._parsePLTE = function (data) {
  this._crc.write(data);

  let entries = Math.floor(data.length / 3);
  // console.log('Palette:', entries);

  for (let i = 0; i < entries; i++) {
    this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 0xff]);
  }

  this.palette(this._palette);

  this._handleChunkEnd();
};

Parser.prototype._handleTRNS = function (length) {
  this.simpleTransparency();
  this.read(length, this._parseTRNS.bind(this));
};
Parser.prototype._parseTRNS = function (data) {
  this._crc.write(data);

  // palette
  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
    if (this._palette.length === 0) {
      this.error(new Error("Transparency chunk must be after palette"));
      return;
    }
    if (data.length > this._palette.length) {
      this.error(new Error("More transparent colors than palette size"));
      return;
    }
    for (let i = 0; i < data.length; i++) {
      this._palette[i][3] = data[i];
    }
    this.palette(this._palette);
  }

  // for colorType 0 (grayscale) and 2 (rgb)
  // there might be one gray/color defined as transparent
  if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
    // grey, 2 bytes
    this.transColor([data.readUInt16BE(0)]);
  }
  if (this._colorType === constants.COLORTYPE_COLOR) {
    this.transColor([
      data.readUInt16BE(0),
      data.readUInt16BE(2),
      data.readUInt16BE(4),
    ]);
  }

  this._handleChunkEnd();
};

Parser.prototype._handleGAMA = function (length) {
  this.read(length, this._parseGAMA.bind(this));
};
Parser.prototype._parseGAMA = function (data) {
  this._crc.write(data);
  this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);

  this._handleChunkEnd();
};

Parser.prototype._handleIDAT = function (length) {
  if (!this._emittedHeadersFinished) {
    this._emittedHeadersFinished = true;
    this.headersFinished();
  }
  this.read(-length, this._parseIDAT.bind(this, length));
};
Parser.prototype._parseIDAT = function (length, data) {
  this._crc.write(data);

  if (
    this._colorType === constants.COLORTYPE_PALETTE_COLOR &&
    this._palette.length === 0
  ) {
    throw new Error("Expected palette not found");
  }

  this.inflateData(data);
  let leftOverLength = length - data.length;

  if (leftOverLength > 0) {
    this._handleIDAT(leftOverLength);
  } else {
    this._handleChunkEnd();
  }
};

Parser.prototype._handleIEND = function (length) {
  this.read(length, this._parseIEND.bind(this));
};
Parser.prototype._parseIEND = function (data) {
  this._crc.write(data);

  this._hasIEND = true;
  this._handleChunkEnd();

  if (this.finished) {
    this.finished();
  }
};


/***/ }),

/***/ 3749:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


let parse = __nccwpck_require__(8308);
let pack = __nccwpck_require__(1541);

exports.read = function (buffer, options) {
  return parse(buffer, options || {});
};

exports.write = function (png, options) {
  return pack(png, options);
};


/***/ }),

/***/ 5076:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


let util = __nccwpck_require__(1669);
let Stream = __nccwpck_require__(2413);
let Parser = __nccwpck_require__(6029);
let Packer = __nccwpck_require__(261);
let PNGSync = __nccwpck_require__(3749);

let PNG = (exports.PNG = function (options) {
  Stream.call(this);

  options = options || {}; // eslint-disable-line no-param-reassign

  // coerce pixel dimensions to integers (also coerces undefined -> 0):
  this.width = options.width | 0;
  this.height = options.height | 0;

  this.data =
    this.width > 0 && this.height > 0
      ? Buffer.alloc(4 * this.width * this.height)
      : null;

  if (options.fill && this.data) {
    this.data.fill(0);
  }

  this.gamma = 0;
  this.readable = this.writable = true;

  this._parser = new Parser(options);

  this._parser.on("error", this.emit.bind(this, "error"));
  this._parser.on("close", this._handleClose.bind(this));
  this._parser.on("metadata", this._metadata.bind(this));
  this._parser.on("gamma", this._gamma.bind(this));
  this._parser.on(
    "parsed",
    function (data) {
      this.data = data;
      this.emit("parsed", data);
    }.bind(this)
  );

  this._packer = new Packer(options);
  this._packer.on("data", this.emit.bind(this, "data"));
  this._packer.on("end", this.emit.bind(this, "end"));
  this._parser.on("close", this._handleClose.bind(this));
  this._packer.on("error", this.emit.bind(this, "error"));
});
util.inherits(PNG, Stream);

PNG.sync = PNGSync;

PNG.prototype.pack = function () {
  if (!this.data || !this.data.length) {
    this.emit("error", "No data provided");
    return this;
  }

  process.nextTick(
    function () {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this)
  );

  return this;
};

PNG.prototype.parse = function (data, callback) {
  if (callback) {
    let onParsed, onError;

    onParsed = function (parsedData) {
      this.removeListener("error", onError);

      this.data = parsedData;
      callback(null, this);
    }.bind(this);

    onError = function (err) {
      this.removeListener("parsed", onParsed);

      callback(err, null);
    }.bind(this);

    this.once("parsed", onParsed);
    this.once("error", onError);
  }

  this.end(data);
  return this;
};

PNG.prototype.write = function (data) {
  this._parser.write(data);
  return true;
};

PNG.prototype.end = function (data) {
  this._parser.end(data);
};

PNG.prototype._metadata = function (metadata) {
  this.width = metadata.width;
  this.height = metadata.height;

  this.emit("metadata", metadata);
};

PNG.prototype._gamma = function (gamma) {
  this.gamma = gamma;
};

PNG.prototype._handleClose = function () {
  if (!this._parser.writable && !this._packer.readable) {
    this.emit("close");
  }
};

PNG.bitblt = function (src, dst, srcX, srcY, width, height, deltaX, deltaY) {
  // eslint-disable-line max-params
  // coerce pixel dimensions to integers (also coerces undefined -> 0):
  /* eslint-disable no-param-reassign */
  srcX |= 0;
  srcY |= 0;
  width |= 0;
  height |= 0;
  deltaX |= 0;
  deltaY |= 0;
  /* eslint-enable no-param-reassign */

  if (
    srcX > src.width ||
    srcY > src.height ||
    srcX + width > src.width ||
    srcY + height > src.height
  ) {
    throw new Error("bitblt reading outside image");
  }

  if (
    deltaX > dst.width ||
    deltaY > dst.height ||
    deltaX + width > dst.width ||
    deltaY + height > dst.height
  ) {
    throw new Error("bitblt writing outside image");
  }

  for (let y = 0; y < height; y++) {
    src.data.copy(
      dst.data,
      ((deltaY + y) * dst.width + deltaX) << 2,
      ((srcY + y) * src.width + srcX) << 2,
      ((srcY + y) * src.width + srcX + width) << 2
    );
  }
};

PNG.prototype.bitblt = function (
  dst,
  srcX,
  srcY,
  width,
  height,
  deltaX,
  deltaY
) {
  // eslint-disable-line max-params

  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
  return this;
};

PNG.adjustGamma = function (src) {
  if (src.gamma) {
    for (let y = 0; y < src.height; y++) {
      for (let x = 0; x < src.width; x++) {
        let idx = (src.width * y + x) << 2;

        for (let i = 0; i < 3; i++) {
          let sample = src.data[idx + i] / 255;
          sample = Math.pow(sample, 1 / 2.2 / src.gamma);
          src.data[idx + i] = Math.round(sample * 255);
        }
      }
    }
    src.gamma = 0;
  }
};

PNG.prototype.adjustGamma = function () {
  PNG.adjustGamma(this);
};


/***/ }),

/***/ 1365:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


let assert = __nccwpck_require__(2357).ok;
let zlib = __nccwpck_require__(8761);
let util = __nccwpck_require__(1669);

let kMaxLength = __nccwpck_require__(4293).kMaxLength;

function Inflate(opts) {
  if (!(this instanceof Inflate)) {
    return new Inflate(opts);
  }

  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
    opts.chunkSize = zlib.Z_MIN_CHUNK;
  }

  zlib.Inflate.call(this, opts);

  // Node 8 --> 9 compatibility check
  this._offset = this._offset === undefined ? this._outOffset : this._offset;
  this._buffer = this._buffer || this._outBuffer;

  if (opts && opts.maxLength != null) {
    this._maxLength = opts.maxLength;
  }
}

function createInflate(opts) {
  return new Inflate(opts);
}

function _close(engine, callback) {
  if (callback) {
    process.nextTick(callback);
  }

  // Caller may invoke .close after a zlib error (which will null _handle).
  if (!engine._handle) {
    return;
  }

  engine._handle.close();
  engine._handle = null;
}

Inflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {
  if (typeof asyncCb === "function") {
    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
  }

  let self = this;

  let availInBefore = chunk && chunk.length;
  let availOutBefore = this._chunkSize - this._offset;
  let leftToInflate = this._maxLength;
  let inOff = 0;

  let buffers = [];
  let nread = 0;

  let error;
  this.on("error", function (err) {
    error = err;
  });

  function handleChunk(availInAfter, availOutAfter) {
    if (self._hadError) {
      return;
    }

    let have = availOutBefore - availOutAfter;
    assert(have >= 0, "have should not go down");

    if (have > 0) {
      let out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;

      if (out.length > leftToInflate) {
        out = out.slice(0, leftToInflate);
      }

      buffers.push(out);
      nread += out.length;
      leftToInflate -= out.length;

      if (leftToInflate === 0) {
        return false;
      }
    }

    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;

      return true;
    }

    return false;
  }

  assert(this._handle, "zlib binding closed");
  let res;
  do {
    res = this._handle.writeSync(
      flushFlag,
      chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore
    ); // out_len
    // Node 8 --> 9 compatibility check
    res = res || this._writeState;
  } while (!this._hadError && handleChunk(res[0], res[1]));

  if (this._hadError) {
    throw error;
  }

  if (nread >= kMaxLength) {
    _close(this);
    throw new RangeError(
      "Cannot create final Buffer. It would be larger than 0x" +
        kMaxLength.toString(16) +
        " bytes"
    );
  }

  let buf = Buffer.concat(buffers, nread);
  _close(this);

  return buf;
};

util.inherits(Inflate, zlib.Inflate);

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === "string") {
    buffer = Buffer.from(buffer);
  }
  if (!(buffer instanceof Buffer)) {
    throw new TypeError("Not a string or buffer");
  }

  let flushFlag = engine._finishFlushFlag;
  if (flushFlag == null) {
    flushFlag = zlib.Z_FINISH;
  }

  return engine._processChunk(buffer, flushFlag);
}

function inflateSync(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
}

module.exports = exports = inflateSync;
exports.Inflate = Inflate;
exports.createInflate = createInflate;
exports.inflateSync = inflateSync;


/***/ }),

/***/ 5872:
/***/ ((module) => {

"use strict";


let SyncReader = (module.exports = function (buffer) {
  this._buffer = buffer;
  this._reads = [];
});

SyncReader.prototype.read = function (length, callback) {
  this._reads.push({
    length: Math.abs(length), // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback,
  });
};

SyncReader.prototype.process = function () {
  // as long as there is any data and read requests
  while (this._reads.length > 0 && this._buffer.length) {
    let read = this._reads[0];

    if (
      this._buffer.length &&
      (this._buffer.length >= read.length || read.allowLess)
    ) {
      // ok there is any data so that we can satisfy this request
      this._reads.shift(); // == read

      let buf = this._buffer;

      this._buffer = buf.slice(read.length);

      read.func.call(this, buf.slice(0, read.length));
    } else {
      break;
    }
  }

  if (this._reads.length > 0) {
    return new Error("There are some read requests waitng on finished stream");
  }

  if (this._buffer.length > 0) {
    return new Error("unrecognised content at end of stream");
  }
};


/***/ }),

/***/ 625:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var parseUrl = __nccwpck_require__(8835).parse;

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),

/***/ 7854:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var once = __nccwpck_require__(328)
var eos = __nccwpck_require__(3359)
var fs = __nccwpck_require__(5747) // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ 4370:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Job_1 = __nccwpck_require__(1400);
const Display_1 = __nccwpck_require__(6836);
const util = __nccwpck_require__(6946);
const Worker_1 = __nccwpck_require__(1013);
const builtInConcurrency = __nccwpck_require__(1968);
const Queue_1 = __nccwpck_require__(5744);
const SystemMonitor_1 = __nccwpck_require__(7517);
const events_1 = __nccwpck_require__(8614);
const debug = util.debugGenerator('Cluster');
const DEFAULT_OPTIONS = {
    concurrency: 2,
    maxConcurrency: 1,
    workerCreationDelay: 0,
    puppeteerOptions: {
    // headless: false, // just for testing...
    },
    perBrowserOptions: undefined,
    monitor: false,
    timeout: 30 * 1000,
    retryLimit: 0,
    retryDelay: 0,
    skipDuplicateUrls: false,
    sameDomainDelay: 0,
    puppeteer: undefined,
};
const MONITORING_DISPLAY_INTERVAL = 500;
const CHECK_FOR_WORK_INTERVAL = 100;
const WORK_CALL_INTERVAL_LIMIT = 10;
class Cluster extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.perBrowserOptions = null;
        this.workers = [];
        this.workersAvail = [];
        this.workersBusy = [];
        this.workersStarting = 0;
        this.allTargetCount = 0;
        this.jobQueue = new Queue_1.default();
        this.errorCount = 0;
        this.taskFunction = null;
        this.idleResolvers = [];
        this.waitForOneResolvers = [];
        this.browser = null;
        this.isClosed = false;
        this.startTime = Date.now();
        this.nextWorkerId = -1;
        this.monitoringInterval = null;
        this.display = null;
        this.duplicateCheckUrls = new Set();
        this.lastDomainAccesses = new Map();
        this.systemMonitor = new SystemMonitor_1.default();
        this.checkForWorkInterval = null;
        this.nextWorkCall = 0;
        this.workCallTimeout = null;
        this.lastLaunchedWorkerTime = 0;
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        if (this.options.monitor) {
            this.monitoringInterval = setInterval(() => this.monitor(), MONITORING_DISPLAY_INTERVAL);
        }
    }
    static launch(options) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('Launching');
            const cluster = new Cluster(options);
            yield cluster.init();
            return cluster;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const browserOptions = this.options.puppeteerOptions;
            let puppeteer = this.options.puppeteer;
            if (this.options.puppeteer == null) { // check for null or undefined
                puppeteer = __nccwpck_require__(994);
            }
            else {
                debug('Using provided (custom) puppteer object.');
            }
            if (this.options.concurrency === Cluster.CONCURRENCY_PAGE) {
                this.browser = new builtInConcurrency.Page(browserOptions, puppeteer);
            }
            else if (this.options.concurrency === Cluster.CONCURRENCY_CONTEXT) {
                this.browser = new builtInConcurrency.Context(browserOptions, puppeteer);
            }
            else if (this.options.concurrency === Cluster.CONCURRENCY_BROWSER) {
                this.browser = new builtInConcurrency.Browser(browserOptions, puppeteer);
            }
            else if (typeof this.options.concurrency === 'function') {
                this.browser = new this.options.concurrency(browserOptions, puppeteer);
            }
            else {
                throw new Error(`Unknown concurrency option: ${this.options.concurrency}`);
            }
            if (typeof this.options.maxConcurrency !== 'number') {
                throw new Error('maxConcurrency must be of number type');
            }
            if (this.options.perBrowserOptions
                && this.options.perBrowserOptions.length !== this.options.maxConcurrency) {
                throw new Error('perBrowserOptions length must equal maxConcurrency');
            }
            if (this.options.perBrowserOptions) {
                this.perBrowserOptions = [...this.options.perBrowserOptions];
            }
            try {
                yield this.browser.init();
            }
            catch (err) {
                throw new Error(`Unable to launch browser, error message: ${err.message}`);
            }
            if (this.options.monitor) {
                yield this.systemMonitor.init();
            }
            // needed in case resources are getting free (like CPU/memory) to check if
            // can launch workers
            this.checkForWorkInterval = setInterval(() => this.work(), CHECK_FOR_WORK_INTERVAL);
        });
    }
    launchWorker() {
        return __awaiter(this, void 0, void 0, function* () {
            // signal, that we are starting a worker
            this.workersStarting += 1;
            this.nextWorkerId += 1;
            this.lastLaunchedWorkerTime = Date.now();
            let nextWorkerOption;
            if (this.perBrowserOptions && this.perBrowserOptions.length > 0) {
                nextWorkerOption = this.perBrowserOptions.shift();
            }
            const workerId = this.nextWorkerId;
            let workerBrowserInstance;
            try {
                workerBrowserInstance = yield this.browser
                    .workerInstance(nextWorkerOption);
            }
            catch (err) {
                throw new Error(`Unable to launch browser for worker, error message: ${err.message}`);
            }
            const worker = new Worker_1.default({
                cluster: this,
                args: [''],
                browser: workerBrowserInstance,
                id: workerId,
            });
            this.workersStarting -= 1;
            if (this.isClosed) {
                // cluster was closed while we created a new worker (should rarely happen)
                worker.close();
            }
            else {
                this.workersAvail.push(worker);
                this.workers.push(worker);
            }
        });
    }
    task(taskFunction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.taskFunction = taskFunction;
        });
    }
    // check for new work soon (wait if there will be put more data into the queue, first)
    work() {
        return __awaiter(this, void 0, void 0, function* () {
            // make sure, we only call work once every WORK_CALL_INTERVAL_LIMIT (currently: 10ms)
            if (this.workCallTimeout === null) {
                const now = Date.now();
                // calculate when the next work call should happen
                this.nextWorkCall = Math.max(this.nextWorkCall + WORK_CALL_INTERVAL_LIMIT, now);
                const timeUntilNextWorkCall = this.nextWorkCall - now;
                this.workCallTimeout = setTimeout(() => {
                    this.workCallTimeout = null;
                    this.doWork();
                }, timeUntilNextWorkCall);
            }
        });
    }
    doWork() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.jobQueue.size() === 0) { // no jobs available
                if (this.workersBusy.length === 0) {
                    this.idleResolvers.forEach(resolve => resolve());
                }
                return;
            }
            if (this.workersAvail.length === 0) { // no workers available
                if (this.allowedToStartWorker()) {
                    yield this.launchWorker();
                    this.work();
                }
                return;
            }
            const job = this.jobQueue.shift();
            if (job === undefined) {
                // skip, there are items in the queue but they are all delayed
                return;
            }
            const url = job.getUrl();
            const domain = job.getDomain();
            // Check if URL was already crawled (on skipDuplicateUrls)
            if (this.options.skipDuplicateUrls
                && url !== undefined && this.duplicateCheckUrls.has(url)) {
                // already crawled, just ignore
                debug(`Skipping duplicate URL: ${job.getUrl()}`);
                this.work();
                return;
            }
            // Check if the job needs to be delayed due to sameDomainDelay
            if (this.options.sameDomainDelay !== 0 && domain !== undefined) {
                const lastDomainAccess = this.lastDomainAccesses.get(domain);
                if (lastDomainAccess !== undefined
                    && lastDomainAccess + this.options.sameDomainDelay > Date.now()) {
                    this.jobQueue.push(job, {
                        delayUntil: lastDomainAccess + this.options.sameDomainDelay,
                    });
                    this.work();
                    return;
                }
            }
            // Check are all positive, let's actually run the job
            if (this.options.skipDuplicateUrls && url !== undefined) {
                this.duplicateCheckUrls.add(url);
            }
            if (this.options.sameDomainDelay !== 0 && domain !== undefined) {
                this.lastDomainAccesses.set(domain, Date.now());
            }
            const worker = this.workersAvail.shift();
            this.workersBusy.push(worker);
            if (this.workersAvail.length !== 0 || this.allowedToStartWorker()) {
                // we can execute more work in parallel
                this.work();
            }
            let jobFunction;
            if (job.taskFunction !== undefined) {
                jobFunction = job.taskFunction;
            }
            else if (this.taskFunction !== null) {
                jobFunction = this.taskFunction;
            }
            else {
                throw new Error('No task function defined!');
            }
            const result = yield worker.handle(jobFunction, job, this.options.timeout);
            if (result.type === 'error') {
                if (job.executeCallbacks) {
                    job.executeCallbacks.reject(result.error);
                    this.errorCount += 1;
                }
                else { // ignore retryLimits in case of executeCallbacks
                    job.addError(result.error);
                    const jobWillRetry = job.tries <= this.options.retryLimit;
                    this.emit('taskerror', result.error, job.data, jobWillRetry);
                    if (jobWillRetry) {
                        let delayUntil = undefined;
                        if (this.options.retryDelay !== 0) {
                            delayUntil = Date.now() + this.options.retryDelay;
                        }
                        this.jobQueue.push(job, {
                            delayUntil,
                        });
                    }
                    else {
                        this.errorCount += 1;
                    }
                }
            }
            else if (result.type === 'success' && job.executeCallbacks) {
                job.executeCallbacks.resolve(result.data);
            }
            this.waitForOneResolvers.forEach(resolve => resolve(job.data));
            this.waitForOneResolvers = [];
            // add worker to available workers again
            const workerIndex = this.workersBusy.indexOf(worker);
            this.workersBusy.splice(workerIndex, 1);
            this.workersAvail.push(worker);
            this.work();
        });
    }
    allowedToStartWorker() {
        const workerCount = this.workers.length + this.workersStarting;
        return (
        // option: maxConcurrency
        (this.options.maxConcurrency === 0
            || workerCount < this.options.maxConcurrency)
            // just allow worker creaton every few milliseconds
            && (this.options.workerCreationDelay === 0
                || this.lastLaunchedWorkerTime + this.options.workerCreationDelay < Date.now()));
    }
    // Type Guard for TypeScript
    isTaskFunction(data) {
        return (typeof data === 'function');
    }
    queueJob(data, taskFunction, callbacks) {
        let realData;
        let realFunction;
        if (this.isTaskFunction(data)) {
            realFunction = data;
        }
        else {
            realData = data;
            realFunction = taskFunction;
        }
        const job = new Job_1.default(realData, realFunction, callbacks);
        this.allTargetCount += 1;
        this.jobQueue.push(job);
        this.emit('queue', realData, realFunction);
        this.work();
    }
    queue(data, taskFunction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.queueJob(data, taskFunction);
        });
    }
    execute(data, taskFunction) {
        return new Promise((resolve, reject) => {
            const callbacks = { resolve, reject };
            this.queueJob(data, taskFunction, callbacks);
        });
    }
    idle() {
        return new Promise(resolve => this.idleResolvers.push(resolve));
    }
    waitForOne() {
        return new Promise(resolve => this.waitForOneResolvers.push(resolve));
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isClosed = true;
            clearInterval(this.checkForWorkInterval);
            clearTimeout(this.workCallTimeout);
            // close workers
            yield Promise.all(this.workers.map(worker => worker.close()));
            try {
                yield this.browser.close();
            }
            catch (err) {
                debug(`Error: Unable to close browser, message: ${err.message}`);
            }
            if (this.monitoringInterval) {
                this.monitor();
                clearInterval(this.monitoringInterval);
            }
            if (this.display) {
                this.display.close();
            }
            this.systemMonitor.close();
            debug('Closed');
        });
    }
    monitor() {
        if (!this.display) {
            this.display = new Display_1.default();
        }
        const display = this.display;
        const now = Date.now();
        const timeDiff = now - this.startTime;
        const doneTargets = this.allTargetCount - this.jobQueue.size() - this.workersBusy.length;
        const donePercentage = this.allTargetCount === 0
            ? 1 : (doneTargets / this.allTargetCount);
        const donePercStr = (100 * donePercentage).toFixed(2);
        const errorPerc = doneTargets === 0 ?
            '0.00' : (100 * this.errorCount / doneTargets).toFixed(2);
        const timeRunning = util.formatDuration(timeDiff);
        let timeRemainingMillis = -1;
        if (donePercentage !== 0) {
            timeRemainingMillis = ((timeDiff) / donePercentage) - timeDiff;
        }
        const timeRemining = util.formatDuration(timeRemainingMillis);
        const cpuUsage = this.systemMonitor.getCpuUsage().toFixed(1);
        const memoryUsage = this.systemMonitor.getMemoryUsage().toFixed(1);
        const pagesPerSecond = doneTargets === 0 ?
            '0' : (doneTargets * 1000 / timeDiff).toFixed(2);
        display.log(`== Start:     ${util.formatDateTime(this.startTime)}`);
        display.log(`== Now:       ${util.formatDateTime(now)} (running for ${timeRunning})`);
        display.log(`== Progress:  ${doneTargets} / ${this.allTargetCount} (${donePercStr}%)`
            + `, errors: ${this.errorCount} (${errorPerc}%)`);
        display.log(`== Remaining: ${timeRemining} (@ ${pagesPerSecond} pages/second)`);
        display.log(`== Sys. load: ${cpuUsage}% CPU / ${memoryUsage}% memory`);
        display.log(`== Workers:   ${this.workers.length + this.workersStarting}`);
        this.workers.forEach((worker, i) => {
            const isIdle = this.workersAvail.indexOf(worker) !== -1;
            let workOrIdle;
            let workerUrl = '';
            if (isIdle) {
                workOrIdle = 'IDLE';
            }
            else {
                workOrIdle = 'WORK';
                if (worker.activeTarget) {
                    workerUrl = worker.activeTarget.getUrl() || 'UNKNOWN TARGET';
                }
                else {
                    workerUrl = 'NO TARGET (should not be happening)';
                }
            }
            display.log(`   #${i} ${workOrIdle} ${workerUrl}`);
        });
        for (let i = 0; i < this.workersStarting; i += 1) {
            display.log(`   #${this.workers.length + i} STARTING...`);
        }
        display.resetCursor();
    }
}
exports.default = Cluster;
Cluster.CONCURRENCY_PAGE = 1; // shares cookies, etc.
Cluster.CONCURRENCY_CONTEXT = 2; // no cookie sharing (uses contexts)
Cluster.CONCURRENCY_BROWSER = 3; // no cookie sharing and individual processes (uses contexts)
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2x1c3Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9DbHVzdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0EsK0JBQTZFO0FBQzdFLHVDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IscUNBQThDO0FBRTlDLHVFQUF1RTtBQUd2RSxtQ0FBNEI7QUFDNUIsbURBQTRDO0FBQzVDLG1DQUFzQztBQUl0QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBdUI3QyxNQUFNLGVBQWUsR0FBbUI7SUFDcEMsV0FBVyxFQUFFLENBQUM7SUFDZCxjQUFjLEVBQUUsQ0FBQztJQUNqQixtQkFBbUIsRUFBRSxDQUFDO0lBQ3RCLGdCQUFnQixFQUFFO0lBQ2QsMENBQTBDO0tBQzdDO0lBQ0QsaUJBQWlCLEVBQUUsU0FBUztJQUM1QixPQUFPLEVBQUUsS0FBSztJQUNkLE9BQU8sRUFBRSxFQUFFLEdBQUcsSUFBSTtJQUNsQixVQUFVLEVBQUUsQ0FBQztJQUNiLFVBQVUsRUFBRSxDQUFDO0lBQ2IsaUJBQWlCLEVBQUUsS0FBSztJQUN4QixlQUFlLEVBQUUsQ0FBQztJQUNsQixTQUFTLEVBQUUsU0FBUztDQUN2QixDQUFDO0FBY0YsTUFBTSwyQkFBMkIsR0FBRyxHQUFHLENBQUM7QUFDeEMsTUFBTSx1QkFBdUIsR0FBRyxHQUFHLENBQUM7QUFDcEMsTUFBTSx3QkFBd0IsR0FBRyxFQUFFLENBQUM7QUFFcEMsTUFBcUIsT0FBeUMsU0FBUSxxQkFBWTtJQTRDOUUsWUFBb0IsT0FBK0I7UUFDL0MsS0FBSyxFQUFFLENBQUM7UUF0Q0osc0JBQWlCLEdBQTJCLElBQUksQ0FBQztRQUNqRCxZQUFPLEdBQWtDLEVBQUUsQ0FBQztRQUM1QyxpQkFBWSxHQUFrQyxFQUFFLENBQUM7UUFDakQsZ0JBQVcsR0FBa0MsRUFBRSxDQUFDO1FBQ2hELG9CQUFlLEdBQUcsQ0FBQyxDQUFDO1FBRXBCLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLGFBQVEsR0FBb0MsSUFBSSxlQUFLLEVBQTRCLENBQUM7UUFDbEYsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUVmLGlCQUFZLEdBQTZDLElBQUksQ0FBQztRQUM5RCxrQkFBYSxHQUFtQixFQUFFLENBQUM7UUFDbkMsd0JBQW1CLEdBQStCLEVBQUUsQ0FBQztRQUNyRCxZQUFPLEdBQXFDLElBQUksQ0FBQztRQUVqRCxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdkIsaUJBQVksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVsQix1QkFBa0IsR0FBd0IsSUFBSSxDQUFDO1FBQy9DLFlBQU8sR0FBbUIsSUFBSSxDQUFDO1FBRS9CLHVCQUFrQixHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzVDLHVCQUFrQixHQUF3QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBRXBELGtCQUFhLEdBQWtCLElBQUksdUJBQWEsRUFBRSxDQUFDO1FBRW5ELHlCQUFvQixHQUF3QixJQUFJLENBQUM7UUFvSGpELGlCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBQ3pCLG9CQUFlLEdBQXNCLElBQUksQ0FBQztRQThJMUMsMkJBQXNCLEdBQVcsQ0FBQyxDQUFDO1FBdFB2QyxJQUFJLENBQUMsT0FBTyxtQ0FDTCxlQUFlLEdBQ2YsT0FBTyxDQUNiLENBQUM7UUFFRixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxXQUFXLENBQ2pDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFDcEIsMkJBQTJCLENBQzlCLENBQUM7U0FDTDtJQUNMLENBQUM7SUF0Qk0sTUFBTSxDQUFPLE1BQU0sQ0FBQyxPQUErQjs7WUFDdEQsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ25CLE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JDLE1BQU0sT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBRXJCLE9BQU8sT0FBTyxDQUFDO1FBQ25CLENBQUM7S0FBQTtJQWtCYSxJQUFJOztZQUNkLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7WUFDckQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7WUFFdkMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxJQUFJLEVBQUUsRUFBRSw4QkFBOEI7Z0JBQ2hFLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDcEM7aUJBQU07Z0JBQ0gsS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7YUFDckQ7WUFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxLQUFLLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDdkQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDekU7aUJBQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsbUJBQW1CLEVBQUU7Z0JBQ2pFLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQzVFO2lCQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEtBQUssT0FBTyxDQUFDLG1CQUFtQixFQUFFO2dCQUNqRSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksa0JBQWtCLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUM1RTtpQkFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEtBQUssVUFBVSxFQUFFO2dCQUN2RCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQzFFO2lCQUFNO2dCQUNILE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQzthQUM5RTtZQUVELElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsS0FBSyxRQUFRLEVBQUU7Z0JBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQzthQUM1RDtZQUNELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUI7bUJBQzNCLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFO2dCQUMxRSxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7YUFDekU7WUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2FBQ2hFO1lBRUQsSUFBSTtnQkFDQSxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDN0I7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDVixNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQzthQUM5RTtZQUVELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7Z0JBQ3RCLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUNuQztZQUVELDBFQUEwRTtZQUMxRSxxQkFBcUI7WUFDckIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztRQUN4RixDQUFDO0tBQUE7SUFFYSxZQUFZOztZQUN0Qix3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDLGVBQWUsSUFBSSxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUV6QyxJQUFJLGdCQUFnQixDQUFDO1lBQ3JCLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUM3RCxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDckQ7WUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1lBRW5DLElBQUkscUJBQXFDLENBQUM7WUFDMUMsSUFBSTtnQkFDQSxxQkFBcUIsR0FBRyxNQUFPLElBQUksQ0FBQyxPQUFxQztxQkFDcEUsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDekM7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDVixNQUFNLElBQUksS0FBSyxDQUFDLHVEQUF1RCxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQzthQUN6RjtZQUVELE1BQU0sTUFBTSxHQUFHLElBQUksZ0JBQU0sQ0FBc0I7Z0JBQzNDLE9BQU8sRUFBRSxJQUFJO2dCQUNiLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDVixPQUFPLEVBQUUscUJBQXFCO2dCQUM5QixFQUFFLEVBQUUsUUFBUTthQUNmLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxlQUFlLElBQUksQ0FBQyxDQUFDO1lBRTFCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZiwwRUFBMEU7Z0JBQzFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNsQjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDN0I7UUFDTCxDQUFDO0tBQUE7SUFFWSxJQUFJLENBQUMsWUFBK0M7O1lBQzdELElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ3JDLENBQUM7S0FBQTtJQUtELHNGQUFzRjtJQUN4RSxJQUFJOztZQUNkLHFGQUFxRjtZQUNyRixJQUFJLElBQUksQ0FBQyxlQUFlLEtBQUssSUFBSSxFQUFFO2dCQUMvQixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBRXZCLGtEQUFrRDtnQkFDbEQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUN4QixJQUFJLENBQUMsWUFBWSxHQUFHLHdCQUF3QixFQUM1QyxHQUFHLENBQ04sQ0FBQztnQkFDRixNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsR0FBRyxDQUFDO2dCQUV0RCxJQUFJLENBQUMsZUFBZSxHQUFHLFVBQVUsQ0FDN0IsR0FBRyxFQUFFO29CQUNELElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO29CQUM1QixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ2xCLENBQUMsRUFDRCxxQkFBcUIsQ0FDeEIsQ0FBQzthQUNMO1FBQ0wsQ0FBQztLQUFBO0lBRWEsTUFBTTs7WUFDaEIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLG9CQUFvQjtnQkFDbEQsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQy9CLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztpQkFDcEQ7Z0JBQ0QsT0FBTzthQUNWO1lBRUQsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsRUFBRSx1QkFBdUI7Z0JBQ3pELElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFLEVBQUU7b0JBQzdCLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO29CQUMxQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ2Y7Z0JBQ0QsT0FBTzthQUNWO1lBRUQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUVsQyxJQUFJLEdBQUcsS0FBSyxTQUFTLEVBQUU7Z0JBQ25CLDhEQUE4RDtnQkFDOUQsT0FBTzthQUNWO1lBRUQsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3pCLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUUvQiwwREFBMEQ7WUFDMUQsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQjttQkFDM0IsR0FBRyxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUMxRCwrQkFBK0I7Z0JBQy9CLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDakQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNaLE9BQU87YUFDVjtZQUVELDhEQUE4RDtZQUM5RCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxLQUFLLENBQUMsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO2dCQUM1RCxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzdELElBQUksZ0JBQWdCLEtBQUssU0FBUzt1QkFDM0IsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO29CQUNqRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7d0JBQ3BCLFVBQVUsRUFBRSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWU7cUJBQzlELENBQUMsQ0FBQztvQkFDSCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7b0JBQ1osT0FBTztpQkFDVjthQUNKO1lBRUQscURBQXFEO1lBQ3JELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO2dCQUNyRCxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3BDO1lBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsS0FBSyxDQUFDLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDNUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7YUFDbkQ7WUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBaUMsQ0FBQztZQUN4RSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUU5QixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBRTtnQkFDL0QsdUNBQXVDO2dCQUN2QyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDZjtZQUVELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksR0FBRyxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7Z0JBQ2hDLFdBQVcsR0FBRyxHQUFHLENBQUMsWUFBWSxDQUFDO2FBQ2xDO2lCQUFNLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxJQUFJLEVBQUU7Z0JBQ25DLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO2FBQ25DO2lCQUFNO2dCQUNILE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQzthQUNoRDtZQUVELE1BQU0sTUFBTSxHQUFlLE1BQU0sTUFBTSxDQUFDLE1BQU0sQ0FDekMsV0FBaUQsRUFDbEQsR0FBRyxFQUNILElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUN2QixDQUFDO1lBRUYsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtnQkFDekIsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLEVBQUU7b0JBQ3RCLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMxQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQztpQkFDeEI7cUJBQU0sRUFBRSxpREFBaUQ7b0JBQ3RELEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMzQixNQUFNLFlBQVksR0FBRyxHQUFHLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO29CQUMxRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7b0JBQzdELElBQUksWUFBWSxFQUFFO3dCQUNkLElBQUksVUFBVSxHQUFHLFNBQVMsQ0FBQzt3QkFDM0IsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUU7NEJBQy9CLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7eUJBQ3JEO3dCQUNELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTs0QkFDcEIsVUFBVTt5QkFDYixDQUFDLENBQUM7cUJBQ047eUJBQU07d0JBQ0gsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7cUJBQ3hCO2lCQUNKO2FBQ0o7aUJBQU0sSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQzFELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzdDO1lBRUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FDNUIsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQWUsQ0FBQyxDQUMxQyxDQUFDO1lBQ0YsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztZQUU5Qix3Q0FBd0M7WUFDeEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDckQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXhDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRS9CLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNoQixDQUFDO0tBQUE7SUFJTyxvQkFBb0I7UUFDeEIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUMvRCxPQUFPO1FBQ0gseUJBQXlCO1FBQ3pCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEtBQUssQ0FBQztlQUMzQixXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7WUFDakQsbURBQW1EO2VBQ2hELENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsS0FBSyxDQUFDO21CQUNuQyxJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FDdEYsQ0FBQztJQUNOLENBQUM7SUFFRCw0QkFBNEI7SUFDcEIsY0FBYyxDQUNsQixJQUFpRDtRQUVqRCxPQUFPLENBQUMsT0FBTyxJQUFJLEtBQUssVUFBVSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVPLFFBQVEsQ0FDWixJQUFpRCxFQUNqRCxZQUFnRCxFQUNoRCxTQUE0QjtRQUU1QixJQUFJLFFBQTZCLENBQUM7UUFDbEMsSUFBSSxZQUEyRCxDQUFDO1FBQ2hFLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMzQixZQUFZLEdBQUcsSUFBSSxDQUFDO1NBQ3ZCO2FBQU07WUFDSCxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ2hCLFlBQVksR0FBRyxZQUFZLENBQUM7U0FDL0I7UUFDRCxNQUFNLEdBQUcsR0FBRyxJQUFJLGFBQUcsQ0FBc0IsUUFBUSxFQUFFLFlBQVksRUFBRSxTQUFTLENBQUMsQ0FBQztRQUU1RSxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUFTWSxLQUFLLENBQ2QsSUFBaUQsRUFDakQsWUFBZ0Q7O1lBRWhELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3RDLENBQUM7S0FBQTtJQVNNLE9BQU8sQ0FDVixJQUFpRCxFQUNqRCxZQUFnRDtRQUVoRCxPQUFPLElBQUksT0FBTyxDQUFhLENBQUMsT0FBdUIsRUFBRSxNQUFxQixFQUFFLEVBQUU7WUFDOUUsTUFBTSxTQUFTLEdBQUcsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUM7WUFDdEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVNLElBQUk7UUFDUCxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRU0sVUFBVTtRQUNiLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVZLEtBQUs7O1lBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFFckIsYUFBYSxDQUFDLElBQUksQ0FBQyxvQkFBb0MsQ0FBQyxDQUFDO1lBQ3pELFlBQVksQ0FBQyxJQUFJLENBQUMsZUFBK0IsQ0FBQyxDQUFDO1lBRW5ELGdCQUFnQjtZQUNoQixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRTlELElBQUk7Z0JBQ0EsTUFBTyxJQUFJLENBQUMsT0FBcUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUM3RDtZQUFDLE9BQU8sR0FBRyxFQUFFO2dCQUNWLEtBQUssQ0FBQyw0Q0FBNEMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDcEU7WUFFRCxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNmLGFBQWEsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUMxQztZQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ3hCO1lBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUUzQixLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEIsQ0FBQztLQUFBO0lBRU8sT0FBTztRQUNYLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGlCQUFPLEVBQUUsQ0FBQztTQUNoQztRQUNELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFFN0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sUUFBUSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBRXRDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUN6RixNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsY0FBYyxLQUFLLENBQUM7WUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzlDLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBRyxHQUFHLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0RCxNQUFNLFNBQVMsR0FBRyxXQUFXLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDakMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU5RCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWxELElBQUksbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxjQUFjLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxjQUFjLENBQUMsR0FBRyxRQUFRLENBQUM7U0FDbEU7UUFDRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFFOUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0QsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFbkUsTUFBTSxjQUFjLEdBQUcsV0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVyRCxPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDcEUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDdEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsV0FBVyxNQUFNLElBQUksQ0FBQyxjQUFjLEtBQUssV0FBVyxJQUFJO2NBQy9FLGFBQWEsSUFBSSxDQUFDLFVBQVUsS0FBSyxTQUFTLElBQUksQ0FBQyxDQUFDO1FBQ3RELE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLFlBQVksT0FBTyxjQUFjLGdCQUFnQixDQUFDLENBQUM7UUFDaEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsUUFBUSxXQUFXLFdBQVcsVUFBVSxDQUFDLENBQUM7UUFDdkUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7UUFFM0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDeEQsSUFBSSxVQUFVLENBQUM7WUFDZixJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFDbkIsSUFBSSxNQUFNLEVBQUU7Z0JBQ1IsVUFBVSxHQUFHLE1BQU0sQ0FBQzthQUN2QjtpQkFBTTtnQkFDSCxVQUFVLEdBQUcsTUFBTSxDQUFDO2dCQUNwQixJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUU7b0JBQ3JCLFNBQVMsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLGdCQUFnQixDQUFDO2lCQUNoRTtxQkFBTTtvQkFDSCxTQUFTLEdBQUcscUNBQXFDLENBQUM7aUJBQ3JEO2FBQ0o7WUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsSUFBSSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELENBQUMsQ0FBQyxDQUFDO1FBQ0gsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUM3RDtRQUVELE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUMxQixDQUFDOztBQWhkTCwwQkFrZEM7QUFoZFUsd0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsdUJBQXVCO0FBQzdDLDJCQUFtQixHQUFHLENBQUMsQ0FBQyxDQUFDLG9DQUFvQztBQUM3RCwyQkFBbUIsR0FBRyxDQUFDLENBQUMsQ0FBQyw2REFBNkQifQ==

/***/ }),

/***/ 6836:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const CLEAR_LINE = '\x1B[K';
class Display {
    constructor() {
        this.lastLinesCount = 0;
        this.linesCount = 0;
    }
    log(str) {
        return __awaiter(this, void 0, void 0, function* () {
            // We create an empty line at the start so that any console.log calls
            // from within the script are above our output.
            if (this.linesCount === 0) {
                console.log(CLEAR_LINE); // erases the current line
                this.linesCount += 1;
            }
            // Strip lines that are too long
            const strToLog = str.substr(0, 78);
            console.log(`${CLEAR_LINE}${strToLog}`);
            this.linesCount += 1;
        });
    }
    resetCursor() {
        return __awaiter(this, void 0, void 0, function* () {
            // move cursor up to draw over out output
            process.stdout.write(`\x1B[${this.linesCount}A`);
            this.lastLinesCount = this.linesCount;
            this.linesCount = 0;
        });
    }
    close() {
        // move cursor down so that console output stays
        process.stdout.write(`\x1B[${this.lastLinesCount}B`);
    }
}
exports.default = Display;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGlzcGxheS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9EaXNwbGF5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0EsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDO0FBRTVCLE1BQXFCLE9BQU87SUFBNUI7UUFFWSxtQkFBYyxHQUFXLENBQUMsQ0FBQztRQUMzQixlQUFVLEdBQVcsQ0FBQyxDQUFDO0lBNEJuQyxDQUFDO0lBMUJnQixHQUFHLENBQUMsR0FBVzs7WUFDeEIscUVBQXFFO1lBQ3JFLCtDQUErQztZQUMvQyxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsMEJBQTBCO2dCQUNuRCxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQzthQUN4QjtZQUVELGdDQUFnQztZQUNoQyxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNuQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsVUFBVSxHQUFHLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDeEMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7UUFDekIsQ0FBQztLQUFBO0lBRVksV0FBVzs7WUFDcEIseUNBQXlDO1lBQ3pDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLENBQUM7S0FBQTtJQUVNLEtBQUs7UUFDUixnREFBZ0Q7UUFDaEQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQztJQUN6RCxDQUFDO0NBRUo7QUEvQkQsMEJBK0JDIn0=

/***/ }),

/***/ 1400:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const url_1 = __nccwpck_require__(8835);
class Job {
    constructor(data, taskFunction, executeCallbacks) {
        this.lastError = null;
        this.tries = 0;
        this.data = data;
        this.taskFunction = taskFunction;
        this.executeCallbacks = executeCallbacks;
    }
    getUrl() {
        if (!this.data) {
            return undefined;
        }
        if (typeof this.data === 'string') {
            return this.data;
        }
        if (typeof this.data.url === 'string') {
            return this.data.url;
        }
        return undefined;
    }
    getDomain() {
        // TODO use tld.js to restrict to top-level domain?
        const urlStr = this.getUrl();
        if (urlStr) {
            try {
                const url = new url_1.URL(urlStr);
                return url.hostname || undefined;
            }
            catch (e) {
                // if urlStr is not a valid URL this might throw
                // but we leave this to the user
                return undefined;
            }
        }
        return undefined;
    }
    addError(error) {
        this.tries += 1;
        this.lastError = error;
    }
}
exports.default = Job;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSm9iLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0pvYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLDZCQUEwQjtBQVUxQixNQUFxQixHQUFHO0lBU3BCLFlBQ0ksSUFBYyxFQUNkLFlBQWdELEVBQ2hELGdCQUFtQztRQU4vQixjQUFTLEdBQWlCLElBQUksQ0FBQztRQUNoQyxVQUFLLEdBQVcsQ0FBQyxDQUFDO1FBT3JCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztJQUM3QyxDQUFDO0lBRU0sTUFBTTtRQUNULElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1osT0FBTyxTQUFTLENBQUM7U0FDcEI7UUFDRCxJQUFJLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDL0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ3BCO1FBQ0QsSUFBSSxPQUFRLElBQUksQ0FBQyxJQUFZLENBQUMsR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUM1QyxPQUFRLElBQUksQ0FBQyxJQUFZLENBQUMsR0FBRyxDQUFDO1NBQ2pDO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztJQUVNLFNBQVM7UUFDWixtREFBbUQ7UUFDbkQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzdCLElBQUksTUFBTSxFQUFFO1lBQ1IsSUFBSTtnQkFDQSxNQUFNLEdBQUcsR0FBRyxJQUFJLFNBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDNUIsT0FBTyxHQUFHLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQzthQUNwQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLGdEQUFnRDtnQkFDaEQsZ0NBQWdDO2dCQUNoQyxPQUFPLFNBQVMsQ0FBQzthQUNwQjtTQUNKO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztJQUVNLFFBQVEsQ0FBQyxLQUFZO1FBQ3hCLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQzNCLENBQUM7Q0FFSjtBQXJERCxzQkFxREMifQ==

/***/ }),

/***/ 5744:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Queue {
    constructor() {
        this.list = [];
        this.delayedItems = 0;
    }
    size() {
        return this.list.length + this.delayedItems;
    }
    push(item, options = {}) {
        if (options && options.delayUntil && options.delayUntil > Date.now()) {
            this.delayedItems += 1;
            setTimeout(() => {
                this.delayedItems -= 1;
                this.list.push(item);
            }, (options.delayUntil - Date.now()));
        }
        else {
            this.list.push(item);
        }
    }
    // Care, this function might actually return undefined even though size() returns a value > 0
    // Reason is, that there might be delayedItems (checkout QueueOptions.delayUntil)
    shift() {
        return this.list.shift();
    }
}
exports.default = Queue;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVldWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvUXVldWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFNQSxNQUFxQixLQUFLO0lBQTFCO1FBRVksU0FBSSxHQUFRLEVBQUUsQ0FBQztRQUNmLGlCQUFZLEdBQVcsQ0FBQyxDQUFDO0lBMkJyQyxDQUFDO0lBekJVLElBQUk7UUFDUCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDaEQsQ0FBQztJQUVNLElBQUksQ0FBQyxJQUFPLEVBQUUsVUFBd0IsRUFBRTtRQUMzQyxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ2xFLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO1lBQ3ZCLFVBQVUsQ0FDTixHQUFHLEVBQUU7Z0JBQ0QsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3pCLENBQUMsRUFDRCxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQ3BDLENBQUM7U0FDTDthQUFNO1lBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7SUFDTCxDQUFDO0lBRUQsNkZBQTZGO0lBQzdGLGlGQUFpRjtJQUMxRSxLQUFLO1FBQ1IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzdCLENBQUM7Q0FFSjtBQTlCRCx3QkE4QkMifQ==

/***/ }),

/***/ 7517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const os = __nccwpck_require__(2087);
const INIT_INTERVAL = 50;
const MEASURE_INTERVAL = 200;
// timespan of which to measure load
// must be a multiple of MEASURE_INTERVAL
const MEASURE_TIMESPAN = 5000;
const loadListSize = MEASURE_TIMESPAN / MEASURE_INTERVAL;
class SystemMonitor {
    constructor() {
        this.cpuUsage = 0;
        this.memoryUsage = 0;
        this.loads = [];
        this.interval = null;
    }
    // After init is called there is at least something in the cpuUsage thingy
    init() {
        this.calcLoad();
        return new Promise((resolve) => {
            setTimeout(() => {
                this.calcLoad();
                this.interval = setInterval(() => this.calcLoad(), MEASURE_INTERVAL);
                resolve();
            }, INIT_INTERVAL);
        });
    }
    close() {
        clearInterval(this.interval);
    }
    calcLoad() {
        let totalIdle = 0;
        let totalTick = 0;
        const cpus = os.cpus();
        if (!cpus) {
            // In some environments, os.cpus() might return undefined (although it's not stated in
            // the Node.js docs), see #113 for more information
            return;
        }
        for (let i = 0, len = cpus.length; i < len; i += 1) {
            const cpu = cpus[i];
            for (const type in cpu.times) {
                totalTick += cpu.times[type];
            }
            totalIdle += cpu.times.idle;
        }
        const currentLoad = {
            idle: totalIdle / cpus.length,
            total: totalTick / cpus.length,
        };
        if (this.loads.length !== 0) {
            const compareLoad = this.loads[0];
            const idleDifference = currentLoad.idle - compareLoad.idle;
            const totalDifference = currentLoad.total - compareLoad.total;
            this.cpuUsage = 100 - (100 * idleDifference / totalDifference);
            this.memoryUsage = 100 - (100 * os.freemem() / os.totalmem());
        }
        this.loads.push(currentLoad);
        if (this.loads.length > loadListSize) {
            // remove oldest entry
            this.loads.shift();
        }
    }
    getCpuUsage() {
        return this.cpuUsage;
    }
    getMemoryUsage() {
        return this.memoryUsage;
    }
}
exports.default = SystemMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3lzdGVtTW9uaXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9TeXN0ZW1Nb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUJBQXlCO0FBT3pCLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUN6QixNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztBQUU3QixvQ0FBb0M7QUFDcEMseUNBQXlDO0FBQ3pDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0FBRTlCLE1BQU0sWUFBWSxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBRXpELE1BQXFCLGFBQWE7SUFBbEM7UUFFWSxhQUFRLEdBQVcsQ0FBQyxDQUFDO1FBQ3JCLGdCQUFXLEdBQVcsQ0FBQyxDQUFDO1FBRXhCLFVBQUssR0FBaUIsRUFBRSxDQUFDO1FBRXpCLGFBQVEsR0FBd0IsSUFBSSxDQUFDO0lBbUVqRCxDQUFDO0lBakVHLDBFQUEwRTtJQUNuRSxJQUFJO1FBQ1AsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2hCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUMzQixVQUFVLENBQ04sR0FBRyxFQUFFO2dCQUNELElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLGdCQUFnQixDQUFDLENBQUM7Z0JBQ3JFLE9BQU8sRUFBRSxDQUFDO1lBQ2QsQ0FBQyxFQUNELGFBQWEsQ0FDaEIsQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVNLEtBQUs7UUFDUixhQUFhLENBQUMsSUFBSSxDQUFDLFFBQXdCLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRU8sUUFBUTtRQUNaLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztRQUNsQixJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbEIsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXZCLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDUCxzRkFBc0Y7WUFDdEYsbURBQW1EO1lBQ25ELE9BQU87U0FDVjtRQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNoRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsS0FBSyxNQUFNLElBQUksSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFO2dCQUMxQixTQUFTLElBQUssR0FBRyxDQUFDLEtBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6QztZQUNELFNBQVMsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztTQUMvQjtRQUVELE1BQU0sV0FBVyxHQUFHO1lBQ2hCLElBQUksRUFBRSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU07WUFDN0IsS0FBSyxFQUFFLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTTtTQUNqQyxDQUFDO1FBRUYsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsQyxNQUFNLGNBQWMsR0FBRyxXQUFXLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUM7WUFDM0QsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1lBRTlELElBQUksQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLGNBQWMsR0FBRyxlQUFlLENBQUMsQ0FBQztZQUMvRCxJQUFJLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDakU7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM3QixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLFlBQVksRUFBRTtZQUNsQyxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUN0QjtJQUNMLENBQUM7SUFFTSxXQUFXO1FBQ2QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFDTSxjQUFjO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUM1QixDQUFDO0NBQ0o7QUExRUQsZ0NBMEVDIn0=

/***/ }),

/***/ 1013:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __nccwpck_require__(6946);
const util_2 = __nccwpck_require__(1669);
const debug = util_1.debugGenerator('Worker');
const DEFAULT_OPTIONS = {
    args: [],
};
const BROWSER_INSTANCE_TRIES = 10;
class Worker {
    constructor({ cluster, args, id, browser }) {
        this.activeTarget = null;
        this.cluster = cluster;
        this.args = args;
        this.id = id;
        this.browser = browser;
        debug(`Starting #${this.id}`);
    }
    handle(task, job, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            this.activeTarget = job;
            let jobInstance = null;
            let page = null;
            let tries = 0;
            while (jobInstance === null) {
                try {
                    jobInstance = yield this.browser.jobInstance();
                    page = jobInstance.resources.page;
                }
                catch (err) {
                    debug(`Error getting browser page (try: ${tries}), message: ${err.message}`);
                    yield this.browser.repair();
                    tries += 1;
                    if (tries >= BROWSER_INSTANCE_TRIES) {
                        throw new Error('Unable to get browser page');
                    }
                }
            }
            // We can be sure that page is set now, otherwise an exception would've been thrown
            page = page; // this is just for TypeScript
            let errorState = null;
            page.on('error', (err) => {
                errorState = err;
                util_1.log(`Error (page error) crawling ${util_2.inspect(job.data)} // message: ${err.message}`);
            });
            debug(`Executing task on worker #${this.id} with data: ${util_2.inspect(job.data)}`);
            let result;
            try {
                result = yield util_1.timeoutExecute(timeout, task({
                    page,
                    // data might be undefined if queue is only called with a function
                    // we ignore that case, as the user should use Cluster<undefined> in that case
                    // to get correct typings
                    data: job.data,
                    worker: {
                        id: this.id,
                    },
                }));
            }
            catch (err) {
                errorState = err;
                util_1.log(`Error crawling ${util_2.inspect(job.data)} // message: ${err.message}`);
            }
            debug(`Finished executing task on worker #${this.id}`);
            try {
                yield jobInstance.close();
            }
            catch (e) {
                debug(`Error closing browser instance for ${util_2.inspect(job.data)}: ${e.message}`);
                yield this.browser.repair();
            }
            this.activeTarget = null;
            if (errorState) {
                return {
                    type: 'error',
                    error: errorState || new Error('asf'),
                };
            }
            return {
                data: result,
                type: 'success',
            };
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.browser.close();
            }
            catch (err) {
                debug(`Unable to close worker browser. Error message: ${err.message}`);
            }
            debug(`Closed #${this.id}`);
        });
    }
}
exports.default = Worker;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1dvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUlBLGlDQUE2RDtBQUM3RCwrQkFBK0I7QUFHL0IsTUFBTSxLQUFLLEdBQUcscUJBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUV2QyxNQUFNLGVBQWUsR0FBRztJQUNwQixJQUFJLEVBQUUsRUFBRTtDQUNYLENBQUM7QUFTRixNQUFNLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztBQWNsQyxNQUFxQixNQUFNO0lBU3ZCLFlBQW1CLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFpQjtRQUZoRSxpQkFBWSxHQUFvQyxJQUFJLENBQUM7UUFHakQsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUV2QixLQUFLLENBQUMsYUFBYSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRVksTUFBTSxDQUNYLElBQXVDLEVBQ3ZDLEdBQTZCLEVBQzdCLE9BQWU7O1lBRW5CLElBQUksQ0FBQyxZQUFZLEdBQUcsR0FBRyxDQUFDO1lBRXhCLElBQUksV0FBVyxHQUF1QixJQUFJLENBQUM7WUFDM0MsSUFBSSxJQUFJLEdBQWdCLElBQUksQ0FBQztZQUU3QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7WUFFZCxPQUFPLFdBQVcsS0FBSyxJQUFJLEVBQUU7Z0JBQ3pCLElBQUk7b0JBQ0EsV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDL0MsSUFBSSxHQUFHLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO2lCQUNyQztnQkFBQyxPQUFPLEdBQUcsRUFBRTtvQkFDVixLQUFLLENBQUMsb0NBQW9DLEtBQUssZUFBZSxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztvQkFDN0UsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUM1QixLQUFLLElBQUksQ0FBQyxDQUFDO29CQUNYLElBQUksS0FBSyxJQUFJLHNCQUFzQixFQUFFO3dCQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7cUJBQ2pEO2lCQUNKO2FBQ0o7WUFFQSxtRkFBbUY7WUFDcEYsSUFBSSxHQUFHLElBQVksQ0FBQyxDQUFDLDhCQUE4QjtZQUVuRCxJQUFJLFVBQVUsR0FBaUIsSUFBSSxDQUFDO1lBRXBDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUU7Z0JBQ3JCLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLFVBQUcsQ0FBQywrQkFBK0IsY0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZGLENBQUMsQ0FBQyxDQUFDO1lBRUgsS0FBSyxDQUFDLDZCQUE2QixJQUFJLENBQUMsRUFBRSxlQUFlLGNBQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRTlFLElBQUksTUFBVyxDQUFDO1lBQ2hCLElBQUk7Z0JBQ0EsTUFBTSxHQUFHLE1BQU0scUJBQWMsQ0FDekIsT0FBTyxFQUNQLElBQUksQ0FBQztvQkFDRCxJQUFJO29CQUNKLGtFQUFrRTtvQkFDbEUsOEVBQThFO29CQUM5RSx5QkFBeUI7b0JBQ3pCLElBQUksRUFBRSxHQUFHLENBQUMsSUFBZTtvQkFDekIsTUFBTSxFQUFFO3dCQUNKLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRTtxQkFDZDtpQkFDSixDQUFDLENBQ0wsQ0FBQzthQUNMO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1YsVUFBVSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsVUFBRyxDQUFDLGtCQUFrQixjQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDekU7WUFFRCxLQUFLLENBQUMsc0NBQXNDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRXZELElBQUk7Z0JBQ0EsTUFBTSxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDN0I7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDUixLQUFLLENBQUMsc0NBQXNDLGNBQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBQy9FLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQzthQUMvQjtZQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1lBRXpCLElBQUksVUFBVSxFQUFFO2dCQUNaLE9BQU87b0JBQ0gsSUFBSSxFQUFFLE9BQU87b0JBQ2IsS0FBSyxFQUFFLFVBQVUsSUFBSSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUM7aUJBQ3hDLENBQUM7YUFDTDtZQUNELE9BQU87Z0JBQ0gsSUFBSSxFQUFFLE1BQU07Z0JBQ1osSUFBSSxFQUFFLFNBQVM7YUFDbEIsQ0FBQztRQUNOLENBQUM7S0FBQTtJQUVZLEtBQUs7O1lBQ2QsSUFBSTtnQkFDQSxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDOUI7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDVixLQUFLLENBQUMsa0RBQWtELEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQzFFO1lBQ0QsS0FBSyxDQUFDLFdBQVcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDaEMsQ0FBQztLQUFBO0NBRUo7QUE1R0QseUJBNEdDIn0=

/***/ }),

/***/ 6312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * ABSTRACT CLASS Needs to be implemented to manage one or more browsers via puppeteer instances
 *
 * The ConcurrencyImplementation creates WorkerInstances. Workers create JobInstances:
 * One WorkerInstance per maxWorkers, one JobInstance per job
 */
class ConcurrencyImplementation {
    /**
     * @param options  Options that should be provided to puppeteer.launch
     * @param puppeteer  puppeteer object (like puppeteer or puppeteer-core)
     */
    constructor(options, puppeteer) {
        this.options = options;
        this.puppeteer = puppeteer;
    }
}
exports.default = ConcurrencyImplementation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29uY3VycmVuY3lJbXBsZW1lbnRhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb25jdXJyZW5jeS9Db25jdXJyZW5jeUltcGxlbWVudGF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBR0E7Ozs7O0dBS0c7QUFDSCxNQUE4Qix5QkFBeUI7SUFLbkQ7OztPQUdHO0lBQ0gsWUFBbUIsT0FBc0IsRUFBRSxTQUFjO1FBQ3JELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQy9CLENBQUM7Q0FrQko7QUE5QkQsNENBOEJDIn0=

/***/ }),

/***/ 5127:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ConcurrencyImplementation_1 = __nccwpck_require__(6312);
const util_1 = __nccwpck_require__(6946);
const debug = util_1.debugGenerator('SingleBrowserImpl');
const BROWSER_TIMEOUT = 5000;
class SingleBrowserImplementation extends ConcurrencyImplementation_1.default {
    constructor(options, puppeteer) {
        super(options, puppeteer);
        this.browser = null;
        this.repairing = false;
        this.repairRequested = false;
        this.openInstances = 0;
        this.waitingForRepairResolvers = [];
    }
    repair() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.openInstances !== 0 || this.repairing) {
                // already repairing or there are still pages open? wait for start/finish
                yield new Promise(resolve => this.waitingForRepairResolvers.push(resolve));
                return;
            }
            this.repairing = true;
            debug('Starting repair');
            try {
                // will probably fail, but just in case the repair was not necessary
                yield this.browser.close();
            }
            catch (e) {
                debug('Unable to close browser.');
            }
            try {
                this.browser = (yield this.puppeteer.launch(this.options));
            }
            catch (err) {
                throw new Error('Unable to restart chrome.');
            }
            this.repairRequested = false;
            this.repairing = false;
            this.waitingForRepairResolvers.forEach(resolve => resolve());
            this.waitingForRepairResolvers = [];
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.browser = yield this.puppeteer.launch(this.options);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.browser.close();
        });
    }
    workerInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            let resources;
            return {
                jobInstance: () => __awaiter(this, void 0, void 0, function* () {
                    if (this.repairRequested) {
                        yield this.repair();
                    }
                    yield util_1.timeoutExecute(BROWSER_TIMEOUT, (() => __awaiter(this, void 0, void 0, function* () {
                        resources = yield this.createResources();
                    }))());
                    this.openInstances += 1;
                    return {
                        resources,
                        close: () => __awaiter(this, void 0, void 0, function* () {
                            this.openInstances -= 1; // decrement first in case of error
                            yield util_1.timeoutExecute(BROWSER_TIMEOUT, this.freeResources(resources));
                            if (this.repairRequested) {
                                yield this.repair();
                            }
                        }),
                    };
                }),
                close: () => __awaiter(this, void 0, void 0, function* () { }),
                repair: () => __awaiter(this, void 0, void 0, function* () {
                    debug('Repair requested');
                    this.repairRequested = true;
                    yield this.repair();
                }),
            };
        });
    }
}
exports.default = SingleBrowserImplementation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2luZ2xlQnJvd3NlckltcGxlbWVudGF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbmN1cnJlbmN5L1NpbmdsZUJyb3dzZXJJbXBsZW1lbnRhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUVBLDJFQUFzRjtBQUV0RixrQ0FBeUQ7QUFDekQsTUFBTSxLQUFLLEdBQUcscUJBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBRWxELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQztBQUU3QixNQUE4QiwyQkFBNEIsU0FBUSxtQ0FBeUI7SUFTdkYsWUFBbUIsT0FBZ0MsRUFBRSxTQUFjO1FBQy9ELEtBQUssQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFScEIsWUFBTyxHQUE2QixJQUFJLENBQUM7UUFFM0MsY0FBUyxHQUFZLEtBQUssQ0FBQztRQUMzQixvQkFBZSxHQUFZLEtBQUssQ0FBQztRQUNqQyxrQkFBYSxHQUFXLENBQUMsQ0FBQztRQUMxQiw4QkFBeUIsR0FBbUIsRUFBRSxDQUFDO0lBSXZELENBQUM7SUFFYSxNQUFNOztZQUNoQixJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQzVDLHlFQUF5RTtnQkFDekUsTUFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDM0UsT0FBTzthQUNWO1lBRUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7WUFDdEIsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFFekIsSUFBSTtnQkFDQSxvRUFBb0U7Z0JBQ3BFLE1BQTBCLElBQUksQ0FBQyxPQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDbkQ7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDUixLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQzthQUNyQztZQUVELElBQUk7Z0JBQ0EsSUFBSSxDQUFDLE9BQU8sSUFBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQXNCLENBQUEsQ0FBQzthQUNqRjtZQUFDLE9BQU8sR0FBRyxFQUFFO2dCQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQzthQUNoRDtZQUNELElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO1lBQzdCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1lBQ3ZCLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyx5QkFBeUIsR0FBRyxFQUFFLENBQUM7UUFDeEMsQ0FBQztLQUFBO0lBRVksSUFBSTs7WUFDYixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzdELENBQUM7S0FBQTtJQUVZLEtBQUs7O1lBQ2QsTUFBTyxJQUFJLENBQUMsT0FBNkIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN0RCxDQUFDO0tBQUE7SUFNWSxjQUFjOztZQUN2QixJQUFJLFNBQXVCLENBQUM7WUFFNUIsT0FBTztnQkFDSCxXQUFXLEVBQUUsR0FBUyxFQUFFO29CQUNwQixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7d0JBQ3RCLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO3FCQUN2QjtvQkFFRCxNQUFNLHFCQUFjLENBQUMsZUFBZSxFQUFFLENBQUMsR0FBUyxFQUFFO3dCQUM5QyxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQzdDLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUNOLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDO29CQUV4QixPQUFPO3dCQUNILFNBQVM7d0JBRVQsS0FBSyxFQUFFLEdBQVMsRUFBRTs0QkFDZCxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxDQUFDLG1DQUFtQzs0QkFDNUQsTUFBTSxxQkFBYyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7NEJBRXJFLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDdEIsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7NkJBQ3ZCO3dCQUNMLENBQUMsQ0FBQTtxQkFDSixDQUFDO2dCQUNOLENBQUMsQ0FBQTtnQkFFRCxLQUFLLEVBQUUsR0FBUyxFQUFFLGdEQUFFLENBQUMsQ0FBQTtnQkFFckIsTUFBTSxFQUFFLEdBQVMsRUFBRTtvQkFDZixLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7b0JBQzVCLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN4QixDQUFDLENBQUE7YUFDSixDQUFDO1FBQ04sQ0FBQztLQUFBO0NBQ0o7QUExRkQsOENBMEZDIn0=

/***/ }),

/***/ 5918:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __nccwpck_require__(6946);
const ConcurrencyImplementation_1 = __nccwpck_require__(6312);
const debug = util_1.debugGenerator('BrowserConcurrency');
const BROWSER_TIMEOUT = 5000;
class Browser extends ConcurrencyImplementation_1.default {
    init() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    workerInstance(perBrowserOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = perBrowserOptions || this.options;
            let chrome = yield this.puppeteer.launch(options);
            let page;
            let context; // puppeteer typings are old...
            return {
                jobInstance: () => __awaiter(this, void 0, void 0, function* () {
                    yield util_1.timeoutExecute(BROWSER_TIMEOUT, (() => __awaiter(this, void 0, void 0, function* () {
                        context = yield chrome.createIncognitoBrowserContext();
                        page = yield context.newPage();
                    }))());
                    return {
                        resources: {
                            page,
                        },
                        close: () => __awaiter(this, void 0, void 0, function* () {
                            yield util_1.timeoutExecute(BROWSER_TIMEOUT, context.close());
                        }),
                    };
                }),
                close: () => __awaiter(this, void 0, void 0, function* () {
                    yield chrome.close();
                }),
                repair: () => __awaiter(this, void 0, void 0, function* () {
                    debug('Starting repair');
                    try {
                        // will probably fail, but just in case the repair was not necessary
                        yield chrome.close();
                    }
                    catch (e) { }
                    // just relaunch as there is only one page per browser
                    chrome = yield this.puppeteer.launch(this.options);
                }),
            };
        });
    }
}
exports.default = Browser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJvd3Nlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb25jdXJyZW5jeS9idWlsdC1pbi9Ccm93c2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBR0EscUNBQTREO0FBQzVELDRFQUF5RjtBQUN6RixNQUFNLEtBQUssR0FBRyxxQkFBYyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFFbkQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDO0FBRTdCLE1BQXFCLE9BQVEsU0FBUSxtQ0FBeUI7SUFDN0MsSUFBSTs4REFBSSxDQUFDO0tBQUE7SUFDVCxLQUFLOzhEQUFJLENBQUM7S0FBQTtJQUVWLGNBQWMsQ0FBQyxpQkFBc0Q7O1lBRzlFLE1BQU0sT0FBTyxHQUFHLGlCQUFpQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUM7WUFDbEQsSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQXNCLENBQUM7WUFDdkUsSUFBSSxJQUFvQixDQUFDO1lBQ3pCLElBQUksT0FBWSxDQUFDLENBQUMsK0JBQStCO1lBRWpELE9BQU87Z0JBQ0gsV0FBVyxFQUFFLEdBQVMsRUFBRTtvQkFDcEIsTUFBTSxxQkFBYyxDQUFDLGVBQWUsRUFBRSxDQUFDLEdBQVMsRUFBRTt3QkFDOUMsT0FBTyxHQUFHLE1BQU0sTUFBTSxDQUFDLDZCQUE2QixFQUFFLENBQUM7d0JBQ3ZELElBQUksR0FBRyxNQUFNLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDbkMsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDLENBQUM7b0JBRU4sT0FBTzt3QkFDSCxTQUFTLEVBQUU7NEJBQ1AsSUFBSTt5QkFDUDt3QkFFRCxLQUFLLEVBQUUsR0FBUyxFQUFFOzRCQUNkLE1BQU0scUJBQWMsQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7d0JBQzNELENBQUMsQ0FBQTtxQkFDSixDQUFDO2dCQUNOLENBQUMsQ0FBQTtnQkFFRCxLQUFLLEVBQUUsR0FBUyxFQUFFO29CQUNkLE1BQU0sTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUN6QixDQUFDLENBQUE7Z0JBRUQsTUFBTSxFQUFFLEdBQVMsRUFBRTtvQkFDZixLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztvQkFDekIsSUFBSTt3QkFDQSxvRUFBb0U7d0JBQ3BFLE1BQU0sTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO3FCQUN4QjtvQkFBQyxPQUFPLENBQUMsRUFBRSxHQUFFO29CQUVkLHNEQUFzRDtvQkFDdEQsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN2RCxDQUFDLENBQUE7YUFDSixDQUFDO1FBQ04sQ0FBQztLQUFBO0NBRUo7QUEvQ0QsMEJBK0NDIn0=

/***/ }),

/***/ 7860:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const SingleBrowserImplementation_1 = __nccwpck_require__(5127);
class Context extends SingleBrowserImplementation_1.default {
    createResources() {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.browser
                .createIncognitoBrowserContext();
            const page = yield context.newPage();
            return {
                context,
                page,
            };
        });
    }
    freeResources(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            yield resources.context.close();
        });
    }
}
exports.default = Context;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb25jdXJyZW5jeS9idWlsdC1pbi9Db250ZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBSUEsZ0ZBQXlFO0FBRXpFLE1BQXFCLE9BQVEsU0FBUSxxQ0FBMkI7SUFFNUMsZUFBZTs7WUFDM0IsTUFBTSxPQUFPLEdBQUcsTUFBTyxJQUFJLENBQUMsT0FBNkI7aUJBQ3BELDZCQUE2QixFQUFFLENBQUM7WUFDckMsTUFBTSxJQUFJLEdBQUcsTUFBTSxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDckMsT0FBTztnQkFDSCxPQUFPO2dCQUNQLElBQUk7YUFDUCxDQUFDO1FBQ04sQ0FBQztLQUFBO0lBRWUsYUFBYSxDQUFDLFNBQXVCOztZQUNqRCxNQUFNLFNBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDcEMsQ0FBQztLQUFBO0NBRUo7QUFoQkQsMEJBZ0JDIn0=

/***/ }),

/***/ 8850:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const SingleBrowserImplementation_1 = __nccwpck_require__(5127);
class Page extends SingleBrowserImplementation_1.default {
    createResources() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                page: yield this.browser.newPage(),
            };
        });
    }
    freeResources(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            yield resources.page.close();
        });
    }
}
exports.default = Page;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb25jdXJyZW5jeS9idWlsdC1pbi9QYWdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBSUEsZ0ZBQXlFO0FBRXpFLE1BQXFCLElBQUssU0FBUSxxQ0FBMkI7SUFFekMsZUFBZTs7WUFDM0IsT0FBTztnQkFDSCxJQUFJLEVBQUUsTUFBTyxJQUFJLENBQUMsT0FBNkIsQ0FBQyxPQUFPLEVBQUU7YUFDNUQsQ0FBQztRQUNOLENBQUM7S0FBQTtJQUVlLGFBQWEsQ0FBQyxTQUF1Qjs7WUFDakQsTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pDLENBQUM7S0FBQTtDQUVKO0FBWkQsdUJBWUMifQ==

/***/ }),

/***/ 1968:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Browser_1 = __nccwpck_require__(5918);
Object.defineProperty(exports, "Browser", ({ enumerable: true, get: function () { return Browser_1.default; } }));
var Context_1 = __nccwpck_require__(7860);
Object.defineProperty(exports, "Context", ({ enumerable: true, get: function () { return Context_1.default; } }));
var Page_1 = __nccwpck_require__(8850);
Object.defineProperty(exports, "Page", ({ enumerable: true, get: function () { return Page_1.default; } }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbHRJbkNvbmN1cnJlbmN5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbmN1cnJlbmN5L2J1aWx0SW5Db25jdXJyZW5jeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLDhDQUF3RDtBQUEvQyxrR0FBQSxPQUFPLE9BQVc7QUFDM0IsOENBQXdEO0FBQS9DLGtHQUFBLE9BQU8sT0FBVztBQUMzQix3Q0FBa0Q7QUFBekMsNEZBQUEsT0FBTyxPQUFRIn0=

/***/ }),

/***/ 449:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Cluster_1 = __nccwpck_require__(4370);
Object.defineProperty(exports, "Cluster", ({ enumerable: true, get: function () { return Cluster_1.default; } }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSxxQ0FBK0M7QUFBdEMsa0dBQUEsT0FBTyxPQUFXIn0=

/***/ }),

/***/ 6946:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.log = exports.debugGenerator = exports.timeoutExecute = exports.formatDuration = exports.formatDateTime = void 0;
const Debug = __nccwpck_require__(2423);
function timeUnit(step, name) {
    return { step, name };
}
const TIME_UNITS = [
    timeUnit(1, 'ms'),
    timeUnit(1000, 'seconds'),
    timeUnit(60, 'minutes'),
    timeUnit(60, 'hours'),
    timeUnit(24, 'days'),
    timeUnit(31, 'months'),
    timeUnit((365 / 31), 'years'),
];
const TIME_UNIT_THRESHOLD = 0.95;
function padDate(value, num) {
    const str = value.toString();
    if (str.length >= num) {
        return str;
    }
    const zeroesToAdd = num - str.length;
    return '0'.repeat(zeroesToAdd) + str;
}
function formatDateTime(datetime) {
    const date = (typeof datetime === 'number') ? new Date(datetime) : datetime;
    const dateStr = `${date.getFullYear()}`
        + `-${padDate(date.getMonth() + 1, 2)}`
        + `-${padDate(date.getDate(), 2)}`;
    const timeStr = `${padDate(date.getHours(), 2)}`
        + `:${padDate(date.getMinutes(), 2)}`
        + `:${padDate(date.getSeconds(), 2)}`
        + `.${padDate(date.getMilliseconds(), 3)}`;
    return `${dateStr} ${timeStr}`;
}
exports.formatDateTime = formatDateTime;
function formatDuration(millis) {
    if (millis < 0) {
        return 'unknown';
    }
    let remaining = millis;
    let nextUnitIndex = 1;
    while (nextUnitIndex < TIME_UNITS.length &&
        remaining / TIME_UNITS[nextUnitIndex].step >= TIME_UNIT_THRESHOLD) {
        remaining = remaining / TIME_UNITS[nextUnitIndex].step;
        nextUnitIndex += 1;
    }
    return `${remaining.toFixed(1)} ${TIME_UNITS[nextUnitIndex - 1].name}`;
}
exports.formatDuration = formatDuration;
function timeoutExecute(millis, promise) {
    return __awaiter(this, void 0, void 0, function* () {
        let timeout = null;
        const result = yield Promise.race([
            (() => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((resolve) => {
                    timeout = setTimeout(resolve, millis);
                });
                throw new Error(`Timeout hit: ${millis}`);
            }))(),
            (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield promise;
                }
                catch (error) {
                    // Cancel timeout in error case
                    clearTimeout(timeout);
                    throw error;
                }
            }))(),
        ]);
        clearTimeout(timeout); // is there a better way?
        return result;
    });
}
exports.timeoutExecute = timeoutExecute;
function debugGenerator(namespace) {
    const debug = Debug(`puppeteer-cluster: ${namespace}`);
    return debug;
}
exports.debugGenerator = debugGenerator;
const logToConsole = Debug('puppeteer-cluster:log');
logToConsole.log = console.error.bind(console);
function log(msg) {
    logToConsole(msg);
}
exports.log = log;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNBLCtCQUErQjtBQU8vQixTQUFTLFFBQVEsQ0FBQyxJQUFZLEVBQUUsSUFBWTtJQUN4QyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO0FBQzFCLENBQUM7QUFFRCxNQUFNLFVBQVUsR0FBZTtJQUMzQixRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQztJQUNqQixRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQztJQUN6QixRQUFRLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQztJQUN2QixRQUFRLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQztJQUNyQixRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQztJQUNwQixRQUFRLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQztJQUN0QixRQUFRLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsT0FBTyxDQUFDO0NBQ2hDLENBQUM7QUFFRixNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQztBQUVqQyxTQUFTLE9BQU8sQ0FBQyxLQUFvQixFQUFFLEdBQVc7SUFDOUMsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdCLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUU7UUFDbkIsT0FBTyxHQUFHLENBQUM7S0FDZDtJQUNELE1BQU0sV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDO0lBQ3JDLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDekMsQ0FBQztBQUVELFNBQWdCLGNBQWMsQ0FBQyxRQUF1QjtJQUNsRCxNQUFNLElBQUksR0FBRyxDQUFDLE9BQU8sUUFBUSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0lBRTVFLE1BQU0sT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO1VBQ2pDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7VUFDckMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDdkMsTUFBTSxPQUFPLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFO1VBQzFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRTtVQUNuQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUU7VUFDbkMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFL0MsT0FBTyxHQUFHLE9BQU8sSUFBSSxPQUFPLEVBQUUsQ0FBQztBQUNuQyxDQUFDO0FBWkQsd0NBWUM7QUFFRCxTQUFnQixjQUFjLENBQUMsTUFBYztJQUN6QyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDWixPQUFPLFNBQVMsQ0FBQztLQUNwQjtJQUVELElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQztJQUN2QixJQUFJLGFBQWEsR0FBRyxDQUFDLENBQUM7SUFDdEIsT0FBTyxhQUFhLEdBQUcsVUFBVSxDQUFDLE1BQU07UUFDaEMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLElBQUksbUJBQW1CLEVBQUU7UUFDdkUsU0FBUyxHQUFHLFNBQVMsR0FBRyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3ZELGFBQWEsSUFBSSxDQUFDLENBQUM7S0FDdEI7SUFFRCxPQUFPLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQzNFLENBQUM7QUFkRCx3Q0FjQztBQUVELFNBQXNCLGNBQWMsQ0FBSSxNQUFjLEVBQUUsT0FBbUI7O1FBRXZFLElBQUksT0FBTyxHQUF3QixJQUFJLENBQUM7UUFFeEMsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQzlCLENBQUMsR0FBUyxFQUFFO2dCQUNSLE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtvQkFDMUIsT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQzFDLENBQUMsQ0FBQyxDQUFDO2dCQUNILE1BQU0sSUFBSSxLQUFLLENBQUMsZ0JBQWdCLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDOUMsQ0FBQyxDQUFBLENBQUMsRUFBRTtZQUNKLENBQUMsR0FBUyxFQUFFO2dCQUNSLElBQUk7b0JBQ0EsT0FBTyxNQUFNLE9BQU8sQ0FBQztpQkFDeEI7Z0JBQUMsT0FBTyxLQUFLLEVBQUU7b0JBQ1osK0JBQStCO29CQUMvQixZQUFZLENBQUMsT0FBOEIsQ0FBQyxDQUFDO29CQUM3QyxNQUFNLEtBQUssQ0FBQztpQkFDZjtZQUNMLENBQUMsQ0FBQSxDQUFDLEVBQUU7U0FDUCxDQUFDLENBQUM7UUFDSCxZQUFZLENBQUMsT0FBOEIsQ0FBQyxDQUFDLENBQUMseUJBQXlCO1FBQ3ZFLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7Q0FBQTtBQXZCRCx3Q0F1QkM7QUFFRCxTQUFnQixjQUFjLENBQUMsU0FBaUI7SUFDNUMsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLHNCQUFzQixTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFIRCx3Q0FHQztBQUVELE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ3BELFlBQVksQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFFL0MsU0FBZ0IsR0FBRyxDQUFDLEdBQVc7SUFDM0IsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCLENBQUM7QUFGRCxrQkFFQyJ9

/***/ }),

/***/ 994:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * We use `export default puppeteer` in `src/index.ts` to expose the library But
 * TypeScript in CJS mode compiles that to `exports.default = `. This means that
 * our CJS Node users would have to use `require('puppeteer').default` which
 * isn't very nice.
 *
 * So instead we expose this file as our entry point. This requires the compiled
 * Puppeteer output and re-exports the `default` export via `module.exports.`
 * This means that we can publish to CJS and ESM whilst maintaining the expected
 * import behaviour for CJS and ESM users.
 */
const puppeteerExport = __nccwpck_require__(8032);
module.exports = puppeteerExport.default;


/***/ }),

/***/ 6772:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Accessibility = void 0;
/**
 * The Accessibility class provides methods for inspecting Chromium's
 * accessibility tree. The accessibility tree is used by assistive technology
 * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or
 * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.
 *
 * @remarks
 *
 * Accessibility is a very platform-specific thing. On different platforms,
 * there are different screen readers that might have wildly different output.
 *
 * Blink - Chrome's rendering engine - has a concept of "accessibility tree",
 * which is then translated into different platform-specific APIs. Accessibility
 * namespace gives users access to the Blink Accessibility Tree.
 *
 * Most of the accessibility tree gets filtered out when converting from Blink
 * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.
 * By default, Puppeteer tries to approximate this filtering, exposing only
 * the "interesting" nodes of the tree.
 *
 * @public
 */
class Accessibility {
    /**
     * @internal
     */
    constructor(client) {
        this._client = client;
    }
    /**
     * Captures the current state of the accessibility tree.
     * The returned object represents the root accessible node of the page.
     *
     * @remarks
     *
     * **NOTE** The Chromium accessibility tree contains nodes that go unused on
     * most platforms and by most screen readers. Puppeteer will discard them as
     * well for an easier to process tree, unless `interestingOnly` is set to
     * `false`.
     *
     * @example
     * An example of dumping the entire accessibility tree:
     * ```js
     * const snapshot = await page.accessibility.snapshot();
     * console.log(snapshot);
     * ```
     *
     * @example
     * An example of logging the focused node's name:
     * ```js
     * const snapshot = await page.accessibility.snapshot();
     * const node = findFocusedNode(snapshot);
     * console.log(node && node.name);
     *
     * function findFocusedNode(node) {
     *   if (node.focused)
     *     return node;
     *   for (const child of node.children || []) {
     *     const foundNode = findFocusedNode(child);
     *     return foundNode;
     *   }
     *   return null;
     * }
     * ```
     *
     * @returns An AXNode object representing the snapshot.
     *
     */
    async snapshot(options = {}) {
        const { interestingOnly = true, root = null } = options;
        const { nodes } = await this._client.send('Accessibility.getFullAXTree');
        let backendNodeId = null;
        if (root) {
            const { node } = await this._client.send('DOM.describeNode', {
                objectId: root._remoteObject.objectId,
            });
            backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(nodes);
        let needle = defaultRoot;
        if (backendNodeId) {
            needle = defaultRoot.find((node) => node.payload.backendDOMNodeId === backendNodeId);
            if (!needle)
                return null;
        }
        if (!interestingOnly)
            return this.serializeTree(needle)[0];
        const interestingNodes = new Set();
        this.collectInterestingNodes(interestingNodes, defaultRoot, false);
        if (!interestingNodes.has(needle))
            return null;
        return this.serializeTree(needle, interestingNodes)[0];
    }
    serializeTree(node, interestingNodes) {
        const children = [];
        for (const child of node.children)
            children.push(...this.serializeTree(child, interestingNodes));
        if (interestingNodes && !interestingNodes.has(node))
            return children;
        const serializedNode = node.serialize();
        if (children.length)
            serializedNode.children = children;
        return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
        if (node.isInteresting(insideControl))
            collection.add(node);
        if (node.isLeafNode())
            return;
        insideControl = insideControl || node.isControl();
        for (const child of node.children)
            this.collectInterestingNodes(collection, child, insideControl);
    }
}
exports.Accessibility = Accessibility;
class AXNode {
    constructor(payload) {
        this.children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._hidden = false;
        this.payload = payload;
        this._name = this.payload.name ? this.payload.name.value : '';
        this._role = this.payload.role ? this.payload.role.value : 'Unknown';
        this._ignored = this.payload.ignored;
        for (const property of this.payload.properties || []) {
            if (property.name === 'editable') {
                this._richlyEditable = property.value.value === 'richtext';
                this._editable = true;
            }
            if (property.name === 'focusable')
                this._focusable = property.value.value;
            if (property.name === 'hidden')
                this._hidden = property.value.value;
        }
    }
    _isPlainTextField() {
        if (this._richlyEditable)
            return false;
        if (this._editable)
            return true;
        return this._role === 'textbox' || this._role === 'searchbox';
    }
    _isTextOnlyObject() {
        const role = this._role;
        return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox';
    }
    _hasFocusableChild() {
        if (this._cachedHasFocusableChild === undefined) {
            this._cachedHasFocusableChild = false;
            for (const child of this.children) {
                if (child._focusable || child._hasFocusableChild()) {
                    this._cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this._cachedHasFocusableChild;
    }
    find(predicate) {
        if (predicate(this))
            return this;
        for (const child of this.children) {
            const result = child.find(predicate);
            if (result)
                return result;
        }
        return null;
    }
    isLeafNode() {
        if (!this.children.length)
            return true;
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this._isPlainTextField() || this._isTextOnlyObject())
            return true;
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this._role) {
            case 'doc-cover':
            case 'graphics-symbol':
            case 'img':
            case 'Meter':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
            default:
                break;
        }
        // Here and below: Android heuristics
        if (this._hasFocusableChild())
            return false;
        if (this._focusable && this._name)
            return true;
        if (this._role === 'heading' && this._name)
            return true;
        return false;
    }
    isControl() {
        switch (this._role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'tree':
            case 'treeitem':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        const role = this._role;
        if (role === 'Ignored' || this._hidden || this._ignored)
            return false;
        if (this._focusable || this._richlyEditable)
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!this._name;
    }
    serialize() {
        const properties = new Map();
        for (const property of this.payload.properties || [])
            properties.set(property.name.toLowerCase(), property.value.value);
        if (this.payload.name)
            properties.set('name', this.payload.name.value);
        if (this.payload.value)
            properties.set('value', this.payload.value.value);
        if (this.payload.description)
            properties.set('description', this.payload.description.value);
        const node = {
            role: this._role,
        };
        const userStringProperties = [
            'name',
            'value',
            'description',
            'keyshortcuts',
            'roledescription',
            'valuetext',
        ];
        const getUserStringPropertyValue = (key) => properties.get(key);
        for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty))
                continue;
            node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        const getBooleanPropertyValue = (key) => properties.get(key);
        for (const booleanProperty of booleanProperties) {
            // WebArea's treat focus differently than other nodes. They report whether
            // their frame  has focus, not whether focus is specifically on the root
            // node.
            if (booleanProperty === 'focused' && this._role === 'WebArea')
                continue;
            const value = getBooleanPropertyValue(booleanProperty);
            if (!value)
                continue;
            node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
        }
        const tristateProperties = ['checked', 'pressed'];
        for (const tristateProperty of tristateProperties) {
            if (!properties.has(tristateProperty))
                continue;
            const value = properties.get(tristateProperty);
            node[tristateProperty] =
                value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        const getNumericalPropertyValue = (key) => properties.get(key);
        for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty))
                continue;
            node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        const getTokenPropertyValue = (key) => properties.get(key);
        for (const tokenProperty of tokenProperties) {
            const value = getTokenPropertyValue(tokenProperty);
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = getTokenPropertyValue(tokenProperty);
        }
        return node;
    }
    static createTree(payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
            nodeById.set(payload.nodeId, new AXNode(payload));
        for (const node of nodeById.values()) {
            for (const childId of node.payload.childIds || [])
                node.children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
    }
}


/***/ }),

/***/ 922:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ariaHandler = void 0;
async function queryAXTree(client, element, accessibleName, role) {
    const { nodes } = await client.send('Accessibility.queryAXTree', {
        objectId: element._remoteObject.objectId,
        accessibleName,
        role,
    });
    const filteredNodes = nodes.filter((node) => node.role.value !== 'text');
    return filteredNodes;
}
function parseAriaSelector(selector) {
    const normalize = (value) => value.replace(/ +/g, ' ').trim();
    const knownAttributes = new Set(['name', 'role']);
    const queryOptions = {};
    const attributeRegexp = /\[\s*(?<attribute>\w+)\s*=\s*"(?<value>\\.|[^"\\]*)"\s*\]/;
    const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {
        attribute = attribute.trim();
        if (!knownAttributes.has(attribute))
            throw new Error('Unkown aria attribute "${groups.attribute}" in selector');
        queryOptions[attribute] = normalize(value);
        return '';
    });
    if (defaultName && !queryOptions.name)
        queryOptions.name = normalize(defaultName);
    return queryOptions;
}
const queryOne = async (element, selector) => {
    const exeCtx = element.executionContext();
    const { name, role } = parseAriaSelector(selector);
    const res = await queryAXTree(exeCtx._client, element, name, role);
    if (res.length < 1) {
        return null;
    }
    return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);
};
const waitFor = async (domWorld, selector, options) => {
    const binding = {
        name: 'ariaQuerySelector',
        pptrFunction: async (selector) => {
            const document = await domWorld._document();
            const element = await queryOne(document, selector);
            return element;
        },
    };
    return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);
};
const queryAll = async (element, selector) => {
    const exeCtx = element.executionContext();
    const { name, role } = parseAriaSelector(selector);
    const res = await queryAXTree(exeCtx._client, element, name, role);
    return Promise.all(res.map((axNode) => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));
};
const queryAllArray = async (element, selector) => {
    const elementHandles = await queryAll(element, selector);
    const exeCtx = element.executionContext();
    const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);
    return jsHandle;
};
/**
 * @internal
 */
exports.ariaHandler = {
    queryOne,
    waitFor,
    queryAll,
    queryAllArray,
};


/***/ }),

/***/ 4523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserContext = exports.Browser = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const Target_js_1 = __nccwpck_require__(8956);
const EventEmitter_js_1 = __nccwpck_require__(241);
const Connection_js_1 = __nccwpck_require__(402);
/**
 * A Browser is created when Puppeteer connects to a Chromium instance, either through
 * {@link PuppeteerNode.launch} or {@link Puppeteer.connect}.
 *
 * @remarks
 *
 * The Browser class extends from Puppeteer's {@link EventEmitter} class and will
 * emit various events which are documented in the {@link BrowserEmittedEvents} enum.
 *
 * @example
 *
 * An example of using a {@link Browser} to create a {@link Page}:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await browser.close();
 * })();
 * ```
 *
 * @example
 *
 * An example of disconnecting from and reconnecting to a {@link Browser}:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   // Store the endpoint to be able to reconnect to Chromium
 *   const browserWSEndpoint = browser.wsEndpoint();
 *   // Disconnect puppeteer from Chromium
 *   browser.disconnect();
 *
 *   // Use the endpoint to reestablish a connection
 *   const browser2 = await puppeteer.connect({browserWSEndpoint});
 *   // Close Chromium
 *   await browser2.close();
 * })();
 * ```
 *
 * @public
 */
class Browser extends EventEmitter_js_1.EventEmitter {
    /**
     * @internal
     */
    constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {
        super();
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        this._process = process;
        this._connection = connection;
        this._closeCallback = closeCallback || function () { };
        this._defaultContext = new BrowserContext(this._connection, this, null);
        this._contexts = new Map();
        for (const contextId of contextIds)
            this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));
        this._targets = new Map();
        this._connection.on(Connection_js_1.ConnectionEmittedEvents.Disconnected, () => this.emit("disconnected" /* Disconnected */));
        this._connection.on('Target.targetCreated', this._targetCreated.bind(this));
        this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));
        this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));
    }
    /**
     * @internal
     */
    static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {
        const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);
        await connection.send('Target.setDiscoverTargets', { discover: true });
        return browser;
    }
    /**
     * The spawned browser process. Returns `null` if the browser instance was created with
     * {@link Puppeteer.connect}.
     */
    process() {
        return this._process;
    }
    /**
     * Creates a new incognito browser context. This won't share cookies/cache with other
     * browser contexts.
     *
     * @example
     * ```js
     * (async () => {
     *  const browser = await puppeteer.launch();
     *   // Create a new incognito browser context.
     *   const context = await browser.createIncognitoBrowserContext();
     *   // Create a new page in a pristine context.
     *   const page = await context.newPage();
     *   // Do stuff
     *   await page.goto('https://example.com');
     * })();
     * ```
     */
    async createIncognitoBrowserContext() {
        const { browserContextId } = await this._connection.send('Target.createBrowserContext');
        const context = new BrowserContext(this._connection, this, browserContextId);
        this._contexts.set(browserContextId, context);
        return context;
    }
    /**
     * Returns an array of all open browser contexts. In a newly created browser, this will
     * return a single instance of {@link BrowserContext}.
     */
    browserContexts() {
        return [this._defaultContext, ...Array.from(this._contexts.values())];
    }
    /**
     * Returns the default browser context. The default browser context cannot be closed.
     */
    defaultBrowserContext() {
        return this._defaultContext;
    }
    /**
     * @internal
     * Used by BrowserContext directly so cannot be marked private.
     */
    async _disposeContext(contextId) {
        await this._connection.send('Target.disposeBrowserContext', {
            browserContextId: contextId || undefined,
        });
        this._contexts.delete(contextId);
    }
    async _targetCreated(event) {
        const targetInfo = event.targetInfo;
        const { browserContextId } = targetInfo;
        const context = browserContextId && this._contexts.has(browserContextId)
            ? this._contexts.get(browserContextId)
            : this._defaultContext;
        const target = new Target_js_1.Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport);
        assert_js_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');
        this._targets.set(event.targetInfo.targetId, target);
        if (await target._initializedPromise) {
            this.emit("targetcreated" /* TargetCreated */, target);
            context.emit("targetcreated" /* TargetCreated */, target);
        }
    }
    async _targetDestroyed(event) {
        const target = this._targets.get(event.targetId);
        target._initializedCallback(false);
        this._targets.delete(event.targetId);
        target._closedCallback();
        if (await target._initializedPromise) {
            this.emit("targetdestroyed" /* TargetDestroyed */, target);
            target
                .browserContext()
                .emit("targetdestroyed" /* TargetDestroyed */, target);
        }
    }
    _targetInfoChanged(event) {
        const target = this._targets.get(event.targetInfo.targetId);
        assert_js_1.assert(target, 'target should exist before targetInfoChanged');
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
            this.emit("targetchanged" /* TargetChanged */, target);
            target
                .browserContext()
                .emit("targetchanged" /* TargetChanged */, target);
        }
    }
    /**
     * The browser websocket endpoint which can be used as an argument to
     * {@link Puppeteer.connect}.
     *
     * @returns The Browser websocket url.
     *
     * @remarks
     *
     * The format is `ws://${host}:${port}/devtools/browser/<id>`.
     *
     * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.
     * Learn more about the
     * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and
     * the {@link
     * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target
     * | browser endpoint}.
     */
    wsEndpoint() {
        return this._connection.url();
    }
    /**
     * Creates a {@link Page} in the default browser context.
     */
    async newPage() {
        return this._defaultContext.newPage();
    }
    /**
     * @internal
     * Used by BrowserContext directly so cannot be marked private.
     */
    async _createPageInContext(contextId) {
        const { targetId } = await this._connection.send('Target.createTarget', {
            url: 'about:blank',
            browserContextId: contextId || undefined,
        });
        const target = await this._targets.get(targetId);
        assert_js_1.assert(await target._initializedPromise, 'Failed to create target for page');
        const page = await target.page();
        return page;
    }
    /**
     * All active targets inside the Browser. In case of multiple browser contexts, returns
     * an array with all the targets in all browser contexts.
     */
    targets() {
        return Array.from(this._targets.values()).filter((target) => target._isInitialized);
    }
    /**
     * The target associated with the browser.
     */
    target() {
        return this.targets().find((target) => target.type() === 'browser');
    }
    /**
     * Searches for a target in all browser contexts.
     *
     * @param predicate - A function to be run for every target.
     * @returns The first target found that matches the `predicate` function.
     *
     * @example
     *
     * An example of finding a target for a page opened via `window.open`:
     * ```js
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');
     * ```
     */
    async waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const existingTarget = this.targets().find(predicate);
        if (existingTarget)
            return existingTarget;
        let resolve;
        const targetPromise = new Promise((x) => (resolve = x));
        this.on("targetcreated" /* TargetCreated */, check);
        this.on("targetchanged" /* TargetChanged */, check);
        try {
            if (!timeout)
                return await targetPromise;
            return await helper_js_1.helper.waitWithTimeout(targetPromise, 'target', timeout);
        }
        finally {
            this.removeListener("targetcreated" /* TargetCreated */, check);
            this.removeListener("targetchanged" /* TargetChanged */, check);
        }
        function check(target) {
            if (predicate(target))
                resolve(target);
        }
    }
    /**
     * An array of all open pages inside the Browser.
     *
     * @remarks
     *
     * In case of multiple browser contexts, returns an array with all the pages in all
     * browser contexts. Non-visible pages, such as `"background_page"`, will not be listed
     * here. You can find them using {@link Target.page}.
     */
    async pages() {
        const contextPages = await Promise.all(this.browserContexts().map((context) => context.pages()));
        // Flatten array.
        return contextPages.reduce((acc, x) => acc.concat(x), []);
    }
    /**
     * A string representing the browser name and version.
     *
     * @remarks
     *
     * For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For
     * non-headless, this is similar to `Chrome/61.0.3153.0`.
     *
     * The format of browser.version() might change with future releases of Chromium.
     */
    async version() {
        const version = await this._getVersion();
        return version.product;
    }
    /**
     * The browser's original user agent. Pages can override the browser user agent with
     * {@link Page.setUserAgent}.
     */
    async userAgent() {
        const version = await this._getVersion();
        return version.userAgent;
    }
    /**
     * Closes Chromium and all of its pages (if any were opened). The {@link Browser} object
     * itself is considered to be disposed and cannot be used anymore.
     */
    async close() {
        await this._closeCallback.call(null);
        this.disconnect();
    }
    /**
     * Disconnects Puppeteer from the browser, but leaves the Chromium process running.
     * After calling `disconnect`, the {@link Browser} object is considered disposed and
     * cannot be used anymore.
     */
    disconnect() {
        this._connection.dispose();
    }
    /**
     * Indicates that the browser is connected.
     */
    isConnected() {
        return !this._connection._closed;
    }
    _getVersion() {
        return this._connection.send('Browser.getVersion');
    }
}
exports.Browser = Browser;
/**
 * BrowserContexts provide a way to operate multiple independent browser
 * sessions. When a browser is launched, it has a single BrowserContext used by
 * default. The method {@link Browser.newPage | Browser.newPage} creates a page
 * in the default browser context.
 *
 * @remarks
 *
 * The Browser class extends from Puppeteer's {@link EventEmitter} class and
 * will emit various events which are documented in the
 * {@link BrowserContextEmittedEvents} enum.
 *
 * If a page opens another page, e.g. with a `window.open` call, the popup will
 * belong to the parent page's browser context.
 *
 * Puppeteer allows creation of "incognito" browser contexts with
 * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}
 * method. "Incognito" browser contexts don't write any browsing data to disk.
 *
 * @example
 * ```js
 * // Create a new incognito browser context
 * const context = await browser.createIncognitoBrowserContext();
 * // Create a new page inside context.
 * const page = await context.newPage();
 * // ... do stuff with page ...
 * await page.goto('https://example.com');
 * // Dispose context once it's no longer needed.
 * await context.close();
 * ```
 */
class BrowserContext extends EventEmitter_js_1.EventEmitter {
    /**
     * @internal
     */
    constructor(connection, browser, contextId) {
        super();
        this._connection = connection;
        this._browser = browser;
        this._id = contextId;
    }
    /**
     * An array of all active targets inside the browser context.
     */
    targets() {
        return this._browser
            .targets()
            .filter((target) => target.browserContext() === this);
    }
    /**
     * This searches for a target in this specific browser context.
     *
     * @example
     * An example of finding a target for a page opened via `window.open`:
     * ```js
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');
     * ```
     *
     * @param predicate - A function to be run for every target
     * @param options - An object of options. Accepts a timout,
     * which is the maximum wait time in milliseconds.
     * Pass `0` to disable the timeout. Defaults to 30 seconds.
     * @returns Promise which resolves to the first target found
     * that matches the `predicate` function.
     */
    waitForTarget(predicate, options = {}) {
        return this._browser.waitForTarget((target) => target.browserContext() === this && predicate(target), options);
    }
    /**
     * An array of all pages inside the browser context.
     *
     * @returns Promise which resolves to an array of all open pages.
     * Non visible pages, such as `"background_page"`, will not be listed here.
     * You can find them using {@link Target.page | the target page}.
     */
    async pages() {
        const pages = await Promise.all(this.targets()
            .filter((target) => target.type() === 'page')
            .map((target) => target.page()));
        return pages.filter((page) => !!page);
    }
    /**
     * Returns whether BrowserContext is incognito.
     * The default browser context is the only non-incognito browser context.
     *
     * @remarks
     * The default browser context cannot be closed.
     */
    isIncognito() {
        return !!this._id;
    }
    /**
     * @example
     * ```js
     * const context = browser.defaultBrowserContext();
     * await context.overridePermissions('https://html5demos.com', ['geolocation']);
     * ```
     *
     * @param origin - The origin to grant permissions to, e.g. "https://example.com".
     * @param permissions - An array of permissions to grant.
     * All permissions that are not listed here will be automatically denied.
     */
    async overridePermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
            ['geolocation', 'geolocation'],
            ['midi', 'midi'],
            ['notifications', 'notifications'],
            // TODO: push isn't a valid type?
            // ['push', 'push'],
            ['camera', 'videoCapture'],
            ['microphone', 'audioCapture'],
            ['background-sync', 'backgroundSync'],
            ['ambient-light-sensor', 'sensors'],
            ['accelerometer', 'sensors'],
            ['gyroscope', 'sensors'],
            ['magnetometer', 'sensors'],
            ['accessibility-events', 'accessibilityEvents'],
            ['clipboard-read', 'clipboardReadWrite'],
            ['clipboard-write', 'clipboardReadWrite'],
            ['payment-handler', 'paymentHandler'],
            ['idle-detection', 'idleDetection'],
            // chrome-specific permissions we have.
            ['midi-sysex', 'midiSysex'],
        ]);
        const protocolPermissions = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._connection.send('Browser.grantPermissions', {
            origin,
            browserContextId: this._id || undefined,
            permissions: protocolPermissions,
        });
    }
    /**
     * Clears all permission overrides for the browser context.
     *
     * @example
     * ```js
     * const context = browser.defaultBrowserContext();
     * context.overridePermissions('https://example.com', ['clipboard-read']);
     * // do stuff ..
     * context.clearPermissionOverrides();
     * ```
     */
    async clearPermissionOverrides() {
        await this._connection.send('Browser.resetPermissions', {
            browserContextId: this._id || undefined,
        });
    }
    /**
     * Creates a new page in the browser context.
     */
    newPage() {
        return this._browser._createPageInContext(this._id);
    }
    /**
     * The browser this browser context belongs to.
     */
    browser() {
        return this._browser;
    }
    /**
     * Closes the browser context. All the targets that belong to the browser context
     * will be closed.
     *
     * @remarks
     * Only incognito browser contexts can be closed.
     */
    async close() {
        assert_js_1.assert(this._id, 'Non-incognito profiles cannot be closed!');
        await this._browser._disposeContext(this._id);
    }
}
exports.BrowserContext = BrowserContext;


/***/ }),

/***/ 8994:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connectToBrowser = void 0;
const Browser_js_1 = __nccwpck_require__(4523);
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const Connection_js_1 = __nccwpck_require__(402);
const fetch_js_1 = __nccwpck_require__(4938);
const environment_js_1 = __nccwpck_require__(4765);
const getWebSocketTransportClass = async () => {
    return environment_js_1.isNode
        ? (await Promise.resolve().then(() => __importStar(__nccwpck_require__(4402)))).NodeWebSocketTransport
        : (await Promise.resolve().then(() => __importStar(__nccwpck_require__(9587))))
            .BrowserWebSocketTransport;
};
/**
 * Users should never call this directly; it's called when calling
 * `puppeteer.connect`.
 * @internal
 */
exports.connectToBrowser = async (options) => {
    const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, slowMo = 0, } = options;
    assert_js_1.assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) ===
        1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');
    let connection = null;
    if (transport) {
        connection = new Connection_js_1.Connection('', transport, slowMo);
    }
    else if (browserWSEndpoint) {
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(browserWSEndpoint);
        connection = new Connection_js_1.Connection(browserWSEndpoint, connectionTransport, slowMo);
    }
    else if (browserURL) {
        const connectionURL = await getWSEndpoint(browserURL);
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(connectionURL);
        connection = new Connection_js_1.Connection(connectionURL, connectionTransport, slowMo);
    }
    const { browserContextIds } = await connection.send('Target.getBrowserContexts');
    return Browser_js_1.Browser.create(connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, null, () => connection.send('Browser.close').catch(helper_js_1.debugError));
};
async function getWSEndpoint(browserURL) {
    const endpointURL = new URL('/json/version', browserURL);
    const fetch = await fetch_js_1.getFetch();
    try {
        const result = await fetch(endpointURL.toString(), {
            method: 'GET',
        });
        if (!result.ok) {
            throw new Error(`HTTP ${result.statusText}`);
        }
        const data = await result.json();
        return data.webSocketDebuggerUrl;
    }
    catch (error) {
        error.message =
            `Failed to fetch browser webSocket URL from ${endpointURL}: ` +
                error.message;
        throw error;
    }
}


/***/ }),

/***/ 9587:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserWebSocketTransport = void 0;
class BrowserWebSocketTransport {
    constructor(ws) {
        this._ws = ws;
        this._ws.addEventListener('message', (event) => {
            if (this.onmessage)
                this.onmessage.call(null, event.data);
        });
        this._ws.addEventListener('close', () => {
            if (this.onclose)
                this.onclose.call(null);
        });
        // Silently ignore all errors - we don't know what to do with them.
        this._ws.addEventListener('error', () => { });
        this.onmessage = null;
        this.onclose = null;
    }
    static create(url) {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket(url);
            ws.addEventListener('open', () => resolve(new BrowserWebSocketTransport(ws)));
            ws.addEventListener('error', reject);
        });
    }
    send(message) {
        this._ws.send(message);
    }
    close() {
        this._ws.close();
    }
}
exports.BrowserWebSocketTransport = BrowserWebSocketTransport;


/***/ }),

/***/ 402:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDPSession = exports.CDPSessionEmittedEvents = exports.Connection = exports.ConnectionEmittedEvents = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const assert_js_1 = __nccwpck_require__(4337);
const Debug_js_1 = __nccwpck_require__(7259);
const debugProtocolSend = Debug_js_1.debug('puppeteer:protocol:SEND ►');
const debugProtocolReceive = Debug_js_1.debug('puppeteer:protocol:RECV ◀');
const EventEmitter_js_1 = __nccwpck_require__(241);
/**
 * Internal events that the Connection class emits.
 *
 * @internal
 */
exports.ConnectionEmittedEvents = {
    Disconnected: Symbol('Connection.Disconnected'),
};
/**
 * @internal
 */
class Connection extends EventEmitter_js_1.EventEmitter {
    constructor(url, transport, delay = 0) {
        super();
        this._lastId = 0;
        this._sessions = new Map();
        this._closed = false;
        this._callbacks = new Map();
        this._url = url;
        this._delay = delay;
        this._transport = transport;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
    }
    static fromSession(session) {
        return session._connection;
    }
    /**
     * @param {string} sessionId
     * @returns {?CDPSession}
     */
    session(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
    url() {
        return this._url;
    }
    send(method, ...paramArgs) {
        // There is only ever 1 param arg passed, but the Protocol defines it as an
        // array of 0 or 1 items See this comment:
        // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285
        // which explains why the protocol defines the params this way for better
        // type-inference.
        // So now we check if there are any params or not and deal with them accordingly.
        const params = paramArgs.length ? paramArgs[0] : undefined;
        const id = this._rawSend({ method, params });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    _rawSend(message) {
        const id = ++this._lastId;
        const stringifiedMessage = JSON.stringify(Object.assign({}, message, { id }));
        debugProtocolSend(stringifiedMessage);
        this._transport.send(stringifiedMessage);
        return id;
    }
    async _onMessage(message) {
        if (this._delay)
            await new Promise((f) => setTimeout(f, this._delay));
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if (object.method === 'Target.attachedToTarget') {
            const sessionId = object.params.sessionId;
            const session = new CDPSession(this, object.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session);
        }
        else if (object.method === 'Target.detachedFromTarget') {
            const session = this._sessions.get(object.params.sessionId);
            if (session) {
                session._onClosed();
                this._sessions.delete(object.params.sessionId);
            }
        }
        if (object.sessionId) {
            const session = this._sessions.get(object.sessionId);
            if (session)
                session._onMessage(object);
        }
        else if (object.id) {
            const callback = this._callbacks.get(object.id);
            // Callbacks could be all rejected if someone has called `.dispose()`.
            if (callback) {
                this._callbacks.delete(object.id);
                if (object.error)
                    callback.reject(createProtocolError(callback.error, callback.method, object));
                else
                    callback.resolve(object.result);
            }
        }
        else {
            this.emit(object.method, object.params);
        }
    }
    _onClose() {
        if (this._closed)
            return;
        this._closed = true;
        this._transport.onmessage = null;
        this._transport.onclose = null;
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        for (const session of this._sessions.values())
            session._onClosed();
        this._sessions.clear();
        this.emit(exports.ConnectionEmittedEvents.Disconnected);
    }
    dispose() {
        this._onClose();
        this._transport.close();
    }
    /**
     * @param {Protocol.Target.TargetInfo} targetInfo
     * @returns {!Promise<!CDPSession>}
     */
    async createSession(targetInfo) {
        const { sessionId } = await this.send('Target.attachToTarget', {
            targetId: targetInfo.targetId,
            flatten: true,
        });
        return this._sessions.get(sessionId);
    }
}
exports.Connection = Connection;
/**
 * Internal events that the CDPSession class emits.
 *
 * @internal
 */
exports.CDPSessionEmittedEvents = {
    Disconnected: Symbol('CDPSession.Disconnected'),
};
/**
 * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.
 *
 * @remarks
 *
 * Protocol methods can be called with {@link CDPSession.send} method and protocol
 * events can be subscribed to with `CDPSession.on` method.
 *
 * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}
 * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/master/README.md | Getting Started with DevTools Protocol}.
 *
 * @example
 * ```js
 * const client = await page.target().createCDPSession();
 * await client.send('Animation.enable');
 * client.on('Animation.animationCreated', () => console.log('Animation created!'));
 * const response = await client.send('Animation.getPlaybackRate');
 * console.log('playback rate is ' + response.playbackRate);
 * await client.send('Animation.setPlaybackRate', {
 *   playbackRate: response.playbackRate / 2
 * });
 * ```
 *
 * @public
 */
class CDPSession extends EventEmitter_js_1.EventEmitter {
    /**
     * @internal
     */
    constructor(connection, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
    }
    send(method, ...paramArgs) {
        if (!this._connection)
            return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        // See the comment in Connection#send explaining why we do this.
        const params = paramArgs.length ? paramArgs[0] : undefined;
        const id = this._connection._rawSend({
            sessionId: this._sessionId,
            method,
            /* TODO(jacktfranklin@): once this Firefox bug is solved
             * we no longer need the `|| {}` check
             * https://bugzilla.mozilla.org/show_bug.cgi?id=1631570
             */
            params: params || {},
        });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    /**
     * @internal
     */
    _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
            else
                callback.resolve(object.result);
        }
        else {
            assert_js_1.assert(!object.id);
            this.emit(object.method, object.params);
        }
    }
    /**
     * Detaches the cdpSession from the target. Once detached, the cdpSession object
     * won't emit any events and can't be used to send messages.
     */
    async detach() {
        if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        await this._connection.send('Target.detachFromTarget', {
            sessionId: this._sessionId,
        });
    }
    /**
     * @internal
     */
    _onClosed() {
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._connection = null;
        this.emit(exports.CDPSessionEmittedEvents.Disconnected);
    }
}
exports.CDPSession = CDPSession;
/**
 * @param {!Error} error
 * @param {string} method
 * @param {{error: {message: string, data: any}}} object
 * @returns {!Error}
 */
function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ('data' in object.error)
        message += ` ${object.error.data}`;
    return rewriteError(error, message);
}
/**
 * @param {!Error} error
 * @param {string} message
 * @returns {!Error}
 */
function rewriteError(error, message) {
    error.message = message;
    return error;
}


/***/ }),

/***/ 7754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleMessage = void 0;
/**
 * ConsoleMessage objects are dispatched by page via the 'console' event.
 * @public
 */
class ConsoleMessage {
    /**
     * @public
     */
    constructor(type, text, args, stackTraceLocations) {
        this._type = type;
        this._text = text;
        this._args = args;
        this._stackTraceLocations = stackTraceLocations;
    }
    /**
     * @returns The type of the console message.
     */
    type() {
        return this._type;
    }
    /**
     * @returns The text of the console message.
     */
    text() {
        return this._text;
    }
    /**
     * @returns An array of arguments passed to the console.
     */
    args() {
        return this._args;
    }
    /**
     * @returns The location of the console message.
     */
    location() {
        return this._stackTraceLocations.length ? this._stackTraceLocations[0] : {};
    }
    /**
     * @returns The array of locations on the stack of the console message.
     */
    stackTrace() {
        return this._stackTraceLocations;
    }
}
exports.ConsoleMessage = ConsoleMessage;


/***/ }),

/***/ 8914:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Coverage = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const ExecutionContext_js_1 = __nccwpck_require__(6069);
/**
 * The Coverage class provides methods to gathers information about parts of
 * JavaScript and CSS that were used by the page.
 *
 * @remarks
 * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},
 * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.
 *
 * @example
 * An example of using JavaScript and CSS coverage to get percentage of initially
 * executed code:
 * ```js
 * // Enable both JavaScript and CSS coverage
 * await Promise.all([
 *   page.coverage.startJSCoverage(),
 *   page.coverage.startCSSCoverage()
 * ]);
 * // Navigate to page
 * await page.goto('https://example.com');
 * // Disable both JavaScript and CSS coverage
 * const [jsCoverage, cssCoverage] = await Promise.all([
 *   page.coverage.stopJSCoverage(),
 *   page.coverage.stopCSSCoverage(),
 * ]);
 * let totalBytes = 0;
 * let usedBytes = 0;
 * const coverage = [...jsCoverage, ...cssCoverage];
 * for (const entry of coverage) {
 *   totalBytes += entry.text.length;
 *   for (const range of entry.ranges)
 *     usedBytes += range.end - range.start - 1;
 * }
 * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);
 * ```
 * @public
 */
class Coverage {
    constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
    }
    /**
     * @param options - defaults to
     * `{ resetOnNavigation : true, reportAnonymousScripts : false }`
     * @returns Promise that resolves when coverage is started.
     *
     * @remarks
     * Anonymous scripts are ones that don't have an associated url. These are
     * scripts that are dynamically created on the page using `eval` or
     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
     * scripts will have `__puppeteer_evaluation_script__` as their URL.
     */
    async startJSCoverage(options = {}) {
        return await this._jsCoverage.start(options);
    }
    /**
     * @returns Promise that resolves to the array of coverage reports for
     * all scripts.
     *
     * @remarks
     * JavaScript Coverage doesn't include anonymous scripts by default.
     * However, scripts with sourceURLs are reported.
     */
    async stopJSCoverage() {
        return await this._jsCoverage.stop();
    }
    /**
     * @param options - defaults to `{ resetOnNavigation : true }`
     * @returns Promise that resolves when coverage is started.
     */
    async startCSSCoverage(options = {}) {
        return await this._cssCoverage.start(options);
    }
    /**
     * @returns Promise that resolves to the array of coverage reports
     * for all stylesheets.
     * @remarks
     * CSS Coverage doesn't include dynamically injected style tags
     * without sourceURLs.
     */
    async stopCSSCoverage() {
        return await this._cssCoverage.stop();
    }
}
exports.Coverage = Coverage;
class JSCoverage {
    constructor(client) {
        this._enabled = false;
        this._scriptURLs = new Map();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
        this._reportAnonymousScripts = false;
        this._client = client;
    }
    async start(options = {}) {
        assert_js_1.assert(!this._enabled, 'JSCoverage is already enabled');
        const { resetOnNavigation = true, reportAnonymousScripts = false, } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptURLs.clear();
        this._scriptSources.clear();
        this._eventListeners = [
            helper_js_1.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),
            helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this._client.send('Profiler.enable'),
            this._client.send('Profiler.startPreciseCoverage', {
                callCount: false,
                detailed: true,
            }),
            this._client.send('Debugger.enable'),
            this._client.send('Debugger.setSkipAllPauses', { skip: true }),
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._scriptURLs.clear();
        this._scriptSources.clear();
    }
    async _onScriptParsed(event) {
        // Ignore puppeteer-injected scripts
        if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL)
            return;
        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.
        if (!event.url && !this._reportAnonymousScripts)
            return;
        try {
            const response = await this._client.send('Debugger.getScriptSource', {
                scriptId: event.scriptId,
            });
            this._scriptURLs.set(event.scriptId, event.url);
            this._scriptSources.set(event.scriptId, response.scriptSource);
        }
        catch (error) {
            // This might happen if the page has already navigated away.
            helper_js_1.debugError(error);
        }
    }
    async stop() {
        assert_js_1.assert(this._enabled, 'JSCoverage is not enabled');
        this._enabled = false;
        const result = await Promise.all([
            this._client.send('Profiler.takePreciseCoverage'),
            this._client.send('Profiler.stopPreciseCoverage'),
            this._client.send('Profiler.disable'),
            this._client.send('Debugger.disable'),
        ]);
        helper_js_1.helper.removeEventListeners(this._eventListeners);
        const coverage = [];
        const profileResponse = result[0];
        for (const entry of profileResponse.result) {
            let url = this._scriptURLs.get(entry.scriptId);
            if (!url && this._reportAnonymousScripts)
                url = 'debugger://VM' + entry.scriptId;
            const text = this._scriptSources.get(entry.scriptId);
            if (text === undefined || url === undefined)
                continue;
            const flattenRanges = [];
            for (const func of entry.functions)
                flattenRanges.push(...func.ranges);
            const ranges = convertToDisjointRanges(flattenRanges);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
class CSSCoverage {
    constructor(client) {
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
        this._reportAnonymousScripts = false;
        this._client = client;
    }
    async start(options = {}) {
        assert_js_1.assert(!this._enabled, 'CSSCoverage is already enabled');
        const { resetOnNavigation = true } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [
            helper_js_1.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),
            helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this._client.send('DOM.enable'),
            this._client.send('CSS.enable'),
            this._client.send('CSS.startRuleUsageTracking'),
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
    }
    async _onStyleSheet(event) {
        const header = event.header;
        // Ignore anonymous scripts
        if (!header.sourceURL)
            return;
        try {
            const response = await this._client.send('CSS.getStyleSheetText', {
                styleSheetId: header.styleSheetId,
            });
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
        }
        catch (error) {
            // This might happen if the page has already navigated away.
            helper_js_1.debugError(error);
        }
    }
    async stop() {
        assert_js_1.assert(this._enabled, 'CSSCoverage is not enabled');
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');
        await Promise.all([
            this._client.send('CSS.disable'),
            this._client.send('DOM.disable'),
        ]);
        helper_js_1.helper.removeEventListeners(this._eventListeners);
        // aggregate by styleSheetId
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
                ranges = [];
                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
                startOffset: entry.startOffset,
                endOffset: entry.endOffset,
                count: entry.used ? 1 : 0,
            });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
    }
    // Sort points to form a valid parenthesis sequence.
    points.sort((a, b) => {
        // Sort with increasing offsets.
        if (a.offset !== b.offset)
            return a.offset - b.offset;
        // All "end" points should go before "start" points.
        if (a.type !== b.type)
            return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        // For two "start" points, the one with longer range goes first.
        if (a.type === 0)
            return bLength - aLength;
        // For two "end" points, the one with shorter range goes first.
        return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    // Run scanning line to intersect all ranges.
    for (const point of points) {
        if (hitCountStack.length &&
            lastOffset < point.offset &&
            hitCountStack[hitCountStack.length - 1] > 0) {
            const lastResult = results.length ? results[results.length - 1] : null;
            if (lastResult && lastResult.end === lastOffset)
                lastResult.end = point.offset;
            else
                results.push({ start: lastOffset, end: point.offset });
        }
        lastOffset = point.offset;
        if (point.type === 0)
            hitCountStack.push(point.range.count);
        else
            hitCountStack.pop();
    }
    // Filter out empty ranges.
    return results.filter((range) => range.end - range.start > 1);
}


/***/ }),

/***/ 923:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaitTask = exports.DOMWorld = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const LifecycleWatcher_js_1 = __nccwpck_require__(1714);
const Errors_js_1 = __nccwpck_require__(6371);
const QueryHandler_js_1 = __nccwpck_require__(7157);
const environment_js_1 = __nccwpck_require__(4765);
/**
 * @internal
 */
class DOMWorld {
    constructor(frameManager, frame, timeoutSettings) {
        this._documentPromise = null;
        this._contextPromise = null;
        this._contextResolveCallback = null;
        this._detached = false;
        /**
         * @internal
         */
        this._waitTasks = new Set();
        /**
         * @internal
         * Contains mapping from functions that should be bound to Puppeteer functions.
         */
        this._boundFunctions = new Map();
        // Set of bindings that have been registered in the current context.
        this._ctxBindings = new Set();
        // If multiple waitFor are set up asynchronously, we need to wait for the
        // first one to set up the binding in the page before running the others.
        this._settingUpBinding = null;
        this._frameManager = frameManager;
        this._frame = frame;
        this._timeoutSettings = timeoutSettings;
        this._setContext(null);
        frameManager._client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));
    }
    frame() {
        return this._frame;
    }
    async _setContext(context) {
        if (context) {
            this._contextResolveCallback.call(null, context);
            this._contextResolveCallback = null;
            for (const waitTask of this._waitTasks)
                waitTask.rerun();
        }
        else {
            this._documentPromise = null;
            this._contextPromise = new Promise((fulfill) => {
                this._contextResolveCallback = fulfill;
            });
        }
    }
    _hasContext() {
        return !this._contextResolveCallback;
    }
    _detach() {
        this._detached = true;
        for (const waitTask of this._waitTasks)
            waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));
    }
    executionContext() {
        if (this._detached)
            throw new Error(`Execution context is not available in detached frame "${this._frame.url()}" (are you trying to evaluate?)`);
        return this._contextPromise;
    }
    async evaluateHandle(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluate(pageFunction, ...args);
    }
    async $(selector) {
        const document = await this._document();
        const value = await document.$(selector);
        return value;
    }
    async _document() {
        if (this._documentPromise)
            return this._documentPromise;
        this._documentPromise = this.executionContext().then(async (context) => {
            const document = await context.evaluateHandle('document');
            return document.asElement();
        });
        return this._documentPromise;
    }
    async $x(expression) {
        const document = await this._document();
        const value = await document.$x(expression);
        return value;
    }
    async $eval(selector, pageFunction, ...args) {
        const document = await this._document();
        return document.$eval(selector, pageFunction, ...args);
    }
    async $$eval(selector, pageFunction, ...args) {
        const document = await this._document();
        const value = await document.$$eval(selector, pageFunction, ...args);
        return value;
    }
    async $$(selector) {
        const document = await this._document();
        const value = await document.$$(selector);
        return value;
    }
    async content() {
        return await this.evaluate(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(html, options = {}) {
        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;
        // We rely upon the fact that document.open() will reset frame lifecycle with "init"
        // lifecycle event. @see https://crrev.com/608658
        await this.evaluate((html) => {
            document.open();
            document.write(html);
            document.close();
        }, html);
        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);
        const error = await Promise.race([
            watcher.timeoutOrTerminationPromise(),
            watcher.lifecyclePromise(),
        ]);
        watcher.dispose();
        if (error)
            throw error;
    }
    /**
     * Adds a script tag into the current context.
     *
     * @remarks
     *
     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer
     * in a browser environment you cannot pass a filepath and should use either
     * `url` or `content`.
     */
    async addScriptTag(options) {
        const { url = null, path = null, content = null, type = '' } = options;
        if (url !== null) {
            try {
                const context = await this.executionContext();
                return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();
            }
            catch (error) {
                throw new Error(`Loading script from ${url} failed`);
            }
        }
        if (path !== null) {
            if (!environment_js_1.isNode) {
                throw new Error('Cannot pass a filepath to addScriptTag in the browser environment.');
            }
            const fs = await helper_js_1.helper.importFSModule();
            let contents = await fs.promises.readFile(path, 'utf8');
            contents += '//# sourceURL=' + path.replace(/\n/g, '');
            const context = await this.executionContext();
            return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();
        }
        if (content !== null) {
            const context = await this.executionContext();
            return (await context.evaluateHandle(addScriptContent, content, type)).asElement();
        }
        throw new Error('Provide an object with a `url`, `path` or `content` property');
        async function addScriptUrl(url, type) {
            const script = document.createElement('script');
            script.src = url;
            if (type)
                script.type = type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = rej;
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(content, type = 'text/javascript') {
            const script = document.createElement('script');
            script.type = type;
            script.text = content;
            let error = null;
            script.onerror = (e) => (error = e);
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    /**
     * Adds a style tag into the current context.
     *
     * @remarks
     *
     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer
     * in a browser environment you cannot pass a filepath and should use either
     * `url` or `content`.
     *
     */
    async addStyleTag(options) {
        const { url = null, path = null, content = null } = options;
        if (url !== null) {
            try {
                const context = await this.executionContext();
                return (await context.evaluateHandle(addStyleUrl, url)).asElement();
            }
            catch (error) {
                throw new Error(`Loading style from ${url} failed`);
            }
        }
        if (path !== null) {
            if (!environment_js_1.isNode) {
                throw new Error('Cannot pass a filepath to addStyleTag in the browser environment.');
            }
            const fs = await helper_js_1.helper.importFSModule();
            let contents = await fs.promises.readFile(path, 'utf8');
            contents += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
            const context = await this.executionContext();
            return (await context.evaluateHandle(addStyleContent, contents)).asElement();
        }
        if (content !== null) {
            const context = await this.executionContext();
            return (await context.evaluateHandle(addStyleContent, content)).asElement();
        }
        throw new Error('Provide an object with a `url`, `path` or `content` property');
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async click(selector, options) {
        const handle = await this.$(selector);
        assert_js_1.assert(handle, 'No node found for selector: ' + selector);
        await handle.click(options);
        await handle.dispose();
    }
    async focus(selector) {
        const handle = await this.$(selector);
        assert_js_1.assert(handle, 'No node found for selector: ' + selector);
        await handle.focus();
        await handle.dispose();
    }
    async hover(selector) {
        const handle = await this.$(selector);
        assert_js_1.assert(handle, 'No node found for selector: ' + selector);
        await handle.hover();
        await handle.dispose();
    }
    async select(selector, ...values) {
        const handle = await this.$(selector);
        assert_js_1.assert(handle, 'No node found for selector: ' + selector);
        const result = await handle.select(...values);
        await handle.dispose();
        return result;
    }
    async tap(selector) {
        const handle = await this.$(selector);
        await handle.tap();
        await handle.dispose();
    }
    async type(selector, text, options) {
        const handle = await this.$(selector);
        assert_js_1.assert(handle, 'No node found for selector: ' + selector);
        await handle.type(text, options);
        await handle.dispose();
    }
    async waitForSelector(selector, options) {
        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);
        return queryHandler.waitFor(this, updatedSelector, options);
    }
    /**
     * @internal
     */
    async addBindingToContext(context, name) {
        // Previous operation added the binding so we are done.
        if (this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) {
            return;
        }
        // Wait for other operation to finish
        if (this._settingUpBinding) {
            await this._settingUpBinding;
            return this.addBindingToContext(context, name);
        }
        const bind = async (name) => {
            const expression = helper_js_1.helper.pageBindingInitString('internal', name);
            try {
                await context._client.send('Runtime.addBinding', {
                    name,
                    executionContextId: context._contextId,
                });
                await context.evaluate(expression);
            }
            catch (error) {
                // We could have tried to evaluate in a context which was already
                // destroyed. This happens, for example, if the page is navigated while
                // we are trying to add the binding
                const ctxDestroyed = error.message.includes('Execution context was destroyed');
                const ctxNotFound = error.message.includes('Cannot find context with specified id');
                if (ctxDestroyed || ctxNotFound) {
                    return;
                }
                else {
                    helper_js_1.debugError(error);
                    return;
                }
            }
            this._ctxBindings.add(DOMWorld.bindingIdentifier(name, context._contextId));
        };
        this._settingUpBinding = bind(name);
        await this._settingUpBinding;
        this._settingUpBinding = null;
    }
    async _onBindingCalled(event) {
        let payload;
        if (!this._hasContext())
            return;
        const context = await this.executionContext();
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            // The binding was either called by something in the page or it was
            // called before our wrapper was initialized.
            return;
        }
        const { type, name, seq, args } = payload;
        if (type !== 'internal' ||
            !this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId)))
            return;
        if (context._contextId !== event.executionContextId)
            return;
        try {
            const result = await this._boundFunctions.get(name)(...args);
            await context.evaluate(deliverResult, name, seq, result);
        }
        catch (error) {
            // The WaitTask may already have been resolved by timing out, or the
            // exection context may have been destroyed.
            // In both caes, the promises above are rejected with a protocol error.
            // We can safely ignores these, as the WaitTask is re-installed in
            // the next execution context if needed.
            if (error.message.includes('Protocol error'))
                return;
            helper_js_1.debugError(error);
        }
        function deliverResult(name, seq, result) {
            globalThis[name].callbacks.get(seq).resolve(result);
            globalThis[name].callbacks.delete(seq);
        }
    }
    /**
     * @internal
     */
    async waitForSelectorInPage(queryOne, selector, options, binding) {
        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;
        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';
        const title = `selector \`${selector}\`${waitForHidden ? ' to be hidden' : ''}`;
        async function predicate(selector, waitForVisible, waitForHidden) {
            const node = predicateQueryHandler
                ? (await predicateQueryHandler(document, selector))
                : document.querySelector(selector);
            return checkWaitForOptions(node, waitForVisible, waitForHidden);
        }
        const waitTaskOptions = {
            domWorld: this,
            predicateBody: helper_js_1.helper.makePredicateString(predicate, queryOne),
            title,
            polling,
            timeout,
            args: [selector, waitForVisible, waitForHidden],
            binding,
        };
        const waitTask = new WaitTask(waitTaskOptions);
        const jsHandle = await waitTask.promise;
        const elementHandle = jsHandle.asElement();
        if (!elementHandle) {
            await jsHandle.dispose();
            return null;
        }
        return elementHandle;
    }
    async waitForXPath(xpath, options) {
        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;
        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';
        const title = `XPath \`${xpath}\`${waitForHidden ? ' to be hidden' : ''}`;
        function predicate(xpath, waitForVisible, waitForHidden) {
            const node = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            return checkWaitForOptions(node, waitForVisible, waitForHidden);
        }
        const waitTaskOptions = {
            domWorld: this,
            predicateBody: helper_js_1.helper.makePredicateString(predicate),
            title,
            polling,
            timeout,
            args: [xpath, waitForVisible, waitForHidden],
        };
        const waitTask = new WaitTask(waitTaskOptions);
        const jsHandle = await waitTask.promise;
        const elementHandle = jsHandle.asElement();
        if (!elementHandle) {
            await jsHandle.dispose();
            return null;
        }
        return elementHandle;
    }
    waitForFunction(pageFunction, options = {}, ...args) {
        const { polling = 'raf', timeout = this._timeoutSettings.timeout(), } = options;
        const waitTaskOptions = {
            domWorld: this,
            predicateBody: pageFunction,
            title: 'function',
            polling,
            timeout,
            args,
        };
        const waitTask = new WaitTask(waitTaskOptions);
        return waitTask.promise;
    }
    async title() {
        return this.evaluate(() => document.title);
    }
}
exports.DOMWorld = DOMWorld;
DOMWorld.bindingIdentifier = (name, contextId) => `${name}_${contextId}`;
/**
 * @internal
 */
class WaitTask {
    constructor(options) {
        this._runCount = 0;
        this._terminated = false;
        if (helper_js_1.helper.isString(options.polling))
            assert_js_1.assert(options.polling === 'raf' || options.polling === 'mutation', 'Unknown polling option: ' + options.polling);
        else if (helper_js_1.helper.isNumber(options.polling))
            assert_js_1.assert(options.polling > 0, 'Cannot poll with non-positive interval: ' + options.polling);
        else
            throw new Error('Unknown polling options: ' + options.polling);
        function getPredicateBody(predicateBody) {
            if (helper_js_1.helper.isString(predicateBody))
                return `return (${predicateBody});`;
            return `return (${predicateBody})(...args);`;
        }
        this._domWorld = options.domWorld;
        this._polling = options.polling;
        this._timeout = options.timeout;
        this._predicateBody = getPredicateBody(options.predicateBody);
        this._args = options.args;
        this._binding = options.binding;
        this._runCount = 0;
        this._domWorld._waitTasks.add(this);
        if (this._binding) {
            this._domWorld._boundFunctions.set(this._binding.name, this._binding.pptrFunction);
        }
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        // Since page navigation requires us to re-install the pageScript, we should track
        // timeout on our end.
        if (options.timeout) {
            const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${options.title} failed: timeout ${options.timeout}ms exceeded`);
            this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), options.timeout);
        }
        this.rerun();
    }
    terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._cleanup();
    }
    async rerun() {
        const runCount = ++this._runCount;
        let success = null;
        let error = null;
        const context = await this._domWorld.executionContext();
        if (this._terminated || runCount !== this._runCount)
            return;
        if (this._binding) {
            await this._domWorld.addBindingToContext(context, this._binding.name);
        }
        if (this._terminated || runCount !== this._runCount)
            return;
        try {
            success = await context.evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);
        }
        catch (error_) {
            error = error_;
        }
        if (this._terminated || runCount !== this._runCount) {
            if (success)
                await success.dispose();
            return;
        }
        // Ignore timeouts in pageScript - we track timeouts ourselves.
        // If the frame's execution context has already changed, `frame.evaluate` will
        // throw an error - ignore this predicate run altogether.
        if (!error &&
            (await this._domWorld.evaluate((s) => !s, success).catch(() => true))) {
            await success.dispose();
            return;
        }
        if (error) {
            if (error.message.includes('TypeError: binding is not a function')) {
                return this.rerun();
            }
            // When frame is detached the task should have been terminated by the DOMWorld.
            // This can fail if we were adding this task while the frame was detached,
            // so we terminate here instead.
            if (error.message.includes('Execution context is not available in detached frame')) {
                this.terminate(new Error('waitForFunction failed: frame got detached.'));
                return;
            }
            // When the page is navigated, the promise is rejected.
            // We will try again in the new execution context.
            if (error.message.includes('Execution context was destroyed'))
                return;
            // We could have tried to evaluate in a context which was already
            // destroyed.
            if (error.message.includes('Cannot find context with specified id'))
                return;
            this._reject(error);
        }
        else {
            this._resolve(success);
        }
        this._cleanup();
    }
    _cleanup() {
        clearTimeout(this._timeoutTimer);
        this._domWorld._waitTasks.delete(this);
    }
}
exports.WaitTask = WaitTask;
async function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {
    const predicate = new Function('...args', predicateBody);
    let timedOut = false;
    if (timeout)
        setTimeout(() => (timedOut = true), timeout);
    if (polling === 'raf')
        return await pollRaf();
    if (polling === 'mutation')
        return await pollMutation();
    if (typeof polling === 'number')
        return await pollInterval(polling);
    /**
     * @returns {!Promise<*>}
     */
    async function pollMutation() {
        const success = await predicate(...args);
        if (success)
            return Promise.resolve(success);
        let fulfill;
        const result = new Promise((x) => (fulfill = x));
        const observer = new MutationObserver(async () => {
            if (timedOut) {
                observer.disconnect();
                fulfill();
            }
            const success = await predicate(...args);
            if (success) {
                observer.disconnect();
                fulfill(success);
            }
        });
        observer.observe(document, {
            childList: true,
            subtree: true,
            attributes: true,
        });
        return result;
    }
    async function pollRaf() {
        let fulfill;
        const result = new Promise((x) => (fulfill = x));
        await onRaf();
        return result;
        async function onRaf() {
            if (timedOut) {
                fulfill();
                return;
            }
            const success = await predicate(...args);
            if (success)
                fulfill(success);
            else
                requestAnimationFrame(onRaf);
        }
    }
    async function pollInterval(pollInterval) {
        let fulfill;
        const result = new Promise((x) => (fulfill = x));
        await onTimeout();
        return result;
        async function onTimeout() {
            if (timedOut) {
                fulfill();
                return;
            }
            const success = await predicate(...args);
            if (success)
                fulfill(success);
            else
                setTimeout(onTimeout, pollInterval);
        }
    }
}


/***/ }),

/***/ 7259:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debug = void 0;
const environment_js_1 = __nccwpck_require__(4765);
/**
 * A debug function that can be used in any environment.
 *
 * @remarks
 *
 * If used in Node, it falls back to the
 * {@link https://www.npmjs.com/package/debug | debug module}. In the browser it
 * uses `console.log`.
 *
 * @param prefix - this will be prefixed to each log.
 * @returns a function that can be called to log to that debug channel.
 *
 * In Node, use the `DEBUG` environment variable to control logging:
 *
 * ```
 * DEBUG=* // logs all channels
 * DEBUG=foo // logs the `foo` channel
 * DEBUG=foo* // logs any channels starting with `foo`
 * ```
 *
 * In the browser, set `window.__PUPPETEER_DEBUG` to a string:
 *
 * ```
 * window.__PUPPETEER_DEBUG='*'; // logs all channels
 * window.__PUPPETEER_DEBUG='foo'; // logs the `foo` channel
 * window.__PUPPETEER_DEBUG='foo*'; // logs any channels starting with `foo`
 * ```
 *
 * @example
 * ```
 * const log = debug('Page');
 *
 * log('new page created')
 * // logs "Page: new page created"
 * ```
 */
exports.debug = (prefix) => {
    if (environment_js_1.isNode) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        return __nccwpck_require__(2423)(prefix);
    }
    return (...logArgs) => {
        const debugLevel = globalThis.__PUPPETEER_DEBUG;
        if (!debugLevel)
            return;
        const everythingShouldBeLogged = debugLevel === '*';
        const prefixMatchesDebugLevel = everythingShouldBeLogged ||
            /**
             * If the debug level is `foo*`, that means we match any prefix that
             * starts with `foo`. If the level is `foo`, we match only the prefix
             * `foo`.
             */
            (debugLevel.endsWith('*')
                ? prefix.startsWith(debugLevel)
                : prefix === debugLevel);
        if (!prefixMatchesDebugLevel)
            return;
        // eslint-disable-next-line no-console
        console.log(`${prefix}:`, ...logArgs);
    };
};


/***/ }),

/***/ 9821:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.devicesMap = void 0;
const devices = [
    {
        name: 'Blackberry PlayBook',
        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
        viewport: {
            width: 600,
            height: 1024,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Blackberry PlayBook landscape',
        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
        viewport: {
            width: 1024,
            height: 600,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'BlackBerry Z30',
        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'BlackBerry Z30 landscape',
        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Note 3',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Note 3 landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Note II',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Note II landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S III',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S III landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S5',
        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Mini',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Mini landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Pro',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 1366,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Pro landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1366,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 4',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
        viewport: {
            width: 320,
            height: 480,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 4 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
        viewport: {
            width: 480,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 5',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 5 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 6',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 6 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 6 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 6 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 7',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 7 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 7 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 7 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 8',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 8 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 8 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 8 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone SE',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone SE landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone X',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone X landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone XR',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone XR landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'JioPhone 2',
        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
        viewport: {
            width: 240,
            height: 320,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'JioPhone 2 landscape',
        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
        viewport: {
            width: 320,
            height: 240,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Kindle Fire HDX',
        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Kindle Fire HDX landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'LG Optimus L70',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 1.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'LG Optimus L70 landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 1.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Microsoft Lumia 550',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Microsoft Lumia 950',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 4,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Microsoft Lumia 950 landscape',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 4,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 10',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 10 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 4',
        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 4 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 5',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 5X',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 5X landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 6',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 6 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 6P',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 6P landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 7',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 600,
            height: 960,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 7 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 960,
            height: 600,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nokia Lumia 520',
        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
        viewport: {
            width: 320,
            height: 533,
            deviceScaleFactor: 1.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nokia Lumia 520 landscape',
        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
        viewport: {
            width: 533,
            height: 320,
            deviceScaleFactor: 1.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nokia N9',
        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
        viewport: {
            width: 480,
            height: 854,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nokia N9 landscape',
        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
        viewport: {
            width: 854,
            height: 480,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 2',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 411,
            height: 731,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 2 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 731,
            height: 411,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 2 XL',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 411,
            height: 823,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 2 XL landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 823,
            height: 411,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
];
const devicesMap = {};
exports.devicesMap = devicesMap;
for (const device of devices)
    devicesMap[device.name] = device;


/***/ }),

/***/ 750:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dialog = void 0;
const assert_js_1 = __nccwpck_require__(4337);
/**
 * Dialog instances are dispatched by the {@link Page} via the `dialog` event.
 *
 * @remarks
 *
 * @example
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   page.on('dialog', async dialog => {
 *     console.log(dialog.message());
 *     await dialog.dismiss();
 *     await browser.close();
 *   });
 *   page.evaluate(() => alert('1'));
 * })();
 * ```
 */
class Dialog {
    /**
     * @internal
     */
    constructor(client, type, message, defaultValue = '') {
        this._handled = false;
        this._client = client;
        this._type = type;
        this._message = message;
        this._defaultValue = defaultValue;
    }
    /**
     * @returns The type of the dialog.
     */
    type() {
        return this._type;
    }
    /**
     * @returns The message displayed in the dialog.
     */
    message() {
        return this._message;
    }
    /**
     * @returns The default value of the prompt, or an empty string if the dialog
     * is not a `prompt`.
     */
    defaultValue() {
        return this._defaultValue;
    }
    /**
     * @param promptText - optional text that will be entered in the dialog
     * prompt. Has no effect if the dialog's type is not `prompt`.
     *
     * @returns A promise that resolves when the dialog has been accepted.
     */
    async accept(promptText) {
        assert_js_1.assert(!this._handled, 'Cannot accept dialog which is already handled!');
        this._handled = true;
        await this._client.send('Page.handleJavaScriptDialog', {
            accept: true,
            promptText: promptText,
        });
    }
    /**
     * @returns A promise which will resolve once the dialog has been dismissed
     */
    async dismiss() {
        assert_js_1.assert(!this._handled, 'Cannot dismiss dialog which is already handled!');
        this._handled = true;
        await this._client.send('Page.handleJavaScriptDialog', {
            accept: false,
        });
    }
}
exports.Dialog = Dialog;


/***/ }),

/***/ 5097:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmulationManager = void 0;
class EmulationManager {
    constructor(client) {
        this._emulatingMobile = false;
        this._hasTouch = false;
        this._client = client;
    }
    async emulateViewport(viewport) {
        const mobile = viewport.isMobile || false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = viewport.deviceScaleFactor || 1;
        const screenOrientation = viewport.isLandscape
            ? { angle: 90, type: 'landscapePrimary' }
            : { angle: 0, type: 'portraitPrimary' };
        const hasTouch = viewport.hasTouch || false;
        await Promise.all([
            this._client.send('Emulation.setDeviceMetricsOverride', {
                mobile,
                width,
                height,
                deviceScaleFactor,
                screenOrientation,
            }),
            this._client.send('Emulation.setTouchEmulationEnabled', {
                enabled: hasTouch,
            }),
        ]);
        const reloadNeeded = this._emulatingMobile !== mobile || this._hasTouch !== hasTouch;
        this._emulatingMobile = mobile;
        this._hasTouch = hasTouch;
        return reloadNeeded;
    }
}
exports.EmulationManager = EmulationManager;


/***/ }),

/***/ 6371:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.puppeteerErrors = exports.TimeoutError = void 0;
class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
/**
 * TimeoutError is emitted whenever certain operations are terminated due to timeout.
 *
 * @remarks
 *
 * Example operations are {@link Page.waitForSelector | page.waitForSelector}
 * or {@link PuppeteerNode.launch | puppeteer.launch}.
 *
 * @public
 */
class TimeoutError extends CustomError {
}
exports.TimeoutError = TimeoutError;
exports.puppeteerErrors = {
    TimeoutError,
};


/***/ }),

/***/ 241:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
const index_js_1 = __importDefault(__nccwpck_require__(3435));
/**
 * The EventEmitter class that many Puppeteer classes extend.
 *
 * @remarks
 *
 * This allows you to listen to events that Puppeteer classes fire and act
 * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and
 * {@link EventEmitter.off | off} to bind
 * and unbind to event listeners.
 *
 * @public
 */
class EventEmitter {
    /**
     * @internal
     */
    constructor() {
        this.eventsMap = new Map();
        this.emitter = index_js_1.default(this.eventsMap);
    }
    /**
     * Bind an event listener to fire when an event occurs.
     * @param event - the event type you'd like to listen to. Can be a string or symbol.
     * @param handler  - the function to be called when the event occurs.
     * @returns `this` to enable you to chain calls.
     */
    on(event, handler) {
        this.emitter.on(event, handler);
        return this;
    }
    /**
     * Remove an event listener from firing.
     * @param event - the event type you'd like to stop listening to.
     * @param handler  - the function that should be removed.
     * @returns `this` to enable you to chain calls.
     */
    off(event, handler) {
        this.emitter.off(event, handler);
        return this;
    }
    /**
     * Remove an event listener.
     * @deprecated please use `off` instead.
     */
    removeListener(event, handler) {
        this.off(event, handler);
        return this;
    }
    /**
     * Add an event listener.
     * @deprecated please use `on` instead.
     */
    addListener(event, handler) {
        this.on(event, handler);
        return this;
    }
    /**
     * Emit an event and call any associated listeners.
     *
     * @param event - the event you'd like to emit
     * @param eventData - any data you'd like to emit with the event
     * @returns `true` if there are any listeners, `false` if there are not.
     */
    emit(event, eventData) {
        this.emitter.emit(event, eventData);
        return this.eventListenersCount(event) > 0;
    }
    /**
     * Like `on` but the listener will only be fired once and then it will be removed.
     * @param event - the event you'd like to listen to
     * @param handler - the handler function to run when the event occurs
     * @returns `this` to enable you to chain calls.
     */
    once(event, handler) {
        const onceHandler = (eventData) => {
            handler(eventData);
            this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
    }
    /**
     * Gets the number of listeners for a given event.
     *
     * @param event - the event to get the listener count for
     * @returns the number of listeners bound to the given event
     */
    listenerCount(event) {
        return this.eventListenersCount(event);
    }
    /**
     * Removes all listeners. If given an event argument, it will remove only
     * listeners for that event.
     * @param event - the event to remove listeners for.
     * @returns `this` to enable you to chain calls.
     */
    removeAllListeners(event) {
        if (event) {
            this.eventsMap.delete(event);
        }
        else {
            this.eventsMap.clear();
        }
        return this;
    }
    eventListenersCount(event) {
        return this.eventsMap.has(event) ? this.eventsMap.get(event).length : 0;
    }
}
exports.EventEmitter = EventEmitter;


/***/ }),

/***/ 6069:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecutionContext = exports.EVALUATION_SCRIPT_URL = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const JSHandle_js_1 = __nccwpck_require__(859);
exports.EVALUATION_SCRIPT_URL = '__puppeteer_evaluation_script__';
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
/**
 * This class represents a context for JavaScript execution. A [Page] might have
 * many execution contexts:
 * - each
 *   {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe |
 *   frame } has "default" execution context that is always created after frame is
 *   attached to DOM. This context is returned by the
 *   {@link frame.executionContext()} method.
 * - {@link https://developer.chrome.com/extensions | Extension}'s content scripts
 *   create additional execution contexts.
 *
 * Besides pages, execution contexts can be found in
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |
 * workers }.
 *
 * @public
 */
class ExecutionContext {
    /**
     * @internal
     */
    constructor(client, contextPayload, world) {
        this._client = client;
        this._world = world;
        this._contextId = contextPayload.id;
    }
    /**
     * @remarks
     *
     * Not every execution context is associated with a frame. For
     * example, workers and extensions have execution contexts that are not
     * associated with frames.
     *
     * @returns The frame associated with this execution context.
     */
    frame() {
        return this._world ? this._world.frame() : null;
    }
    /**
     * @remarks
     * If the function passed to the `executionContext.evaluate` returns a
     * Promise, then `executionContext.evaluate` would wait for the promise to
     * resolve and return its value. If the function passed to the
     * `executionContext.evaluate` returns a non-serializable value, then
     * `executionContext.evaluate` resolves to `undefined`. DevTools Protocol also
     * supports transferring some additional values that are not serializable by
     * `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
     *
     *
     * @example
     * ```js
     * const executionContext = await page.mainFrame().executionContext();
     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
     * console.log(result); // prints "56"
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```js
     * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the
     * `executionContext.* evaluate`:
     * ```js
     * const oneHandle = await executionContext.evaluateHandle(() => 1);
     * const twoHandle = await executionContext.evaluateHandle(() => 2);
     * const result = await executionContext.evaluate(
     *    (a, b) => a + b, oneHandle, * twoHandle
     * );
     * await oneHandle.dispose();
     * await twoHandle.dispose();
     * console.log(result); // prints '3'.
     * ```
     * @param pageFunction a function to be evaluated in the `executionContext`
     * @param args argument to pass to the page function
     *
     * @returns A promise that resolves to the return value of the given function.
     */
    async evaluate(pageFunction, ...args) {
        return await this._evaluateInternal(true, pageFunction, ...args);
    }
    /**
     * @remarks
     * The only difference between `executionContext.evaluate` and
     * `executionContext.evaluateHandle` is that `executionContext.evaluateHandle`
     * returns an in-page object (a {@link JSHandle}).
     * If the function passed to the `executionContext.evaluateHandle` returns a
     * Promise, then `executionContext.evaluateHandle` would wait for the
     * promise to resolve and return its value.
     *
     * @example
     * ```js
     * const context = await page.mainFrame().executionContext();
     * const aHandle = await context.evaluateHandle(() => Promise.resolve(self));
     * aHandle; // Handle for the global object.
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```js
     * // Handle for the '3' * object.
     * const aHandle = await context.evaluateHandle('1 + 2');
     * ```
     *
     * @example
     * JSHandle instances can be passed as arguments
     * to the `executionContext.* evaluateHandle`:
     *
     * ```js
     * const aHandle = await context.evaluateHandle(() => document.body);
     * const resultHandle = await context.evaluateHandle(body => body.innerHTML, * aHandle);
     * console.log(await resultHandle.jsonValue()); // prints body's innerHTML
     * await aHandle.dispose();
     * await resultHandle.dispose();
     * ```
     *
     * @param pageFunction a function to be evaluated in the `executionContext`
     * @param args argument to pass to the page function
     *
     * @returns A promise that resolves to the return value of the given function
     * as an in-page object (a {@link JSHandle}).
     */
    async evaluateHandle(pageFunction, ...args) {
        return this._evaluateInternal(false, pageFunction, ...args);
    }
    async _evaluateInternal(returnByValue, pageFunction, ...args) {
        const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;
        if (helper_js_1.helper.isString(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)
                ? expression
                : expression + '\n' + suffix;
            const { exceptionDetails, result: remoteObject } = await this._client
                .send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            })
                .catch(rewriteError);
            if (exceptionDetails)
                throw new Error('Evaluation failed: ' + helper_js_1.helper.getExceptionMessage(exceptionDetails));
            return returnByValue
                ? helper_js_1.helper.valueFromRemoteObject(remoteObject)
                : JSHandle_js_1.createJSHandle(this, remoteObject);
        }
        if (typeof pageFunction !== 'function')
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        let functionText = pageFunction.toString();
        try {
            new Function('(' + functionText + ')');
        }
        catch (error) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (functionText.startsWith('async '))
                functionText =
                    'async function ' + functionText.substring('async '.length);
            else
                functionText = 'function ' + functionText;
            try {
                new Function('(' + functionText + ')');
            }
            catch (error) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
        let callFunctionOnPromise;
        try {
            callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: functionText + '\n' + suffix + '\n',
                executionContextId: this._contextId,
                arguments: args.map(convertArgument.bind(this)),
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            });
        }
        catch (error) {
            if (error instanceof TypeError &&
                error.message.startsWith('Converting circular structure to JSON'))
                error.message += ' Are you passing a nested JSHandle?';
            throw error;
        }
        const { exceptionDetails, result: remoteObject, } = await callFunctionOnPromise.catch(rewriteError);
        if (exceptionDetails)
            throw new Error('Evaluation failed: ' + helper_js_1.helper.getExceptionMessage(exceptionDetails));
        return returnByValue
            ? helper_js_1.helper.valueFromRemoteObject(remoteObject)
            : JSHandle_js_1.createJSHandle(this, remoteObject);
        /**
         * @param {*} arg
         * @returns {*}
         * @this {ExecutionContext}
         */
        function convertArgument(arg) {
            if (typeof arg === 'bigint')
                // eslint-disable-line valid-typeof
                return { unserializableValue: `${arg.toString()}n` };
            if (Object.is(arg, -0))
                return { unserializableValue: '-0' };
            if (Object.is(arg, Infinity))
                return { unserializableValue: 'Infinity' };
            if (Object.is(arg, -Infinity))
                return { unserializableValue: '-Infinity' };
            if (Object.is(arg, NaN))
                return { unserializableValue: 'NaN' };
            const objectHandle = arg && arg instanceof JSHandle_js_1.JSHandle ? arg : null;
            if (objectHandle) {
                if (objectHandle._context !== this)
                    throw new Error('JSHandles can be evaluated only in the context they were created!');
                if (objectHandle._disposed)
                    throw new Error('JSHandle is disposed!');
                if (objectHandle._remoteObject.unserializableValue)
                    return {
                        unserializableValue: objectHandle._remoteObject.unserializableValue,
                    };
                if (!objectHandle._remoteObject.objectId)
                    return { value: objectHandle._remoteObject.value };
                return { objectId: objectHandle._remoteObject.objectId };
            }
            return { value: arg };
        }
        function rewriteError(error) {
            if (error.message.includes('Object reference chain is too long'))
                return { result: { type: 'undefined' } };
            if (error.message.includes("Object couldn't be returned by value"))
                return { result: { type: 'undefined' } };
            if (error.message.endsWith('Cannot find context with specified id') ||
                error.message.endsWith('Inspected target navigated or closed'))
                throw new Error('Execution context was destroyed, most likely because of a navigation.');
            throw error;
        }
    }
    /**
     * This method iterates the JavaScript heap and finds all the objects with the
     * given prototype.
     * @remarks
     * @example
     * ```js
     * // Create a Map object
     * await page.evaluate(() => window.map = new Map());
     * // Get a handle to the Map object prototype
     * const mapPrototype = await page.evaluateHandle(() => Map.prototype);
     * // Query all map instances into an array
     * const mapInstances = await page.queryObjects(mapPrototype);
     * // Count amount of map objects in heap
     * const count = await page.evaluate(maps => maps.length, mapInstances);
     * await mapInstances.dispose();
     * await mapPrototype.dispose();
     * ```
     *
     * @param prototypeHandle a handle to the object prototype
     *
     * @returns A handle to an array of objects with the given prototype.
     */
    async queryObjects(prototypeHandle) {
        assert_js_1.assert(!prototypeHandle._disposed, 'Prototype JSHandle is disposed!');
        assert_js_1.assert(prototypeHandle._remoteObject.objectId, 'Prototype JSHandle must not be referencing primitive value');
        const response = await this._client.send('Runtime.queryObjects', {
            prototypeObjectId: prototypeHandle._remoteObject.objectId,
        });
        return JSHandle_js_1.createJSHandle(this, response.objects);
    }
    /**
     * @internal
     */
    async _adoptBackendNodeId(backendNodeId) {
        const { object } = await this._client.send('DOM.resolveNode', {
            backendNodeId: backendNodeId,
            executionContextId: this._contextId,
        });
        return JSHandle_js_1.createJSHandle(this, object);
    }
    /**
     * @internal
     */
    async _adoptElementHandle(elementHandle) {
        assert_js_1.assert(elementHandle.executionContext() !== this, 'Cannot adopt handle that already belongs to this execution context');
        assert_js_1.assert(this._world, 'Cannot adopt handle without DOMWorld');
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: elementHandle._remoteObject.objectId,
        });
        return this._adoptBackendNodeId(nodeInfo.node.backendNodeId);
    }
}
exports.ExecutionContext = ExecutionContext;


/***/ }),

/***/ 3225:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChooser = void 0;
const assert_js_1 = __nccwpck_require__(4337);
/**
 * File choosers let you react to the page requesting for a file.
 * @remarks
 * `FileChooser` objects are returned via the `page.waitForFileChooser` method.
 * @example
 * An example of using `FileChooser`:
 * ```js
 * const [fileChooser] = await Promise.all([
 *   page.waitForFileChooser(),
 *   page.click('#upload-file-button'), // some button that triggers file selection
 * ]);
 * await fileChooser.accept(['/tmp/myfile.pdf']);
 * ```
 * **NOTE** In browsers, only one file chooser can be opened at a time.
 * All file choosers must be accepted or canceled. Not doing so will prevent
 * subsequent file choosers from appearing.
 */
class FileChooser {
    /**
     * @internal
     */
    constructor(element, event) {
        this._handled = false;
        this._element = element;
        this._multiple = event.mode !== 'selectSingle';
    }
    /**
     * Whether file chooser allow for {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple} file selection.
     */
    isMultiple() {
        return this._multiple;
    }
    /**
     * Accept the file chooser request with given paths.
     * @param filePaths - If some of the  `filePaths` are relative paths,
     * then they are resolved relative to the {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
     */
    async accept(filePaths) {
        assert_js_1.assert(!this._handled, 'Cannot accept FileChooser which is already handled!');
        this._handled = true;
        await this._element.uploadFile(...filePaths);
    }
    /**
     * Closes the file chooser without selecting any files.
     */
    async cancel() {
        assert_js_1.assert(!this._handled, 'Cannot cancel FileChooser which is already handled!');
        this._handled = true;
    }
}
exports.FileChooser = FileChooser;


/***/ }),

/***/ 1125:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Frame = exports.FrameManager = exports.FrameManagerEmittedEvents = void 0;
const Debug_js_1 = __nccwpck_require__(7259);
const EventEmitter_js_1 = __nccwpck_require__(241);
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const ExecutionContext_js_1 = __nccwpck_require__(6069);
const LifecycleWatcher_js_1 = __nccwpck_require__(1714);
const DOMWorld_js_1 = __nccwpck_require__(923);
const NetworkManager_js_1 = __nccwpck_require__(8560);
const UTILITY_WORLD_NAME = '__puppeteer_utility_world__';
/**
 * We use symbols to prevent external parties listening to these events.
 * They are internal to Puppeteer.
 *
 * @internal
 */
exports.FrameManagerEmittedEvents = {
    FrameAttached: Symbol('FrameManager.FrameAttached'),
    FrameNavigated: Symbol('FrameManager.FrameNavigated'),
    FrameDetached: Symbol('FrameManager.FrameDetached'),
    LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),
    FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),
    ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),
    ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed'),
};
/**
 * @internal
 */
class FrameManager extends EventEmitter_js_1.EventEmitter {
    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
        super();
        this._frames = new Map();
        this._contextIdToContext = new Map();
        this._isolatedWorlds = new Set();
        this._client = client;
        this._page = page;
        this._networkManager = new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this);
        this._timeoutSettings = timeoutSettings;
        this._client.on('Page.frameAttached', (event) => this._onFrameAttached(event.frameId, event.parentFrameId));
        this._client.on('Page.frameNavigated', (event) => this._onFrameNavigated(event.frame));
        this._client.on('Page.navigatedWithinDocument', (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url));
        this._client.on('Page.frameDetached', (event) => this._onFrameDetached(event.frameId));
        this._client.on('Page.frameStoppedLoading', (event) => this._onFrameStoppedLoading(event.frameId));
        this._client.on('Runtime.executionContextCreated', (event) => this._onExecutionContextCreated(event.context));
        this._client.on('Runtime.executionContextDestroyed', (event) => this._onExecutionContextDestroyed(event.executionContextId));
        this._client.on('Runtime.executionContextsCleared', () => this._onExecutionContextsCleared());
        this._client.on('Page.lifecycleEvent', (event) => this._onLifecycleEvent(event));
        this._client.on('Target.attachedToTarget', async (event) => this._onFrameMoved(event));
    }
    async initialize() {
        const result = await Promise.all([
            this._client.send('Page.enable'),
            this._client.send('Page.getFrameTree'),
        ]);
        const { frameTree } = result[1];
        this._handleFrameTree(frameTree);
        await Promise.all([
            this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
            this._client
                .send('Runtime.enable')
                .then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),
            this._networkManager.initialize(),
        ]);
    }
    networkManager() {
        return this._networkManager;
    }
    async navigateFrame(frame, url, options = {}) {
        assertNoLegacyNavigationOptions(options);
        const { referer = this._networkManager.extraHTTPHeaders()['referer'], waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;
        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);
        let ensureNewDocumentNavigation = false;
        let error = await Promise.race([
            navigate(this._client, url, referer, frame._id),
            watcher.timeoutOrTerminationPromise(),
        ]);
        if (!error) {
            error = await Promise.race([
                watcher.timeoutOrTerminationPromise(),
                ensureNewDocumentNavigation
                    ? watcher.newDocumentNavigationPromise()
                    : watcher.sameDocumentNavigationPromise(),
            ]);
        }
        watcher.dispose();
        if (error)
            throw error;
        return watcher.navigationResponse();
        async function navigate(client, url, referrer, frameId) {
            try {
                const response = await client.send('Page.navigate', {
                    url,
                    referrer,
                    frameId,
                });
                ensureNewDocumentNavigation = !!response.loaderId;
                return response.errorText
                    ? new Error(`${response.errorText} at ${url}`)
                    : null;
            }
            catch (error) {
                return error;
            }
        }
    }
    async waitForFrameNavigation(frame, options = {}) {
        assertNoLegacyNavigationOptions(options);
        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;
        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);
        const error = await Promise.race([
            watcher.timeoutOrTerminationPromise(),
            watcher.sameDocumentNavigationPromise(),
            watcher.newDocumentNavigationPromise(),
        ]);
        watcher.dispose();
        if (error)
            throw error;
        return watcher.navigationResponse();
    }
    async _onFrameMoved(event) {
        if (event.targetInfo.type !== 'iframe') {
            return;
        }
        // TODO(sadym): Remove debug message once proper OOPIF support is
        // implemented: https://github.com/puppeteer/puppeteer/issues/2548
        Debug_js_1.debug('puppeteer:frame')(`The frame '${event.targetInfo.targetId}' moved to another session. ` +
            `Out-of-process iframes (OOPIF) are not supported by Puppeteer yet. ` +
            `https://github.com/puppeteer/puppeteer/issues/2548`);
    }
    _onLifecycleEvent(event) {
        const frame = this._frames.get(event.frameId);
        if (!frame)
            return;
        frame._onLifecycleEvent(event.loaderId, event.name);
        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);
    }
    _onFrameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._onLoadingStopped();
        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);
    }
    _handleFrameTree(frameTree) {
        if (frameTree.frame.parentId)
            this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);
        this._onFrameNavigated(frameTree.frame);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    page() {
        return this._page;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        return Array.from(this._frames.values());
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    _onFrameAttached(frameId, parentFrameId) {
        if (this._frames.has(frameId))
            return;
        assert_js_1.assert(parentFrameId);
        const parentFrame = this._frames.get(parentFrameId);
        const frame = new Frame(this, parentFrame, frameId);
        this._frames.set(frame._id, frame);
        this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);
    }
    _onFrameNavigated(framePayload) {
        const isMainFrame = !framePayload.parentId;
        let frame = isMainFrame
            ? this._mainFrame
            : this._frames.get(framePayload.id);
        assert_js_1.assert(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame');
        // Detach all child frames first.
        if (frame) {
            for (const child of frame.childFrames())
                this._removeFramesRecursively(child);
        }
        // Update or create main frame.
        if (isMainFrame) {
            if (frame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(frame._id);
                frame._id = framePayload.id;
            }
            else {
                // Initial main frame navigation.
                frame = new Frame(this, null, framePayload.id);
            }
            this._frames.set(framePayload.id, frame);
            this._mainFrame = frame;
        }
        // Update frame payload.
        frame._navigated(framePayload);
        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);
    }
    async _ensureIsolatedWorld(name) {
        if (this._isolatedWorlds.has(name))
            return;
        this._isolatedWorlds.add(name);
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,
            worldName: name,
        }),
            await Promise.all(this.frames().map((frame) => this._client
                .send('Page.createIsolatedWorld', {
                frameId: frame._id,
                grantUniveralAccess: true,
                worldName: name,
            })
                .catch(helper_js_1.debugError))); // frames might be removed before we send this
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._navigatedWithinDocument(url);
        this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);
        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);
    }
    _onFrameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    _onExecutionContextCreated(contextPayload) {
        const auxData = contextPayload.auxData;
        const frameId = auxData ? auxData.frameId : null;
        const frame = this._frames.get(frameId) || null;
        let world = null;
        if (frame) {
            if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {
                world = frame._mainWorld;
            }
            else if (contextPayload.name === UTILITY_WORLD_NAME &&
                !frame._secondaryWorld._hasContext()) {
                // In case of multiple sessions to the same target, there's a race between
                // connections so we might end up creating multiple isolated worlds.
                // We can use either.
                world = frame._secondaryWorld;
            }
        }
        if (contextPayload.auxData && contextPayload.auxData['type'] === 'isolated')
            this._isolatedWorlds.add(contextPayload.name);
        const context = new ExecutionContext_js_1.ExecutionContext(this._client, contextPayload, world);
        if (world)
            world._setContext(context);
        this._contextIdToContext.set(contextPayload.id, context);
    }
    _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        if (context._world)
            context._world._setContext(null);
    }
    _onExecutionContextsCleared() {
        for (const context of this._contextIdToContext.values()) {
            if (context._world)
                context._world._setContext(null);
        }
        this._contextIdToContext.clear();
    }
    executionContextById(contextId) {
        const context = this._contextIdToContext.get(contextId);
        assert_js_1.assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);
        return context;
    }
    _removeFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        frame._detach();
        this._frames.delete(frame._id);
        this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);
    }
}
exports.FrameManager = FrameManager;
/**
 * At every point of time, page exposes its current frame tree via the
 * {@link Page.mainFrame | page.mainFrame} and
 * {@link Frame.childFrames | frame.childFrames} methods.
 *
 * @remarks
 *
 * `Frame` object lifecycles are controlled by three events that are all
 * dispatched on the page object:
 *
 * - {@link PageEmittedEvents.FrameAttached}
 *
 * - {@link PageEmittedEvents.FrameNavigated}
 *
 * - {@link PageEmittedEvents.FrameDetached}
 *
 * @Example
 * An example of dumping frame tree:
 *
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://www.google.com/chrome/browser/canary.html');
 *   dumpFrameTree(page.mainFrame(), '');
 *   await browser.close();
 *
 *   function dumpFrameTree(frame, indent) {
 *     console.log(indent + frame.url());
 *     for (const child of frame.childFrames()) {
 *     dumpFrameTree(child, indent + '  ');
 *     }
 *   }
 * })();
 * ```
 *
 * @Example
 * An example of getting text from an iframe element:
 *
 * ```js
 * const frame = page.frames().find(frame => frame.name() === 'myframe');
 * const text = await frame.$eval('.selector', element => element.textContent);
 * console.log(text);
 * ```
 *
 * @public
 */
class Frame {
    /**
     * @internal
     */
    constructor(frameManager, parentFrame, frameId) {
        this._url = '';
        this._detached = false;
        /**
         * @internal
         */
        this._loaderId = '';
        /**
         * @internal
         */
        this._lifecycleEvents = new Set();
        this._frameManager = frameManager;
        this._parentFrame = parentFrame;
        this._url = '';
        this._id = frameId;
        this._detached = false;
        this._loaderId = '';
        this._mainWorld = new DOMWorld_js_1.DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._secondaryWorld = new DOMWorld_js_1.DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._childFrames = new Set();
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    /**
     * @remarks
     *
     * `frame.goto` will throw an error if:
     * - there's an SSL error (e.g. in case of self-signed certificates).
     *
     * - target URL is invalid.
     *
     * - the `timeout` is exceeded during navigation.
     *
     * - the remote server does not respond or is unreachable.
     *
     * - the main resource failed to load.
     *
     * `frame.goto` will not throw an error when any valid HTTP status code is
     * returned by the remote server, including 404 "Not Found" and 500 "Internal
     * Server Error".  The status code for such responses can be retrieved by
     * calling {@link HTTPResponse.status}.
     *
     * NOTE: `frame.goto` either throws an error or returns a main resource
     * response. The only exceptions are navigation to `about:blank` or
     * navigation to the same URL with a different hash, which would succeed and
     * return `null`.
     *
     * NOTE: Headless mode doesn't support navigation to a PDF document. See
     * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
     * issue}.
     *
     * @param url - the URL to navigate the frame to. This should include the
     * scheme, e.g. `https://`.
     * @param options - navigation options. `waitUntil` is useful to define when
     * the navigation should be considered successful - see the docs for
     * {@link PuppeteerLifeCycleEvent} for more details.
     *
     * @returns A promise which resolves to the main resource response. In case of
     * multiple redirects, the navigation will resolve with the response of the
     * last redirect.
     */
    async goto(url, options = {}) {
        return await this._frameManager.navigateFrame(this, url, options);
    }
    /**
     * @remarks
     *
     * This resolves when the frame navigates to a new URL. It is useful for when
     * you run code which will indirectly cause the frame to navigate. Consider
     * this example:
     *
     * ```js
     * const [response] = await Promise.all([
     *   // The navigation promise resolves after navigation has finished
     *   frame.waitForNavigation(),
     *   // Clicking the link will indirectly cause a navigation
     *   frame.click('a.my-link'),
     * ]);
     * ```
     *
     * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.
     *
     * @param options - options to configure when the navigation is consided finished.
     * @returns a promise that resolves when the frame navigates to a new URL.
     */
    async waitForNavigation(options = {}) {
        return await this._frameManager.waitForFrameNavigation(this, options);
    }
    /**
     * @returns a promise that resolves to the frame's default execution context.
     */
    executionContext() {
        return this._mainWorld.executionContext();
    }
    /**
     * @remarks
     *
     * The only difference between {@link Frame.evaluate} and
     * `frame.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * This method behaves identically to {@link Page.evaluateHandle} except it's
     * run within the context of the `frame`, rather than the entire page.
     *
     * @param pageFunction - a function that is run within the frame
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args) {
        return this._mainWorld.evaluateHandle(pageFunction, ...args);
    }
    /**
     * @remarks
     *
     * This method behaves identically to {@link Page.evaluate} except it's run
     * within the context of the `frame`, rather than the entire page.
     *
     * @param pageFunction - a function that is run within the frame
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluate(pageFunction, ...args) {
        return this._mainWorld.evaluate(pageFunction, ...args);
    }
    /**
     * This method queries the frame for the given selector.
     *
     * @param selector - a selector to query for.
     * @returns A promise which resolves to an `ElementHandle` pointing at the
     * element, or `null` if it was not found.
     */
    async $(selector) {
        return this._mainWorld.$(selector);
    }
    /**
     * This method evaluates the given XPath expression and returns the results.
     *
     * @param expression - the XPath expression to evaluate.
     */
    async $x(expression) {
        return this._mainWorld.$x(expression);
    }
    /**
     * @remarks
     *
     * This method runs `document.querySelector` within
     * the frame and passes it as the first argument to `pageFunction`.
     *
     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for
     * the promise to resolve and return its value.
     *
     * @example
     *
     * ```js
     * const searchValue = await frame.$eval('#search', el => el.value);
     * ```
     *
     * @param selector - the selector to query for
     * @param pageFunction - the function to be evaluated in the frame's context
     * @param args - additional arguments to pass to `pageFuncton`
     */
    async $eval(selector, pageFunction, ...args) {
        return this._mainWorld.$eval(selector, pageFunction, ...args);
    }
    /**
     * @remarks
     *
     * This method runs `Array.from(document.querySelectorAll(selector))` within
     * the frame and passes it as the first argument to `pageFunction`.
     *
     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for
     * the promise to resolve and return its value.
     *
     * @example
     *
     * ```js
     * const divsCounts = await frame.$$eval('div', divs => divs.length);
     * ```
     *
     * @param selector - the selector to query for
     * @param pageFunction - the function to be evaluated in the frame's context
     * @param args - additional arguments to pass to `pageFuncton`
     */
    async $$eval(selector, pageFunction, ...args) {
        return this._mainWorld.$$eval(selector, pageFunction, ...args);
    }
    /**
     * This runs `document.querySelectorAll` in the frame and returns the result.
     *
     * @param selector - a selector to search for
     * @returns An array of element handles pointing to the found frame elements.
     */
    async $$(selector) {
        return this._mainWorld.$$(selector);
    }
    /**
     * @returns the full HTML contents of the frame, including the doctype.
     */
    async content() {
        return this._secondaryWorld.content();
    }
    /**
     * Set the content of the frame.
     *
     * @param html - HTML markup to assign to the page.
     * @param options - options to configure how long before timing out and at
     * what point to consider the content setting successful.
     */
    async setContent(html, options = {}) {
        return this._secondaryWorld.setContent(html, options);
    }
    /**
     * @remarks
     *
     * If the name is empty, it returns the `id` attribute instead.
     *
     * Note: This value is calculated once when the frame is created, and will not
     * update if the attribute is changed later.
     *
     * @returns the frame's `name` attribute as specified in the tag.
     */
    name() {
        return this._name || '';
    }
    /**
     * @returns the frame's URL.
     */
    url() {
        return this._url;
    }
    /**
     * @returns the parent `Frame`, if any. Detached and main frames return `null`.
     */
    parentFrame() {
        return this._parentFrame;
    }
    /**
     * @returns an array of child frames.
     */
    childFrames() {
        return Array.from(this._childFrames);
    }
    /**
     * @returns `true` if the frame has been detached, or `false` otherwise.
     */
    isDetached() {
        return this._detached;
    }
    /**
     * Adds a `<script>` tag into the page with the desired url or content.
     *
     * @param options - configure the script to add to the page.
     *
     * @returns a promise that resolves to the added tag when the script's
     * `onload` event fires or when the script content was injected into the
     * frame.
     */
    async addScriptTag(options) {
        return this._mainWorld.addScriptTag(options);
    }
    /**
     * Adds a `<link rel="stylesheet">` tag into the page with the desired url or
     * a `<style type="text/css">` tag with the content.
     *
     * @param options - configure the CSS to add to the page.
     *
     * @returns a promise that resolves to the added tag when the stylesheets's
     * `onload` event fires or when the CSS content was injected into the
     * frame.
     */
    async addStyleTag(options) {
        return this._mainWorld.addStyleTag(options);
    }
    /**
     *
     * This method clicks the first element found that matches `selector`.
     *
     * @remarks
     *
     * This method scrolls the element into view if needed, and then uses
     * {@link Page.mouse} to click in the center of the element. If there's no
     * element matching `selector`, the method throws an error.
     *
     * Bear in mind that if `click()` triggers a navigation event and there's a
     * separate `page.waitForNavigation()` promise to be resolved, you may end up
     * with a race condition that yields unexpected results. The correct pattern
     * for click and wait for navigation is the following:
     *
     * ```javascript
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   frame.click(selector, clickOptions),
     * ]);
     * ```
     * @param selector - the selector to search for to click. If there are
     * multiple elements, the first will be clicked.
     */
    async click(selector, options = {}) {
        return this._secondaryWorld.click(selector, options);
    }
    /**
     * This method fetches an element with `selector` and focuses it.
     *
     * @remarks
     * If there's no element matching `selector`, the method throws an error.
     *
     * @param selector - the selector for the element to focus. If there are
     * multiple elements, the first will be focused.
     */
    async focus(selector) {
        return this._secondaryWorld.focus(selector);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse} to hover over the center of the
     * element.
     *
     * @remarks
     * If there's no element matching `selector`, the method throws an
     *
     * @param selector - the selector for the element to hover. If there are
     * multiple elements, the first will be hovered.
     */
    async hover(selector) {
        return this._secondaryWorld.hover(selector);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have
     * been selected.
     *
     * @remarks
     *
     * If there's no `<select>` element matching `selector`, the
     * method throws an error.
     *
     * @example
     * ```js
     * frame.select('select#colors', 'blue'); // single selection
     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - a selector to query the frame for
     * @param values - an array of values to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     * @returns the list of values that were successfully selected.
     */
    select(selector, ...values) {
        return this._secondaryWorld.select(selector, ...values);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.touchscreen} to tap in the center of the
     * element.
     *
     * @remarks
     *
     * If there's no element matching `selector`, the method throws an error.
     *
     * @param selector - the selector to tap.
     * @returns a promise that resolves when the element has been tapped.
     */
    async tap(selector) {
        return this._secondaryWorld.tap(selector);
    }
    /**
     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
     * in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`, use
     * {@link Keyboard.press}.
     *
     * @example
     * ```js
     * await frame.type('#mytextarea', 'Hello'); // Types instantly
     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param selector - the selector for the element to type into. If there are
     * multiple the first will be used.
     * @param text - text to type into the element
     * @param options - takes one option, `delay`, which sets the time to wait
     * between key presses in milliseconds. Defaults to `0`.
     *
     * @returns a promise that resolves when the typing is complete.
     */
    async type(selector, text, options) {
        return this._mainWorld.type(selector, text, options);
    }
    /**
     * @remarks
     *
     * This method behaves differently depending on the first parameter. If it's a
     * `string`, it will be treated as a `selector` or `xpath` (if the string
     * starts with `//`). This method then is a shortcut for
     * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.
     *
     * If the first argument is a function this method is a shortcut for
     * {@link Frame.waitForFunction}.
     *
     * If the first argument is a `number`, it's treated as a timeout in
     * milliseconds and the method returns a promise which resolves after the
     * timeout.
     *
     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to
     * wait for.
     * @param options - optional waiting parameters.
     * @param args - arguments to pass to `pageFunction`.
     *
     * @deprecated Don't use this method directly. Instead use the more explicit
     * methods available: {@link Frame.waitForSelector},
     * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or
     * {@link Frame.waitForTimeout}.
     */
    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        const xPathPattern = '//';
        console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');
        if (helper_js_1.helper.isString(selectorOrFunctionOrTimeout)) {
            const string = selectorOrFunctionOrTimeout;
            if (string.startsWith(xPathPattern))
                return this.waitForXPath(string, options);
            return this.waitForSelector(string, options);
        }
        if (helper_js_1.helper.isNumber(selectorOrFunctionOrTimeout))
            return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));
        if (typeof selectorOrFunctionOrTimeout === 'function')
            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);
        return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));
    }
    /**
     * Causes your script to wait for the given number of milliseconds.
     *
     * @remarks
     * It's generally recommended to not wait for a number of seconds, but instead
     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
     *
     * @example
     *
     * Wait for 1 second:
     *
     * ```
     * await frame.waitForTimeout(1000);
     * ```
     *
     * @param milliseconds - the number of milliseconds to wait.
     */
    waitForTimeout(milliseconds) {
        return new Promise((resolve) => {
            setTimeout(resolve, milliseconds);
        });
    }
    /**
     * @remarks
     *
     *
     * Wait for the `selector` to appear in page. If at the moment of calling the
     * method the `selector` already exists, the method will return immediately.
     * If the selector doesn't appear after the `timeout` milliseconds of waiting,
     * the function will throw.
     *
     * This method works across navigations.
     *
     * @example
     * ```js
     * const puppeteer = require('puppeteer');
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page.mainFrame()
     *   .waitForSelector('img')
     *   .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     * @param selector - the selector to wait for.
     * @param options - options to define if the element should be visible and how
     * long to wait before timing out.
     * @returns a promise which resolves when an element matching the selector
     * string is added to the DOM.
     */
    async waitForSelector(selector, options = {}) {
        const handle = await this._secondaryWorld.waitForSelector(selector, options);
        if (!handle)
            return null;
        const mainExecutionContext = await this._mainWorld.executionContext();
        const result = await mainExecutionContext._adoptElementHandle(handle);
        await handle.dispose();
        return result;
    }
    /**
     * @remarks
     * Wait for the `xpath` to appear in page. If at the moment of calling the
     * method the `xpath` already exists, the method will return immediately. If
     * the xpath doesn't appear after the `timeout` milliseconds of waiting, the
     * function will throw.
     *
     * For a code example, see the example for {@link Frame.waitForSelector}. That
     * function behaves identically other than taking a CSS selector rather than
     * an XPath.
     *
     * @param xpath - the XPath expression to wait for.
     * @param options  - options to configure the visiblity of the element and how
     * long to wait before timing out.
     */
    async waitForXPath(xpath, options = {}) {
        const handle = await this._secondaryWorld.waitForXPath(xpath, options);
        if (!handle)
            return null;
        const mainExecutionContext = await this._mainWorld.executionContext();
        const result = await mainExecutionContext._adoptElementHandle(handle);
        await handle.dispose();
        return result;
    }
    /**
     * @remarks
     *
     * @example
     *
     * The `waitForFunction` can be used to observe viewport size change:
     * ```js
     * const puppeteer = require('puppeteer');
     *
     * (async () => {
     * .  const browser = await puppeteer.launch();
     * .  const page = await browser.newPage();
     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
     * .  page.setViewport({width: 50, height: 50});
     * .  await watchDog;
     * .  await browser.close();
     * })();
     * ```
     *
     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
     *
     * ```js
     * const selector = '.foo';
     * await frame.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {}, // empty options object
     *   selector
     *);
     * ```
     *
     * @param pageFunction - the function to evaluate in the frame context.
     * @param options - options to configure the polling method and timeout.
     * @param args - arguments to pass to the `pageFunction`.
     * @returns the promise which resolve when the `pageFunction` returns a truthy value.
     */
    waitForFunction(pageFunction, options = {}, ...args) {
        return this._mainWorld.waitForFunction(pageFunction, options, ...args);
    }
    /**
     * @returns the frame's title.
     */
    async title() {
        return this._secondaryWorld.title();
    }
    /**
     * @internal
     */
    _navigated(framePayload) {
        this._name = framePayload.name;
        this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;
    }
    /**
     * @internal
     */
    _navigatedWithinDocument(url) {
        this._url = url;
    }
    /**
     * @internal
     */
    _onLifecycleEvent(loaderId, name) {
        if (name === 'init') {
            this._loaderId = loaderId;
            this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
    }
    /**
     * @internal
     */
    _onLoadingStopped() {
        this._lifecycleEvents.add('DOMContentLoaded');
        this._lifecycleEvents.add('load');
    }
    /**
     * @internal
     */
    _detach() {
        this._detached = true;
        this._mainWorld._detach();
        this._secondaryWorld._detach();
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
}
exports.Frame = Frame;
function assertNoLegacyNavigationOptions(options) {
    assert_js_1.assert(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');
    assert_js_1.assert(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');
    assert_js_1.assert(options.waitUntil !== 'networkidle', 'ERROR: "networkidle" option is no longer supported. Use "networkidle2" instead');
}


/***/ }),

/***/ 1437:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPRequest = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
/**
 *
 * Represents an HTTP request sent by a page.
 * @remarks
 *
 * Whenever the page sends a request, such as for a network resource, the
 * following events are emitted by Puppeteer's `page`:
 *
 * - `request`:  emitted when the request is issued by the page.
 * - `requestfinished` - emitted when the response body is downloaded and the
 *   request is complete.
 *
 * If request fails at some point, then instead of `requestfinished` event the
 * `requestfailed` event is emitted.
 *
 * All of these events provide an instance of `HTTPRequest` representing the
 * request that occurred:
 *
 * ```
 * page.on('request', request => ...)
 * ```
 *
 * NOTE: HTTP Error responses, such as 404 or 503, are still successful
 * responses from HTTP standpoint, so request will complete with
 * `requestfinished` event.
 *
 * If request gets a 'redirect' response, the request is successfully finished
 * with the `requestfinished` event, and a new request is issued to a
 * redirected url.
 *
 * @public
 */
class HTTPRequest {
    /**
     * @internal
     */
    constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
        /**
         * @internal
         */
        this._failureText = null;
        /**
         * @internal
         */
        this._response = null;
        /**
         * @internal
         */
        this._fromMemoryCache = false;
        this._interceptionHandled = false;
        this._headers = {};
        this._client = client;
        this._requestId = event.requestId;
        this._isNavigationRequest =
            event.requestId === event.loaderId && event.type === 'Document';
        this._interceptionId = interceptionId;
        this._allowInterception = allowInterception;
        this._url = event.request.url;
        this._resourceType = event.type.toLowerCase();
        this._method = event.request.method;
        this._postData = event.request.postData;
        this._frame = frame;
        this._redirectChain = redirectChain;
        for (const key of Object.keys(event.request.headers))
            this._headers[key.toLowerCase()] = event.request.headers[key];
    }
    /**
     * @returns the URL of the request
     */
    url() {
        return this._url;
    }
    /**
     * Contains the request's resource type as it was perceived by the rendering
     * engine.
     * @remarks
     * @returns one of the following: `document`, `stylesheet`, `image`, `media`,
     * `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`,
     * `manifest`, `other`.
     */
    resourceType() {
        // TODO (@jackfranklin): protocol.d.ts has a type for this, but all the
        // string values are uppercase. The Puppeteer docs explicitly say the
        // potential values are all lower case, and the constructor takes the event
        // type and calls toLowerCase() on it, so we can't reuse the type from the
        // protocol.d.ts. Why do we lower case?
        return this._resourceType;
    }
    /**
     * @returns the method used (`GET`, `POST`, etc.)
     */
    method() {
        return this._method;
    }
    /**
     * @returns the request's post body, if any.
     */
    postData() {
        return this._postData;
    }
    /**
     * @returns an object with HTTP headers associated with the request. All
     * header names are lower-case.
     */
    headers() {
        return this._headers;
    }
    /**
     * @returns the response for this request, if a response has been received.
     */
    response() {
        return this._response;
    }
    /**
     * @returns the frame that initiated the request.
     */
    frame() {
        return this._frame;
    }
    /**
     * @returns true if the request is the driver of the current frame's navigation.
     */
    isNavigationRequest() {
        return this._isNavigationRequest;
    }
    /**
     * @remarks
     *
     * `redirectChain` is shared between all the requests of the same chain.
     *
     * For example, if the website `http://example.com` has a single redirect to
     * `https://example.com`, then the chain will contain one request:
     *
     * ```js
     * const response = await page.goto('http://example.com');
     * const chain = response.request().redirectChain();
     * console.log(chain.length); // 1
     * console.log(chain[0].url()); // 'http://example.com'
     * ```
     *
     * If the website `https://google.com` has no redirects, then the chain will be empty:
     *
     * ```js
     * const response = await page.goto('https://google.com');
     * const chain = response.request().redirectChain();
     * console.log(chain.length); // 0
     * ```
     *
     * @returns the chain of requests - if a server responds with at least a
     * single redirect, this chain will contain all requests that were redirected.
     */
    redirectChain() {
        return this._redirectChain.slice();
    }
    /**
     * Access information about the request's failure.
     *
     * @remarks
     *
     * @example
     *
     * Example of logging all failed requests:
     *
     * ```js
     * page.on('requestfailed', request => {
     *   console.log(request.url() + ' ' + request.failure().errorText);
     * });
     * ```
     *
     * @returns `null` unless the request failed. If the request fails this can
     * return an object with `errorText` containing a human-readable error
     * message, e.g. `net::ERR_FAILED`. It is not guaranteeded that there will be
     * failure text if the request fails.
     */
    failure() {
        if (!this._failureText)
            return null;
        return {
            errorText: this._failureText,
        };
    }
    /**
     * Continues request with optional request overrides.
     *
     * @remarks
     *
     * To use this, request
     * interception should be enabled with {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     *
     * @example
     * ```js
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   // Override headers
     *   const headers = Object.assign({}, request.headers(), {
     *     foo: 'bar', // set "foo" header
     *     origin: undefined, // remove "origin" header
     *   });
     *   request.continue({headers});
     * });
     * ```
     *
     * @param overrides - optional overrides to apply to the request.
     */
    async continue(overrides = {}) {
        // Request interception is not supported for data: urls.
        if (this._url.startsWith('data:'))
            return;
        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');
        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');
        const { url, method, postData, headers } = overrides;
        this._interceptionHandled = true;
        const postDataBinaryBase64 = postData
            ? Buffer.from(postData).toString('base64')
            : undefined;
        await this._client
            .send('Fetch.continueRequest', {
            requestId: this._interceptionId,
            url,
            method,
            postData: postDataBinaryBase64,
            headers: headers ? headersArray(headers) : undefined,
        })
            .catch((error) => {
            // In certain cases, protocol will return error if the request was
            // already canceled or the page was closed. We should tolerate these
            // errors.
            helper_js_1.debugError(error);
        });
    }
    /**
     * Fulfills a request with the given response.
     *
     * @remarks
     *
     * To use this, request
     * interception should be enabled with {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     *
     * @example
     * An example of fulfilling all requests with 404 responses:
     * ```js
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   request.respond({
     *     status: 404,
     *     contentType: 'text/plain',
     *     body: 'Not Found!'
     *   });
     * });
     * ```
     *
     * NOTE: Mocking responses for dataURL requests is not supported.
     * Calling `request.respond` for a dataURL request is a noop.
     *
     * @param response - the response to fulfill the request with.
     */
    async respond(response) {
        // Mocking responses for dataURL requests is not currently supported.
        if (this._url.startsWith('data:'))
            return;
        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');
        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');
        this._interceptionHandled = true;
        const responseBody = response.body && helper_js_1.helper.isString(response.body)
            ? Buffer.from(response.body)
            : response.body || null;
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers))
                responseHeaders[header.toLowerCase()] = response.headers[header];
        }
        if (response.contentType)
            responseHeaders['content-type'] = response.contentType;
        if (responseBody && !('content-length' in responseHeaders))
            responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));
        await this._client
            .send('Fetch.fulfillRequest', {
            requestId: this._interceptionId,
            responseCode: response.status || 200,
            responsePhrase: STATUS_TEXTS[response.status || 200],
            responseHeaders: headersArray(responseHeaders),
            body: responseBody ? responseBody.toString('base64') : undefined,
        })
            .catch((error) => {
            // In certain cases, protocol will return error if the request was
            // already canceled or the page was closed. We should tolerate these
            // errors.
            helper_js_1.debugError(error);
        });
    }
    /**
     * Aborts a request.
     *
     * @remarks
     * To use this, request interception should be enabled with
     * {@link Page.setRequestInterception}. If it is not enabled, this method will
     * throw an exception immediately.
     *
     * @param errorCode - optional error code to provide.
     */
    async abort(errorCode = 'failed') {
        // Request interception is not supported for data: urls.
        if (this._url.startsWith('data:'))
            return;
        const errorReason = errorReasons[errorCode];
        assert_js_1.assert(errorReason, 'Unknown error code: ' + errorCode);
        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');
        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');
        this._interceptionHandled = true;
        await this._client
            .send('Fetch.failRequest', {
            requestId: this._interceptionId,
            errorReason,
        })
            .catch((error) => {
            // In certain cases, protocol will return error if the request was
            // already canceled or the page was closed. We should tolerate these
            // errors.
            helper_js_1.debugError(error);
        });
    }
}
exports.HTTPRequest = HTTPRequest;
const errorReasons = {
    aborted: 'Aborted',
    accessdenied: 'AccessDenied',
    addressunreachable: 'AddressUnreachable',
    blockedbyclient: 'BlockedByClient',
    blockedbyresponse: 'BlockedByResponse',
    connectionaborted: 'ConnectionAborted',
    connectionclosed: 'ConnectionClosed',
    connectionfailed: 'ConnectionFailed',
    connectionrefused: 'ConnectionRefused',
    connectionreset: 'ConnectionReset',
    internetdisconnected: 'InternetDisconnected',
    namenotresolved: 'NameNotResolved',
    timedout: 'TimedOut',
    failed: 'Failed',
};
function headersArray(headers) {
    const result = [];
    for (const name in headers) {
        if (!Object.is(headers[name], undefined))
            result.push({ name, value: headers[name] + '' });
    }
    return result;
}
// List taken from
// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
// with extra 306 and 418 codes.
const STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': "I'm a teapot",
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};


/***/ }),

/***/ 1281:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPResponse = void 0;
const SecurityDetails_js_1 = __nccwpck_require__(1822);
/**
 * The HTTPResponse class represents responses which are received by the
 * {@link Page} class.
 *
 * @public
 */
class HTTPResponse {
    /**
     * @internal
     */
    constructor(client, request, responsePayload) {
        this._contentPromise = null;
        this._headers = {};
        this._client = client;
        this._request = request;
        this._bodyLoadedPromise = new Promise((fulfill) => {
            this._bodyLoadedPromiseFulfill = fulfill;
        });
        this._remoteAddress = {
            ip: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort,
        };
        this._status = responsePayload.status;
        this._statusText = responsePayload.statusText;
        this._url = request.url();
        this._fromDiskCache = !!responsePayload.fromDiskCache;
        this._fromServiceWorker = !!responsePayload.fromServiceWorker;
        for (const key of Object.keys(responsePayload.headers))
            this._headers[key.toLowerCase()] = responsePayload.headers[key];
        this._securityDetails = responsePayload.securityDetails
            ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails)
            : null;
    }
    /**
     * @internal
     */
    _resolveBody(err) {
        return this._bodyLoadedPromiseFulfill(err);
    }
    /**
     * @returns The IP address and port number used to connect to the remote
     * server.
     */
    remoteAddress() {
        return this._remoteAddress;
    }
    /**
     * @returns The URL of the response.
     */
    url() {
        return this._url;
    }
    /**
     * @returns True if the response was successful (status in the range 200-299).
     */
    ok() {
        // TODO: document === 0 case?
        return this._status === 0 || (this._status >= 200 && this._status <= 299);
    }
    /**
     * @returns The status code of the response (e.g., 200 for a success).
     */
    status() {
        return this._status;
    }
    /**
     * @returns  The status text of the response (e.g. usually an "OK" for a
     * success).
     */
    statusText() {
        return this._statusText;
    }
    /**
     * @returns An object with HTTP headers associated with the response. All
     * header names are lower-case.
     */
    headers() {
        return this._headers;
    }
    /**
     * @returns {@link SecurityDetails} if the response was received over the
     * secure connection, or `null` otherwise.
     */
    securityDetails() {
        return this._securityDetails;
    }
    /**
     * @returns Promise which resolves to a buffer with response body.
     */
    buffer() {
        if (!this._contentPromise) {
            this._contentPromise = this._bodyLoadedPromise.then(async (error) => {
                if (error)
                    throw error;
                const response = await this._client.send('Network.getResponseBody', {
                    requestId: this._request._requestId,
                });
                return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
            });
        }
        return this._contentPromise;
    }
    /**
     * @returns Promise which resolves to a text representation of response body.
     */
    async text() {
        const content = await this.buffer();
        return content.toString('utf8');
    }
    /**
     *
     * @returns Promise which resolves to a JSON representation of response body.
     *
     * @remarks
     *
     * This method will throw if the response body is not parsable via
     * `JSON.parse`.
     */
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    /**
     * @returns A matching {@link HTTPRequest} object.
     */
    request() {
        return this._request;
    }
    /**
     * @returns True if the response was served from either the browser's disk
     * cache or memory cache.
     */
    fromCache() {
        return this._fromDiskCache || this._request._fromMemoryCache;
    }
    /**
     * @returns True if the response was served by a service worker.
     */
    fromServiceWorker() {
        return this._fromServiceWorker;
    }
    /**
     * @returns A {@link Frame} that initiated this response, or `null` if
     * navigating to error pages.
     */
    frame() {
        return this._request.frame();
    }
}
exports.HTTPResponse = HTTPResponse;


/***/ }),

/***/ 1361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const USKeyboardLayout_js_1 = __nccwpck_require__(7651);
/**
 * Keyboard provides an api for managing a virtual keyboard.
 * The high level api is {@link Keyboard."type"},
 * which takes raw characters and generates proper keydown, keypress/input,
 * and keyup events on your page.
 *
 * @remarks
 * For finer control, you can use {@link Keyboard.down},
 * {@link Keyboard.up}, and {@link Keyboard.sendCharacter}
 * to manually fire events as if they were generated from a real keyboard.
 *
 * On MacOS, keyboard shortcuts like `⌘ A` -\> Select All do not work.
 * See {@link https://github.com/puppeteer/puppeteer/issues/1313 | #1313}.
 *
 * @example
 * An example of holding down `Shift` in order to select and delete some text:
 * ```js
 * await page.keyboard.type('Hello World!');
 * await page.keyboard.press('ArrowLeft');
 *
 * await page.keyboard.down('Shift');
 * for (let i = 0; i < ' World'.length; i++)
 *   await page.keyboard.press('ArrowLeft');
 * await page.keyboard.up('Shift');
 *
 * await page.keyboard.press('Backspace');
 * // Result text will end up saying 'Hello!'
 * ```
 *
 * @example
 * An example of pressing `A`
 * ```js
 * await page.keyboard.down('Shift');
 * await page.keyboard.press('KeyA');
 * await page.keyboard.up('Shift');
 * ```
 *
 * @public
 */
class Keyboard {
    /** @internal */
    constructor(client) {
        /** @internal */
        this._modifiers = 0;
        this._pressedKeys = new Set();
        this._client = client;
    }
    /**
     * Dispatches a `keydown` event.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also generated.
     * The `text` option can be specified to force an input event to be generated.
     * If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`,
     * subsequent key presses will be sent with that modifier active.
     * To release the modifier key, use {@link Keyboard.up}.
     *
     * After the key is pressed once, subsequent calls to
     * {@link Keyboard.down} will have
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat | repeat}
     * set to true. To release the key, use {@link Keyboard.up}.
     *
     * Modifier keys DO influence {@link Keyboard.down}.
     * Holding down `Shift` will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     *
     * @param options - An object of options. Accepts text which, if specified,
     * generates an input event with this text.
     */
    async down(key, options = { text: undefined }) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        this._modifiers |= this._modifierBit(description.key);
        const text = options.text === undefined ? description.text : options.text;
        await this._client.send('Input.dispatchKeyEvent', {
            type: text ? 'keyDown' : 'rawKeyDown',
            modifiers: this._modifiers,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            key: description.key,
            text: text,
            unmodifiedText: text,
            autoRepeat,
            location: description.location,
            isKeypad: description.location === 3,
        });
    }
    _modifierBit(key) {
        if (key === 'Alt')
            return 1;
        if (key === 'Control')
            return 2;
        if (key === 'Meta')
            return 4;
        if (key === 'Shift')
            return 8;
        return 0;
    }
    _keyDescriptionForString(keyString) {
        const shift = this._modifiers & 8;
        const description = {
            key: '',
            keyCode: 0,
            code: '',
            text: '',
            location: 0,
        };
        const definition = USKeyboardLayout_js_1.keyDefinitions[keyString];
        assert_js_1.assert(definition, `Unknown key: "${keyString}"`);
        if (definition.key)
            description.key = definition.key;
        if (shift && definition.shiftKey)
            description.key = definition.shiftKey;
        if (definition.keyCode)
            description.keyCode = definition.keyCode;
        if (shift && definition.shiftKeyCode)
            description.keyCode = definition.shiftKeyCode;
        if (definition.code)
            description.code = definition.code;
        if (definition.location)
            description.location = definition.location;
        if (description.key.length === 1)
            description.text = description.key;
        if (definition.text)
            description.text = definition.text;
        if (shift && definition.shiftText)
            description.text = definition.shiftText;
        // if any modifiers besides shift are pressed, no text should be sent
        if (this._modifiers & ~8)
            description.text = '';
        return description;
    }
    /**
     * Dispatches a `keyup` event.
     *
     * @param key - Name of key to release, such as `ArrowLeft`.
     * See {@link KeyInput | KeyInput}
     * for a list of all key names.
     */
    async up(key) {
        const description = this._keyDescriptionForString(key);
        this._modifiers &= ~this._modifierBit(description.key);
        this._pressedKeys.delete(description.code);
        await this._client.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: this._modifiers,
            key: description.key,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            location: description.location,
        });
    }
    /**
     * Dispatches a `keypress` and `input` event.
     * This does not send a `keydown` or `keyup` event.
     *
     * @remarks
     * Modifier keys DO NOT effect {@link Keyboard.sendCharacter | Keyboard.sendCharacter}.
     * Holding down `Shift` will not type the text in upper case.
     *
     * @example
     * ```js
     * page.keyboard.sendCharacter('嗨');
     * ```
     *
     * @param char - Character to send into the page.
     */
    async sendCharacter(char) {
        await this._client.send('Input.insertText', { text: char });
    }
    charIsKey(char) {
        return !!USKeyboardLayout_js_1.keyDefinitions[char];
    }
    /**
     * Sends a `keydown`, `keypress`/`input`,
     * and `keyup` event for each character in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link Keyboard.press}.
     *
     * Modifier keys DO NOT effect `keyboard.type`.
     * Holding down `Shift` will not type the text in upper case.
     *
     * @example
     * ```js
     * await page.keyboard.type('Hello'); // Types instantly
     * await page.keyboard.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param text - A text to type into a focused element.
     * @param options - An object of options. Accepts delay which,
     * if specified, is the time to wait between `keydown` and `keyup` in milliseconds.
     * Defaults to 0.
     */
    async type(text, options = {}) {
        const delay = options.delay || null;
        for (const char of text) {
            if (this.charIsKey(char)) {
                await this.press(char, { delay });
            }
            else {
                if (delay)
                    await new Promise((f) => setTimeout(f, delay));
                await this.sendCharacter(char);
            }
        }
    }
    /**
     * Shortcut for {@link Keyboard.down}
     * and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * Modifier keys DO effect {@link Keyboard.press}.
     * Holding down `Shift` will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     *
     * @param options - An object of options. Accepts text which, if specified,
     * generates an input event with this text. Accepts delay which,
     * if specified, is the time to wait between `keydown` and `keyup` in milliseconds.
     * Defaults to 0.
     */
    async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay)
            await new Promise((f) => setTimeout(f, options.delay));
        await this.up(key);
    }
}
exports.Keyboard = Keyboard;
/**
 * The Mouse class operates in main-frame CSS pixels
 * relative to the top-left corner of the viewport.
 * @remarks
 * Every `page` object has its own Mouse, accessible with [`page.mouse`](#pagemouse).
 *
 * @example
 * ```js
 * // Using ‘page.mouse’ to trace a 100x100 square.
 * await page.mouse.move(0, 0);
 * await page.mouse.down();
 * await page.mouse.move(0, 100);
 * await page.mouse.move(100, 100);
 * await page.mouse.move(100, 0);
 * await page.mouse.move(0, 0);
 * await page.mouse.up();
 * ```
 *
 * **Note**: The mouse events trigger synthetic `MouseEvent`s.
 * This means that it does not fully replicate the functionality of what a normal user
 * would be able to do with their mouse.
 *
 * For example, dragging and selecting text is not possible using `page.mouse`.
 * Instead, you can use the {@link https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/getSelection | `DocumentOrShadowRoot.getSelection()`} functionality implemented in the platform.
 *
 * @example
 * For example, if you want to select all content between nodes:
 * ```js
 * await page.evaluate((from, to) => {
 *   const selection = from.getRootNode().getSelection();
 *   const range = document.createRange();
 *   range.setStartBefore(from);
 *   range.setEndAfter(to);
 *   selection.removeAllRanges();
 *   selection.addRange(range);
 * }, fromJSHandle, toJSHandle);
 * ```
 * If you then would want to copy-paste your selection, you can use the clipboard api:
 * ```js
 * // The clipboard api does not allow you to copy, unless the tab is focused.
 * await page.bringToFront();
 * await page.evaluate(() => {
 *   // Copy the selected content to the clipboard
 *   document.execCommand('copy');
 *   // Obtain the content of the clipboard as a string
 *   return navigator.clipboard.readText();
 * });
 * ```
 * **Note**: If you want access to the clipboard API,
 * you have to give it permission to do so:
 * ```js
 * await browser.defaultBrowserContext().overridePermissions(
 *   '<your origin>', ['clipboard-read', 'clipboard-write']
 * );
 * ```
 * @public
 */
class Mouse {
    /**
     * @internal
     */
    constructor(client, keyboard) {
        this._x = 0;
        this._y = 0;
        this._button = 'none';
        this._client = client;
        this._keyboard = keyboard;
    }
    /**
     * Dispatches a `mousemove` event.
     * @param x - Horizontal position of the mouse.
     * @param y - Vertical position of the mouse.
     * @param options - Optional object. If specified, the `steps` property
     * sends intermediate `mousemove` events when set to `1` (default).
     */
    async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const fromX = this._x, fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
            await this._client.send('Input.dispatchMouseEvent', {
                type: 'mouseMoved',
                button: this._button,
                x: fromX + (this._x - fromX) * (i / steps),
                y: fromY + (this._y - fromY) * (i / steps),
                modifiers: this._keyboard._modifiers,
            });
        }
    }
    /**
     * Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.
     * @param x - Horizontal position of the mouse.
     * @param y - Vertical position of the mouse.
     * @param options - Optional `MouseOptions`.
     */
    async click(x, y, options = {}) {
        const { delay = null } = options;
        if (delay !== null) {
            await Promise.all([this.move(x, y), this.down(options)]);
            await new Promise((f) => setTimeout(f, delay));
            await this.up(options);
        }
        else {
            await Promise.all([
                this.move(x, y),
                this.down(options),
                this.up(options),
            ]);
        }
    }
    /**
     * Dispatches a `mousedown` event.
     * @param options - Optional `MouseOptions`.
     */
    async down(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._button = button;
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mousePressed',
            button,
            x: this._x,
            y: this._y,
            modifiers: this._keyboard._modifiers,
            clickCount,
        });
    }
    /**
     * Dispatches a `mouseup` event.
     * @param options - Optional `MouseOptions`.
     */
    async up(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._button = 'none';
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseReleased',
            button,
            x: this._x,
            y: this._y,
            modifiers: this._keyboard._modifiers,
            clickCount,
        });
    }
    /**
     * Dispatches a `mousewheel` event.
     * @param options - Optional: `MouseWheelOptions`.
     *
     * @example
     * An example of zooming into an element:
     * ```js
     * await page.goto('https://mdn.mozillademos.org/en-US/docs/Web/API/Element/wheel_event$samples/Scaling_an_element_via_the_wheel?revision=1587366');
     *
     * const elem = await page.$('div');
     * const boundingBox = await elem.boundingBox();
     * await page.mouse.move(
     *   boundingBox.x + boundingBox.width / 2,
     *   boundingBox.y + boundingBox.height / 2
     * );
     *
     * await page.mouse.wheel({ deltaY: -100 })
     * ```
     */
    async wheel(options = {}) {
        const { deltaX = 0, deltaY = 0 } = options;
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseWheel',
            x: this._x,
            y: this._y,
            deltaX,
            deltaY,
            modifiers: this._keyboard._modifiers,
            pointerType: 'mouse',
        });
    }
}
exports.Mouse = Mouse;
/**
 * The Touchscreen class exposes touchscreen events.
 * @public
 */
class Touchscreen {
    /**
     * @internal
     */
    constructor(client, keyboard) {
        this._client = client;
        this._keyboard = keyboard;
    }
    /**
     * Dispatches a `touchstart` and `touchend` event.
     * @param x - Horizontal position of the tap.
     * @param y - Vertical position of the tap.
     */
    async tap(x, y) {
        const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
        await this._client.send('Input.dispatchTouchEvent', {
            type: 'touchStart',
            touchPoints,
            modifiers: this._keyboard._modifiers,
        });
        await this._client.send('Input.dispatchTouchEvent', {
            type: 'touchEnd',
            touchPoints: [],
            modifiers: this._keyboard._modifiers,
        });
    }
}
exports.Touchscreen = Touchscreen;


/***/ }),

/***/ 859:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElementHandle = exports.JSHandle = exports.createJSHandle = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const QueryHandler_js_1 = __nccwpck_require__(7157);
const environment_js_1 = __nccwpck_require__(4765);
/**
 * @internal
 */
function createJSHandle(context, remoteObject) {
    const frame = context.frame();
    if (remoteObject.subtype === 'node' && frame) {
        const frameManager = frame._frameManager;
        return new ElementHandle(context, context._client, remoteObject, frameManager.page(), frameManager);
    }
    return new JSHandle(context, context._client, remoteObject);
}
exports.createJSHandle = createJSHandle;
/**
 * Represents an in-page JavaScript object. JSHandles can be created with the
 * {@link Page.evaluateHandle | page.evaluateHandle} method.
 *
 * @example
 * ```js
 * const windowHandle = await page.evaluateHandle(() => window);
 * ```
 *
 * JSHandle prevents the referenced JavaScript object from being garbage-collected
 * unless the handle is {@link JSHandle.dispose | disposed}. JSHandles are auto-
 * disposed when their origin frame gets navigated or the parent context gets destroyed.
 *
 * JSHandle instances can be used as arguments for {@link Page.$eval},
 * {@link Page.evaluate}, and {@link Page.evaluateHandle}.
 *
 * @public
 */
class JSHandle {
    /**
     * @internal
     */
    constructor(context, client, remoteObject) {
        /**
         * @internal
         */
        this._disposed = false;
        this._context = context;
        this._client = client;
        this._remoteObject = remoteObject;
    }
    /** Returns the execution context the handle belongs to.
     */
    executionContext() {
        return this._context;
    }
    /**
     * This method passes this handle as the first argument to `pageFunction`.
     * If `pageFunction` returns a Promise, then `handle.evaluate` would wait
     * for the promise to resolve and return its value.
     *
     * @example
     * ```js
     * const tweetHandle = await page.$('.tweet .retweets');
     * expect(await tweetHandle.evaluate(node => node.innerText)).toBe('10');
     * ```
     */
    async evaluate(pageFunction, ...args) {
        return await this.executionContext().evaluate(pageFunction, this, ...args);
    }
    /**
     * This method passes this handle as the first argument to `pageFunction`.
     *
     * @remarks
     *
     * The only difference between `jsHandle.evaluate` and
     * `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle`
     * returns an in-page object (JSHandle).
     *
     * If the function passed to `jsHandle.evaluateHandle` returns a Promise,
     * then `evaluateHandle.evaluateHandle` waits for the promise to resolve and
     * returns its value.
     *
     * See {@link Page.evaluateHandle} for more details.
     */
    async evaluateHandle(pageFunction, ...args) {
        return await this.executionContext().evaluateHandle(pageFunction, this, ...args);
    }
    /** Fetches a single property from the referenced object.
     */
    async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName) => {
            const result = { __proto__: null };
            result[propertyName] = object[propertyName];
            return result;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName) || null;
        await objectHandle.dispose();
        return result;
    }
    /**
     * The method returns a map with property names as keys and JSHandle
     * instances for the property values.
     *
     * @example
     * ```js
     * const listHandle = await page.evaluateHandle(() => document.body.children);
     * const properties = await listHandle.getProperties();
     * const children = [];
     * for (const property of properties.values()) {
     *   const element = property.asElement();
     *   if (element)
     *     children.push(element);
     * }
     * children; // holds elementHandles to all children of document.body
     * ```
     */
    async getProperties() {
        const response = await this._client.send('Runtime.getProperties', {
            objectId: this._remoteObject.objectId,
            ownProperties: true,
        });
        const result = new Map();
        for (const property of response.result) {
            if (!property.enumerable)
                continue;
            result.set(property.name, createJSHandle(this._context, property.value));
        }
        return result;
    }
    /**
     * Returns a JSON representation of the object.
     *
     * @remarks
     *
     * The JSON is generated by running {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify | JSON.stringify}
     * on the object in page and consequent {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse | JSON.parse} in puppeteer.
     * **NOTE** The method throws if the referenced object is not stringifiable.
     */
    async jsonValue() {
        if (this._remoteObject.objectId) {
            const response = await this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: 'function() { return this; }',
                objectId: this._remoteObject.objectId,
                returnByValue: true,
                awaitPromise: true,
            });
            return helper_js_1.helper.valueFromRemoteObject(response.result);
        }
        return helper_js_1.helper.valueFromRemoteObject(this._remoteObject);
    }
    /**
     * Returns either `null` or the object handle itself, if the object handle is
     * an instance of {@link ElementHandle}.
     */
    asElement() {
        // This always returns null, but subclasses can override this and return an
        // ElementHandle.
        return null;
    }
    /**
     * Stops referencing the element handle, and resolves when the object handle is
     * successfully disposed of.
     */
    async dispose() {
        if (this._disposed)
            return;
        this._disposed = true;
        await helper_js_1.helper.releaseObject(this._client, this._remoteObject);
    }
    /**
     * Returns a string representation of the JSHandle.
     *
     * @remarks Useful during debugging.
     */
    toString() {
        if (this._remoteObject.objectId) {
            const type = this._remoteObject.subtype || this._remoteObject.type;
            return 'JSHandle@' + type;
        }
        return 'JSHandle:' + helper_js_1.helper.valueFromRemoteObject(this._remoteObject);
    }
}
exports.JSHandle = JSHandle;
/**
 * ElementHandle represents an in-page DOM element.
 *
 * @remarks
 *
 * ElementHandles can be created with the {@link Page.$} method.
 *
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *  const browser = await puppeteer.launch();
 *  const page = await browser.newPage();
 *  await page.goto('https://example.com');
 *  const hrefElement = await page.$('a');
 *  await hrefElement.click();
 *  // ...
 * })();
 * ```
 *
 * ElementHandle prevents the DOM element from being garbage-collected unless the
 * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed
 * when their origin frame gets navigated.
 *
 * ElementHandle instances can be used as arguments in {@link Page.$eval} and
 * {@link Page.evaluate} methods.
 *
 * If you're using TypeScript, ElementHandle takes a generic argument that
 * denotes the type of element the handle is holding within. For example, if you
 * have a handle to a `<select>` element, you can type it as
 * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.
 *
 * @public
 */
class ElementHandle extends JSHandle {
    /**
     * @internal
     */
    constructor(context, client, remoteObject, page, frameManager) {
        super(context, client, remoteObject);
        this._client = client;
        this._remoteObject = remoteObject;
        this._page = page;
        this._frameManager = frameManager;
    }
    asElement() {
        return this;
    }
    /**
     * Resolves to the content frame for element handles referencing
     * iframe nodes, or null otherwise
     */
    async contentFrame() {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: this._remoteObject.objectId,
        });
        if (typeof nodeInfo.node.frameId !== 'string')
            return null;
        return this._frameManager.frame(nodeInfo.node.frameId);
    }
    async _scrollIntoViewIfNeeded() {
        const error = await this.evaluate(async (element, pageJavascriptEnabled) => {
            if (!element.isConnected)
                return 'Node is detached from document';
            if (element.nodeType !== Node.ELEMENT_NODE)
                return 'Node is not of type HTMLElement';
            // force-scroll if page's javascript is disabled.
            if (!pageJavascriptEnabled) {
                element.scrollIntoView({
                    block: 'center',
                    inline: 'center',
                    // @ts-expect-error Chrome still supports behavior: instant but
                    // it's not in the spec so TS shouts We don't want to make this
                    // breaking change in Puppeteer yet so we'll ignore the line.
                    behavior: 'instant',
                });
                return false;
            }
            const visibleRatio = await new Promise((resolve) => {
                const observer = new IntersectionObserver((entries) => {
                    resolve(entries[0].intersectionRatio);
                    observer.disconnect();
                });
                observer.observe(element);
            });
            if (visibleRatio !== 1.0) {
                element.scrollIntoView({
                    block: 'center',
                    inline: 'center',
                    // @ts-expect-error Chrome still supports behavior: instant but
                    // it's not in the spec so TS shouts We don't want to make this
                    // breaking change in Puppeteer yet so we'll ignore the line.
                    behavior: 'instant',
                });
            }
            return false;
        }, this._page.isJavaScriptEnabled());
        if (error)
            throw new Error(error);
    }
    async _clickablePoint() {
        const [result, layoutMetrics] = await Promise.all([
            this._client
                .send('DOM.getContentQuads', {
                objectId: this._remoteObject.objectId,
            })
                .catch(helper_js_1.debugError),
            this._client.send('Page.getLayoutMetrics'),
        ]);
        if (!result || !result.quads.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        // Filter out quads that have too small area to click into.
        const { clientWidth, clientHeight } = layoutMetrics.layoutViewport;
        const quads = result.quads
            .map((quad) => this._fromProtocolQuad(quad))
            .map((quad) => this._intersectQuadWithViewport(quad, clientWidth, clientHeight))
            .filter((quad) => computeQuadArea(quad) > 1);
        if (!quads.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        // Return the middle point of the first quad.
        const quad = quads[0];
        let x = 0;
        let y = 0;
        for (const point of quad) {
            x += point.x;
            y += point.y;
        }
        return {
            x: x / 4,
            y: y / 4,
        };
    }
    _getBoxModel() {
        const params = {
            objectId: this._remoteObject.objectId,
        };
        return this._client
            .send('DOM.getBoxModel', params)
            .catch((error) => helper_js_1.debugError(error));
    }
    _fromProtocolQuad(quad) {
        return [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] },
        ];
    }
    _intersectQuadWithViewport(quad, width, height) {
        return quad.map((point) => ({
            x: Math.min(Math.max(point.x, 0), width),
            y: Math.min(Math.max(point.y, 0), height),
        }));
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to hover over the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async hover() {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.mouse.move(x, y);
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to click in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async click(options = {}) {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.mouse.click(x, y, options);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     * ```js
     * handle.select('blue'); // single selection
     * handle.select('red', 'green', 'blue'); // multiple selections
     * ```
     * @param values - Values of options to select. If the `<select>` has the
     *    `multiple` attribute, all values are considered, otherwise only the first
     *    one is taken into account.
     */
    async select(...values) {
        for (const value of values)
            assert_js_1.assert(helper_js_1.helper.isString(value), 'Values must be strings. Found value "' +
                value +
                '" of type "' +
                typeof value +
                '"');
        return this.evaluate((element, values) => {
            if (element.nodeName.toLowerCase() !== 'select')
                throw new Error('Element is not a <select> element.');
            const options = Array.from(element.options);
            element.value = undefined;
            for (const option of options) {
                option.selected = values.includes(option.value);
                if (option.selected && !element.multiple)
                    break;
            }
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            return options
                .filter((option) => option.selected)
                .map((option) => option.value);
        }, values);
    }
    /**
     * This method expects `elementHandle` to point to an
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}.
     * @param filePaths - Sets the value of the file input to these paths.
     *    If some of the  `filePaths` are relative paths, then they are resolved
     *    relative to the {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}
     */
    async uploadFile(...filePaths) {
        const isMultiple = await this.evaluate((element) => element.multiple);
        assert_js_1.assert(filePaths.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');
        if (!environment_js_1.isNode) {
            throw new Error(`JSHandle#uploadFile can only be used in Node environments.`);
        }
        // This import is only needed for `uploadFile`, so keep it scoped here to avoid paying
        // the cost unnecessarily.
        const path = await Promise.resolve().then(() => __importStar(__nccwpck_require__(5622)));
        const fs = await helper_js_1.helper.importFSModule();
        // Locate all files and confirm that they exist.
        const files = await Promise.all(filePaths.map(async (filePath) => {
            const resolvedPath = path.resolve(filePath);
            try {
                await fs.promises.access(resolvedPath, fs.constants.R_OK);
            }
            catch (error) {
                if (error.code === 'ENOENT')
                    throw new Error(`${filePath} does not exist or is not readable`);
            }
            return resolvedPath;
        }));
        const { objectId } = this._remoteObject;
        const { node } = await this._client.send('DOM.describeNode', { objectId });
        const { backendNodeId } = node;
        // The zero-length array is a special case, it seems that DOM.setFileInputFiles does
        // not actually update the files in that case, so the solution is to eval the element
        // value to a new FileList directly.
        if (files.length === 0) {
            await this.evaluate((element) => {
                element.files = new DataTransfer().files;
                // Dispatch events for this case because it should behave akin to a user action.
                element.dispatchEvent(new Event('input', { bubbles: true }));
                element.dispatchEvent(new Event('change', { bubbles: true }));
            });
        }
        else {
            await this._client.send('DOM.setFileInputFiles', {
                objectId,
                files,
                backendNodeId,
            });
        }
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Touchscreen.tap} to tap in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async tap() {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.touchscreen.tap(x, y);
    }
    /**
     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
     */
    async focus() {
        await this.evaluate((element) => element.focus());
    }
    /**
     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
     * `keyup` event for each character in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link ElementHandle.press}.
     *
     * @example
     * ```js
     * await elementHandle.type('Hello'); // Types instantly
     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @example
     * An example of typing into a text field and then submitting the form:
     *
     * ```js
     * const elementHandle = await page.$('input');
     * await elementHandle.type('some text');
     * await elementHandle.press('Enter');
     * ```
     */
    async type(text, options) {
        await this.focus();
        await this._page.keyboard.type(text, options);
    }
    /**
     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also be generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
     * will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     *    See {@link KeyInput} for a list of all key names.
     */
    async press(key, options) {
        await this.focus();
        await this._page.keyboard.press(key, options);
    }
    /**
     * This method returns the bounding box of the element (relative to the main frame),
     * or `null` if the element is not visible.
     */
    async boundingBox() {
        const result = await this._getBoxModel();
        if (!result)
            return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        return { x, y, width, height };
    }
    /**
     * This method returns boxes of the element, or `null` if the element is not visible.
     *
     * @remarks
     *
     * Boxes are represented as an array of points;
     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
     */
    async boxModel() {
        const result = await this._getBoxModel();
        if (!result)
            return null;
        const { content, padding, border, margin, width, height } = result.model;
        return {
            content: this._fromProtocolQuad(content),
            padding: this._fromProtocolQuad(padding),
            border: this._fromProtocolQuad(border),
            margin: this._fromProtocolQuad(margin),
            width,
            height,
        };
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Page.screenshot} to take a screenshot of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async screenshot(options = {}) {
        let needsViewportReset = false;
        let boundingBox = await this.boundingBox();
        assert_js_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');
        const viewport = this._page.viewport();
        if (viewport &&
            (boundingBox.width > viewport.width ||
                boundingBox.height > viewport.height)) {
            const newViewport = {
                width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
                height: Math.max(viewport.height, Math.ceil(boundingBox.height)),
            };
            await this._page.setViewport(Object.assign({}, viewport, newViewport));
            needsViewportReset = true;
        }
        await this._scrollIntoViewIfNeeded();
        boundingBox = await this.boundingBox();
        assert_js_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');
        assert_js_1.assert(boundingBox.width !== 0, 'Node has 0 width.');
        assert_js_1.assert(boundingBox.height !== 0, 'Node has 0 height.');
        const { layoutViewport: { pageX, pageY }, } = await this._client.send('Page.getLayoutMetrics');
        const clip = Object.assign({}, boundingBox);
        clip.x += pageX;
        clip.y += pageY;
        const imageData = await this._page.screenshot(Object.assign({}, {
            clip,
        }, options));
        if (needsViewportReset)
            await this._page.setViewport(viewport);
        return imageData;
    }
    /**
     * Runs `element.querySelector` within the page. If no element matches the selector,
     * the return value resolves to `null`.
     */
    async $(selector) {
        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);
        return queryHandler.queryOne(this, updatedSelector);
    }
    /**
     * Runs `element.querySelectorAll` within the page. If no elements match the selector,
     * the return value resolves to `[]`.
     */
    async $$(selector) {
        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);
        return queryHandler.queryAll(this, updatedSelector);
    }
    /**
     * This method runs `document.querySelector` within the element and passes it as
     * the first argument to `pageFunction`. If there's no element matching `selector`,
     * the method throws an error.
     *
     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise
     * to resolve and return its value.
     *
     * @example
     * ```js
     * const tweetHandle = await page.$('.tweet');
     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');
     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');
     * ```
     */
    async $eval(selector, pageFunction, ...args) {
        const elementHandle = await this.$(selector);
        if (!elementHandle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await elementHandle.evaluate(pageFunction, ...args);
        await elementHandle.dispose();
        /**
         * This `as` is a little unfortunate but helps TS understand the behavior of
         * `elementHandle.evaluate`. If evaluate returns an element it will return an
         * ElementHandle instance, rather than the plain object. All the
         * WrapElementHandle type does is wrap ReturnType into
         * ElementHandle<ReturnType> if it is an ElementHandle, or leave it alone as
         * ReturnType if it isn't.
         */
        return result;
    }
    /**
     * This method runs `document.querySelectorAll` within the element and passes it as
     * the first argument to `pageFunction`. If there's no element matching `selector`,
     * the method throws an error.
     *
     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the
     * promise to resolve and return its value.
     *
     * @example
     * ```html
     * <div class="feed">
     *   <div class="tweet">Hello!</div>
     *   <div class="tweet">Hi!</div>
     * </div>
     * ```
     *
     * @example
     * ```js
     * const feedHandle = await page.$('.feed');
     * expect(await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)))
     *  .toEqual(['Hello!', 'Hi!']);
     * ```
     */
    async $$eval(selector, pageFunction, ...args) {
        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);
        const arrayHandle = await queryHandler.queryAllArray(this, updatedSelector);
        const result = await arrayHandle.evaluate(pageFunction, ...args);
        await arrayHandle.dispose();
        /* This `as` exists for the same reason as the `as` in $eval above.
         * See the comment there for a full explanation.
         */
        return result;
    }
    /**
     * The method evaluates the XPath expression relative to the elementHandle.
     * If there are no such elements, the method will resolve to an empty array.
     * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}
     */
    async $x(expression) {
        const arrayHandle = await this.evaluateHandle((element, expression) => {
            const document = element.ownerDocument || element;
            const iterator = document.evaluate(expression, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
            const array = [];
            let item;
            while ((item = iterator.iterateNext()))
                array.push(item);
            return array;
        }, expression);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(elementHandle);
        }
        return result;
    }
    /**
     * Resolves to true if the element is visible in the current viewport.
     */
    async isIntersectingViewport() {
        return await this.evaluate(async (element) => {
            const visibleRatio = await new Promise((resolve) => {
                const observer = new IntersectionObserver((entries) => {
                    resolve(entries[0].intersectionRatio);
                    observer.disconnect();
                });
                observer.observe(element);
            });
            return visibleRatio > 0;
        });
    }
}
exports.ElementHandle = ElementHandle;
function computeQuadArea(quad) {
    // Compute sum of all directed areas of adjacent triangles
    // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
    let area = 0;
    for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
    }
    return Math.abs(area);
}


/***/ }),

/***/ 1714:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LifecycleWatcher = void 0;
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const Errors_js_1 = __nccwpck_require__(6371);
const FrameManager_js_1 = __nccwpck_require__(1125);
const NetworkManager_js_1 = __nccwpck_require__(8560);
const Connection_js_1 = __nccwpck_require__(402);
const puppeteerToProtocolLifecycle = new Map([
    ['load', 'load'],
    ['domcontentloaded', 'DOMContentLoaded'],
    ['networkidle0', 'networkIdle'],
    ['networkidle2', 'networkAlmostIdle'],
]);
/**
 * @internal
 */
class LifecycleWatcher {
    constructor(frameManager, frame, waitUntil, timeout) {
        if (Array.isArray(waitUntil))
            waitUntil = waitUntil.slice();
        else if (typeof waitUntil === 'string')
            waitUntil = [waitUntil];
        this._expectedLifecycle = waitUntil.map((value) => {
            const protocolEvent = puppeteerToProtocolLifecycle.get(value);
            assert_js_1.assert(protocolEvent, 'Unknown value for options.waitUntil: ' + value);
            return protocolEvent;
        });
        this._frameManager = frameManager;
        this._frame = frame;
        this._initialLoaderId = frame._loaderId;
        this._timeout = timeout;
        this._navigationRequest = null;
        this._eventListeners = [
            helper_js_1.helper.addEventListener(frameManager._client, Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => this._terminate(new Error('Navigation failed because browser has disconnected!'))),
            helper_js_1.helper.addEventListener(this._frameManager, FrameManager_js_1.FrameManagerEmittedEvents.LifecycleEvent, this._checkLifecycleComplete.bind(this)),
            helper_js_1.helper.addEventListener(this._frameManager, FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, this._navigatedWithinDocument.bind(this)),
            helper_js_1.helper.addEventListener(this._frameManager, FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, this._onFrameDetached.bind(this)),
            helper_js_1.helper.addEventListener(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Request, this._onRequest.bind(this)),
        ];
        this._sameDocumentNavigationPromise = new Promise((fulfill) => {
            this._sameDocumentNavigationCompleteCallback = fulfill;
        });
        this._lifecyclePromise = new Promise((fulfill) => {
            this._lifecycleCallback = fulfill;
        });
        this._newDocumentNavigationPromise = new Promise((fulfill) => {
            this._newDocumentNavigationCompleteCallback = fulfill;
        });
        this._timeoutPromise = this._createTimeoutPromise();
        this._terminationPromise = new Promise((fulfill) => {
            this._terminationCallback = fulfill;
        });
        this._checkLifecycleComplete();
    }
    _onRequest(request) {
        if (request.frame() !== this._frame || !request.isNavigationRequest())
            return;
        this._navigationRequest = request;
    }
    _onFrameDetached(frame) {
        if (this._frame === frame) {
            this._terminationCallback.call(null, new Error('Navigating frame was detached'));
            return;
        }
        this._checkLifecycleComplete();
    }
    navigationResponse() {
        return this._navigationRequest ? this._navigationRequest.response() : null;
    }
    _terminate(error) {
        this._terminationCallback.call(null, error);
    }
    sameDocumentNavigationPromise() {
        return this._sameDocumentNavigationPromise;
    }
    newDocumentNavigationPromise() {
        return this._newDocumentNavigationPromise;
    }
    lifecyclePromise() {
        return this._lifecyclePromise;
    }
    timeoutOrTerminationPromise() {
        return Promise.race([this._timeoutPromise, this._terminationPromise]);
    }
    _createTimeoutPromise() {
        if (!this._timeout)
            return new Promise(() => { });
        const errorMessage = 'Navigation timeout of ' + this._timeout + ' ms exceeded';
        return new Promise((fulfill) => (this._maximumTimer = setTimeout(fulfill, this._timeout))).then(() => new Errors_js_1.TimeoutError(errorMessage));
    }
    _navigatedWithinDocument(frame) {
        if (frame !== this._frame)
            return;
        this._hasSameDocumentNavigation = true;
        this._checkLifecycleComplete();
    }
    _checkLifecycleComplete() {
        // We expect navigation to commit.
        if (!checkLifecycle(this._frame, this._expectedLifecycle))
            return;
        this._lifecycleCallback();
        if (this._frame._loaderId === this._initialLoaderId &&
            !this._hasSameDocumentNavigation)
            return;
        if (this._hasSameDocumentNavigation)
            this._sameDocumentNavigationCompleteCallback();
        if (this._frame._loaderId !== this._initialLoaderId)
            this._newDocumentNavigationCompleteCallback();
        /**
         * @param {!Frame} frame
         * @param {!Array<string>} expectedLifecycle
         * @returns {boolean}
         */
        function checkLifecycle(frame, expectedLifecycle) {
            for (const event of expectedLifecycle) {
                if (!frame._lifecycleEvents.has(event))
                    return false;
            }
            for (const child of frame.childFrames()) {
                if (!checkLifecycle(child, expectedLifecycle))
                    return false;
            }
            return true;
        }
    }
    dispose() {
        helper_js_1.helper.removeEventListeners(this._eventListeners);
        clearTimeout(this._maximumTimer);
    }
}
exports.LifecycleWatcher = LifecycleWatcher;


/***/ }),

/***/ 8560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EventEmitter_js_1 = __nccwpck_require__(241);
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const HTTPRequest_js_1 = __nccwpck_require__(1437);
const HTTPResponse_js_1 = __nccwpck_require__(1281);
/**
 * We use symbols to prevent any external parties listening to these events.
 * They are internal to Puppeteer.
 *
 * @internal
 */
exports.NetworkManagerEmittedEvents = {
    Request: Symbol('NetworkManager.Request'),
    Response: Symbol('NetworkManager.Response'),
    RequestFailed: Symbol('NetworkManager.RequestFailed'),
    RequestFinished: Symbol('NetworkManager.RequestFinished'),
};
/**
 * @internal
 */
class NetworkManager extends EventEmitter_js_1.EventEmitter {
    constructor(client, ignoreHTTPSErrors, frameManager) {
        super();
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._extraHTTPHeaders = {};
        this._offline = false;
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._userCacheDisabled = false;
        this._requestIdToInterceptionId = new Map();
        this._client = client;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._frameManager = frameManager;
        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));
        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));
        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));
        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));
        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));
        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));
        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));
    }
    async initialize() {
        await this._client.send('Network.enable');
        if (this._ignoreHTTPSErrors)
            await this._client.send('Security.setIgnoreCertificateErrors', {
                ignore: true,
            });
    }
    async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
    }
    async setExtraHTTPHeaders(extraHTTPHeaders) {
        this._extraHTTPHeaders = {};
        for (const key of Object.keys(extraHTTPHeaders)) {
            const value = extraHTTPHeaders[key];
            assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
            this._extraHTTPHeaders[key.toLowerCase()] = value;
        }
        await this._client.send('Network.setExtraHTTPHeaders', {
            headers: this._extraHTTPHeaders,
        });
    }
    extraHTTPHeaders() {
        return Object.assign({}, this._extraHTTPHeaders);
    }
    async setOfflineMode(value) {
        if (this._offline === value)
            return;
        this._offline = value;
        await this._client.send('Network.emulateNetworkConditions', {
            offline: this._offline,
            // values of 0 remove any active throttling. crbug.com/456324#c9
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1,
        });
    }
    async setUserAgent(userAgent) {
        await this._client.send('Network.setUserAgentOverride', { userAgent });
    }
    async setCacheEnabled(enabled) {
        this._userCacheDisabled = !enabled;
        await this._updateProtocolCacheDisabled();
    }
    async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
    }
    async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
            return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
            await Promise.all([
                this._updateProtocolCacheDisabled(),
                this._client.send('Fetch.enable', {
                    handleAuthRequests: true,
                    patterns: [{ urlPattern: '*' }],
                }),
            ]);
        }
        else {
            await Promise.all([
                this._updateProtocolCacheDisabled(),
                this._client.send('Fetch.disable'),
            ]);
        }
    }
    async _updateProtocolCacheDisabled() {
        await this._client.send('Network.setCacheDisabled', {
            cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled,
        });
    }
    _onRequestWillBeSent(event) {
        // Request interception doesn't happen for data URLs with Network Service.
        if (this._protocolRequestInterceptionEnabled &&
            !event.request.url.startsWith('data:')) {
            const requestId = event.requestId;
            const interceptionId = this._requestIdToInterceptionId.get(requestId);
            if (interceptionId) {
                this._onRequest(event, interceptionId);
                this._requestIdToInterceptionId.delete(requestId);
            }
            else {
                this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
            }
            return;
        }
        this._onRequest(event, null);
    }
    _onAuthRequired(event) {
        let response = 'Default';
        if (this._attemptedAuthentications.has(event.requestId)) {
            response = 'CancelAuth';
        }
        else if (this._credentials) {
            response = 'ProvideCredentials';
            this._attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this._credentials || {
            username: undefined,
            password: undefined,
        };
        this._client
            .send('Fetch.continueWithAuth', {
            requestId: event.requestId,
            authChallengeResponse: { response, username, password },
        })
            .catch(helper_js_1.debugError);
    }
    _onRequestPaused(event) {
        if (!this._userRequestInterceptionEnabled &&
            this._protocolRequestInterceptionEnabled) {
            this._client
                .send('Fetch.continueRequest', {
                requestId: event.requestId,
            })
                .catch(helper_js_1.debugError);
        }
        const requestId = event.networkId;
        const interceptionId = event.requestId;
        if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {
            const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
            this._onRequest(requestWillBeSentEvent, interceptionId);
            this._requestIdToRequestWillBeSentEvent.delete(requestId);
        }
        else {
            this._requestIdToInterceptionId.set(requestId, interceptionId);
        }
    }
    _onRequest(event, interceptionId) {
        let redirectChain = [];
        if (event.redirectResponse) {
            const request = this._requestIdToRequest.get(event.requestId);
            // If we connect late to the target, we could have missed the
            // requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, event.redirectResponse);
                redirectChain = request._redirectChain;
            }
        }
        const frame = event.frameId
            ? this._frameManager.frame(event.frameId)
            : null;
        const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);
        this._requestIdToRequest.set(event.requestId, request);
        this.emit(exports.NetworkManagerEmittedEvents.Request, request);
    }
    _onRequestServedFromCache(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request)
            request._fromMemoryCache = true;
    }
    _handleRequestRedirect(request, responsePayload) {
        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);
        request._response = response;
        request._redirectChain.push(request);
        response._resolveBody(new Error('Response body is unavailable for redirect responses'));
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(exports.NetworkManagerEmittedEvents.Response, response);
        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);
        request._response = response;
        this.emit(exports.NetworkManagerEmittedEvents.Response, response);
    }
    _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        if (request.response())
            request.response()._resolveBody(null);
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);
    }
    _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        request._failureText = event.errorText;
        const response = request.response();
        if (response)
            response._resolveBody(null);
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);
    }
}
exports.NetworkManager = NetworkManager;


/***/ }),

/***/ 5782:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paperFormats = void 0;
/**
 * @internal
 */
exports.paperFormats = {
    letter: { width: 8.5, height: 11 },
    legal: { width: 8.5, height: 14 },
    tabloid: { width: 11, height: 17 },
    ledger: { width: 17, height: 11 },
    a0: { width: 33.1, height: 46.8 },
    a1: { width: 23.4, height: 33.1 },
    a2: { width: 16.54, height: 23.4 },
    a3: { width: 11.7, height: 16.54 },
    a4: { width: 8.27, height: 11.7 },
    a5: { width: 5.83, height: 8.27 },
    a6: { width: 4.13, height: 5.83 },
};


/***/ }),

/***/ 6057:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Page = void 0;
const EventEmitter_js_1 = __nccwpck_require__(241);
const Connection_js_1 = __nccwpck_require__(402);
const Dialog_js_1 = __nccwpck_require__(750);
const EmulationManager_js_1 = __nccwpck_require__(5097);
const FrameManager_js_1 = __nccwpck_require__(1125);
const Input_js_1 = __nccwpck_require__(1361);
const Tracing_js_1 = __nccwpck_require__(6503);
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const Coverage_js_1 = __nccwpck_require__(8914);
const WebWorker_js_1 = __nccwpck_require__(6206);
const JSHandle_js_1 = __nccwpck_require__(859);
const NetworkManager_js_1 = __nccwpck_require__(8560);
const Accessibility_js_1 = __nccwpck_require__(6772);
const TimeoutSettings_js_1 = __nccwpck_require__(8355);
const FileChooser_js_1 = __nccwpck_require__(3225);
const ConsoleMessage_js_1 = __nccwpck_require__(7754);
const PDFOptions_js_1 = __nccwpck_require__(5782);
const environment_js_1 = __nccwpck_require__(4765);
class ScreenshotTaskQueue {
    constructor() {
        this._chain = Promise.resolve(undefined);
    }
    postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => { });
        return result;
    }
}
/**
 * Page provides methods to interact with a single tab or
 * {@link https://developer.chrome.com/extensions/background_pages | extension background page} in Chromium.
 *
 * @remarks
 *
 * One Browser instance might have multiple Page instances.
 *
 * @example
 * This example creates a page, navigates it to a URL, and then * saves a screenshot:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await page.screenshot({path: 'screenshot.png'});
 *   await browser.close();
 * })();
 * ```
 *
 * The Page class extends from Puppeteer's {@link EventEmitter} class and will
 * emit various events which are documented in the {@link PageEmittedEvents} enum.
 *
 * @example
 * This example logs a message for a single page `load` event:
 * ```js
 * page.once('load', () => console.log('Page loaded!'));
 * ```
 *
 * To unsubscribe from events use the `off` method:
 *
 * ```js
 * function logRequest(interceptedRequest) {
 *   console.log('A request was made:', interceptedRequest.url());
 * }
 * page.on('request', logRequest);
 * // Sometime later...
 * page.off('request', logRequest);
 * ```
 * @public
 */
class Page extends EventEmitter_js_1.EventEmitter {
    /**
     * @internal
     */
    constructor(client, target, ignoreHTTPSErrors) {
        super();
        this._closed = false;
        this._timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();
        this._pageBindings = new Map();
        this._javascriptEnabled = true;
        this._workers = new Map();
        // TODO: improve this typedef - it's a function that takes a file chooser or
        // something?
        this._fileChooserInterceptors = new Set();
        this._client = client;
        this._target = target;
        this._keyboard = new Input_js_1.Keyboard(client);
        this._mouse = new Input_js_1.Mouse(client, this._keyboard);
        this._touchscreen = new Input_js_1.Touchscreen(client, this._keyboard);
        this._accessibility = new Accessibility_js_1.Accessibility(client);
        this._frameManager = new FrameManager_js_1.FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
        this._emulationManager = new EmulationManager_js_1.EmulationManager(client);
        this._tracing = new Tracing_js_1.Tracing(client);
        this._coverage = new Coverage_js_1.Coverage(client);
        this._screenshotTaskQueue = new ScreenshotTaskQueue();
        this._viewport = null;
        client.on('Target.attachedToTarget', (event) => {
            if (event.targetInfo.type !== 'worker') {
                // If we don't detach from service workers, they will never die.
                client
                    .send('Target.detachFromTarget', {
                    sessionId: event.sessionId,
                })
                    .catch(helper_js_1.debugError);
                return;
            }
            const session = Connection_js_1.Connection.fromSession(client).session(event.sessionId);
            const worker = new WebWorker_js_1.WebWorker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));
            this._workers.set(event.sessionId, worker);
            this.emit("workercreated" /* WorkerCreated */, worker);
        });
        client.on('Target.detachedFromTarget', (event) => {
            const worker = this._workers.get(event.sessionId);
            if (!worker)
                return;
            this.emit("workerdestroyed" /* WorkerDestroyed */, worker);
            this._workers.delete(event.sessionId);
        });
        this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, (event) => this.emit("frameattached" /* FrameAttached */, event));
        this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, (event) => this.emit("framedetached" /* FrameDetached */, event));
        this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, (event) => this.emit("framenavigated" /* FrameNavigated */, event));
        const networkManager = this._frameManager.networkManager();
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Request, (event) => this.emit("request" /* Request */, event));
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Response, (event) => this.emit("response" /* Response */, event));
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, (event) => this.emit("requestfailed" /* RequestFailed */, event));
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished, (event) => this.emit("requestfinished" /* RequestFinished */, event));
        this._fileChooserInterceptors = new Set();
        client.on('Page.domContentEventFired', () => this.emit("domcontentloaded" /* DOMContentLoaded */));
        client.on('Page.loadEventFired', () => this.emit("load" /* Load */));
        client.on('Runtime.consoleAPICalled', (event) => this._onConsoleAPI(event));
        client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));
        client.on('Page.javascriptDialogOpening', (event) => this._onDialog(event));
        client.on('Runtime.exceptionThrown', (exception) => this._handleException(exception.exceptionDetails));
        client.on('Inspector.targetCrashed', () => this._onTargetCrashed());
        client.on('Performance.metrics', (event) => this._emitMetrics(event));
        client.on('Log.entryAdded', (event) => this._onLogEntryAdded(event));
        client.on('Page.fileChooserOpened', (event) => this._onFileChooser(event));
        this._target._isClosedPromise.then(() => {
            this.emit("close" /* Close */);
            this._closed = true;
        });
    }
    /**
     * @internal
     */
    static async create(client, target, ignoreHTTPSErrors, defaultViewport) {
        const page = new Page(client, target, ignoreHTTPSErrors);
        await page._initialize();
        if (defaultViewport)
            await page.setViewport(defaultViewport);
        return page;
    }
    async _initialize() {
        await Promise.all([
            this._frameManager.initialize(),
            this._client.send('Target.setAutoAttach', {
                autoAttach: true,
                waitForDebuggerOnStart: false,
                flatten: true,
            }),
            this._client.send('Performance.enable'),
            this._client.send('Log.enable'),
        ]);
    }
    async _onFileChooser(event) {
        if (!this._fileChooserInterceptors.size)
            return;
        const frame = this._frameManager.frame(event.frameId);
        const context = await frame.executionContext();
        const element = await context._adoptBackendNodeId(event.backendNodeId);
        const interceptors = Array.from(this._fileChooserInterceptors);
        this._fileChooserInterceptors.clear();
        const fileChooser = new FileChooser_js_1.FileChooser(element, event);
        for (const interceptor of interceptors)
            interceptor.call(null, fileChooser);
    }
    /**
     * @returns `true` if the page has JavaScript enabled, `false` otherwise.
     */
    isJavaScriptEnabled() {
        return this._javascriptEnabled;
    }
    /**
     * @param options - Optional waiting parameters
     * @returns Resolves after a page requests a file picker.
     */
    async waitForFileChooser(options = {}) {
        if (!this._fileChooserInterceptors.size)
            await this._client.send('Page.setInterceptFileChooserDialog', {
                enabled: true,
            });
        const { timeout = this._timeoutSettings.timeout() } = options;
        let callback;
        const promise = new Promise((x) => (callback = x));
        this._fileChooserInterceptors.add(callback);
        return helper_js_1.helper
            .waitWithTimeout(promise, 'waiting for file chooser', timeout)
            .catch((error) => {
            this._fileChooserInterceptors.delete(callback);
            throw error;
        });
    }
    /**
     * Sets the page's geolocation.
     *
     * @remarks
     * Consider using {@link BrowserContext.overridePermissions} to grant
     * permissions for the page to read its geolocation.
     *
     * @example
     * ```js
     * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});
     * ```
     */
    async setGeolocation(options) {
        const { longitude, latitude, accuracy = 0 } = options;
        if (longitude < -180 || longitude > 180)
            throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
        if (latitude < -90 || latitude > 90)
            throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
        if (accuracy < 0)
            throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
        await this._client.send('Emulation.setGeolocationOverride', {
            longitude,
            latitude,
            accuracy,
        });
    }
    /**
     * @returns A target this page was created from.
     */
    target() {
        return this._target;
    }
    /**
     * @returns The browser this page belongs to.
     */
    browser() {
        return this._target.browser();
    }
    /**
     * @returns The browser context that the page belongs to
     */
    browserContext() {
        return this._target.browserContext();
    }
    _onTargetCrashed() {
        this.emit('error', new Error('Page crashed!'));
    }
    _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
            args.map((arg) => helper_js_1.helper.releaseObject(this._client, arg));
        if (source !== 'worker')
            this.emit("console" /* Console */, new ConsoleMessage_js_1.ConsoleMessage(level, text, [], [{ url, lineNumber }]));
    }
    /**
     * @returns The page's main frame.
     */
    mainFrame() {
        return this._frameManager.mainFrame();
    }
    get keyboard() {
        return this._keyboard;
    }
    get touchscreen() {
        return this._touchscreen;
    }
    get coverage() {
        return this._coverage;
    }
    get tracing() {
        return this._tracing;
    }
    get accessibility() {
        return this._accessibility;
    }
    /**
     * @returns An array of all frames attached to the page.
     */
    frames() {
        return this._frameManager.frames();
    }
    /**
     * @returns all of the dedicated
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorkers}
     * associated with the page.
     */
    workers() {
        return Array.from(this._workers.values());
    }
    /**
     * @param value - Whether to enable request interception.
     *
     * @remarks
     * Activating request interception enables {@link HTTPRequest.abort},
     * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods.  This
     * provides the capability to modify network requests that are made by a page.
     *
     * Once request interception is enabled, every request will stall unless it's
     * continued, responded or aborted.
     *
     * **NOTE** Enabling request interception disables page caching.
     *
     * @example
     * An example of a naïve request interceptor that aborts all image requests:
     * ```js
     * const puppeteer = require('puppeteer');
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.setRequestInterception(true);
     *   page.on('request', interceptedRequest => {
     *     if (interceptedRequest.url().endsWith('.png') ||
     *         interceptedRequest.url().endsWith('.jpg'))
     *       interceptedRequest.abort();
     *     else
     *       interceptedRequest.continue();
     *     });
     *   await page.goto('https://example.com');
     *   await browser.close();
     * })();
     * ```
     */
    async setRequestInterception(value) {
        return this._frameManager.networkManager().setRequestInterception(value);
    }
    /**
     * @param enabled - When `true`, enables offline mode for the page.
     */
    setOfflineMode(enabled) {
        return this._frameManager.networkManager().setOfflineMode(enabled);
    }
    /**
     * @param timeout - Maximum navigation time in milliseconds.
     */
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    /**
     * @param timeout - Maximum time in milliseconds.
     */
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    /**
     * Runs `document.querySelector` within the page. If no element matches the
     * selector, the return value resolves to `null`.
     *
     * @remarks
     * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query page for.
     */
    async $(selector) {
        return this.mainFrame().$(selector);
    }
    /**
     * @remarks
     *
     * The only difference between {@link Page.evaluate | page.evaluate} and
     * `page.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * If the function passed to `page.evaluteHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     * ```
     * const aHandle = await page.evaluateHandle('document')
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
     * ```
     * const aHandle = await page.evaluateHandle(() => document.body);
     * const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);
     * console.log(await resultHandle.jsonValue());
     * await resultHandle.dispose();
     * ```
     *
     * Most of the time this function returns a {@link JSHandle},
     * but if `pageFunction` returns a reference to an element,
     * you instead get an {@link ElementHandle} back:
     *
     * @example
     * ```
     * const button = await page.evaluateHandle(() => document.querySelector('button'));
     * // can call `click` because `button` is an `ElementHandle`
     * await button.click();
     * ```
     *
     * The TypeScript definitions assume that `evaluateHandle` returns
     *  a `JSHandle`, but if you know it's going to return an
     * `ElementHandle`, pass it as the generic argument:
     *
     * ```
     * const button = await page.evaluateHandle<ElementHandle>(...);
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args) {
        const context = await this.mainFrame().executionContext();
        return context.evaluateHandle(pageFunction, ...args);
    }
    /**
     * This method iterates the JavaScript heap and finds all objects with the
     * given prototype.
     *
     * @remarks
     *
     * @example
     *
     * ```js
     * // Create a Map object
     * await page.evaluate(() => window.map = new Map());
     * // Get a handle to the Map object prototype
     * const mapPrototype = await page.evaluateHandle(() => Map.prototype);
     * // Query all map instances into an array
     * const mapInstances = await page.queryObjects(mapPrototype);
     * // Count amount of map objects in heap
     * const count = await page.evaluate(maps => maps.length, mapInstances);
     * await mapInstances.dispose();
     * await mapPrototype.dispose();
     * ```
     * @param prototypeHandle - a handle to the object prototype.
     */
    async queryObjects(prototypeHandle) {
        const context = await this.mainFrame().executionContext();
        return context.queryObjects(prototypeHandle);
    }
    /**
     * This method runs `document.querySelector` within the page and passes the
     * result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If no element is found matching `selector`, the method will throw an error.
     *
     * If `pageFunction` returns a promise `$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```
     * const searchValue = await page.$eval('#search', el => el.value);
     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
     * const html = await page.$eval('.main-container', el => el.outerHTML);
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * const searchValue = await page.$eval('#search', (el: HTMLInputElement) => el.value);
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$eval`:
     *
     * @example
     *
     * ```
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const searchValue = await page.$eval<string>(
     *  '#search', (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of `document.querySelector(selector)` as its
     * first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $eval(selector, pageFunction, ...args) {
        return this.mainFrame().$eval(selector, pageFunction, ...args);
    }
    /**
     * This method runs `Array.from(document.querySelectorAll(selector))` within
     * the page and passes the result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```
     * // get the amount of divs on the page
     * const divCount = await page.$$eval('div', divs => divs.length);
     *
     * // get the text content of all the `.options` elements:
     * const options = await page.$$eval('div > span.options', options => {
     *   return options.map(option => option.textContent)
     * });
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element[]`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * await page.$$eval('input', (elements: HTMLInputElement[]) => {
     *   return elements.map(e => e.value);
     * });
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$$eval`:
     *
     * @example
     *
     * ```
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const allInputValues = await page.$$eval<string[]>(
     *  'input', (elements: HTMLInputElement[]) => elements.map(e => e.textContent)
     * );
     * ```
     *
     * @param selector the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction the function to be evaluated in the page context. Will
     * be passed the result of `Array.from(document.querySelectorAll(selector))`
     * as its first argument.
     * @param args any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $$eval(selector, pageFunction, ...args) {
        return this.mainFrame().$$eval(selector, pageFunction, ...args);
    }
    async $$(selector) {
        return this.mainFrame().$$(selector);
    }
    async $x(expression) {
        return this.mainFrame().$x(expression);
    }
    /**
     * If no URLs are specified, this method returns cookies for the current page
     * URL. If URLs are specified, only cookies for those URLs are returned.
     */
    async cookies(...urls) {
        const originalCookies = (await this._client.send('Network.getCookies', {
            urls: urls.length ? urls : [this.url()],
        })).cookies;
        const unsupportedCookieAttributes = ['priority'];
        const filterUnsupportedAttributes = (cookie) => {
            for (const attr of unsupportedCookieAttributes)
                delete cookie[attr];
            return cookie;
        };
        return originalCookies.map(filterUnsupportedAttributes);
    }
    async deleteCookie(...cookies) {
        const pageURL = this.url();
        for (const cookie of cookies) {
            const item = Object.assign({}, cookie);
            if (!cookie.url && pageURL.startsWith('http'))
                item.url = pageURL;
            await this._client.send('Network.deleteCookies', item);
        }
    }
    async setCookie(...cookies) {
        const pageURL = this.url();
        const startsWithHTTP = pageURL.startsWith('http');
        const items = cookies.map((cookie) => {
            const item = Object.assign({}, cookie);
            if (!item.url && startsWithHTTP)
                item.url = pageURL;
            assert_js_1.assert(item.url !== 'about:blank', `Blank page can not have cookie "${item.name}"`);
            assert_js_1.assert(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie "${item.name}"`);
            return item;
        });
        await this.deleteCookie(...items);
        if (items.length)
            await this._client.send('Network.setCookies', { cookies: items });
    }
    async addScriptTag(options) {
        return this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
        return this.mainFrame().addStyleTag(options);
    }
    async exposeFunction(name, puppeteerFunction) {
        if (this._pageBindings.has(name))
            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        this._pageBindings.set(name, puppeteerFunction);
        const expression = helper_js_1.helper.pageBindingInitString('exposedFun', name);
        await this._client.send('Runtime.addBinding', { name: name });
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: expression,
        });
        await Promise.all(this.frames().map((frame) => frame.evaluate(expression).catch(helper_js_1.debugError)));
    }
    async authenticate(credentials) {
        return this._frameManager.networkManager().authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
        return this._frameManager.networkManager().setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent) {
        return this._frameManager.networkManager().setUserAgent(userAgent);
    }
    async metrics() {
        const response = await this._client.send('Performance.getMetrics');
        return this._buildMetricsObject(response.metrics);
    }
    _emitMetrics(event) {
        this.emit("metrics" /* Metrics */, {
            title: event.title,
            metrics: this._buildMetricsObject(event.metrics),
        });
    }
    _buildMetricsObject(metrics) {
        const result = {};
        for (const metric of metrics || []) {
            if (supportedMetrics.has(metric.name))
                result[metric.name] = metric.value;
        }
        return result;
    }
    _handleException(exceptionDetails) {
        const message = helper_js_1.helper.getExceptionMessage(exceptionDetails);
        const err = new Error(message);
        err.stack = ''; // Don't report clientside error with a node stack attached
        this.emit("pageerror" /* PageError */, err);
    }
    async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
            // DevTools protocol stores the last 1000 console messages. These
            // messages are always reported even for removed execution contexts. In
            // this case, they are marked with executionContextId = 0 and are
            // reported upon enabling Runtime agent.
            //
            // Ignore these messages since:
            // - there's no execution context we can use to operate with message
            //   arguments
            // - these messages are reported before Puppeteer clients can subscribe
            //   to the 'console'
            //   page event.
            //
            // @see https://github.com/puppeteer/puppeteer/issues/3865
            return;
        }
        const context = this._frameManager.executionContextById(event.executionContextId);
        const values = event.args.map((arg) => JSHandle_js_1.createJSHandle(context, arg));
        this._addConsoleMessage(event.type, values, event.stackTrace);
    }
    async _onBindingCalled(event) {
        let payload;
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            // The binding was either called by something in the page or it was
            // called before our wrapper was initialized.
            return;
        }
        const { type, name, seq, args } = payload;
        if (type !== 'exposedFun' || !this._pageBindings.has(name))
            return;
        let expression = null;
        try {
            const result = await this._pageBindings.get(name)(...args);
            expression = helper_js_1.helper.pageBindingDeliverResultString(name, seq, result);
        }
        catch (error) {
            if (error instanceof Error)
                expression = helper_js_1.helper.pageBindingDeliverErrorString(name, seq, error.message, error.stack);
            else
                expression = helper_js_1.helper.pageBindingDeliverErrorValueString(name, seq, error);
        }
        this._client
            .send('Runtime.evaluate', {
            expression,
            contextId: event.executionContextId,
        })
            .catch(helper_js_1.debugError);
    }
    _addConsoleMessage(type, args, stackTrace) {
        if (!this.listenerCount("console" /* Console */)) {
            args.forEach((arg) => arg.dispose());
            return;
        }
        const textTokens = [];
        for (const arg of args) {
            const remoteObject = arg._remoteObject;
            if (remoteObject.objectId)
                textTokens.push(arg.toString());
            else
                textTokens.push(helper_js_1.helper.valueFromRemoteObject(remoteObject));
        }
        const stackTraceLocations = [];
        if (stackTrace) {
            for (const callFrame of stackTrace.callFrames) {
                stackTraceLocations.push({
                    url: callFrame.url,
                    lineNumber: callFrame.lineNumber,
                    columnNumber: callFrame.columnNumber,
                });
            }
        }
        const message = new ConsoleMessage_js_1.ConsoleMessage(type, textTokens.join(' '), args, stackTraceLocations);
        this.emit("console" /* Console */, message);
    }
    _onDialog(event) {
        let dialogType = null;
        const validDialogTypes = new Set([
            'alert',
            'confirm',
            'prompt',
            'beforeunload',
        ]);
        if (validDialogTypes.has(event.type)) {
            dialogType = event.type;
        }
        assert_js_1.assert(dialogType, 'Unknown javascript dialog type: ' + event.type);
        const dialog = new Dialog_js_1.Dialog(this._client, dialogType, event.message, event.defaultPrompt);
        this.emit("dialog" /* Dialog */, dialog);
    }
    url() {
        return this.mainFrame().url();
    }
    async content() {
        return await this._frameManager.mainFrame().content();
    }
    async setContent(html, options = {}) {
        await this._frameManager.mainFrame().setContent(html, options);
    }
    async goto(url, options = {}) {
        return await this._frameManager.mainFrame().goto(url, options);
    }
    async reload(options) {
        const result = await Promise.all([
            this.waitForNavigation(options),
            this._client.send('Page.reload'),
        ]);
        return result[0];
    }
    async waitForNavigation(options = {}) {
        return await this._frameManager.mainFrame().waitForNavigation(options);
    }
    _sessionClosePromise() {
        if (!this._disconnectPromise)
            this._disconnectPromise = new Promise((fulfill) => this._client.once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => fulfill(new Error('Target closed'))));
        return this._disconnectPromise;
    }
    async waitForRequest(urlOrPredicate, options = {}) {
        const { timeout = this._timeoutSettings.timeout() } = options;
        return helper_js_1.helper.waitForEvent(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Request, (request) => {
            if (helper_js_1.helper.isString(urlOrPredicate))
                return urlOrPredicate === request.url();
            if (typeof urlOrPredicate === 'function')
                return !!urlOrPredicate(request);
            return false;
        }, timeout, this._sessionClosePromise());
    }
    async waitForResponse(urlOrPredicate, options = {}) {
        const { timeout = this._timeoutSettings.timeout() } = options;
        return helper_js_1.helper.waitForEvent(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Response, (response) => {
            if (helper_js_1.helper.isString(urlOrPredicate))
                return urlOrPredicate === response.url();
            if (typeof urlOrPredicate === 'function')
                return !!urlOrPredicate(response);
            return false;
        }, timeout, this._sessionClosePromise());
    }
    async goBack(options = {}) {
        return this._go(-1, options);
    }
    async goForward(options = {}) {
        return this._go(+1, options);
    }
    async _go(delta, options) {
        const history = await this._client.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
            return null;
        const result = await Promise.all([
            this.waitForNavigation(options),
            this._client.send('Page.navigateToHistoryEntry', { entryId: entry.id }),
        ]);
        return result[0];
    }
    async bringToFront() {
        await this._client.send('Page.bringToFront');
    }
    async emulate(options) {
        await Promise.all([
            this.setViewport(options.viewport),
            this.setUserAgent(options.userAgent),
        ]);
    }
    async setJavaScriptEnabled(enabled) {
        if (this._javascriptEnabled === enabled)
            return;
        this._javascriptEnabled = enabled;
        await this._client.send('Emulation.setScriptExecutionDisabled', {
            value: !enabled,
        });
    }
    async setBypassCSP(enabled) {
        await this._client.send('Page.setBypassCSP', { enabled });
    }
    async emulateMediaType(type) {
        assert_js_1.assert(type === 'screen' || type === 'print' || type === null, 'Unsupported media type: ' + type);
        await this._client.send('Emulation.setEmulatedMedia', {
            media: type || '',
        });
    }
    async emulateMediaFeatures(features) {
        if (features === null)
            await this._client.send('Emulation.setEmulatedMedia', { features: null });
        if (Array.isArray(features)) {
            features.every((mediaFeature) => {
                const name = mediaFeature.name;
                assert_js_1.assert(/^prefers-(?:color-scheme|reduced-motion)$/.test(name), 'Unsupported media feature: ' + name);
                return true;
            });
            await this._client.send('Emulation.setEmulatedMedia', {
                features: features,
            });
        }
    }
    async emulateTimezone(timezoneId) {
        try {
            await this._client.send('Emulation.setTimezoneOverride', {
                timezoneId: timezoneId || '',
            });
        }
        catch (error) {
            if (error.message.includes('Invalid timezone'))
                throw new Error(`Invalid timezone ID: ${timezoneId}`);
            throw error;
        }
    }
    /**
     * Emulates the idle state.
     * If no arguments set, clears idle state emulation.
     *
     * @example
     * ```js
     * // set idle emulation
     * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});
     *
     * // do some checks here
     * ...
     *
     * // clear idle emulation
     * await page.emulateIdleState();
     * ```
     *
     * @param overrides Mock idle state. If not set, clears idle overrides
     * @param isUserActive Mock isUserActive
     * @param isScreenUnlocked Mock isScreenUnlocked
     */
    async emulateIdleState(overrides) {
        if (overrides) {
            await this._client.send('Emulation.setIdleOverride', {
                isUserActive: overrides.isUserActive,
                isScreenUnlocked: overrides.isScreenUnlocked,
            });
        }
        else {
            await this._client.send('Emulation.clearIdleOverride');
        }
    }
    /**
     * Simulates the given vision deficiency on the page.
     *
     * @example
     * ```js
     * const puppeteer = require('puppeteer');
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.goto('https://v8.dev/blog/10-years');
     *
     *   await page.emulateVisionDeficiency('achromatopsia');
     *   await page.screenshot({ path: 'achromatopsia.png' });
     *
     *   await page.emulateVisionDeficiency('deuteranopia');
     *   await page.screenshot({ path: 'deuteranopia.png' });
     *
     *   await page.emulateVisionDeficiency('blurredVision');
     *   await page.screenshot({ path: 'blurred-vision.png' });
     *
     *   await browser.close();
     * })();
     * ```
     *
     * @param type - the type of deficiency to simulate, or `'none'` to reset.
     */
    async emulateVisionDeficiency(type) {
        const visionDeficiencies = new Set([
            'none',
            'achromatopsia',
            'blurredVision',
            'deuteranopia',
            'protanopia',
            'tritanopia',
        ]);
        try {
            assert_js_1.assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
            await this._client.send('Emulation.setEmulatedVisionDeficiency', {
                type: type || 'none',
            });
        }
        catch (error) {
            throw error;
        }
    }
    async setViewport(viewport) {
        const needsReload = await this._emulationManager.emulateViewport(viewport);
        this._viewport = viewport;
        if (needsReload)
            await this.reload();
    }
    viewport() {
        return this._viewport;
    }
    /**
     * @remarks
     *
     * Evaluates a function in the page's context and returns the result.
     *
     * If the function passed to `page.evaluteHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * @example
     *
     * ```js
     * const result = await frame.evaluate(() => {
     *   return Promise.resolve(8 * 7);
     * });
     * console.log(result); // prints "56"
     * ```
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     * ```
     * const aHandle = await page.evaluate('1 + 2');
     * ```
     *
     * To get the best TypeScript experience, you should pass in as the
     * generic the type of `pageFunction`:
     *
     * ```
     * const aHandle = await page.evaluate<() => number>(() => 2);
     * ```
     *
     * @example
     *
     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
     * as arguments to the `pageFunction`:
     *
     * ```
     * const bodyHandle = await page.$('body');
     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
     * await bodyHandle.dispose();
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     *
     * @returns the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
        return this._frameManager.mainFrame().evaluate(pageFunction, ...args);
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
        const source = helper_js_1.helper.evaluationString(pageFunction, ...args);
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source,
        });
    }
    async setCacheEnabled(enabled = true) {
        await this._frameManager.networkManager().setCacheEnabled(enabled);
    }
    async screenshot(options = {}) {
        let screenshotType = null;
        // options.type takes precedence over inferring the type from options.path
        // because it may be a 0-length file with no extension created beforehand
        // (i.e. as a temp file).
        if (options.type) {
            assert_js_1.assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);
            screenshotType = options.type;
        }
        else if (options.path) {
            const filePath = options.path;
            const extension = filePath
                .slice(filePath.lastIndexOf('.') + 1)
                .toLowerCase();
            if (extension === 'png')
                screenshotType = 'png';
            else if (extension === 'jpg' || extension === 'jpeg')
                screenshotType = 'jpeg';
            assert_js_1.assert(screenshotType, `Unsupported screenshot type for extension \`.${extension}\``);
        }
        if (!screenshotType)
            screenshotType = 'png';
        if (options.quality) {
            assert_js_1.assert(screenshotType === 'jpeg', 'options.quality is unsupported for the ' +
                screenshotType +
                ' screenshots');
            assert_js_1.assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' +
                typeof options.quality);
            assert_js_1.assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');
            assert_js_1.assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' +
                options.quality);
        }
        assert_js_1.assert(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');
        if (options.clip) {
            assert_js_1.assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' +
                typeof options.clip.x);
            assert_js_1.assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' +
                typeof options.clip.y);
            assert_js_1.assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' +
                typeof options.clip.width);
            assert_js_1.assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' +
                typeof options.clip.height);
            assert_js_1.assert(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');
            assert_js_1.assert(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');
        }
        return this._screenshotTaskQueue.postTask(() => this._screenshotTask(screenshotType, options));
    }
    async _screenshotTask(format, options) {
        await this._client.send('Target.activateTarget', {
            targetId: this._target._targetId,
        });
        let clip = options.clip ? processClip(options.clip) : undefined;
        if (options.fullPage) {
            const metrics = await this._client.send('Page.getLayoutMetrics');
            const width = Math.ceil(metrics.contentSize.width);
            const height = Math.ceil(metrics.contentSize.height);
            // Overwrite clip for full page at all times.
            clip = { x: 0, y: 0, width, height, scale: 1 };
            const { isMobile = false, deviceScaleFactor = 1, isLandscape = false } = this._viewport || {};
            const screenOrientation = isLandscape
                ? { angle: 90, type: 'landscapePrimary' }
                : { angle: 0, type: 'portraitPrimary' };
            await this._client.send('Emulation.setDeviceMetricsOverride', {
                mobile: isMobile,
                width,
                height,
                deviceScaleFactor,
                screenOrientation,
            });
        }
        const shouldSetDefaultBackground = options.omitBackground && format === 'png';
        if (shouldSetDefaultBackground)
            await this._client.send('Emulation.setDefaultBackgroundColorOverride', {
                color: { r: 0, g: 0, b: 0, a: 0 },
            });
        const result = await this._client.send('Page.captureScreenshot', {
            format,
            quality: options.quality,
            clip,
        });
        if (shouldSetDefaultBackground)
            await this._client.send('Emulation.setDefaultBackgroundColorOverride');
        if (options.fullPage && this._viewport)
            await this.setViewport(this._viewport);
        const buffer = options.encoding === 'base64'
            ? result.data
            : Buffer.from(result.data, 'base64');
        if (!environment_js_1.isNode && options.path) {
            throw new Error('Screenshots can only be written to a file path in a Node environment.');
        }
        const fs = await helper_js_1.helper.importFSModule();
        if (options.path)
            await fs.promises.writeFile(options.path, buffer);
        return buffer;
        function processClip(clip) {
            const x = Math.round(clip.x);
            const y = Math.round(clip.y);
            const width = Math.round(clip.width + clip.x - x);
            const height = Math.round(clip.height + clip.y - y);
            return { x, y, width, height, scale: 1 };
        }
    }
    /**
     * Generatees a PDF of the page with the `print` CSS media type.
     * @remarks
     *
     * IMPORTANT: PDF generation is only supported in Chrome headless mode.
     *
     * To generate a PDF with the `screen` media type, call
     * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before
     * calling `page.pdf()`.
     *
     * By default, `page.pdf()` generates a pdf with modified colors for printing.
     * Use the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}
     * property to force rendering of exact colors.
     *
     *
     * @param options - options for generating the PDF.
     */
    async pdf(options = {}) {
        const { scale = 1, displayHeaderFooter = false, headerTemplate = '', footerTemplate = '', printBackground = false, landscape = false, pageRanges = '', preferCSSPageSize = false, margin = {}, path = null, } = options;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options.format) {
            const format = PDFOptions_js_1.paperFormats[options.format.toLowerCase()];
            assert_js_1.assert(format, 'Unknown paper format: ' + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
        }
        else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight =
                convertPrintParameterToInches(options.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        const result = await this._client.send('Page.printToPDF', {
            transferMode: 'ReturnAsStream',
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize,
        });
        return await helper_js_1.helper.readProtocolStream(this._client, result.stream, path);
    }
    async title() {
        return this.mainFrame().title();
    }
    async close(options = { runBeforeUnload: undefined }) {
        assert_js_1.assert(!!this._client._connection, 'Protocol error: Connection closed. Most likely the page has been closed.');
        const runBeforeUnload = !!options.runBeforeUnload;
        if (runBeforeUnload) {
            await this._client.send('Page.close');
        }
        else {
            await this._client._connection.send('Target.closeTarget', {
                targetId: this._target._targetId,
            });
            await this._target._isClosedPromise;
        }
    }
    isClosed() {
        return this._closed;
    }
    get mouse() {
        return this._mouse;
    }
    click(selector, options = {}) {
        return this.mainFrame().click(selector, options);
    }
    focus(selector) {
        return this.mainFrame().focus(selector);
    }
    hover(selector) {
        return this.mainFrame().hover(selector);
    }
    select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
    }
    tap(selector) {
        return this.mainFrame().tap(selector);
    }
    type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
    }
    /**
     * @remarks
     *
     * This method behaves differently depending on the first parameter. If it's a
     * `string`, it will be treated as a `selector` or `xpath` (if the string
     * starts with `//`). This method then is a shortcut for
     * {@link Page.waitForSelector} or {@link Page.waitForXPath}.
     *
     * If the first argument is a function this method is a shortcut for
     * {@link Page.waitForFunction}.
     *
     * If the first argument is a `number`, it's treated as a timeout in
     * milliseconds and the method returns a promise which resolves after the
     * timeout.
     *
     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to
     * wait for.
     * @param options - optional waiting parameters.
     * @param args - arguments to pass to `pageFunction`.
     *
     * @deprecated Don't use this method directly. Instead use the more explicit
     * methods available: {@link Page.waitForSelector},
     * {@link Page.waitForXPath}, {@link Page.waitForFunction} or
     * {@link Page.waitForTimeout}.
     */
    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);
    }
    /**
     * Causes your script to wait for the given number of milliseconds.
     *
     * @remarks
     *
     * It's generally recommended to not wait for a number of seconds, but instead
     * use {@link Page.waitForSelector}, {@link Page.waitForXPath} or
     * {@link Page.waitForFunction} to wait for exactly the conditions you want.
     *
     * @example
     *
     * Wait for 1 second:
     *
     * ```
     * await page.waitForTimeout(1000);
     * ```
     *
     * @param milliseconds - the number of milliseconds to wait.
     */
    waitForTimeout(milliseconds) {
        return this.mainFrame().waitForTimeout(milliseconds);
    }
    waitForSelector(selector, options = {}) {
        return this.mainFrame().waitForSelector(selector, options);
    }
    waitForXPath(xpath, options = {}) {
        return this.mainFrame().waitForXPath(xpath, options);
    }
    waitForFunction(pageFunction, options = {}, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
    }
}
exports.Page = Page;
const supportedMetrics = new Set([
    'Timestamp',
    'Documents',
    'Frames',
    'JSEventListeners',
    'Nodes',
    'LayoutCount',
    'RecalcStyleCount',
    'LayoutDuration',
    'RecalcStyleDuration',
    'ScriptDuration',
    'TaskDuration',
    'JSHeapUsedSize',
    'JSHeapTotalSize',
]);
const unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78,
};
function convertPrintParameterToInches(parameter) {
    if (typeof parameter === 'undefined')
        return undefined;
    let pixels;
    if (helper_js_1.helper.isNumber(parameter)) {
        // Treat numbers as pixel values to be aligned with phantom's paperSize.
        pixels = /** @type {number} */ parameter;
    }
    else if (helper_js_1.helper.isString(parameter)) {
        const text = /** @type {string} */ parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = '';
        if (unitToPixels.hasOwnProperty(unit)) {
            valueText = text.substring(0, text.length - 2);
        }
        else {
            // In case of unknown unit try to parse the whole parameter as number of pixels.
            // This is consistent with phantom's paperSize behavior.
            unit = 'px';
            valueText = text;
        }
        const value = Number(valueText);
        assert_js_1.assert(!isNaN(value), 'Failed to parse parameter value: ' + text);
        pixels = value * unitToPixels[unit];
    }
    else {
        throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);
    }
    return pixels / 96;
}


/***/ }),

/***/ 2994:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Puppeteer = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Errors_js_1 = __nccwpck_require__(6371);
const DeviceDescriptors_js_1 = __nccwpck_require__(9821);
const QueryHandler_js_1 = __nccwpck_require__(7157);
const BrowserConnector_js_1 = __nccwpck_require__(8994);
/**
 * The main Puppeteer class.
 *
 * IMPORTANT: if you are using Puppeteer in a Node environment, you will get an
 * instance of {@link PuppeteerNode} when you import or require `puppeteer`.
 * That class extends `Puppeteer`, so has all the methods documented below as
 * well as all that are defined on {@link PuppeteerNode}.
 * @public
 */
class Puppeteer {
    /**
     * @internal
     */
    constructor(settings) {
        this._changedProduct = false;
        this._isPuppeteerCore = settings.isPuppeteerCore;
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @remarks
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
        return BrowserConnector_js_1.connectToBrowser(options);
    }
    /**
     * @remarks
     * A list of devices to be used with `page.emulate(options)`. Actual list of devices can be found in {@link https://github.com/puppeteer/puppeteer/blob/main/src/common/DeviceDescriptors.ts | src/common/DeviceDescriptors.ts}.
     *
     * @example
     *
     * ```js
     * const puppeteer = require('puppeteer');
     * const iPhone = puppeteer.devices['iPhone 6'];
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.emulate(iPhone);
     *   await page.goto('https://www.google.com');
     *   // other actions...
     *   await browser.close();
     * })();
     * ```
     *
     */
    get devices() {
        return DeviceDescriptors_js_1.devicesMap;
    }
    /**
     * @remarks
     *
     * Puppeteer methods might throw errors if they are unable to fulfill a request.
     * For example, `page.waitForSelector(selector[, options])` might fail if
     * the selector doesn't match any nodes during the given timeframe.
     *
     * For certain types of errors Puppeteer uses specific error classes.
     * These classes are available via `puppeteer.errors`.
     *
     * @example
     * An example of handling a timeout error:
     * ```js
     * try {
     *   await page.waitForSelector('.foo');
     * } catch (e) {
     *   if (e instanceof puppeteer.errors.TimeoutError) {
     *     // Do something if this is a timeout.
     *   }
     * }
     * ```
     */
    get errors() {
        return Errors_js_1.puppeteerErrors;
    }
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}. After
     * registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is
     * only allowed to consist of lower- and upper case latin letters.
     * @example
     * ```
     * puppeteer.registerCustomQueryHandler('text', { … });
     * const aHandle = await page.$('text/…');
     * ```
     * @param name - The name that the custom query handler will be registered under.
     * @param queryHandler - The {@link CustomQueryHandler | custom query handler} to
     * register.
     */
    registerCustomQueryHandler(name, queryHandler) {
        QueryHandler_js_1.registerCustomQueryHandler(name, queryHandler);
    }
    /**
     * @param name - The name of the query handler to unregistered.
     */
    unregisterCustomQueryHandler(name) {
        QueryHandler_js_1.unregisterCustomQueryHandler(name);
    }
    /**
     * @returns a list with the names of all registered custom query handlers.
     */
    customQueryHandlerNames() {
        return QueryHandler_js_1.customQueryHandlerNames();
    }
    /**
     * Clears all registered handlers.
     */
    clearCustomQueryHandlers() {
        QueryHandler_js_1.clearCustomQueryHandlers();
    }
}
exports.Puppeteer = Puppeteer;


/***/ }),

/***/ 7157:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getQueryHandlerAndSelector = exports.clearCustomQueryHandlers = exports.customQueryHandlerNames = exports.unregisterCustomQueryHandler = exports.registerCustomQueryHandler = void 0;
const AriaQueryHandler_js_1 = __nccwpck_require__(922);
function makeQueryHandler(handler) {
    const internalHandler = {};
    if (handler.queryOne) {
        internalHandler.queryOne = async (element, selector) => {
            const jsHandle = await element.evaluateHandle(handler.queryOne, selector);
            const elementHandle = jsHandle.asElement();
            if (elementHandle)
                return elementHandle;
            await jsHandle.dispose();
            return null;
        };
        internalHandler.waitFor = (domWorld, selector, options) => domWorld.waitForSelectorInPage(handler.queryOne, selector, options);
    }
    if (handler.queryAll) {
        internalHandler.queryAll = async (element, selector) => {
            const jsHandle = await element.evaluateHandle(handler.queryAll, selector);
            const properties = await jsHandle.getProperties();
            await jsHandle.dispose();
            const result = [];
            for (const property of properties.values()) {
                const elementHandle = property.asElement();
                if (elementHandle)
                    result.push(elementHandle);
            }
            return result;
        };
        internalHandler.queryAllArray = async (element, selector) => {
            const resultHandle = await element.evaluateHandle(handler.queryAll, selector);
            const arrayHandle = await resultHandle.evaluateHandle((res) => Array.from(res));
            return arrayHandle;
        };
    }
    return internalHandler;
}
const _defaultHandler = makeQueryHandler({
    queryOne: (element, selector) => element.querySelector(selector),
    queryAll: (element, selector) => element.querySelectorAll(selector),
});
const pierceHandler = makeQueryHandler({
    queryOne: (element, selector) => {
        let found = null;
        const search = (root) => {
            const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            do {
                const currentNode = iter.currentNode;
                if (currentNode.shadowRoot) {
                    search(currentNode.shadowRoot);
                }
                if (currentNode instanceof ShadowRoot) {
                    continue;
                }
                if (!found && currentNode.matches(selector)) {
                    found = currentNode;
                }
            } while (!found && iter.nextNode());
        };
        if (element instanceof Document) {
            element = element.documentElement;
        }
        search(element);
        return found;
    },
    queryAll: (element, selector) => {
        const result = [];
        const collect = (root) => {
            const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            do {
                const currentNode = iter.currentNode;
                if (currentNode.shadowRoot) {
                    collect(currentNode.shadowRoot);
                }
                if (currentNode instanceof ShadowRoot) {
                    continue;
                }
                if (currentNode.matches(selector)) {
                    result.push(currentNode);
                }
            } while (iter.nextNode());
        };
        if (element instanceof Document) {
            element = element.documentElement;
        }
        collect(element);
        return result;
    },
});
const _builtInHandlers = new Map([
    ['aria', AriaQueryHandler_js_1.ariaHandler],
    ['pierce', pierceHandler],
]);
const _queryHandlers = new Map(_builtInHandlers);
/**
 * @internal
 */
function registerCustomQueryHandler(name, handler) {
    if (_queryHandlers.get(name))
        throw new Error(`A custom query handler named "${name}" already exists`);
    const isValidName = /^[a-zA-Z]+$/.test(name);
    if (!isValidName)
        throw new Error(`Custom query handler names may only contain [a-zA-Z]`);
    const internalHandler = makeQueryHandler(handler);
    _queryHandlers.set(name, internalHandler);
}
exports.registerCustomQueryHandler = registerCustomQueryHandler;
/**
 * @internal
 */
function unregisterCustomQueryHandler(name) {
    if (_queryHandlers.has(name) && !_builtInHandlers.has(name)) {
        _queryHandlers.delete(name);
    }
}
exports.unregisterCustomQueryHandler = unregisterCustomQueryHandler;
/**
 * @internal
 */
function customQueryHandlerNames() {
    return [..._queryHandlers.keys()].filter((name) => !_builtInHandlers.has(name));
}
exports.customQueryHandlerNames = customQueryHandlerNames;
/**
 * @internal
 */
function clearCustomQueryHandlers() {
    customQueryHandlerNames().forEach(unregisterCustomQueryHandler);
}
exports.clearCustomQueryHandlers = clearCustomQueryHandlers;
/**
 * @internal
 */
function getQueryHandlerAndSelector(selector) {
    const hasCustomQueryHandler = /^[a-zA-Z]+\//.test(selector);
    if (!hasCustomQueryHandler)
        return { updatedSelector: selector, queryHandler: _defaultHandler };
    const index = selector.indexOf('/');
    const name = selector.slice(0, index);
    const updatedSelector = selector.slice(index + 1);
    const queryHandler = _queryHandlers.get(name);
    if (!queryHandler)
        throw new Error(`Query set to use "${name}", but no query handler of that name was found`);
    return {
        updatedSelector,
        queryHandler,
    };
}
exports.getQueryHandlerAndSelector = getQueryHandlerAndSelector;


/***/ }),

/***/ 1822:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityDetails = void 0;
/**
 * The SecurityDetails class represents the security details of a
 * response that was received over a secure connection.
 *
 * @public
 */
class SecurityDetails {
    /**
     * @internal
     */
    constructor(securityPayload) {
        this._subjectName = securityPayload.subjectName;
        this._issuer = securityPayload.issuer;
        this._validFrom = securityPayload.validFrom;
        this._validTo = securityPayload.validTo;
        this._protocol = securityPayload.protocol;
        this._sanList = securityPayload.sanList;
    }
    /**
     * @returns The name of the issuer of the certificate.
     */
    issuer() {
        return this._issuer;
    }
    /**
     * @returns {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the start of the certificate's validity.
     */
    validFrom() {
        return this._validFrom;
    }
    /**
     * @returns {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the end of the certificate's validity.
     */
    validTo() {
        return this._validTo;
    }
    /**
     * @returns The security protocol being used, e.g. "TLS 1.2".
     */
    protocol() {
        return this._protocol;
    }
    /**
     * @returns The name of the subject to which the certificate was issued.
     */
    subjectName() {
        return this._subjectName;
    }
    /**
     * @returns The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
     */
    subjectAlternativeNames() {
        return this._sanList;
    }
}
exports.SecurityDetails = SecurityDetails;


/***/ }),

/***/ 8956:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Target = void 0;
const Page_js_1 = __nccwpck_require__(6057);
const WebWorker_js_1 = __nccwpck_require__(6206);
/**
 * @public
 */
class Target {
    /**
     * @internal
     */
    constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport) {
        this._targetInfo = targetInfo;
        this._browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this._sessionFactory = sessionFactory;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        /** @type {?Promise<!Puppeteer.Page>} */
        this._pagePromise = null;
        /** @type {?Promise<!WebWorker>} */
        this._workerPromise = null;
        this._initializedPromise = new Promise((fulfill) => (this._initializedCallback = fulfill)).then(async (success) => {
            if (!success)
                return false;
            const opener = this.opener();
            if (!opener || !opener._pagePromise || this.type() !== 'page')
                return true;
            const openerPage = await opener._pagePromise;
            if (!openerPage.listenerCount("popup" /* Popup */))
                return true;
            const popupPage = await this.page();
            openerPage.emit("popup" /* Popup */, popupPage);
            return true;
        });
        this._isClosedPromise = new Promise((fulfill) => (this._closedCallback = fulfill));
        this._isInitialized =
            this._targetInfo.type !== 'page' || this._targetInfo.url !== '';
        if (this._isInitialized)
            this._initializedCallback(true);
    }
    /**
     * Creates a Chrome Devtools Protocol session attached to the target.
     */
    createCDPSession() {
        return this._sessionFactory();
    }
    /**
     * If the target is not of type `"page"` or `"background_page"`, returns `null`.
     */
    async page() {
        if ((this._targetInfo.type === 'page' ||
            this._targetInfo.type === 'background_page' ||
            this._targetInfo.type === 'webview') &&
            !this._pagePromise) {
            this._pagePromise = this._sessionFactory().then((client) => Page_js_1.Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport));
        }
        return this._pagePromise;
    }
    /**
     * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
     */
    async worker() {
        if (this._targetInfo.type !== 'service_worker' &&
            this._targetInfo.type !== 'shared_worker')
            return null;
        if (!this._workerPromise) {
            // TODO(einbinder): Make workers send their console logs.
            this._workerPromise = this._sessionFactory().then((client) => new WebWorker_js_1.WebWorker(client, this._targetInfo.url, () => { } /* consoleAPICalled */, () => { } /* exceptionThrown */));
        }
        return this._workerPromise;
    }
    url() {
        return this._targetInfo.url;
    }
    /**
     * Identifies what kind of target this is.
     *
     * @remarks
     *
     * See {@link https://developer.chrome.com/extensions/background_pages | docs} for more info about background pages.
     */
    type() {
        const type = this._targetInfo.type;
        if (type === 'page' ||
            type === 'background_page' ||
            type === 'service_worker' ||
            type === 'shared_worker' ||
            type === 'browser' ||
            type === 'webview')
            return type;
        return 'other';
    }
    /**
     * Get the browser the target belongs to.
     */
    browser() {
        return this._browserContext.browser();
    }
    browserContext() {
        return this._browserContext;
    }
    /**
     * Get the target that opened this target. Top-level targets return `null`.
     */
    opener() {
        const { openerId } = this._targetInfo;
        if (!openerId)
            return null;
        return this.browser()._targets.get(openerId);
    }
    /**
     * @internal
     */
    _targetInfoChanged(targetInfo) {
        this._targetInfo = targetInfo;
        if (!this._isInitialized &&
            (this._targetInfo.type !== 'page' || this._targetInfo.url !== '')) {
            this._isInitialized = true;
            this._initializedCallback(true);
            return;
        }
    }
}
exports.Target = Target;


/***/ }),

/***/ 8355:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutSettings = void 0;
const DEFAULT_TIMEOUT = 30000;
/**
 * @internal
 */
class TimeoutSettings {
    constructor() {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
    }
    setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
    }
    setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
    }
    navigationTimeout() {
        if (this._defaultNavigationTimeout !== null)
            return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
    }
    timeout() {
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
    }
}
exports.TimeoutSettings = TimeoutSettings;


/***/ }),

/***/ 6503:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tracing = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
/**
 * The Tracing class exposes the tracing audit interface.
 * @remarks
 * You can use `tracing.start` and `tracing.stop` to create a trace file
 * which can be opened in Chrome DevTools or {@link https://chromedevtools.github.io/timeline-viewer/ | timeline viewer}.
 *
 * @example
 * ```js
 * await page.tracing.start({path: 'trace.json'});
 * await page.goto('https://www.google.com');
 * await page.tracing.stop();
 * ```
 *
 * @public
 */
class Tracing {
    /**
     * @internal
     */
    constructor(client) {
        this._recording = false;
        this._path = '';
        this._client = client;
    }
    /**
     * Starts a trace for the current page.
     * @remarks
     * Only one trace can be active at a time per browser.
     * @param options - Optional `TracingOptions`.
     */
    async start(options = {}) {
        assert_js_1.assert(!this._recording, 'Cannot start recording trace while already recording trace.');
        const defaultCategories = [
            '-*',
            'devtools.timeline',
            'v8.execute',
            'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame',
            'toplevel',
            'blink.console',
            'blink.user_timing',
            'latencyInfo',
            'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler',
            'disabled-by-default-v8.cpu_profiler.hires',
        ];
        const { path = null, screenshots = false, categories = defaultCategories, } = options;
        if (screenshots)
            categories.push('disabled-by-default-devtools.screenshot');
        this._path = path;
        this._recording = true;
        await this._client.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            categories: categories.join(','),
        });
    }
    /**
     * Stops a trace started with the `start` method.
     * @returns Promise which resolves to buffer with trace data.
     */
    async stop() {
        let fulfill;
        let reject;
        const contentPromise = new Promise((x, y) => {
            fulfill = x;
            reject = y;
        });
        this._client.once('Tracing.tracingComplete', (event) => {
            helper_js_1.helper
                .readProtocolStream(this._client, event.stream, this._path)
                .then(fulfill, reject);
        });
        await this._client.send('Tracing.end');
        this._recording = false;
        return contentPromise;
    }
}
exports.Tracing = Tracing;


/***/ }),

/***/ 7651:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keyDefinitions = void 0;
/**
 * @internal
 */
exports.keyDefinitions = {
    '0': { keyCode: 48, key: '0', code: 'Digit0' },
    '1': { keyCode: 49, key: '1', code: 'Digit1' },
    '2': { keyCode: 50, key: '2', code: 'Digit2' },
    '3': { keyCode: 51, key: '3', code: 'Digit3' },
    '4': { keyCode: 52, key: '4', code: 'Digit4' },
    '5': { keyCode: 53, key: '5', code: 'Digit5' },
    '6': { keyCode: 54, key: '6', code: 'Digit6' },
    '7': { keyCode: 55, key: '7', code: 'Digit7' },
    '8': { keyCode: 56, key: '8', code: 'Digit8' },
    '9': { keyCode: 57, key: '9', code: 'Digit9' },
    Power: { key: 'Power', code: 'Power' },
    Eject: { key: 'Eject', code: 'Eject' },
    Abort: { keyCode: 3, code: 'Abort', key: 'Cancel' },
    Help: { keyCode: 6, code: 'Help', key: 'Help' },
    Backspace: { keyCode: 8, code: 'Backspace', key: 'Backspace' },
    Tab: { keyCode: 9, code: 'Tab', key: 'Tab' },
    Numpad5: {
        keyCode: 12,
        shiftKeyCode: 101,
        key: 'Clear',
        code: 'Numpad5',
        shiftKey: '5',
        location: 3,
    },
    NumpadEnter: {
        keyCode: 13,
        code: 'NumpadEnter',
        key: 'Enter',
        text: '\r',
        location: 3,
    },
    Enter: { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\r': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\n': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    ShiftLeft: { keyCode: 16, code: 'ShiftLeft', key: 'Shift', location: 1 },
    ShiftRight: { keyCode: 16, code: 'ShiftRight', key: 'Shift', location: 2 },
    ControlLeft: {
        keyCode: 17,
        code: 'ControlLeft',
        key: 'Control',
        location: 1,
    },
    ControlRight: {
        keyCode: 17,
        code: 'ControlRight',
        key: 'Control',
        location: 2,
    },
    AltLeft: { keyCode: 18, code: 'AltLeft', key: 'Alt', location: 1 },
    AltRight: { keyCode: 18, code: 'AltRight', key: 'Alt', location: 2 },
    Pause: { keyCode: 19, code: 'Pause', key: 'Pause' },
    CapsLock: { keyCode: 20, code: 'CapsLock', key: 'CapsLock' },
    Escape: { keyCode: 27, code: 'Escape', key: 'Escape' },
    Convert: { keyCode: 28, code: 'Convert', key: 'Convert' },
    NonConvert: { keyCode: 29, code: 'NonConvert', key: 'NonConvert' },
    Space: { keyCode: 32, code: 'Space', key: ' ' },
    Numpad9: {
        keyCode: 33,
        shiftKeyCode: 105,
        key: 'PageUp',
        code: 'Numpad9',
        shiftKey: '9',
        location: 3,
    },
    PageUp: { keyCode: 33, code: 'PageUp', key: 'PageUp' },
    Numpad3: {
        keyCode: 34,
        shiftKeyCode: 99,
        key: 'PageDown',
        code: 'Numpad3',
        shiftKey: '3',
        location: 3,
    },
    PageDown: { keyCode: 34, code: 'PageDown', key: 'PageDown' },
    End: { keyCode: 35, code: 'End', key: 'End' },
    Numpad1: {
        keyCode: 35,
        shiftKeyCode: 97,
        key: 'End',
        code: 'Numpad1',
        shiftKey: '1',
        location: 3,
    },
    Home: { keyCode: 36, code: 'Home', key: 'Home' },
    Numpad7: {
        keyCode: 36,
        shiftKeyCode: 103,
        key: 'Home',
        code: 'Numpad7',
        shiftKey: '7',
        location: 3,
    },
    ArrowLeft: { keyCode: 37, code: 'ArrowLeft', key: 'ArrowLeft' },
    Numpad4: {
        keyCode: 37,
        shiftKeyCode: 100,
        key: 'ArrowLeft',
        code: 'Numpad4',
        shiftKey: '4',
        location: 3,
    },
    Numpad8: {
        keyCode: 38,
        shiftKeyCode: 104,
        key: 'ArrowUp',
        code: 'Numpad8',
        shiftKey: '8',
        location: 3,
    },
    ArrowUp: { keyCode: 38, code: 'ArrowUp', key: 'ArrowUp' },
    ArrowRight: { keyCode: 39, code: 'ArrowRight', key: 'ArrowRight' },
    Numpad6: {
        keyCode: 39,
        shiftKeyCode: 102,
        key: 'ArrowRight',
        code: 'Numpad6',
        shiftKey: '6',
        location: 3,
    },
    Numpad2: {
        keyCode: 40,
        shiftKeyCode: 98,
        key: 'ArrowDown',
        code: 'Numpad2',
        shiftKey: '2',
        location: 3,
    },
    ArrowDown: { keyCode: 40, code: 'ArrowDown', key: 'ArrowDown' },
    Select: { keyCode: 41, code: 'Select', key: 'Select' },
    Open: { keyCode: 43, code: 'Open', key: 'Execute' },
    PrintScreen: { keyCode: 44, code: 'PrintScreen', key: 'PrintScreen' },
    Insert: { keyCode: 45, code: 'Insert', key: 'Insert' },
    Numpad0: {
        keyCode: 45,
        shiftKeyCode: 96,
        key: 'Insert',
        code: 'Numpad0',
        shiftKey: '0',
        location: 3,
    },
    Delete: { keyCode: 46, code: 'Delete', key: 'Delete' },
    NumpadDecimal: {
        keyCode: 46,
        shiftKeyCode: 110,
        code: 'NumpadDecimal',
        key: '\u0000',
        shiftKey: '.',
        location: 3,
    },
    Digit0: { keyCode: 48, code: 'Digit0', shiftKey: ')', key: '0' },
    Digit1: { keyCode: 49, code: 'Digit1', shiftKey: '!', key: '1' },
    Digit2: { keyCode: 50, code: 'Digit2', shiftKey: '@', key: '2' },
    Digit3: { keyCode: 51, code: 'Digit3', shiftKey: '#', key: '3' },
    Digit4: { keyCode: 52, code: 'Digit4', shiftKey: '$', key: '4' },
    Digit5: { keyCode: 53, code: 'Digit5', shiftKey: '%', key: '5' },
    Digit6: { keyCode: 54, code: 'Digit6', shiftKey: '^', key: '6' },
    Digit7: { keyCode: 55, code: 'Digit7', shiftKey: '&', key: '7' },
    Digit8: { keyCode: 56, code: 'Digit8', shiftKey: '*', key: '8' },
    Digit9: { keyCode: 57, code: 'Digit9', shiftKey: '(', key: '9' },
    KeyA: { keyCode: 65, code: 'KeyA', shiftKey: 'A', key: 'a' },
    KeyB: { keyCode: 66, code: 'KeyB', shiftKey: 'B', key: 'b' },
    KeyC: { keyCode: 67, code: 'KeyC', shiftKey: 'C', key: 'c' },
    KeyD: { keyCode: 68, code: 'KeyD', shiftKey: 'D', key: 'd' },
    KeyE: { keyCode: 69, code: 'KeyE', shiftKey: 'E', key: 'e' },
    KeyF: { keyCode: 70, code: 'KeyF', shiftKey: 'F', key: 'f' },
    KeyG: { keyCode: 71, code: 'KeyG', shiftKey: 'G', key: 'g' },
    KeyH: { keyCode: 72, code: 'KeyH', shiftKey: 'H', key: 'h' },
    KeyI: { keyCode: 73, code: 'KeyI', shiftKey: 'I', key: 'i' },
    KeyJ: { keyCode: 74, code: 'KeyJ', shiftKey: 'J', key: 'j' },
    KeyK: { keyCode: 75, code: 'KeyK', shiftKey: 'K', key: 'k' },
    KeyL: { keyCode: 76, code: 'KeyL', shiftKey: 'L', key: 'l' },
    KeyM: { keyCode: 77, code: 'KeyM', shiftKey: 'M', key: 'm' },
    KeyN: { keyCode: 78, code: 'KeyN', shiftKey: 'N', key: 'n' },
    KeyO: { keyCode: 79, code: 'KeyO', shiftKey: 'O', key: 'o' },
    KeyP: { keyCode: 80, code: 'KeyP', shiftKey: 'P', key: 'p' },
    KeyQ: { keyCode: 81, code: 'KeyQ', shiftKey: 'Q', key: 'q' },
    KeyR: { keyCode: 82, code: 'KeyR', shiftKey: 'R', key: 'r' },
    KeyS: { keyCode: 83, code: 'KeyS', shiftKey: 'S', key: 's' },
    KeyT: { keyCode: 84, code: 'KeyT', shiftKey: 'T', key: 't' },
    KeyU: { keyCode: 85, code: 'KeyU', shiftKey: 'U', key: 'u' },
    KeyV: { keyCode: 86, code: 'KeyV', shiftKey: 'V', key: 'v' },
    KeyW: { keyCode: 87, code: 'KeyW', shiftKey: 'W', key: 'w' },
    KeyX: { keyCode: 88, code: 'KeyX', shiftKey: 'X', key: 'x' },
    KeyY: { keyCode: 89, code: 'KeyY', shiftKey: 'Y', key: 'y' },
    KeyZ: { keyCode: 90, code: 'KeyZ', shiftKey: 'Z', key: 'z' },
    MetaLeft: { keyCode: 91, code: 'MetaLeft', key: 'Meta', location: 1 },
    MetaRight: { keyCode: 92, code: 'MetaRight', key: 'Meta', location: 2 },
    ContextMenu: { keyCode: 93, code: 'ContextMenu', key: 'ContextMenu' },
    NumpadMultiply: {
        keyCode: 106,
        code: 'NumpadMultiply',
        key: '*',
        location: 3,
    },
    NumpadAdd: { keyCode: 107, code: 'NumpadAdd', key: '+', location: 3 },
    NumpadSubtract: {
        keyCode: 109,
        code: 'NumpadSubtract',
        key: '-',
        location: 3,
    },
    NumpadDivide: { keyCode: 111, code: 'NumpadDivide', key: '/', location: 3 },
    F1: { keyCode: 112, code: 'F1', key: 'F1' },
    F2: { keyCode: 113, code: 'F2', key: 'F2' },
    F3: { keyCode: 114, code: 'F3', key: 'F3' },
    F4: { keyCode: 115, code: 'F4', key: 'F4' },
    F5: { keyCode: 116, code: 'F5', key: 'F5' },
    F6: { keyCode: 117, code: 'F6', key: 'F6' },
    F7: { keyCode: 118, code: 'F7', key: 'F7' },
    F8: { keyCode: 119, code: 'F8', key: 'F8' },
    F9: { keyCode: 120, code: 'F9', key: 'F9' },
    F10: { keyCode: 121, code: 'F10', key: 'F10' },
    F11: { keyCode: 122, code: 'F11', key: 'F11' },
    F12: { keyCode: 123, code: 'F12', key: 'F12' },
    F13: { keyCode: 124, code: 'F13', key: 'F13' },
    F14: { keyCode: 125, code: 'F14', key: 'F14' },
    F15: { keyCode: 126, code: 'F15', key: 'F15' },
    F16: { keyCode: 127, code: 'F16', key: 'F16' },
    F17: { keyCode: 128, code: 'F17', key: 'F17' },
    F18: { keyCode: 129, code: 'F18', key: 'F18' },
    F19: { keyCode: 130, code: 'F19', key: 'F19' },
    F20: { keyCode: 131, code: 'F20', key: 'F20' },
    F21: { keyCode: 132, code: 'F21', key: 'F21' },
    F22: { keyCode: 133, code: 'F22', key: 'F22' },
    F23: { keyCode: 134, code: 'F23', key: 'F23' },
    F24: { keyCode: 135, code: 'F24', key: 'F24' },
    NumLock: { keyCode: 144, code: 'NumLock', key: 'NumLock' },
    ScrollLock: { keyCode: 145, code: 'ScrollLock', key: 'ScrollLock' },
    AudioVolumeMute: {
        keyCode: 173,
        code: 'AudioVolumeMute',
        key: 'AudioVolumeMute',
    },
    AudioVolumeDown: {
        keyCode: 174,
        code: 'AudioVolumeDown',
        key: 'AudioVolumeDown',
    },
    AudioVolumeUp: { keyCode: 175, code: 'AudioVolumeUp', key: 'AudioVolumeUp' },
    MediaTrackNext: {
        keyCode: 176,
        code: 'MediaTrackNext',
        key: 'MediaTrackNext',
    },
    MediaTrackPrevious: {
        keyCode: 177,
        code: 'MediaTrackPrevious',
        key: 'MediaTrackPrevious',
    },
    MediaStop: { keyCode: 178, code: 'MediaStop', key: 'MediaStop' },
    MediaPlayPause: {
        keyCode: 179,
        code: 'MediaPlayPause',
        key: 'MediaPlayPause',
    },
    Semicolon: { keyCode: 186, code: 'Semicolon', shiftKey: ':', key: ';' },
    Equal: { keyCode: 187, code: 'Equal', shiftKey: '+', key: '=' },
    NumpadEqual: { keyCode: 187, code: 'NumpadEqual', key: '=', location: 3 },
    Comma: { keyCode: 188, code: 'Comma', shiftKey: '<', key: ',' },
    Minus: { keyCode: 189, code: 'Minus', shiftKey: '_', key: '-' },
    Period: { keyCode: 190, code: 'Period', shiftKey: '>', key: '.' },
    Slash: { keyCode: 191, code: 'Slash', shiftKey: '?', key: '/' },
    Backquote: { keyCode: 192, code: 'Backquote', shiftKey: '~', key: '`' },
    BracketLeft: { keyCode: 219, code: 'BracketLeft', shiftKey: '{', key: '[' },
    Backslash: { keyCode: 220, code: 'Backslash', shiftKey: '|', key: '\\' },
    BracketRight: { keyCode: 221, code: 'BracketRight', shiftKey: '}', key: ']' },
    Quote: { keyCode: 222, code: 'Quote', shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: 'AltGraph', key: 'AltGraph' },
    Props: { keyCode: 247, code: 'Props', key: 'CrSel' },
    Cancel: { keyCode: 3, key: 'Cancel', code: 'Abort' },
    Clear: { keyCode: 12, key: 'Clear', code: 'Numpad5', location: 3 },
    Shift: { keyCode: 16, key: 'Shift', code: 'ShiftLeft', location: 1 },
    Control: { keyCode: 17, key: 'Control', code: 'ControlLeft', location: 1 },
    Alt: { keyCode: 18, key: 'Alt', code: 'AltLeft', location: 1 },
    Accept: { keyCode: 30, key: 'Accept' },
    ModeChange: { keyCode: 31, key: 'ModeChange' },
    ' ': { keyCode: 32, key: ' ', code: 'Space' },
    Print: { keyCode: 42, key: 'Print' },
    Execute: { keyCode: 43, key: 'Execute', code: 'Open' },
    '\u0000': { keyCode: 46, key: '\u0000', code: 'NumpadDecimal', location: 3 },
    a: { keyCode: 65, key: 'a', code: 'KeyA' },
    b: { keyCode: 66, key: 'b', code: 'KeyB' },
    c: { keyCode: 67, key: 'c', code: 'KeyC' },
    d: { keyCode: 68, key: 'd', code: 'KeyD' },
    e: { keyCode: 69, key: 'e', code: 'KeyE' },
    f: { keyCode: 70, key: 'f', code: 'KeyF' },
    g: { keyCode: 71, key: 'g', code: 'KeyG' },
    h: { keyCode: 72, key: 'h', code: 'KeyH' },
    i: { keyCode: 73, key: 'i', code: 'KeyI' },
    j: { keyCode: 74, key: 'j', code: 'KeyJ' },
    k: { keyCode: 75, key: 'k', code: 'KeyK' },
    l: { keyCode: 76, key: 'l', code: 'KeyL' },
    m: { keyCode: 77, key: 'm', code: 'KeyM' },
    n: { keyCode: 78, key: 'n', code: 'KeyN' },
    o: { keyCode: 79, key: 'o', code: 'KeyO' },
    p: { keyCode: 80, key: 'p', code: 'KeyP' },
    q: { keyCode: 81, key: 'q', code: 'KeyQ' },
    r: { keyCode: 82, key: 'r', code: 'KeyR' },
    s: { keyCode: 83, key: 's', code: 'KeyS' },
    t: { keyCode: 84, key: 't', code: 'KeyT' },
    u: { keyCode: 85, key: 'u', code: 'KeyU' },
    v: { keyCode: 86, key: 'v', code: 'KeyV' },
    w: { keyCode: 87, key: 'w', code: 'KeyW' },
    x: { keyCode: 88, key: 'x', code: 'KeyX' },
    y: { keyCode: 89, key: 'y', code: 'KeyY' },
    z: { keyCode: 90, key: 'z', code: 'KeyZ' },
    Meta: { keyCode: 91, key: 'Meta', code: 'MetaLeft', location: 1 },
    '*': { keyCode: 106, key: '*', code: 'NumpadMultiply', location: 3 },
    '+': { keyCode: 107, key: '+', code: 'NumpadAdd', location: 3 },
    '-': { keyCode: 109, key: '-', code: 'NumpadSubtract', location: 3 },
    '/': { keyCode: 111, key: '/', code: 'NumpadDivide', location: 3 },
    ';': { keyCode: 186, key: ';', code: 'Semicolon' },
    '=': { keyCode: 187, key: '=', code: 'Equal' },
    ',': { keyCode: 188, key: ',', code: 'Comma' },
    '.': { keyCode: 190, key: '.', code: 'Period' },
    '`': { keyCode: 192, key: '`', code: 'Backquote' },
    '[': { keyCode: 219, key: '[', code: 'BracketLeft' },
    '\\': { keyCode: 220, key: '\\', code: 'Backslash' },
    ']': { keyCode: 221, key: ']', code: 'BracketRight' },
    "'": { keyCode: 222, key: "'", code: 'Quote' },
    Attn: { keyCode: 246, key: 'Attn' },
    CrSel: { keyCode: 247, key: 'CrSel', code: 'Props' },
    ExSel: { keyCode: 248, key: 'ExSel' },
    EraseEof: { keyCode: 249, key: 'EraseEof' },
    Play: { keyCode: 250, key: 'Play' },
    ZoomOut: { keyCode: 251, key: 'ZoomOut' },
    ')': { keyCode: 48, key: ')', code: 'Digit0' },
    '!': { keyCode: 49, key: '!', code: 'Digit1' },
    '@': { keyCode: 50, key: '@', code: 'Digit2' },
    '#': { keyCode: 51, key: '#', code: 'Digit3' },
    $: { keyCode: 52, key: '$', code: 'Digit4' },
    '%': { keyCode: 53, key: '%', code: 'Digit5' },
    '^': { keyCode: 54, key: '^', code: 'Digit6' },
    '&': { keyCode: 55, key: '&', code: 'Digit7' },
    '(': { keyCode: 57, key: '(', code: 'Digit9' },
    A: { keyCode: 65, key: 'A', code: 'KeyA' },
    B: { keyCode: 66, key: 'B', code: 'KeyB' },
    C: { keyCode: 67, key: 'C', code: 'KeyC' },
    D: { keyCode: 68, key: 'D', code: 'KeyD' },
    E: { keyCode: 69, key: 'E', code: 'KeyE' },
    F: { keyCode: 70, key: 'F', code: 'KeyF' },
    G: { keyCode: 71, key: 'G', code: 'KeyG' },
    H: { keyCode: 72, key: 'H', code: 'KeyH' },
    I: { keyCode: 73, key: 'I', code: 'KeyI' },
    J: { keyCode: 74, key: 'J', code: 'KeyJ' },
    K: { keyCode: 75, key: 'K', code: 'KeyK' },
    L: { keyCode: 76, key: 'L', code: 'KeyL' },
    M: { keyCode: 77, key: 'M', code: 'KeyM' },
    N: { keyCode: 78, key: 'N', code: 'KeyN' },
    O: { keyCode: 79, key: 'O', code: 'KeyO' },
    P: { keyCode: 80, key: 'P', code: 'KeyP' },
    Q: { keyCode: 81, key: 'Q', code: 'KeyQ' },
    R: { keyCode: 82, key: 'R', code: 'KeyR' },
    S: { keyCode: 83, key: 'S', code: 'KeyS' },
    T: { keyCode: 84, key: 'T', code: 'KeyT' },
    U: { keyCode: 85, key: 'U', code: 'KeyU' },
    V: { keyCode: 86, key: 'V', code: 'KeyV' },
    W: { keyCode: 87, key: 'W', code: 'KeyW' },
    X: { keyCode: 88, key: 'X', code: 'KeyX' },
    Y: { keyCode: 89, key: 'Y', code: 'KeyY' },
    Z: { keyCode: 90, key: 'Z', code: 'KeyZ' },
    ':': { keyCode: 186, key: ':', code: 'Semicolon' },
    '<': { keyCode: 188, key: '<', code: 'Comma' },
    _: { keyCode: 189, key: '_', code: 'Minus' },
    '>': { keyCode: 190, key: '>', code: 'Period' },
    '?': { keyCode: 191, key: '?', code: 'Slash' },
    '~': { keyCode: 192, key: '~', code: 'Backquote' },
    '{': { keyCode: 219, key: '{', code: 'BracketLeft' },
    '|': { keyCode: 220, key: '|', code: 'Backslash' },
    '}': { keyCode: 221, key: '}', code: 'BracketRight' },
    '"': { keyCode: 222, key: '"', code: 'Quote' },
    SoftLeft: { key: 'SoftLeft', code: 'SoftLeft', location: 4 },
    SoftRight: { key: 'SoftRight', code: 'SoftRight', location: 4 },
    Camera: { keyCode: 44, key: 'Camera', code: 'Camera', location: 4 },
    Call: { key: 'Call', code: 'Call', location: 4 },
    EndCall: { keyCode: 95, key: 'EndCall', code: 'EndCall', location: 4 },
    VolumeDown: {
        keyCode: 182,
        key: 'VolumeDown',
        code: 'VolumeDown',
        location: 4,
    },
    VolumeUp: { keyCode: 183, key: 'VolumeUp', code: 'VolumeUp', location: 4 },
};


/***/ }),

/***/ 6206:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebWorker = void 0;
/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EventEmitter_js_1 = __nccwpck_require__(241);
const helper_js_1 = __nccwpck_require__(4342);
const ExecutionContext_js_1 = __nccwpck_require__(6069);
const JSHandle_js_1 = __nccwpck_require__(859);
/**
 * The WebWorker class represents a
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.
 *
 * @remarks
 * The events `workercreated` and `workerdestroyed` are emitted on the page
 * object to signal the worker lifecycle.
 *
 * @example
 * ```js
 * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));
 * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));
 *
 * console.log('Current workers:');
 * for (const worker of page.workers()) {
 *   console.log('  ' + worker.url());
 * }
 * ```
 *
 * @public
 */
class WebWorker extends EventEmitter_js_1.EventEmitter {
    /**
     *
     * @internal
     */
    constructor(client, url, consoleAPICalled, exceptionThrown) {
        super();
        this._client = client;
        this._url = url;
        this._executionContextPromise = new Promise((x) => (this._executionContextCallback = x));
        let jsHandleFactory;
        this._client.once('Runtime.executionContextCreated', async (event) => {
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            jsHandleFactory = (remoteObject) => new JSHandle_js_1.JSHandle(executionContext, client, remoteObject);
            const executionContext = new ExecutionContext_js_1.ExecutionContext(client, event.context, null);
            this._executionContextCallback(executionContext);
        });
        // This might fail if the target is closed before we recieve all execution contexts.
        this._client.send('Runtime.enable').catch(helper_js_1.debugError);
        this._client.on('Runtime.consoleAPICalled', (event) => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));
        this._client.on('Runtime.exceptionThrown', (exception) => exceptionThrown(exception.exceptionDetails));
    }
    /**
     * @returns The URL of this web worker.
     */
    url() {
        return this._url;
    }
    /**
     * Returns the ExecutionContext the WebWorker runs in
     * @returns The ExecutionContext the web worker runs in.
     */
    async executionContext() {
        return this._executionContextPromise;
    }
    /**
     * If the function passed to the `worker.evaluate` returns a Promise, then
     * `worker.evaluate` would wait for the promise to resolve and return its
     * value. If the function passed to the `worker.evaluate` returns a
     * non-serializable value, then `worker.evaluate` resolves to `undefined`.
     * DevTools Protocol also supports transferring some additional values that
     * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and
     * bigint literals.
     * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.
     *
     * @param pageFunction - Function to be evaluated in the worker context.
     * @param args - Arguments to pass to `pageFunction`.
     * @returns Promise which resolves to the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
        return (await this._executionContextPromise).evaluate(pageFunction, ...args);
    }
    /**
     * The only difference between `worker.evaluate` and `worker.evaluateHandle`
     * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the
     * function passed to the `worker.evaluateHandle` returns a [Promise], then
     * `worker.evaluateHandle` would wait for the promise to resolve and return
     * its value. Shortcut for
     * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`
     *
     * @param pageFunction - Function to be evaluated in the page context.
     * @param args - Arguments to pass to `pageFunction`.
     * @returns Promise which resolves to the return value of `pageFunction`.
     */
    async evaluateHandle(pageFunction, ...args) {
        return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);
    }
}
exports.WebWorker = WebWorker;


/***/ }),

/***/ 4337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = void 0;
/**
 * Asserts that the given value is truthy.
 * @param value
 * @param message - the error message to throw if the value is not truthy.
 */
exports.assert = (value, message) => {
    if (!value)
        throw new Error(message);
};


/***/ }),

/***/ 4938:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFetch = void 0;
const environment_js_1 = __nccwpck_require__(4765);
/* Use the global version if we're in the browser, else load the node-fetch module. */
exports.getFetch = async () => {
    return environment_js_1.isNode ? await Promise.resolve().then(() => __importStar(__nccwpck_require__(9030))) : globalThis.fetch;
};


/***/ }),

/***/ 4342:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.helper = exports.debugError = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Errors_js_1 = __nccwpck_require__(6371);
const Debug_js_1 = __nccwpck_require__(7259);
const assert_js_1 = __nccwpck_require__(4337);
const environment_js_1 = __nccwpck_require__(4765);
exports.debugError = Debug_js_1.debug('puppeteer:error');
function getExceptionMessage(exceptionDetails) {
    if (exceptionDetails.exception)
        return (exceptionDetails.exception.description || exceptionDetails.exception.value);
    let message = exceptionDetails.text;
    if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
            const location = callframe.url +
                ':' +
                callframe.lineNumber +
                ':' +
                callframe.columnNumber;
            const functionName = callframe.functionName || '<anonymous>';
            message += `\n    at ${functionName} (${location})`;
        }
    }
    return message;
}
function valueFromRemoteObject(remoteObject) {
    assert_js_1.assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');
    if (remoteObject.unserializableValue) {
        if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined')
            return BigInt(remoteObject.unserializableValue.replace('n', ''));
        switch (remoteObject.unserializableValue) {
            case '-0':
                return -0;
            case 'NaN':
                return NaN;
            case 'Infinity':
                return Infinity;
            case '-Infinity':
                return -Infinity;
            default:
                throw new Error('Unsupported unserializable value: ' +
                    remoteObject.unserializableValue);
        }
    }
    return remoteObject.value;
}
async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId)
        return;
    await client
        .send('Runtime.releaseObject', { objectId: remoteObject.objectId })
        .catch((error) => {
        // Exceptions might happen in case of a page been navigated or closed.
        // Swallow these since they are harmless and we don't leak anything in this case.
        exports.debugError(error);
    });
}
function addEventListener(emitter, eventName, handler) {
    emitter.on(eventName, handler);
    return { emitter, eventName, handler };
}
function removeEventListeners(listeners) {
    for (const listener of listeners)
        listener.emitter.removeListener(listener.eventName, listener.handler);
    listeners.length = 0;
}
function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}
function isNumber(obj) {
    return typeof obj === 'number' || obj instanceof Number;
}
async function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
    let eventTimeout, resolveCallback, rejectCallback;
    const promise = new Promise((resolve, reject) => {
        resolveCallback = resolve;
        rejectCallback = reject;
    });
    const listener = addEventListener(emitter, eventName, (event) => {
        if (!predicate(event))
            return;
        resolveCallback(event);
    });
    if (timeout) {
        eventTimeout = setTimeout(() => {
            rejectCallback(new Errors_js_1.TimeoutError('Timeout exceeded while waiting for event'));
        }, timeout);
    }
    function cleanup() {
        removeEventListeners([listener]);
        clearTimeout(eventTimeout);
    }
    const result = await Promise.race([promise, abortPromise]).then((r) => {
        cleanup();
        return r;
    }, (error) => {
        cleanup();
        throw error;
    });
    if (result instanceof Error)
        throw result;
    return result;
}
function evaluationString(fun, ...args) {
    if (isString(fun)) {
        assert_js_1.assert(args.length === 0, 'Cannot evaluate a string with arguments');
        return fun;
    }
    function serializeArgument(arg) {
        if (Object.is(arg, undefined))
            return 'undefined';
        return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(',')})`;
}
function pageBindingInitString(type, name) {
    function addPageBinding(type, bindingName) {
        /* Cast window to any here as we're about to add properties to it
         * via win[bindingName] which TypeScript doesn't like.
         */
        const win = window;
        const binding = win[bindingName];
        win[bindingName] = (...args) => {
            const me = window[bindingName];
            let callbacks = me.callbacks;
            if (!callbacks) {
                callbacks = new Map();
                me.callbacks = callbacks;
            }
            const seq = (me.lastSeq || 0) + 1;
            me.lastSeq = seq;
            const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
            binding(JSON.stringify({ type, name: bindingName, seq, args }));
            return promise;
        };
    }
    return evaluationString(addPageBinding, type, name);
}
function pageBindingDeliverResultString(name, seq, result) {
    function deliverResult(name, seq, result) {
        window[name].callbacks.get(seq).resolve(result);
        window[name].callbacks.delete(seq);
    }
    return evaluationString(deliverResult, name, seq, result);
}
function pageBindingDeliverErrorString(name, seq, message, stack) {
    function deliverError(name, seq, message, stack) {
        const error = new Error(message);
        error.stack = stack;
        window[name].callbacks.get(seq).reject(error);
        window[name].callbacks.delete(seq);
    }
    return evaluationString(deliverError, name, seq, message, stack);
}
function pageBindingDeliverErrorValueString(name, seq, value) {
    function deliverErrorValue(name, seq, value) {
        window[name].callbacks.get(seq).reject(value);
        window[name].callbacks.delete(seq);
    }
    return evaluationString(deliverErrorValue, name, seq, value);
}
function makePredicateString(predicate, predicateQueryHandler) {
    function checkWaitForOptions(node, waitForVisible, waitForHidden) {
        if (!node)
            return waitForHidden;
        if (!waitForVisible && !waitForHidden)
            return node;
        const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
        const style = window.getComputedStyle(element);
        const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();
        const success = waitForVisible === isVisible || waitForHidden === !isVisible;
        return success ? node : null;
        function hasVisibleBoundingBox() {
            const rect = element.getBoundingClientRect();
            return !!(rect.top || rect.bottom || rect.width || rect.height);
        }
    }
    const predicateQueryHandlerDef = predicateQueryHandler
        ? `const predicateQueryHandler = ${predicateQueryHandler};`
        : '';
    return `
    (() => {
      ${predicateQueryHandlerDef}
      const checkWaitForOptions = ${checkWaitForOptions};
      return (${predicate})(...args)
    })() `;
}
async function waitWithTimeout(promise, taskName, timeout) {
    let reject;
    const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
    const timeoutPromise = new Promise((resolve, x) => (reject = x));
    let timeoutTimer = null;
    if (timeout)
        timeoutTimer = setTimeout(() => reject(timeoutError), timeout);
    try {
        return await Promise.race([promise, timeoutPromise]);
    }
    finally {
        if (timeoutTimer)
            clearTimeout(timeoutTimer);
    }
}
async function readProtocolStream(client, handle, path) {
    if (!environment_js_1.isNode && path) {
        throw new Error('Cannot write to a path outside of Node.js environment.');
    }
    const fs = environment_js_1.isNode ? await importFSModule() : null;
    let eof = false;
    let fileHandle;
    if (path && fs) {
        fileHandle = await fs.promises.open(path, 'w');
    }
    const bufs = [];
    while (!eof) {
        const response = await client.send('IO.read', { handle });
        eof = response.eof;
        const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);
        bufs.push(buf);
        if (path && fs) {
            await fs.promises.writeFile(fileHandle, buf);
        }
    }
    if (path)
        await fileHandle.close();
    await client.send('IO.close', { handle });
    let resultBuffer = null;
    try {
        resultBuffer = Buffer.concat(bufs);
    }
    finally {
        return resultBuffer;
    }
}
/**
 * Loads the Node fs promises API. Needed because on Node 10.17 and below,
 * fs.promises is experimental, and therefore not marked as enumerable. That
 * means when TypeScript compiles an `import('fs')`, its helper doesn't spot the
 * promises declaration and therefore on Node <10.17 you get an error as
 * fs.promises is undefined in compiled TypeScript land.
 *
 * See https://github.com/puppeteer/puppeteer/issues/6548 for more details.
 *
 * Once Node 10 is no longer supported (April 2021) we can remove this and use
 * `(await import('fs')).promises`.
 */
async function importFSModule() {
    if (!environment_js_1.isNode) {
        throw new Error('Cannot load the fs module API outside of Node.');
    }
    const fs = await Promise.resolve().then(() => __importStar(__nccwpck_require__(5747)));
    if (fs.promises) {
        return fs;
    }
    return fs.default;
}
exports.helper = {
    evaluationString,
    pageBindingInitString,
    pageBindingDeliverResultString,
    pageBindingDeliverErrorString,
    pageBindingDeliverErrorValueString,
    makePredicateString,
    readProtocolStream,
    waitWithTimeout,
    waitForEvent,
    isString,
    isNumber,
    importFSModule,
    addEventListener,
    removeEventListeners,
    valueFromRemoteObject,
    getExceptionMessage,
    releaseObject,
};


/***/ }),

/***/ 4765:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNode = void 0;
exports.isNode = !!(typeof process !== 'undefined' && process.version);


/***/ }),

/***/ 3124:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializePuppeteerNode = void 0;
const Puppeteer_js_1 = __nccwpck_require__(5165);
const revisions_js_1 = __nccwpck_require__(9354);
const pkg_dir_1 = __importDefault(__nccwpck_require__(6832));
exports.initializePuppeteerNode = (packageName) => {
    const puppeteerRootDirectory = pkg_dir_1.default.sync(__dirname);
    let preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.chromium;
    const isPuppeteerCore = packageName === 'puppeteer-core';
    // puppeteer-core ignores environment variables
    const productName = isPuppeteerCore
        ? undefined
        : process.env.PUPPETEER_PRODUCT ||
            process.env.npm_config_puppeteer_product ||
            process.env.npm_package_config_puppeteer_product;
    if (!isPuppeteerCore && productName === 'firefox')
        preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
    return new Puppeteer_js_1.PuppeteerNode({
        projectRoot: puppeteerRootDirectory,
        preferredRevision,
        isPuppeteerCore,
        productName: productName,
    });
};


/***/ }),

/***/ 8032:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const initialize_node_js_1 = __nccwpck_require__(3124);
const environment_js_1 = __nccwpck_require__(4765);
if (!environment_js_1.isNode) {
    throw new Error('Trying to run Puppeteer-Node in a web environment.');
}
exports.default = initialize_node_js_1.initializePuppeteerNode('puppeteer');


/***/ }),

/***/ 1445:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserFetcher = void 0;
const os = __importStar(__nccwpck_require__(2087));
const fs = __importStar(__nccwpck_require__(5747));
const path = __importStar(__nccwpck_require__(5622));
const util = __importStar(__nccwpck_require__(1669));
const childProcess = __importStar(__nccwpck_require__(3129));
const https = __importStar(__nccwpck_require__(7211));
const http = __importStar(__nccwpck_require__(8605));
const extract_zip_1 = __importDefault(__nccwpck_require__(6108));
const Debug_js_1 = __nccwpck_require__(7259);
const util_1 = __nccwpck_require__(1669);
const rimraf_1 = __importDefault(__nccwpck_require__(9859));
const URL = __importStar(__nccwpck_require__(8835));
const https_proxy_agent_1 = __importDefault(__nccwpck_require__(1383));
const proxy_from_env_1 = __nccwpck_require__(625);
const assert_js_1 = __nccwpck_require__(4337);
const debugFetcher = Debug_js_1.debug(`puppeteer:fetcher`);
const downloadURLs = {
    chrome: {
        linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',
        mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',
        win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',
        win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip',
    },
    firefox: {
        linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',
        mac: '%s/firefox-%s.en-US.%s.dmg',
        win32: '%s/firefox-%s.en-US.%s.zip',
        win64: '%s/firefox-%s.en-US.%s.zip',
    },
};
const browserConfig = {
    chrome: {
        host: 'https://storage.googleapis.com',
        destination: '.local-chromium',
    },
    firefox: {
        host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',
        destination: '.local-firefox',
    },
};
function archiveName(product, platform, revision) {
    if (product === 'chrome') {
        if (platform === 'linux')
            return 'chrome-linux';
        if (platform === 'mac')
            return 'chrome-mac';
        if (platform === 'win32' || platform === 'win64') {
            // Windows archive name changed at r591479.
            return parseInt(revision, 10) > 591479 ? 'chrome-win' : 'chrome-win32';
        }
    }
    else if (product === 'firefox') {
        return platform;
    }
}
/**
 * @internal
 */
function downloadURL(product, platform, host, revision) {
    const url = util.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));
    return url;
}
/**
 * @internal
 */
function handleArm64() {
    fs.stat('/usr/bin/chromium-browser', function (err, stats) {
        if (stats === undefined) {
            console.error(`The chromium binary is not available for arm64: `);
            console.error(`If you are on Ubuntu, you can install with: `);
            console.error(`\n apt-get install chromium-browser\n`);
            throw new Error();
        }
    });
}
const readdirAsync = util_1.promisify(fs.readdir.bind(fs));
const mkdirAsync = util_1.promisify(fs.mkdir.bind(fs));
const unlinkAsync = util_1.promisify(fs.unlink.bind(fs));
const chmodAsync = util_1.promisify(fs.chmod.bind(fs));
function existsAsync(filePath) {
    return new Promise((resolve) => {
        fs.access(filePath, (err) => resolve(!err));
    });
}
/**
 * BrowserFetcher can download and manage different versions of Chromium and Firefox.
 *
 * @remarks
 * BrowserFetcher operates on revision strings that specify a precise version of Chromium, e.g. `"533271"`. Revision strings can be obtained from {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}.
 * In the Firefox case, BrowserFetcher downloads Firefox Nightly and
 * operates on version numbers such as `"75"`.
 *
 * @example
 * An example of using BrowserFetcher to download a specific version of Chromium
 * and running Puppeteer against it:
 *
 * ```js
 * const browserFetcher = puppeteer.createBrowserFetcher();
 * const revisionInfo = await browserFetcher.download('533271');
 * const browser = await puppeteer.launch({executablePath: revisionInfo.executablePath})
 * ```
 *
 * **NOTE** BrowserFetcher is not designed to work concurrently with other
 * instances of BrowserFetcher that share the same downloads directory.
 *
 * @public
 */
class BrowserFetcher {
    /**
     * @internal
     */
    constructor(projectRoot, options = {}) {
        this._product = (options.product || 'chrome').toLowerCase();
        assert_js_1.assert(this._product === 'chrome' || this._product === 'firefox', `Unknown product: "${options.product}"`);
        this._downloadsFolder =
            options.path ||
                path.join(projectRoot, browserConfig[this._product].destination);
        this._downloadHost = options.host || browserConfig[this._product].host;
        this.setPlatform(options.platform);
        assert_js_1.assert(downloadURLs[this._product][this._platform], 'Unsupported platform: ' + this._platform);
    }
    setPlatform(platformFromOptions) {
        if (platformFromOptions) {
            this._platform = platformFromOptions;
            return;
        }
        const platform = os.platform();
        if (platform === 'darwin')
            this._platform = 'mac';
        else if (platform === 'linux')
            this._platform = 'linux';
        else if (platform === 'win32')
            this._platform = os.arch() === 'x64' ? 'win64' : 'win32';
        else
            assert_js_1.assert(this._platform, 'Unsupported platform: ' + os.platform());
    }
    /**
     * @returns Returns the current `Platform`.
     */
    platform() {
        return this._platform;
    }
    /**
     * @returns Returns the current `Product`.
     */
    product() {
        return this._product;
    }
    /**
     * @returns The download host being used.
     */
    host() {
        return this._downloadHost;
    }
    /**
     * Initiates a HEAD request to check if the revision is available.
     * @remarks
     * This method is affected by the current `product`.
     * @param revision - The revision to check availability for.
     * @returns A promise that resolves to `true` if the revision could be downloaded
     * from the host.
     */
    canDownload(revision) {
        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);
        return new Promise((resolve) => {
            const request = httpRequest(url, 'HEAD', (response) => {
                resolve(response.statusCode === 200);
            });
            request.on('error', (error) => {
                console.error(error);
                resolve(false);
            });
        });
    }
    /**
     * Initiates a GET request to download the revision from the host.
     * @remarks
     * This method is affected by the current `product`.
     * @param revision - The revision to download.
     * @param progressCallback - A function that will be called with two arguments:
     * How many bytes have been downloaded and the total number of bytes of the download.
     * @returns A promise with revision information when the revision is downloaded
     * and extracted.
     */
    async download(revision, progressCallback = () => { }) {
        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);
        const fileName = url.split('/').pop();
        const archivePath = path.join(this._downloadsFolder, fileName);
        const outputPath = this._getFolderPath(revision);
        if (await existsAsync(outputPath))
            return this.revisionInfo(revision);
        if (!(await existsAsync(this._downloadsFolder)))
            await mkdirAsync(this._downloadsFolder);
        if (os.arch() === 'arm64') {
            handleArm64();
            return;
        }
        try {
            await downloadFile(url, archivePath, progressCallback);
            await install(archivePath, outputPath);
        }
        finally {
            if (await existsAsync(archivePath))
                await unlinkAsync(archivePath);
        }
        const revisionInfo = this.revisionInfo(revision);
        if (revisionInfo)
            await chmodAsync(revisionInfo.executablePath, 0o755);
        return revisionInfo;
    }
    /**
     * @remarks
     * This method is affected by the current `product`.
     * @returns A promise with a list of all revision strings (for the current `product`)
     * available locally on disk.
     */
    async localRevisions() {
        if (!(await existsAsync(this._downloadsFolder)))
            return [];
        const fileNames = await readdirAsync(this._downloadsFolder);
        return fileNames
            .map((fileName) => parseFolderPath(this._product, fileName))
            .filter((entry) => entry && entry.platform === this._platform)
            .map((entry) => entry.revision);
    }
    /**
     * @remarks
     * This method is affected by the current `product`.
     * @param revision - A revision to remove for the current `product`.
     * @returns A promise that resolves when the revision has been removes or
     * throws if the revision has not been downloaded.
     */
    async remove(revision) {
        const folderPath = this._getFolderPath(revision);
        assert_js_1.assert(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);
        await new Promise((fulfill) => rimraf_1.default(folderPath, fulfill));
    }
    /**
     * @param revision - The revision to get info for.
     * @returns The revision info for the given revision.
     */
    revisionInfo(revision) {
        const folderPath = this._getFolderPath(revision);
        let executablePath = '';
        if (this._product === 'chrome') {
            if (this._platform === 'mac')
                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');
            else if (this._platform === 'linux')
                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome');
            else if (this._platform === 'win32' || this._platform === 'win64')
                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome.exe');
            else
                throw new Error('Unsupported platform: ' + this._platform);
        }
        else if (this._product === 'firefox') {
            if (this._platform === 'mac')
                executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');
            else if (this._platform === 'linux')
                executablePath = path.join(folderPath, 'firefox', 'firefox');
            else if (this._platform === 'win32' || this._platform === 'win64')
                executablePath = path.join(folderPath, 'firefox', 'firefox.exe');
            else
                throw new Error('Unsupported platform: ' + this._platform);
        }
        else {
            throw new Error('Unsupported product: ' + this._product);
        }
        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);
        const local = fs.existsSync(folderPath);
        debugFetcher({
            revision,
            executablePath,
            folderPath,
            local,
            url,
            product: this._product,
        });
        return {
            revision,
            executablePath,
            folderPath,
            local,
            url,
            product: this._product,
        };
    }
    /**
     * @internal
     */
    _getFolderPath(revision) {
        return path.join(this._downloadsFolder, this._platform + '-' + revision);
    }
}
exports.BrowserFetcher = BrowserFetcher;
function parseFolderPath(product, folderPath) {
    const name = path.basename(folderPath);
    const splits = name.split('-');
    if (splits.length !== 2)
        return null;
    const [platform, revision] = splits;
    if (!downloadURLs[product][platform])
        return null;
    return { product, platform, revision };
}
/**
 * @internal
 */
function downloadFile(url, destinationPath, progressCallback) {
    debugFetcher(`Downloading binary from ${url}`);
    let fulfill, reject;
    let downloadedBytes = 0;
    let totalBytes = 0;
    const promise = new Promise((x, y) => {
        fulfill = x;
        reject = y;
    });
    const request = httpRequest(url, 'GET', (response) => {
        if (response.statusCode !== 200) {
            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
            // consume response data to free up memory
            response.resume();
            reject(error);
            return;
        }
        const file = fs.createWriteStream(destinationPath);
        file.on('finish', () => fulfill());
        file.on('error', (error) => reject(error));
        response.pipe(file);
        totalBytes = parseInt(
        /** @type {string} */ response.headers['content-length'], 10);
        if (progressCallback)
            response.on('data', onData);
    });
    request.on('error', (error) => reject(error));
    return promise;
    function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
    }
}
function install(archivePath, folderPath) {
    debugFetcher(`Installing ${archivePath} to ${folderPath}`);
    if (archivePath.endsWith('.zip'))
        return extract_zip_1.default(archivePath, { dir: folderPath });
    else if (archivePath.endsWith('.tar.bz2'))
        return extractTar(archivePath, folderPath);
    else if (archivePath.endsWith('.dmg'))
        return mkdirAsync(folderPath).then(() => installDMG(archivePath, folderPath));
    else
        throw new Error(`Unsupported archive format: ${archivePath}`);
}
/**
 * @internal
 */
function extractTar(tarPath, folderPath) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const tar = __nccwpck_require__(7789);
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const bzip = __nccwpck_require__(8239);
    return new Promise((fulfill, reject) => {
        const tarStream = tar.extract(folderPath);
        tarStream.on('error', reject);
        tarStream.on('finish', fulfill);
        const readStream = fs.createReadStream(tarPath);
        readStream.pipe(bzip()).pipe(tarStream);
    });
}
/**
 * @internal
 */
function installDMG(dmgPath, folderPath) {
    let mountPath;
    function mountAndCopy(fulfill, reject) {
        const mountCommand = `hdiutil attach -nobrowse -noautoopen "${dmgPath}"`;
        childProcess.exec(mountCommand, (err, stdout) => {
            if (err)
                return reject(err);
            const volumes = stdout.match(/\/Volumes\/(.*)/m);
            if (!volumes)
                return reject(new Error(`Could not find volume path in ${stdout}`));
            mountPath = volumes[0];
            readdirAsync(mountPath)
                .then((fileNames) => {
                const appName = fileNames.filter((item) => typeof item === 'string' && item.endsWith('.app'))[0];
                if (!appName)
                    return reject(new Error(`Cannot find app in ${mountPath}`));
                const copyPath = path.join(mountPath, appName);
                debugFetcher(`Copying ${copyPath} to ${folderPath}`);
                childProcess.exec(`cp -R "${copyPath}" "${folderPath}"`, (err) => {
                    if (err)
                        reject(err);
                    else
                        fulfill();
                });
            })
                .catch(reject);
        });
    }
    function unmount() {
        if (!mountPath)
            return;
        const unmountCommand = `hdiutil detach "${mountPath}" -quiet`;
        debugFetcher(`Unmounting ${mountPath}`);
        childProcess.exec(unmountCommand, (err) => {
            if (err)
                console.error(`Error unmounting dmg: ${err}`);
        });
    }
    return new Promise(mountAndCopy)
        .catch((error) => {
        console.error(error);
    })
        .finally(unmount);
}
function httpRequest(url, method, response) {
    const urlParsed = URL.parse(url);
    let options = {
        ...urlParsed,
        method,
    };
    const proxyURL = proxy_from_env_1.getProxyForUrl(url);
    if (proxyURL) {
        if (url.startsWith('http:')) {
            const proxy = URL.parse(proxyURL);
            options = {
                path: options.href,
                host: proxy.hostname,
                port: proxy.port,
            };
        }
        else {
            const parsedProxyURL = URL.parse(proxyURL);
            const proxyOptions = {
                ...parsedProxyURL,
                secureProxy: parsedProxyURL.protocol === 'https:',
            };
            options.agent = new https_proxy_agent_1.default(proxyOptions);
            options.rejectUnauthorized = false;
        }
    }
    const requestCallback = (res) => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)
            httpRequest(res.headers.location, method, response);
        else
            response(res);
    };
    const request = options.protocol === 'https:'
        ? https.request(options, requestCallback)
        : http.request(options, requestCallback);
    request.end();
    return request;
}


/***/ }),

/***/ 723:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserRunner = void 0;
const Debug_js_1 = __nccwpck_require__(7259);
const rimraf_1 = __importDefault(__nccwpck_require__(9859));
const childProcess = __importStar(__nccwpck_require__(3129));
const assert_js_1 = __nccwpck_require__(4337);
const helper_js_1 = __nccwpck_require__(4342);
const Connection_js_1 = __nccwpck_require__(402);
const NodeWebSocketTransport_js_1 = __nccwpck_require__(4402);
const PipeTransport_js_1 = __nccwpck_require__(3043);
const readline = __importStar(__nccwpck_require__(1058));
const Errors_js_1 = __nccwpck_require__(6371);
const util_1 = __nccwpck_require__(1669);
const removeFolderAsync = util_1.promisify(rimraf_1.default);
const debugLauncher = Debug_js_1.debug('puppeteer:launcher');
const PROCESS_ERROR_EXPLANATION = `Puppeteer was unable to kill the process which ran the browser binary.
This means that, on future Puppeteer launches, Puppeteer might not be able to launch the browser.
Please check your open processes and ensure that the browser processes that Puppeteer launched have been killed.
If you think this is a bug, please report it on the Puppeteer issue tracker.`;
class BrowserRunner {
    constructor(executablePath, processArguments, tempDirectory) {
        this.proc = null;
        this.connection = null;
        this._closed = true;
        this._listeners = [];
        this._executablePath = executablePath;
        this._processArguments = processArguments;
        this._tempDirectory = tempDirectory;
    }
    start(options) {
        const { handleSIGINT, handleSIGTERM, handleSIGHUP, dumpio, env, pipe, } = options;
        let stdio = ['pipe', 'pipe', 'pipe'];
        if (pipe) {
            if (dumpio)
                stdio = ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'];
            else
                stdio = ['ignore', 'ignore', 'ignore', 'pipe', 'pipe'];
        }
        assert_js_1.assert(!this.proc, 'This process has previously been started.');
        debugLauncher(`Calling ${this._executablePath} ${this._processArguments.join(' ')}`);
        this.proc = childProcess.spawn(this._executablePath, this._processArguments, {
            // On non-windows platforms, `detached: true` makes child process a
            // leader of a new process group, making it possible to kill child
            // process tree with `.kill(-pid)` command. @see
            // https://nodejs.org/api/child_process.html#child_process_options_detached
            detached: process.platform !== 'win32',
            env,
            stdio,
        });
        if (dumpio) {
            this.proc.stderr.pipe(process.stderr);
            this.proc.stdout.pipe(process.stdout);
        }
        this._closed = false;
        this._processClosing = new Promise((fulfill) => {
            this.proc.once('exit', () => {
                this._closed = true;
                // Cleanup as processes exit.
                if (this._tempDirectory) {
                    removeFolderAsync(this._tempDirectory)
                        .then(() => fulfill())
                        .catch((error) => console.error(error));
                }
                else {
                    fulfill();
                }
            });
        });
        this._listeners = [
            helper_js_1.helper.addEventListener(process, 'exit', this.kill.bind(this)),
        ];
        if (handleSIGINT)
            this._listeners.push(helper_js_1.helper.addEventListener(process, 'SIGINT', () => {
                this.kill();
                process.exit(130);
            }));
        if (handleSIGTERM)
            this._listeners.push(helper_js_1.helper.addEventListener(process, 'SIGTERM', this.close.bind(this)));
        if (handleSIGHUP)
            this._listeners.push(helper_js_1.helper.addEventListener(process, 'SIGHUP', this.close.bind(this)));
    }
    close() {
        if (this._closed)
            return Promise.resolve();
        if (this._tempDirectory) {
            this.kill();
        }
        else if (this.connection) {
            // Attempt to close the browser gracefully
            this.connection.send('Browser.close').catch((error) => {
                helper_js_1.debugError(error);
                this.kill();
            });
        }
        // Cleanup this listener last, as that makes sure the full callback runs. If we
        // perform this earlier, then the previous function calls would not happen.
        helper_js_1.helper.removeEventListeners(this._listeners);
        return this._processClosing;
    }
    kill() {
        // Attempt to remove temporary profile directory to avoid littering.
        try {
            rimraf_1.default.sync(this._tempDirectory);
        }
        catch (error) { }
        // If the process failed to launch (for example if the browser executable path
        // is invalid), then the process does not get a pid assigned. A call to
        // `proc.kill` would error, as the `pid` to-be-killed can not be found.
        if (this.proc && this.proc.pid && !this.proc.killed) {
            try {
                this.proc.kill('SIGKILL');
            }
            catch (error) {
                throw new Error(`${PROCESS_ERROR_EXPLANATION}\nError cause: ${error.stack}`);
            }
        }
        // Cleanup this listener last, as that makes sure the full callback runs. If we
        // perform this earlier, then the previous function calls would not happen.
        helper_js_1.helper.removeEventListeners(this._listeners);
    }
    async setupConnection(options) {
        const { usePipe, timeout, slowMo, preferredRevision } = options;
        if (!usePipe) {
            const browserWSEndpoint = await waitForWSEndpoint(this.proc, timeout, preferredRevision);
            const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
            this.connection = new Connection_js_1.Connection(browserWSEndpoint, transport, slowMo);
        }
        else {
            // stdio was assigned during start(), and the 'pipe' option there adds the
            // 4th and 5th items to stdio array
            const { 3: pipeWrite, 4: pipeRead } = this.proc.stdio;
            const transport = new PipeTransport_js_1.PipeTransport(pipeWrite, pipeRead);
            this.connection = new Connection_js_1.Connection('', transport, slowMo);
        }
        return this.connection;
    }
}
exports.BrowserRunner = BrowserRunner;
function waitForWSEndpoint(browserProcess, timeout, preferredRevision) {
    return new Promise((resolve, reject) => {
        const rl = readline.createInterface({ input: browserProcess.stderr });
        let stderr = '';
        const listeners = [
            helper_js_1.helper.addEventListener(rl, 'line', onLine),
            helper_js_1.helper.addEventListener(rl, 'close', () => onClose()),
            helper_js_1.helper.addEventListener(browserProcess, 'exit', () => onClose()),
            helper_js_1.helper.addEventListener(browserProcess, 'error', (error) => onClose(error)),
        ];
        const timeoutId = timeout ? setTimeout(onTimeout, timeout) : 0;
        /**
         * @param {!Error=} error
         */
        function onClose(error) {
            cleanup();
            reject(new Error([
                'Failed to launch the browser process!' +
                    (error ? ' ' + error.message : ''),
                stderr,
                '',
                'TROUBLESHOOTING: https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md',
                '',
            ].join('\n')));
        }
        function onTimeout() {
            cleanup();
            reject(new Errors_js_1.TimeoutError(`Timed out after ${timeout} ms while trying to connect to the browser! Only Chrome at revision r${preferredRevision} is guaranteed to work.`));
        }
        function onLine(line) {
            stderr += line + '\n';
            const match = line.match(/^DevTools listening on (ws:\/\/.*)$/);
            if (!match)
                return;
            cleanup();
            resolve(match[1]);
        }
        function cleanup() {
            if (timeoutId)
                clearTimeout(timeoutId);
            helper_js_1.helper.removeEventListeners(listeners);
        }
    });
}


/***/ }),

/***/ 2956:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const os = __importStar(__nccwpck_require__(2087));
const path = __importStar(__nccwpck_require__(5622));
const fs = __importStar(__nccwpck_require__(5747));
const BrowserFetcher_js_1 = __nccwpck_require__(1445);
const Browser_js_1 = __nccwpck_require__(4523);
const BrowserRunner_js_1 = __nccwpck_require__(723);
const util_1 = __nccwpck_require__(1669);
const mkdtempAsync = util_1.promisify(fs.mkdtemp);
const writeFileAsync = util_1.promisify(fs.writeFile);
/**
 * @internal
 */
class ChromeLauncher {
    constructor(projectRoot, preferredRevision, isPuppeteerCore) {
        this._projectRoot = projectRoot;
        this._preferredRevision = preferredRevision;
        this._isPuppeteerCore = isPuppeteerCore;
    }
    async launch(options = {}) {
        const { ignoreDefaultArgs = false, args = [], dumpio = false, executablePath = null, pipe = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, slowMo = 0, timeout = 30000, } = options;
        const profilePath = path.join(os.tmpdir(), 'puppeteer_dev_chrome_profile-');
        const chromeArguments = [];
        if (!ignoreDefaultArgs)
            chromeArguments.push(...this.defaultArgs(options));
        else if (Array.isArray(ignoreDefaultArgs))
            chromeArguments.push(...this.defaultArgs(options).filter((arg) => !ignoreDefaultArgs.includes(arg)));
        else
            chromeArguments.push(...args);
        let temporaryUserDataDir = null;
        if (!chromeArguments.some((argument) => argument.startsWith('--remote-debugging-')))
            chromeArguments.push(pipe ? '--remote-debugging-pipe' : '--remote-debugging-port=0');
        if (!chromeArguments.some((arg) => arg.startsWith('--user-data-dir'))) {
            temporaryUserDataDir = await mkdtempAsync(profilePath);
            chromeArguments.push(`--user-data-dir=${temporaryUserDataDir}`);
        }
        let chromeExecutable = executablePath;
        if (os.arch() === 'arm64') {
            chromeExecutable = '/usr/bin/chromium-browser';
        }
        else if (!executablePath) {
            const { missingText, executablePath } = resolveExecutablePath(this);
            if (missingText)
                throw new Error(missingText);
            chromeExecutable = executablePath;
        }
        const usePipe = chromeArguments.includes('--remote-debugging-pipe');
        const runner = new BrowserRunner_js_1.BrowserRunner(chromeExecutable, chromeArguments, temporaryUserDataDir);
        runner.start({
            handleSIGHUP,
            handleSIGTERM,
            handleSIGINT,
            dumpio,
            env,
            pipe: usePipe,
        });
        try {
            const connection = await runner.setupConnection({
                usePipe,
                timeout,
                slowMo,
                preferredRevision: this._preferredRevision,
            });
            const browser = await Browser_js_1.Browser.create(connection, [], ignoreHTTPSErrors, defaultViewport, runner.proc, runner.close.bind(runner));
            await browser.waitForTarget((t) => t.type() === 'page');
            return browser;
        }
        catch (error) {
            runner.kill();
            throw error;
        }
    }
    /**
     * @param {!Launcher.ChromeArgOptions=} options
     * @returns {!Array<string>}
     */
    defaultArgs(options = {}) {
        const chromeArguments = [
            '--disable-background-networking',
            '--enable-features=NetworkService,NetworkServiceInProcess',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-breakpad',
            '--disable-client-side-phishing-detection',
            '--disable-component-extensions-with-background-pages',
            '--disable-default-apps',
            '--disable-dev-shm-usage',
            '--disable-extensions',
            '--disable-features=TranslateUI',
            '--disable-hang-monitor',
            '--disable-ipc-flooding-protection',
            '--disable-popup-blocking',
            '--disable-prompt-on-repost',
            '--disable-renderer-backgrounding',
            '--disable-sync',
            '--force-color-profile=srgb',
            '--metrics-recording-only',
            '--no-first-run',
            '--enable-automation',
            '--password-store=basic',
            '--use-mock-keychain',
            // TODO(sadym): remove '--enable-blink-features=IdleDetection'
            // once IdleDetection is turned on by default.
            '--enable-blink-features=IdleDetection',
        ];
        const { devtools = false, headless = !devtools, args = [], userDataDir = null, } = options;
        if (userDataDir)
            chromeArguments.push(`--user-data-dir=${path.resolve(userDataDir)}`);
        if (devtools)
            chromeArguments.push('--auto-open-devtools-for-tabs');
        if (headless) {
            chromeArguments.push('--headless', '--hide-scrollbars', '--mute-audio');
        }
        if (args.every((arg) => arg.startsWith('-')))
            chromeArguments.push('about:blank');
        chromeArguments.push(...args);
        return chromeArguments;
    }
    executablePath() {
        return resolveExecutablePath(this).executablePath;
    }
    get product() {
        return 'chrome';
    }
}
/**
 * @internal
 */
class FirefoxLauncher {
    constructor(projectRoot, preferredRevision, isPuppeteerCore) {
        this._projectRoot = projectRoot;
        this._preferredRevision = preferredRevision;
        this._isPuppeteerCore = isPuppeteerCore;
    }
    async launch(options = {}) {
        const { ignoreDefaultArgs = false, args = [], dumpio = false, executablePath = null, pipe = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, slowMo = 0, timeout = 30000, extraPrefsFirefox = {}, } = options;
        const firefoxArguments = [];
        if (!ignoreDefaultArgs)
            firefoxArguments.push(...this.defaultArgs(options));
        else if (Array.isArray(ignoreDefaultArgs))
            firefoxArguments.push(...this.defaultArgs(options).filter((arg) => !ignoreDefaultArgs.includes(arg)));
        else
            firefoxArguments.push(...args);
        if (!firefoxArguments.some((argument) => argument.startsWith('--remote-debugging-')))
            firefoxArguments.push('--remote-debugging-port=0');
        let temporaryUserDataDir = null;
        if (!firefoxArguments.includes('-profile') &&
            !firefoxArguments.includes('--profile')) {
            temporaryUserDataDir = await this._createProfile(extraPrefsFirefox);
            firefoxArguments.push('--profile');
            firefoxArguments.push(temporaryUserDataDir);
        }
        await this._updateRevision();
        let firefoxExecutable = executablePath;
        if (!executablePath) {
            const { missingText, executablePath } = resolveExecutablePath(this);
            if (missingText)
                throw new Error(missingText);
            firefoxExecutable = executablePath;
        }
        const runner = new BrowserRunner_js_1.BrowserRunner(firefoxExecutable, firefoxArguments, temporaryUserDataDir);
        runner.start({
            handleSIGHUP,
            handleSIGTERM,
            handleSIGINT,
            dumpio,
            env,
            pipe,
        });
        try {
            const connection = await runner.setupConnection({
                usePipe: pipe,
                timeout,
                slowMo,
                preferredRevision: this._preferredRevision,
            });
            const browser = await Browser_js_1.Browser.create(connection, [], ignoreHTTPSErrors, defaultViewport, runner.proc, runner.close.bind(runner));
            await browser.waitForTarget((t) => t.type() === 'page');
            return browser;
        }
        catch (error) {
            runner.kill();
            throw error;
        }
    }
    executablePath() {
        return resolveExecutablePath(this).executablePath;
    }
    async _updateRevision() {
        // replace 'latest' placeholder with actual downloaded revision
        if (this._preferredRevision === 'latest') {
            const browserFetcher = new BrowserFetcher_js_1.BrowserFetcher(this._projectRoot, {
                product: this.product,
            });
            const localRevisions = await browserFetcher.localRevisions();
            if (localRevisions[0])
                this._preferredRevision = localRevisions[0];
        }
    }
    get product() {
        return 'firefox';
    }
    defaultArgs(options = {}) {
        const firefoxArguments = ['--no-remote', '--foreground'];
        if (os.platform().startsWith('win')) {
            firefoxArguments.push('--wait-for-browser');
        }
        const { devtools = false, headless = !devtools, args = [], userDataDir = null, } = options;
        if (userDataDir) {
            firefoxArguments.push('--profile');
            firefoxArguments.push(userDataDir);
        }
        if (headless)
            firefoxArguments.push('--headless');
        if (devtools)
            firefoxArguments.push('--devtools');
        if (args.every((arg) => arg.startsWith('-')))
            firefoxArguments.push('about:blank');
        firefoxArguments.push(...args);
        return firefoxArguments;
    }
    async _createProfile(extraPrefs) {
        const profilePath = await mkdtempAsync(path.join(os.tmpdir(), 'puppeteer_dev_firefox_profile-'));
        const prefsJS = [];
        const userJS = [];
        const server = 'dummy.test';
        const defaultPreferences = {
            // Make sure Shield doesn't hit the network.
            'app.normandy.api_url': '',
            // Disable Firefox old build background check
            'app.update.checkInstallTime': false,
            // Disable automatically upgrading Firefox
            'app.update.disabledForTesting': true,
            // Increase the APZ content response timeout to 1 minute
            'apz.content_response_timeout': 60000,
            // Prevent various error message on the console
            // jest-puppeteer asserts that no error message is emitted by the console
            'browser.contentblocking.features.standard': '-tp,tpPrivate,cookieBehavior0,-cm,-fp',
            // Enable the dump function: which sends messages to the system
            // console
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115
            'browser.dom.window.dump.enabled': true,
            // Disable topstories
            'browser.newtabpage.activity-stream.feeds.system.topstories': false,
            // Always display a blank page
            'browser.newtabpage.enabled': false,
            // Background thumbnails in particular cause grief: and disabling
            // thumbnails in general cannot hurt
            'browser.pagethumbnails.capturing_disabled': true,
            // Disable safebrowsing components.
            'browser.safebrowsing.blockedURIs.enabled': false,
            'browser.safebrowsing.downloads.enabled': false,
            'browser.safebrowsing.malware.enabled': false,
            'browser.safebrowsing.passwords.enabled': false,
            'browser.safebrowsing.phishing.enabled': false,
            // Disable updates to search engines.
            'browser.search.update': false,
            // Do not restore the last open set of tabs if the browser has crashed
            'browser.sessionstore.resume_from_crash': false,
            // Skip check for default browser on startup
            'browser.shell.checkDefaultBrowser': false,
            // Disable newtabpage
            'browser.startup.homepage': 'about:blank',
            // Do not redirect user when a milstone upgrade of Firefox is detected
            'browser.startup.homepage_override.mstone': 'ignore',
            // Start with a blank page about:blank
            'browser.startup.page': 0,
            // Do not allow background tabs to be zombified on Android: otherwise for
            // tests that open additional tabs: the test harness tab itself might get
            // unloaded
            'browser.tabs.disableBackgroundZombification': false,
            // Do not warn when closing all other open tabs
            'browser.tabs.warnOnCloseOtherTabs': false,
            // Do not warn when multiple tabs will be opened
            'browser.tabs.warnOnOpen': false,
            // Disable the UI tour.
            'browser.uitour.enabled': false,
            // Turn off search suggestions in the location bar so as not to trigger
            // network connections.
            'browser.urlbar.suggest.searches': false,
            // Disable first run splash page on Windows 10
            'browser.usedOnWindows10.introURL': '',
            // Do not warn on quitting Firefox
            'browser.warnOnQuit': false,
            // Defensively disable data reporting systems
            'datareporting.healthreport.documentServerURI': `http://${server}/dummy/healthreport/`,
            'datareporting.healthreport.logging.consoleEnabled': false,
            'datareporting.healthreport.service.enabled': false,
            'datareporting.healthreport.service.firstRun': false,
            'datareporting.healthreport.uploadEnabled': false,
            // Do not show datareporting policy notifications which can interfere with tests
            'datareporting.policy.dataSubmissionEnabled': false,
            'datareporting.policy.dataSubmissionPolicyBypassNotification': true,
            // DevTools JSONViewer sometimes fails to load dependencies with its require.js.
            // This doesn't affect Puppeteer but spams console (Bug 1424372)
            'devtools.jsonview.enabled': false,
            // Disable popup-blocker
            'dom.disable_open_during_load': false,
            // Enable the support for File object creation in the content process
            // Required for |Page.setFileInputFiles| protocol method.
            'dom.file.createInChild': true,
            // Disable the ProcessHangMonitor
            'dom.ipc.reportProcessHangs': false,
            // Disable slow script dialogues
            'dom.max_chrome_script_run_time': 0,
            'dom.max_script_run_time': 0,
            // Only load extensions from the application and user profile
            // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
            'extensions.autoDisableScopes': 0,
            'extensions.enabledScopes': 5,
            // Disable metadata caching for installed add-ons by default
            'extensions.getAddons.cache.enabled': false,
            // Disable installing any distribution extensions or add-ons.
            'extensions.installDistroAddons': false,
            // Disabled screenshots extension
            'extensions.screenshots.disabled': true,
            // Turn off extension updates so they do not bother tests
            'extensions.update.enabled': false,
            // Turn off extension updates so they do not bother tests
            'extensions.update.notifyUser': false,
            // Make sure opening about:addons will not hit the network
            'extensions.webservice.discoverURL': `http://${server}/dummy/discoveryURL`,
            // Allow the application to have focus even it runs in the background
            'focusmanager.testmode': true,
            // Disable useragent updates
            'general.useragent.updates.enabled': false,
            // Always use network provider for geolocation tests so we bypass the
            // macOS dialog raised by the corelocation provider
            'geo.provider.testing': true,
            // Do not scan Wifi
            'geo.wifi.scan': false,
            // No hang monitor
            'hangmonitor.timeout': 0,
            // Show chrome errors and warnings in the error console
            'javascript.options.showInConsole': true,
            // Disable download and usage of OpenH264: and Widevine plugins
            'media.gmp-manager.updateEnabled': false,
            // Prevent various error message on the console
            // jest-puppeteer asserts that no error message is emitted by the console
            'network.cookie.cookieBehavior': 0,
            // Do not prompt for temporary redirects
            'network.http.prompt-temp-redirect': false,
            // Disable speculative connections so they are not reported as leaking
            // when they are hanging around
            'network.http.speculative-parallel-limit': 0,
            // Do not automatically switch between offline and online
            'network.manage-offline-status': false,
            // Make sure SNTP requests do not hit the network
            'network.sntp.pools': server,
            // Disable Flash.
            'plugin.state.flash': 0,
            'privacy.trackingprotection.enabled': false,
            // Enable Remote Agent
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1544393
            'remote.enabled': true,
            // Don't do network connections for mitm priming
            'security.certerrors.mitm.priming.enabled': false,
            // Local documents have access to all other local documents,
            // including directory listings
            'security.fileuri.strict_origin_policy': false,
            // Do not wait for the notification button security delay
            'security.notification_enable_delay': 0,
            // Ensure blocklist updates do not hit the network
            'services.settings.server': `http://${server}/dummy/blocklist/`,
            // Do not automatically fill sign-in forms with known usernames and
            // passwords
            'signon.autofillForms': false,
            // Disable password capture, so that tests that include forms are not
            // influenced by the presence of the persistent doorhanger notification
            'signon.rememberSignons': false,
            // Disable first-run welcome page
            'startup.homepage_welcome_url': 'about:blank',
            // Disable first-run welcome page
            'startup.homepage_welcome_url.additional': '',
            // Disable browser animations (tabs, fullscreen, sliding alerts)
            'toolkit.cosmeticAnimations.enabled': false,
            // Prevent starting into safe mode after application crashes
            'toolkit.startup.max_resumed_crashes': -1,
        };
        Object.assign(defaultPreferences, extraPrefs);
        for (const [key, value] of Object.entries(defaultPreferences))
            userJS.push(`user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`);
        await writeFileAsync(path.join(profilePath, 'user.js'), userJS.join('\n'));
        await writeFileAsync(path.join(profilePath, 'prefs.js'), prefsJS.join('\n'));
        return profilePath;
    }
}
function resolveExecutablePath(launcher) {
    let downloadPath;
    // puppeteer-core doesn't take into account PUPPETEER_* env variables.
    if (!launcher._isPuppeteerCore) {
        const executablePath = process.env.PUPPETEER_EXECUTABLE_PATH ||
            process.env.npm_config_puppeteer_executable_path ||
            process.env.npm_package_config_puppeteer_executable_path;
        if (executablePath) {
            const missingText = !fs.existsSync(executablePath)
                ? 'Tried to use PUPPETEER_EXECUTABLE_PATH env variable to launch browser but did not find any executable at: ' +
                    executablePath
                : null;
            return { executablePath, missingText };
        }
        downloadPath =
            process.env.PUPPETEER_DOWNLOAD_PATH ||
                process.env.npm_config_puppeteer_download_path ||
                process.env.npm_package_config_puppeteer_download_path;
    }
    const browserFetcher = new BrowserFetcher_js_1.BrowserFetcher(launcher._projectRoot, {
        product: launcher.product,
        path: downloadPath,
    });
    if (!launcher._isPuppeteerCore && launcher.product === 'chrome') {
        const revision = process.env['PUPPETEER_CHROMIUM_REVISION'];
        if (revision) {
            const revisionInfo = browserFetcher.revisionInfo(revision);
            const missingText = !revisionInfo.local
                ? 'Tried to use PUPPETEER_CHROMIUM_REVISION env variable to launch browser but did not find executable at: ' +
                    revisionInfo.executablePath
                : null;
            return { executablePath: revisionInfo.executablePath, missingText };
        }
    }
    const revisionInfo = browserFetcher.revisionInfo(launcher._preferredRevision);
    const missingText = !revisionInfo.local
        ? `Could not find browser revision ${launcher._preferredRevision}. Run "PUPPETEER_PRODUCT=firefox npm install" or "PUPPETEER_PRODUCT=firefox yarn install" to download a supported Firefox browser binary.`
        : null;
    return { executablePath: revisionInfo.executablePath, missingText };
}
/**
 * @internal
 */
function Launcher(projectRoot, preferredRevision, isPuppeteerCore, product) {
    // puppeteer-core doesn't take into account PUPPETEER_* env variables.
    if (!product && !isPuppeteerCore)
        product =
            process.env.PUPPETEER_PRODUCT ||
                process.env.npm_config_puppeteer_product ||
                process.env.npm_package_config_puppeteer_product;
    switch (product) {
        case 'firefox':
            return new FirefoxLauncher(projectRoot, preferredRevision, isPuppeteerCore);
        case 'chrome':
        default:
            if (typeof product !== 'undefined' && product !== 'chrome') {
                /* The user gave us an incorrect product name
                 * we'll default to launching Chrome, but log to the console
                 * to let the user know (they've probably typoed).
                 */
                console.warn(`Warning: unknown product name ${product}. Falling back to chrome.`);
            }
            return new ChromeLauncher(projectRoot, preferredRevision, isPuppeteerCore);
    }
}
exports.default = Launcher;


/***/ }),

/***/ 4402:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeWebSocketTransport = void 0;
const ws_1 = __importDefault(__nccwpck_require__(7550));
class NodeWebSocketTransport {
    constructor(ws) {
        this._ws = ws;
        this._ws.addEventListener('message', (event) => {
            if (this.onmessage)
                this.onmessage.call(null, event.data);
        });
        this._ws.addEventListener('close', () => {
            if (this.onclose)
                this.onclose.call(null);
        });
        // Silently ignore all errors - we don't know what to do with them.
        this._ws.addEventListener('error', () => { });
        this.onmessage = null;
        this.onclose = null;
    }
    static create(url) {
        return new Promise((resolve, reject) => {
            const ws = new ws_1.default(url, [], {
                perMessageDeflate: false,
                maxPayload: 256 * 1024 * 1024,
            });
            ws.addEventListener('open', () => resolve(new NodeWebSocketTransport(ws)));
            ws.addEventListener('error', reject);
        });
    }
    send(message) {
        this._ws.send(message);
    }
    close() {
        this._ws.close();
    }
}
exports.NodeWebSocketTransport = NodeWebSocketTransport;


/***/ }),

/***/ 3043:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PipeTransport = void 0;
/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const helper_js_1 = __nccwpck_require__(4342);
class PipeTransport {
    constructor(pipeWrite, pipeRead) {
        this._pipeWrite = pipeWrite;
        this._pendingMessage = '';
        this._eventListeners = [
            helper_js_1.helper.addEventListener(pipeRead, 'data', (buffer) => this._dispatch(buffer)),
            helper_js_1.helper.addEventListener(pipeRead, 'close', () => {
                if (this.onclose)
                    this.onclose.call(null);
            }),
            helper_js_1.helper.addEventListener(pipeRead, 'error', helper_js_1.debugError),
            helper_js_1.helper.addEventListener(pipeWrite, 'error', helper_js_1.debugError),
        ];
        this.onmessage = null;
        this.onclose = null;
    }
    send(message) {
        this._pipeWrite.write(message);
        this._pipeWrite.write('\0');
    }
    _dispatch(buffer) {
        let end = buffer.indexOf('\0');
        if (end === -1) {
            this._pendingMessage += buffer.toString();
            return;
        }
        const message = this._pendingMessage + buffer.toString(undefined, 0, end);
        if (this.onmessage)
            this.onmessage.call(null, message);
        let start = end + 1;
        end = buffer.indexOf('\0', start);
        while (end !== -1) {
            if (this.onmessage)
                this.onmessage.call(null, buffer.toString(undefined, start, end));
            start = end + 1;
            end = buffer.indexOf('\0', start);
        }
        this._pendingMessage = buffer.toString(undefined, start);
    }
    close() {
        this._pipeWrite = null;
        helper_js_1.helper.removeEventListeners(this._eventListeners);
    }
}
exports.PipeTransport = PipeTransport;


/***/ }),

/***/ 5165:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PuppeteerNode = void 0;
const Puppeteer_js_1 = __nccwpck_require__(2994);
const BrowserFetcher_js_1 = __nccwpck_require__(1445);
const Launcher_js_1 = __importDefault(__nccwpck_require__(2956));
const revisions_js_1 = __nccwpck_require__(9354);
/**
 * Extends the main {@link Puppeteer} class with Node specific behaviour for fetching and
 * downloading browsers.
 *
 * If you're using Puppeteer in a Node environment, this is the class you'll get
 * when you run `require('puppeteer')` (or the equivalent ES `import`).
 *
 * @remarks
 *
 * The most common method to use is {@link PuppeteerNode.launch | launch}, which
 * is used to launch and connect to a new browser instance.
 *
 * See {@link Puppeteer | the main Puppeteer class} for methods common to all
 * environments, such as {@link Puppeteer.connect}.
 *
 * @example
 * The following is a typical example of using Puppeteer to drive automation:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://www.google.com');
 *   // other actions...
 *   await browser.close();
 * })();
 * ```
 *
 * Once you have created a `page` you have access to a large API to interact
 * with the page, navigate, or find certain elements in that page.
 * The {@link Page | `page` documentation} lists all the available methods.
 *
 * @public
 */
class PuppeteerNode extends Puppeteer_js_1.Puppeteer {
    /**
     * @internal
     */
    constructor(settings) {
        const { projectRoot, preferredRevision, productName, ...commonSettings } = settings;
        super(commonSettings);
        this._projectRoot = projectRoot;
        this.__productName = productName;
        this._preferredRevision = preferredRevision;
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @remarks
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
        if (options.product)
            this._productName = options.product;
        return super.connect(options);
    }
    /**
     * @internal
     */
    get _productName() {
        return this.__productName;
    }
    // don't need any TSDoc here - because the getter is internal the setter is too.
    set _productName(name) {
        if (this.__productName !== name)
            this._changedProduct = true;
        this.__productName = name;
    }
    /**
     * Launches puppeteer and launches a browser instance with given arguments
     * and options when specified.
     *
     * @remarks
     *
     * @example
     * You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:
     * ```js
     * const browser = await puppeteer.launch({
     *   ignoreDefaultArgs: ['--mute-audio']
     * });
     * ```
     *
     * **NOTE** Puppeteer can also be used to control the Chrome browser,
     * but it works best with the version of Chromium it is bundled with.
     * There is no guarantee it will work with any other version.
     * Use `executablePath` option with extreme caution.
     * If Google Chrome (rather than Chromium) is preferred, a {@link https://www.google.com/chrome/browser/canary.html | Chrome Canary} or {@link https://www.chromium.org/getting-involved/dev-channel | Dev Channel} build is suggested.
     * In `puppeteer.launch([options])`, any mention of Chromium also applies to Chrome.
     * See {@link https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/ | this article} for a description of the differences between Chromium and Chrome. {@link https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md | This article} describes some differences for Linux users.
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    launch(options = {}) {
        if (options.product)
            this._productName = options.product;
        return this._launcher.launch(options);
    }
    /**
     * @remarks
     *
     * **NOTE** `puppeteer.executablePath()` is affected by the `PUPPETEER_EXECUTABLE_PATH`
     * and `PUPPETEER_CHROMIUM_REVISION` environment variables.
     *
     * @returns A path where Puppeteer expects to find the bundled browser.
     * The browser binary might not be there if the download was skipped with
     * the `PUPPETEER_SKIP_DOWNLOAD` environment variable.
     */
    executablePath() {
        return this._launcher.executablePath();
    }
    /**
     * @internal
     */
    get _launcher() {
        if (!this._lazyLauncher ||
            this._lazyLauncher.product !== this._productName ||
            this._changedProduct) {
            switch (this._productName) {
                case 'firefox':
                    this._preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
                    break;
                case 'chrome':
                default:
                    this._preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.chromium;
            }
            this._changedProduct = false;
            this._lazyLauncher = Launcher_js_1.default(this._projectRoot, this._preferredRevision, this._isPuppeteerCore, this._productName);
        }
        return this._lazyLauncher;
    }
    /**
     * The name of the browser that is under automation (`"chrome"` or `"firefox"`)
     *
     * @remarks
     * The product is set by the `PUPPETEER_PRODUCT` environment variable or the `product`
     * option in `puppeteer.launch([options])` and defaults to `chrome`.
     * Firefox support is experimental.
     */
    get product() {
        return this._launcher.product;
    }
    /**
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns The default flags that Chromium will be launched with.
     */
    defaultArgs(options = {}) {
        return this._launcher.defaultArgs(options);
    }
    /**
     * @param options - Set of configurable options to specify the settings
     * of the BrowserFetcher.
     * @returns A new BrowserFetcher instance.
     */
    createBrowserFetcher(options) {
        return new BrowserFetcher_js_1.BrowserFetcher(this._projectRoot, options);
    }
}
exports.PuppeteerNode = PuppeteerNode;


/***/ }),

/***/ 9354:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PUPPETEER_REVISIONS = void 0;
exports.PUPPETEER_REVISIONS = {
    chromium: '818858',
    firefox: 'latest',
};


/***/ }),

/***/ 3435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Mitt: Tiny (~200b) functional event emitter / pubsub.
 * @name mitt
 * @returns {Mitt}
 */
function mitt(all) {
    all = all || new Map();
    return {
        /**
         * A Map of event names to registered handler functions.
         */
        all,
        /**
         * Register an event handler for the given type.
         * @param {string|symbol} type Type of event to listen for, or `"*"` for all events
         * @param {Function} handler Function to call in response to given event
         * @memberOf mitt
         */
        on(type, handler) {
            const handlers = all.get(type);
            const added = handlers && handlers.push(handler);
            if (!added) {
                all.set(type, [handler]);
            }
        },
        /**
         * Remove an event handler for the given type.
         * @param {string|symbol} type Type of event to unregister `handler` from, or `"*"`
         * @param {Function} handler Handler function to remove
         * @memberOf mitt
         */
        off(type, handler) {
            const handlers = all.get(type);
            if (handlers) {
                handlers.splice(handlers.indexOf(handler) >>> 0, 1);
            }
        },
        /**
         * Invoke all handlers for the given type.
         * If present, `"*"` handlers are invoked after type-matched handlers.
         *
         * Note: Manually firing "*" handlers is not supported.
         *
         * @param {string|symbol} type The event type to invoke
         * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
         * @memberOf mitt
         */
        emit(type, evt) {
            (all.get(type) || []).slice().map((handler) => { handler(evt); });
            (all.get('*') || []).slice().map((handler) => { handler(type, evt); });
        }
    };
}
exports.default = mitt;


/***/ }),

/***/ 397:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const events_1 = __nccwpck_require__(8614);
const promisify_1 = __importDefault(__nccwpck_require__(8419));
function isAgentBase(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isHttpAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string')
        return false;
    return stack.split('\n').some(l => l.indexOf('(https.js:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function (createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */
    class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
            super();
            // The callback gets promisified lazily
            this.promisifiedCallback = undefined;
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            }
            else if (callback) {
                opts = callback;
            }
            // timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            this.options = opts || {};
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.sockets = [];
            this.requests = [];
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            else {
                return isSecureEndpoint() ? 443 : 80;
            }
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            else {
                return isSecureEndpoint() ? 'https:' : 'http:';
            }
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
            const ownOpts = Object.assign({}, _opts);
            if (typeof ownOpts.secureEndpoint !== 'boolean') {
                ownOpts.secureEndpoint = isSecureEndpoint();
            }
            // Set default `host` for HTTP to localhost
            if (ownOpts.host == null) {
                ownOpts.host = 'localhost';
            }
            // Set default `port` for HTTP if none was explicitly specified
            if (ownOpts.port == null) {
                ownOpts.port = ownOpts.secureEndpoint ? 443 : 80;
            }
            const opts = Object.assign(Object.assign({}, this.options), ownOpts);
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most likely the
                // result of a `url.parse()` call... we need to remove the `path` portion so
                // that `net.connect()` doesn't attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            // Create the `stream.Duplex` instance
            let timedOut = false;
            let timeout = null;
            const timeoutMs = this.timeout;
            const freeSocket = this.freeSocket;
            function onerror(err) {
                if (req._hadError)
                    return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            }
            function ontimeout() {
                timeout = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            }
            function callbackError(err) {
                if (timedOut)
                    return;
                if (timeout !== null) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                onerror(err);
            }
            function onsocket(socket) {
                let sock;
                function onfree() {
                    freeSocket(sock, opts);
                }
                if (timedOut)
                    return;
                if (timeout != null) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                if (isAgentBase(socket) || isHttpAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    sock = socket;
                    sock.on('free', onfree);
                    req.onSocket(sock);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            }
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    // Legacy callback function - convert to a Promise
                    this.promisifiedCallback = promisify_1.default(this.callback);
                }
                else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeout = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            }
            catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            // TODO reuse sockets
            socket.destroy();
        }
        destroy() { }
    }
    createAgent.Agent = Agent;
})(createAgent || (createAgent = {}));
// So that `instanceof` works correctly
createAgent.prototype = createAgent.Agent.prototype;
module.exports = createAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8419:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function promisify(fn) {
    return function (req, opts) {
        return new Promise((resolve, reject) => {
            fn.call(this, req, opts, (err, rtn) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports.default = promisify;
//# sourceMappingURL=promisify.js.map

/***/ }),

/***/ 1383:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var net = __nccwpck_require__(1631);
var tls = __nccwpck_require__(4016);
var url = __nccwpck_require__(8835);
var assert = __nccwpck_require__(2357);
var Agent = __nccwpck_require__(397);
var inherits = __nccwpck_require__(1669).inherits;
var debug = __nccwpck_require__(2423)('https-proxy-agent');

/**
 * Module exports.
 */

module.exports = HttpsProxyAgent;

/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the
 * specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * @api public
 */

function HttpsProxyAgent(opts) {
	if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);
	if ('string' == typeof opts) opts = url.parse(opts);
	if (!opts)
		throw new Error(
			'an HTTP(S) proxy server `host` and `port` must be specified!'
		);
	debug('creating new HttpsProxyAgent instance: %o', opts);
	Agent.call(this, opts);

	var proxy = Object.assign({}, opts);

	// if `true`, then connect to the proxy server over TLS. defaults to `false`.
	this.secureProxy = proxy.protocol
		? /^https:?$/i.test(proxy.protocol)
		: false;

	// prefer `hostname` over `host`, and set the `port` if needed
	proxy.host = proxy.hostname || proxy.host;
	proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);

	// ALPN is supported by Node.js >= v5.
	// attempt to negotiate http/1.1 for proxy servers that support http/2
	if (this.secureProxy && !('ALPNProtocols' in proxy)) {
		proxy.ALPNProtocols = ['http 1.1'];
	}

	if (proxy.host && proxy.path) {
		// if both a `host` and `path` are specified then it's most likely the
		// result of a `url.parse()` call... we need to remove the `path` portion so
		// that `net.connect()` doesn't attempt to open that as a unix socket file.
		delete proxy.path;
		delete proxy.pathname;
	}

	this.proxy = proxy;
}
inherits(HttpsProxyAgent, Agent);

/**
 * Called when the node-core HTTP client library is creating a new HTTP request.
 *
 * @api public
 */

HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
	var proxy = this.proxy;

	// create a socket connection to the proxy server
	var socket;
	if (this.secureProxy) {
		socket = tls.connect(proxy);
	} else {
		socket = net.connect(proxy);
	}

	// we need to buffer any HTTP traffic that happens with the proxy before we get
	// the CONNECT response, so that if the response is anything other than an "200"
	// response code, then we can re-play the "data" events on the socket once the
	// HTTP parser is hooked up...
	var buffers = [];
	var buffersLength = 0;

	function read() {
		var b = socket.read();
		if (b) ondata(b);
		else socket.once('readable', read);
	}

	function cleanup() {
		socket.removeListener('end', onend);
		socket.removeListener('error', onerror);
		socket.removeListener('close', onclose);
		socket.removeListener('readable', read);
	}

	function onclose(err) {
		debug('onclose had error %o', err);
	}

	function onend() {
		debug('onend');
	}

	function onerror(err) {
		cleanup();
		fn(err);
	}

	function ondata(b) {
		buffers.push(b);
		buffersLength += b.length;
		var buffered = Buffer.concat(buffers, buffersLength);
		var str = buffered.toString('ascii');

		if (!~str.indexOf('\r\n\r\n')) {
			// keep buffering
			debug('have not received end of HTTP headers yet...');
			read();
			return;
		}

		var firstLine = str.substring(0, str.indexOf('\r\n'));
		var statusCode = +firstLine.split(' ')[1];
		debug('got proxy server response: %o', firstLine);

		if (200 == statusCode) {
			// 200 Connected status code!
			var sock = socket;

			// nullify the buffered data since we won't be needing it
			buffers = buffered = null;

			if (opts.secureEndpoint) {
				// since the proxy is connecting to an SSL server, we have
				// to upgrade this socket connection to an SSL connection
				debug(
					'upgrading proxy-connected socket to TLS connection: %o',
					opts.host
				);
				opts.socket = socket;
				opts.servername = opts.servername || opts.host;
				opts.host = null;
				opts.hostname = null;
				opts.port = null;
				sock = tls.connect(opts);
			}

			cleanup();
			req.once('socket', resume);
			fn(null, sock);
		} else {
			// some other status code that's not 200... need to re-play the HTTP header
			// "data" events onto the socket once the HTTP machinery is attached so
			// that the node core `http` can parse and handle the error status code
			cleanup();

			// the original socket is closed, and a new closed socket is
			// returned instead, so that the proxy doesn't get the HTTP request
			// written to it (which may contain `Authorization` headers or other
			// sensitive data).
			//
			// See: https://hackerone.com/reports/541502
			socket.destroy();
			socket = new net.Socket();
			socket.readable = true;

			// save a reference to the concat'd Buffer for the `onsocket` callback
			buffers = buffered;

			// need to wait for the "socket" event to re-play the "data" events
			req.once('socket', onsocket);

			fn(null, socket);
		}
	}

	function onsocket(socket) {
		debug('replaying proxy buffer for failed request');
		assert(socket.listenerCount('data') > 0);

		// replay the "buffers" Buffer onto the `socket`, since at this point
		// the HTTP module machinery has been hooked up for the user
		socket.push(buffers);

		// nullify the cached Buffer instance
		buffers = null;
	}

	socket.on('error', onerror);
	socket.on('close', onclose);
	socket.on('end', onend);

	read();

	var hostname = opts.host + ':' + opts.port;
	var msg = 'CONNECT ' + hostname + ' HTTP/1.1\r\n';

	var headers = Object.assign({}, proxy.headers);
	if (proxy.auth) {
		headers['Proxy-Authorization'] =
			'Basic ' + Buffer.from(proxy.auth).toString('base64');
	}

	// the Host header should only include the port
	// number when it is a non-standard port
	var host = opts.host;
	if (!isDefaultPort(opts.port, opts.secureEndpoint)) {
		host += ':' + opts.port;
	}
	headers['Host'] = host;

	headers['Connection'] = 'close';
	Object.keys(headers).forEach(function(name) {
		msg += name + ': ' + headers[name] + '\r\n';
	});

	socket.write(msg + '\r\n');
};

/**
 * Resumes a socket.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket to resume
 * @api public
 */

function resume(socket) {
	socket.resume();
}

function isDefaultPort(port, secure) {
	return Boolean((!secure && port === 80) || (secure && port === 443));
}


/***/ }),

/***/ 1372:
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.q = codes;


/***/ }),

/***/ 2835:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __nccwpck_require__(4458);

var Writable = __nccwpck_require__(4382);

__nccwpck_require__(5588)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 5783:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __nccwpck_require__(5035);

__nccwpck_require__(5588)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 4458:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __nccwpck_require__(8614).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __nccwpck_require__(203);
/*</replacement>*/


var Buffer = __nccwpck_require__(4293).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __nccwpck_require__(1669);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __nccwpck_require__(6552);

var destroyImpl = __nccwpck_require__(8800);

var _require = __nccwpck_require__(9282),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __nccwpck_require__(1372)/* .codes */ .q,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__nccwpck_require__(5588)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(2835);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __nccwpck_require__(21)/* .StringDecoder */ .s;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __nccwpck_require__(2835);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __nccwpck_require__(21)/* .StringDecoder */ .s;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __nccwpck_require__(8115);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __nccwpck_require__(6195);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ 5035:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __nccwpck_require__(1372)/* .codes */ .q,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __nccwpck_require__(2835);

__nccwpck_require__(5588)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 4382:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __nccwpck_require__(4410)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __nccwpck_require__(203);
/*</replacement>*/


var Buffer = __nccwpck_require__(4293).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __nccwpck_require__(8800);

var _require = __nccwpck_require__(9282),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __nccwpck_require__(1372)/* .codes */ .q,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__nccwpck_require__(5588)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(2835);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __nccwpck_require__(2835); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 8115:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __nccwpck_require__(9392);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 6552:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __nccwpck_require__(4293),
    Buffer = _require.Buffer;

var _require2 = __nccwpck_require__(1669),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ 8800:
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 9392:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __nccwpck_require__(1372)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ 6195:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERR_INVALID_ARG_TYPE = __nccwpck_require__(1372)/* .codes.ERR_INVALID_ARG_TYPE */ .q.ERR_INVALID_ARG_TYPE;

function from(Readable, iterable, opts) {
  var iterator;

  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);

  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts)); // Reading boolean to protect against _read
  // being called before last iteration completion.

  var reading = false;

  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };

  function next() {
    return _next2.apply(this, arguments);
  }

  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _ref = yield iterator.next(),
            value = _ref.value,
            done = _ref.done;

        if (done) {
          readable.push(null);
        } else if (readable.push((yield value))) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }

  return readable;
}

module.exports = from;

/***/ }),

/***/ 8824:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __nccwpck_require__(1372)/* .codes */ .q,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __nccwpck_require__(9392);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ 9282:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = __nccwpck_require__(1372)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 203:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2413);


/***/ }),

/***/ 2298:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2413);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __nccwpck_require__(4458);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __nccwpck_require__(4382);
  exports.Duplex = __nccwpck_require__(2835);
  exports.Transform = __nccwpck_require__(5035);
  exports.PassThrough = __nccwpck_require__(5783);
  exports.finished = __nccwpck_require__(9392);
  exports.pipeline = __nccwpck_require__(8824);
}


/***/ }),

/***/ 9859:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const assert = __nccwpck_require__(2357)
const path = __nccwpck_require__(5622)
const fs = __nccwpck_require__(5747)
let glob = undefined
try {
  glob = __nccwpck_require__(2216)
} catch (_err) {
  // treat glob as optional.
}

const defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
let timeout = 0

const isWindows = (process.platform === "win32")

const defaults = options => {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  if (options.disableGlob !== true && glob === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

const rimraf = (p, options, cb) => {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  let busyTries = 0
  let errState = null
  let n = 0

  const next = (er) => {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  const afterGlob = (er, results) => {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(p => {
      const CB = (er) => {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(() => rimraf_(p, options, CB), timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      }
      rimraf_(p, options, CB)
    })
  }

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, (er, stat) => {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
const rimraf_ = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, er => {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

const fixWinEPERM = (p, options, er, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.chmod(p, 0o666, er2 => {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, (er3, stats) => {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

const fixWinEPERMSync = (p, options, er) => {
  assert(p)
  assert(options)

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  let stats
  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

const rmdir = (p, options, originalEr, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

const rmkids = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er)
      return cb(er)
    let n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    let errState
    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
const rimrafSync = (p, options) => {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  let results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (let i = 0; i < results.length; i++) {
    const p = results[i]

    let st
    try {
      st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

const rmdirSync = (p, options, originalEr) => {
  assert(p)
  assert(options)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

const rmkidsSync = (p, options) => {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1
  let i = 0
  do {
    let threw = true
    try {
      const ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),

/***/ 7759:
/***/ ((module, exports, __nccwpck_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(4293)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 7240:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const escapeStringRegexp = __nccwpck_require__(8361);

const natives = [].concat(
  __nccwpck_require__(2282).builtinModules,
  'bootstrap_node',
  'node',
).map(n => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));

natives.push(
  /\((?:node:)?internal\/[^:]+:\d+:\d+\)$/,
  /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/,
  /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/
);

class StackUtils {
  constructor (opts) {
    opts = {
      ignoredPackages: [],
      ...opts
    };

    if ('internals' in opts === false) {
      opts.internals = StackUtils.nodeInternals();
    }

    if ('cwd' in opts === false) {
      opts.cwd = process.cwd()
    }

    this._cwd = opts.cwd.replace(/\\/g, '/');
    this._internals = [].concat(
      opts.internals,
      ignoredPackagesRegExp(opts.ignoredPackages)
    );

    this._wrapCallSite = opts.wrapCallSite || false;
  }

  static nodeInternals () {
    return [...natives];
  }

  clean (stack, indent = 0) {
    indent = ' '.repeat(indent);

    if (!Array.isArray(stack)) {
      stack = stack.split('\n');
    }

    if (!(/^\s*at /.test(stack[0])) && (/^\s*at /.test(stack[1]))) {
      stack = stack.slice(1);
    }

    let outdent = false;
    let lastNonAtLine = null;
    const result = [];

    stack.forEach(st => {
      st = st.replace(/\\/g, '/');

      if (this._internals.some(internal => internal.test(st))) {
        return;
      }

      const isAtLine = /^\s*at /.test(st);

      if (outdent) {
        st = st.trimEnd().replace(/^(\s+)at /, '$1');
      } else {
        st = st.trim();
        if (isAtLine) {
          st = st.slice(3);
        }
      }

      st = st.replace(`${this._cwd}/`, '');

      if (st) {
        if (isAtLine) {
          if (lastNonAtLine) {
            result.push(lastNonAtLine);
            lastNonAtLine = null;
          }

          result.push(st);
        } else {
          outdent = true;
          lastNonAtLine = st;
        }
      }
    });

    return result.map(line => `${indent}${line}\n`).join('');
  }

  captureString (limit, fn = this.captureString) {
    if (typeof limit === 'function') {
      fn = limit;
      limit = Infinity;
    }

    const {stackTraceLimit} = Error;
    if (limit) {
      Error.stackTraceLimit = limit;
    }

    const obj = {};

    Error.captureStackTrace(obj, fn);
    const {stack} = obj;
    Error.stackTraceLimit = stackTraceLimit;

    return this.clean(stack);
  }

  capture (limit, fn = this.capture) {
    if (typeof limit === 'function') {
      fn = limit;
      limit = Infinity;
    }

    const {prepareStackTrace, stackTraceLimit} = Error;
    Error.prepareStackTrace = (obj, site) => {
      if (this._wrapCallSite) {
        return site.map(this._wrapCallSite);
      }

      return site;
    };

    if (limit) {
      Error.stackTraceLimit = limit;
    }

    const obj = {};
    Error.captureStackTrace(obj, fn);
    const { stack } = obj;
    Object.assign(Error, {prepareStackTrace, stackTraceLimit});

    return stack;
  }

  at (fn = this.at) {
    const [site] = this.capture(1, fn);

    if (!site) {
      return {};
    }

    const res = {
      line: site.getLineNumber(),
      column: site.getColumnNumber()
    };

    setFile(res, site.getFileName(), this._cwd);

    if (site.isConstructor()) {
      res.constructor = true;
    }

    if (site.isEval()) {
      res.evalOrigin = site.getEvalOrigin();
    }

    // Node v10 stopped with the isNative() on callsites, apparently
    /* istanbul ignore next */
    if (site.isNative()) {
      res.native = true;
    }

    let typename;
    try {
      typename = site.getTypeName();
    } catch (_) {
    }

    if (typename && typename !== 'Object' && typename !== '[object Object]') {
      res.type = typename;
    }

    const fname = site.getFunctionName();
    if (fname) {
      res.function = fname;
    }

    const meth = site.getMethodName();
    if (meth && fname !== meth) {
      res.method = meth;
    }

    return res;
  }

  parseLine (line) {
    const match = line && line.match(re);
    if (!match) {
      return null;
    }

    const ctor = match[1] === 'new';
    let fname = match[2];
    const evalOrigin = match[3];
    const evalFile = match[4];
    const evalLine = Number(match[5]);
    const evalCol = Number(match[6]);
    let file = match[7];
    const lnum = match[8];
    const col = match[9];
    const native = match[10] === 'native';
    const closeParen = match[11] === ')';
    let method;

    const res = {};

    if (lnum) {
      res.line = Number(lnum);
    }

    if (col) {
      res.column = Number(col);
    }

    if (closeParen && file) {
      // make sure parens are balanced
      // if we have a file like "asdf) [as foo] (xyz.js", then odds are
      // that the fname should be += " (asdf) [as foo]" and the file
      // should be just "xyz.js"
      // walk backwards from the end to find the last unbalanced (
      let closes = 0;
      for (let i = file.length - 1; i > 0; i--) {
        if (file.charAt(i) === ')') {
          closes++;
        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {
          closes--;
          if (closes === -1 && file.charAt(i - 1) === ' ') {
            const before = file.slice(0, i - 1);
            const after = file.slice(i + 1);
            file = after;
            fname += ` (${before}`;
            break;
          }
        }
      }
    }

    if (fname) {
      const methodMatch = fname.match(methodRe);
      if (methodMatch) {
        fname = methodMatch[1];
        method = methodMatch[2];
      }
    }

    setFile(res, file, this._cwd);

    if (ctor) {
      res.constructor = true;
    }

    if (evalOrigin) {
      res.evalOrigin = evalOrigin;
      res.evalLine = evalLine;
      res.evalColumn = evalCol;
      res.evalFile = evalFile && evalFile.replace(/\\/g, '/');
    }

    if (native) {
      res.native = true;
    }

    if (fname) {
      res.function = fname;
    }

    if (method && fname !== method) {
      res.method = method;
    }

    return res;
  }
}

function setFile (result, filename, cwd) {
  if (filename) {
    filename = filename.replace(/\\/g, '/');
    if (filename.startsWith(`${cwd}/`)) {
      filename = filename.slice(cwd.length + 1);
    }

    result.file = filename;
  }
}

function ignoredPackagesRegExp(ignoredPackages) {
  if (ignoredPackages.length === 0) {
    return [];
  }

  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));

  return new RegExp(`[\/\\\\]node_modules[\/\\\\](?:${packages.join('|')})[\/\\\\][^:]+:\\d+:\\d+`)
}

const re = new RegExp(
  '^' +
    // Sometimes we strip out the '    at' because it's noisy
  '(?:\\s*at )?' +
    // $1 = ctor if 'new'
  '(?:(new) )?' +
    // $2 = function name (can be literally anything)
    // May contain method at the end as [as xyz]
  '(?:(.*?) \\()?' +
    // (eval at <anonymous> (file.js:1:1),
    // $3 = eval origin
    // $4:$5:$6 are eval file/line/col, but not normally reported
  '(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?' +
    // file:line:col
    // $7:$8:$9
    // $10 = 'native' if native
  '(?:(.+?):(\\d+):(\\d+)|(native))' +
    // maybe close the paren, then end
    // if $11 is ), then we only allow balanced parens in the filename
    // any imbalance is placed on the fname.  This is a heuristic, and
    // bound to be incorrect in some edge cases.  The bet is that
    // having weird characters in method names is more common than
    // having weird characters in filenames, which seems reasonable.
  '(\\)?)$'
);

const methodRe = /^(.*?) \[as (.*?)\]$/;

module.exports = StackUtils;


/***/ }),

/***/ 21:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __nccwpck_require__(7759).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 7789:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var chownr = __nccwpck_require__(5769)
var tar = __nccwpck_require__(789)
var pump = __nccwpck_require__(7854)
var mkdirp = __nccwpck_require__(9573)
var fs = __nccwpck_require__(5747)
var path = __nccwpck_require__(5622)
var os = __nccwpck_require__(2087)

var win32 = os.platform() === 'win32'

var noop = function () {}

var echo = function (name) {
  return name
}

var normalize = !win32 ? echo : function (name) {
  return name.replace(/\\/g, '/').replace(/[:?<>|]/g, '_')
}

var statAll = function (fs, stat, cwd, ignore, entries, sort) {
  var queue = entries || ['.']

  return function loop (callback) {
    if (!queue.length) return callback()
    var next = queue.shift()
    var nextAbs = path.join(cwd, next)

    stat.call(fs, nextAbs, function (err, stat) {
      if (err) return callback(err)

      if (!stat.isDirectory()) return callback(null, next, stat)

      fs.readdir(nextAbs, function (err, files) {
        if (err) return callback(err)

        if (sort) files.sort()
        for (var i = 0; i < files.length; i++) {
          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))
        }

        callback(null, next, stat)
      })
    })
  }
}

var strip = function (map, level) {
  return function (header) {
    header.name = header.name.split('/').slice(level).join('/')

    var linkname = header.linkname
    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {
      header.linkname = linkname.split('/').slice(level).join('/')
    }

    return map(header)
  }
}

exports.pack = function (cwd, opts) {
  if (!cwd) cwd = '.'
  if (!opts) opts = {}

  var xfs = opts.fs || fs
  var ignore = opts.ignore || opts.filter || noop
  var map = opts.map || noop
  var mapStream = opts.mapStream || echo
  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)
  var strict = opts.strict !== false
  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()
  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0
  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0
  var pack = opts.pack || tar.pack()
  var finish = opts.finish || noop

  if (opts.strip) map = strip(map, opts.strip)

  if (opts.readable) {
    dmode |= parseInt(555, 8)
    fmode |= parseInt(444, 8)
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8)
    fmode |= parseInt(222, 8)
  }

  var onsymlink = function (filename, header) {
    xfs.readlink(path.join(cwd, filename), function (err, linkname) {
      if (err) return pack.destroy(err)
      header.linkname = normalize(linkname)
      pack.entry(header, onnextentry)
    })
  }

  var onstat = function (err, filename, stat) {
    if (err) return pack.destroy(err)
    if (!filename) {
      if (opts.finalize !== false) pack.finalize()
      return finish(pack)
    }

    if (stat.isSocket()) return onnextentry() // tar does not support sockets...

    var header = {
      name: normalize(filename),
      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
      mtime: stat.mtime,
      size: stat.size,
      type: 'file',
      uid: stat.uid,
      gid: stat.gid
    }

    if (stat.isDirectory()) {
      header.size = 0
      header.type = 'directory'
      header = map(header) || header
      return pack.entry(header, onnextentry)
    }

    if (stat.isSymbolicLink()) {
      header.size = 0
      header.type = 'symlink'
      header = map(header) || header
      return onsymlink(filename, header)
    }

    // TODO: add fifo etc...

    header = map(header) || header

    if (!stat.isFile()) {
      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))
      return onnextentry()
    }

    var entry = pack.entry(header, onnextentry)
    if (!entry) return

    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header)

    rs.on('error', function (err) { // always forward errors on destroy
      entry.destroy(err)
    })

    pump(rs, entry)
  }

  var onnextentry = function (err) {
    if (err) return pack.destroy(err)
    statNext(onstat)
  }

  onnextentry()

  return pack
}

var head = function (list) {
  return list.length ? list[list.length - 1] : null
}

var processGetuid = function () {
  return process.getuid ? process.getuid() : -1
}

var processUmask = function () {
  return process.umask ? process.umask() : 0
}

exports.extract = function (cwd, opts) {
  if (!cwd) cwd = '.'
  if (!opts) opts = {}

  var xfs = opts.fs || fs
  var ignore = opts.ignore || opts.filter || noop
  var map = opts.map || noop
  var mapStream = opts.mapStream || echo
  var own = opts.chown !== false && !win32 && processGetuid() === 0
  var extract = opts.extract || tar.extract()
  var stack = []
  var now = new Date()
  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()
  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0
  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0
  var strict = opts.strict !== false

  if (opts.strip) map = strip(map, opts.strip)

  if (opts.readable) {
    dmode |= parseInt(555, 8)
    fmode |= parseInt(444, 8)
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8)
    fmode |= parseInt(222, 8)
  }

  var utimesParent = function (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry
    var top
    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()
    if (!top) return cb()
    xfs.utimes(top[0], now, top[1], cb)
  }

  var utimes = function (name, header, cb) {
    if (opts.utimes === false) return cb()

    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)
    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?

    xfs.utimes(name, now, header.mtime, function (err) {
      if (err) return cb(err)
      utimesParent(name, cb)
    })
  }

  var chperm = function (name, header, cb) {
    var link = header.type === 'symlink'

    /* eslint-disable node/no-deprecated-api */
    var chmod = link ? xfs.lchmod : xfs.chmod
    var chown = link ? xfs.lchown : xfs.chown
    /* eslint-enable node/no-deprecated-api */

    if (!chmod) return cb()

    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask

    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown)
    else onchown(null)

    function onchown (err) {
      if (err) return cb(err)
      if (!chmod) return cb()
      chmod.call(xfs, name, mode, cb)
    }
  }

  extract.on('entry', function (header, stream, next) {
    header = map(header) || header
    header.name = normalize(header.name)
    var name = path.join(cwd, path.join('/', header.name))

    if (ignore(name, header)) {
      stream.resume()
      return next()
    }

    var stat = function (err) {
      if (err) return next(err)
      utimes(name, header, function (err) {
        if (err) return next(err)
        if (win32) return next()
        chperm(name, header, next)
      })
    }

    var onsymlink = function () {
      if (win32) return next() // skip symlinks on win for now before it can be tested
      xfs.unlink(name, function () {
        xfs.symlink(header.linkname, name, stat)
      })
    }

    var onlink = function () {
      if (win32) return next() // skip links on win for now before it can be tested
      xfs.unlink(name, function () {
        var srcpath = path.join(cwd, path.join('/', header.linkname))

        xfs.link(srcpath, name, function (err) {
          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {
            stream = xfs.createReadStream(srcpath)
            return onfile()
          }

          stat(err)
        })
      })
    }

    var onfile = function () {
      var ws = xfs.createWriteStream(name)
      var rs = mapStream(stream, header)

      ws.on('error', function (err) { // always forward errors on destroy
        rs.destroy(err)
      })

      pump(rs, ws, function (err) {
        if (err) return next(err)
        ws.on('close', stat)
      })
    }

    if (header.type === 'directory') {
      stack.push([name, header.mtime])
      return mkdirfix(name, {
        fs: xfs, own: own, uid: header.uid, gid: header.gid
      }, stat)
    }

    var dir = path.dirname(name)

    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {
      if (err) return next(err)
      if (!valid) return next(new Error(dir + ' is not a valid path'))

      mkdirfix(dir, {
        fs: xfs, own: own, uid: header.uid, gid: header.gid
      }, function (err) {
        if (err) return next(err)

        switch (header.type) {
          case 'file': return onfile()
          case 'link': return onlink()
          case 'symlink': return onsymlink()
        }

        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))

        stream.resume()
        next()
      })
    })
  })

  if (opts.finish) extract.on('finish', opts.finish)

  return extract
}

function validate (fs, name, root, cb) {
  if (name === root) return cb(null, true)
  fs.lstat(name, function (err, st) {
    if (err && err.code !== 'ENOENT') return cb(err)
    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)
    cb(null, false)
  })
}

function mkdirfix (name, opts, cb) {
  mkdirp(name, { fs: opts.fs }, function (err, made) {
    if (!err && made && opts.own) {
      chownr(made, opts.uid, opts.gid, cb)
    } else {
      cb(err)
    }
  })
}


/***/ }),

/***/ 7005:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(1669)
var bl = __nccwpck_require__(8969)
var headers = __nccwpck_require__(3878)

var Writable = __nccwpck_require__(2298).Writable
var PassThrough = __nccwpck_require__(2298).PassThrough

var noop = function () {}

var overflow = function (size) {
  size &= 511
  return size && 512 - size
}

var emptyStream = function (self, offset) {
  var s = new Source(self, offset)
  s.end()
  return s
}

var mixinPax = function (header, pax) {
  if (pax.path) header.name = pax.path
  if (pax.linkpath) header.linkname = pax.linkpath
  if (pax.size) header.size = parseInt(pax.size, 10)
  header.pax = pax
  return header
}

var Source = function (self, offset) {
  this._parent = self
  this.offset = offset
  PassThrough.call(this, { autoDestroy: false })
}

util.inherits(Source, PassThrough)

Source.prototype.destroy = function (err) {
  this._parent.destroy(err)
}

var Extract = function (opts) {
  if (!(this instanceof Extract)) return new Extract(opts)
  Writable.call(this, opts)

  opts = opts || {}

  this._offset = 0
  this._buffer = bl()
  this._missing = 0
  this._partial = false
  this._onparse = noop
  this._header = null
  this._stream = null
  this._overflow = null
  this._cb = null
  this._locked = false
  this._destroyed = false
  this._pax = null
  this._paxGlobal = null
  this._gnuLongPath = null
  this._gnuLongLinkPath = null

  var self = this
  var b = self._buffer

  var oncontinue = function () {
    self._continue()
  }

  var onunlock = function (err) {
    self._locked = false
    if (err) return self.destroy(err)
    if (!self._stream) oncontinue()
  }

  var onstreamend = function () {
    self._stream = null
    var drain = overflow(self._header.size)
    if (drain) self._parse(drain, ondrain)
    else self._parse(512, onheader)
    if (!self._locked) oncontinue()
  }

  var ondrain = function () {
    self._buffer.consume(overflow(self._header.size))
    self._parse(512, onheader)
    oncontinue()
  }

  var onpaxglobalheader = function () {
    var size = self._header.size
    self._paxGlobal = headers.decodePax(b.slice(0, size))
    b.consume(size)
    onstreamend()
  }

  var onpaxheader = function () {
    var size = self._header.size
    self._pax = headers.decodePax(b.slice(0, size))
    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)
    b.consume(size)
    onstreamend()
  }

  var ongnulongpath = function () {
    var size = self._header.size
    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var ongnulonglinkpath = function () {
    var size = self._header.size
    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var onheader = function () {
    var offset = self._offset
    var header
    try {
      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat)
    } catch (err) {
      self.emit('error', err)
    }
    b.consume(512)

    if (!header) {
      self._parse(512, onheader)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-path') {
      self._parse(header.size, ongnulongpath)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-link-path') {
      self._parse(header.size, ongnulonglinkpath)
      oncontinue()
      return
    }
    if (header.type === 'pax-global-header') {
      self._parse(header.size, onpaxglobalheader)
      oncontinue()
      return
    }
    if (header.type === 'pax-header') {
      self._parse(header.size, onpaxheader)
      oncontinue()
      return
    }

    if (self._gnuLongPath) {
      header.name = self._gnuLongPath
      self._gnuLongPath = null
    }

    if (self._gnuLongLinkPath) {
      header.linkname = self._gnuLongLinkPath
      self._gnuLongLinkPath = null
    }

    if (self._pax) {
      self._header = header = mixinPax(header, self._pax)
      self._pax = null
    }

    self._locked = true

    if (!header.size || header.type === 'directory') {
      self._parse(512, onheader)
      self.emit('entry', header, emptyStream(self, offset), onunlock)
      return
    }

    self._stream = new Source(self, offset)

    self.emit('entry', header, self._stream, onunlock)
    self._parse(header.size, onstreamend)
    oncontinue()
  }

  this._onheader = onheader
  this._parse(512, onheader)
}

util.inherits(Extract, Writable)

Extract.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream) this._stream.emit('close')
}

Extract.prototype._parse = function (size, onparse) {
  if (this._destroyed) return
  this._offset += size
  this._missing = size
  if (onparse === this._onheader) this._partial = false
  this._onparse = onparse
}

Extract.prototype._continue = function () {
  if (this._destroyed) return
  var cb = this._cb
  this._cb = noop
  if (this._overflow) this._write(this._overflow, undefined, cb)
  else cb()
}

Extract.prototype._write = function (data, enc, cb) {
  if (this._destroyed) return

  var s = this._stream
  var b = this._buffer
  var missing = this._missing
  if (data.length) this._partial = true

  // we do not reach end-of-chunk now. just forward it

  if (data.length < missing) {
    this._missing -= data.length
    this._overflow = null
    if (s) return s.write(data, cb)
    b.append(data)
    return cb()
  }

  // end-of-chunk. the parser should call cb.

  this._cb = cb
  this._missing = 0

  var overflow = null
  if (data.length > missing) {
    overflow = data.slice(missing)
    data = data.slice(0, missing)
  }

  if (s) s.end(data)
  else b.append(data)

  this._overflow = overflow
  this._onparse()
}

Extract.prototype._final = function (cb) {
  if (this._partial) return this.destroy(new Error('Unexpected end of data'))
  cb()
}

module.exports = Extract


/***/ }),

/***/ 3878:
/***/ ((__unused_webpack_module, exports) => {

var alloc = Buffer.alloc

var ZEROS = '0000000000000000000'
var SEVENS = '7777777777777777777'
var ZERO_OFFSET = '0'.charCodeAt(0)
var USTAR_MAGIC = Buffer.from('ustar\x00', 'binary')
var USTAR_VER = Buffer.from('00', 'binary')
var GNU_MAGIC = Buffer.from('ustar\x20', 'binary')
var GNU_VER = Buffer.from('\x20\x00', 'binary')
var MASK = parseInt('7777', 8)
var MAGIC_OFFSET = 257
var VERSION_OFFSET = 263

var clamp = function (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

var toType = function (flag) {
  switch (flag) {
    case 0:
      return 'file'
    case 1:
      return 'link'
    case 2:
      return 'symlink'
    case 3:
      return 'character-device'
    case 4:
      return 'block-device'
    case 5:
      return 'directory'
    case 6:
      return 'fifo'
    case 7:
      return 'contiguous-file'
    case 72:
      return 'pax-header'
    case 55:
      return 'pax-global-header'
    case 27:
      return 'gnu-long-link-path'
    case 28:
    case 30:
      return 'gnu-long-path'
  }

  return null
}

var toTypeflag = function (flag) {
  switch (flag) {
    case 'file':
      return 0
    case 'link':
      return 1
    case 'symlink':
      return 2
    case 'character-device':
      return 3
    case 'block-device':
      return 4
    case 'directory':
      return 5
    case 'fifo':
      return 6
    case 'contiguous-file':
      return 7
    case 'pax-header':
      return 72
  }

  return 0
}

var indexOf = function (block, num, offset, end) {
  for (; offset < end; offset++) {
    if (block[offset] === num) return offset
  }
  return end
}

var cksum = function (block) {
  var sum = 8 * 32
  for (var i = 0; i < 148; i++) sum += block[i]
  for (var j = 156; j < 512; j++) sum += block[j]
  return sum
}

var encodeOct = function (val, n) {
  val = val.toString(8)
  if (val.length > n) return SEVENS.slice(0, n) + ' '
  else return ZEROS.slice(0, n - val.length) + val + ' '
}

/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */
function parse256 (buf) {
  // first byte MUST be either 80 or FF
  // 80 for positive, FF for 2's comp
  var positive
  if (buf[0] === 0x80) positive = true
  else if (buf[0] === 0xFF) positive = false
  else return null

  // build up a base-256 tuple from the least sig to the highest
  var tuple = []
  for (var i = buf.length - 1; i > 0; i--) {
    var byte = buf[i]
    if (positive) tuple.push(byte)
    else tuple.push(0xFF - byte)
  }

  var sum = 0
  var l = tuple.length
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i)
  }

  return positive ? sum : -1 * sum
}

var decodeOct = function (val, offset, length) {
  val = val.slice(offset, offset + length)
  offset = 0

  // If prefixed with 0x80 then parse as a base-256 integer
  if (val[offset] & 0x80) {
    return parse256(val)
  } else {
    // Older versions of tar can prefix with spaces
    while (offset < val.length && val[offset] === 32) offset++
    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
    while (offset < end && val[offset] === 0) offset++
    if (end === offset) return 0
    return parseInt(val.slice(offset, end).toString(), 8)
  }
}

var decodeStr = function (val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)
}

var addLength = function (str) {
  var len = Buffer.byteLength(str)
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1
  if (len + digits >= Math.pow(10, digits)) digits++

  return (len + digits) + str
}

exports.decodeLongPath = function (buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding)
}

exports.encodePax = function (opts) { // TODO: encode more stuff in pax
  var result = ''
  if (opts.name) result += addLength(' path=' + opts.name + '\n')
  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
  var pax = opts.pax
  if (pax) {
    for (var key in pax) {
      result += addLength(' ' + key + '=' + pax[key] + '\n')
    }
  }
  return Buffer.from(result)
}

exports.decodePax = function (buf) {
  var result = {}

  while (buf.length) {
    var i = 0
    while (i < buf.length && buf[i] !== 32) i++
    var len = parseInt(buf.slice(0, i).toString(), 10)
    if (!len) return result

    var b = buf.slice(i + 1, len - 1).toString()
    var keyIndex = b.indexOf('=')
    if (keyIndex === -1) return result
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)

    buf = buf.slice(len)
  }

  return result
}

exports.encode = function (opts) {
  var buf = alloc(512)
  var name = opts.name
  var prefix = ''

  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
  if (Buffer.byteLength(name) !== name.length) return null // utf-8

  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf('/')
    if (i === -1) return null
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
    name = name.slice(i + 1)
  }

  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null

  buf.write(name)
  buf.write(encodeOct(opts.mode & MASK, 6), 100)
  buf.write(encodeOct(opts.uid, 6), 108)
  buf.write(encodeOct(opts.gid, 6), 116)
  buf.write(encodeOct(opts.size, 11), 124)
  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)

  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)

  if (opts.linkname) buf.write(opts.linkname, 157)

  USTAR_MAGIC.copy(buf, MAGIC_OFFSET)
  USTAR_VER.copy(buf, VERSION_OFFSET)
  if (opts.uname) buf.write(opts.uname, 265)
  if (opts.gname) buf.write(opts.gname, 297)
  buf.write(encodeOct(opts.devmajor || 0, 6), 329)
  buf.write(encodeOct(opts.devminor || 0, 6), 337)

  if (prefix) buf.write(prefix, 345)

  buf.write(encodeOct(cksum(buf), 6), 148)

  return buf
}

exports.decode = function (buf, filenameEncoding, allowUnknownFormat) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET

  var name = decodeStr(buf, 0, 100, filenameEncoding)
  var mode = decodeOct(buf, 100, 8)
  var uid = decodeOct(buf, 108, 8)
  var gid = decodeOct(buf, 116, 8)
  var size = decodeOct(buf, 124, 12)
  var mtime = decodeOct(buf, 136, 12)
  var type = toType(typeflag)
  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)
  var uname = decodeStr(buf, 265, 32)
  var gname = decodeStr(buf, 297, 32)
  var devmajor = decodeOct(buf, 329, 8)
  var devminor = decodeOct(buf, 337, 8)

  var c = cksum(buf)

  // checksum is still initial value if header was null.
  if (c === 8 * 32) return null

  // valid checksum
  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

  if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
    // ustar (posix) format.
    // prepend prefix, if present.
    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name
  } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 &&
             GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and
    // multi-volume tarballs.
  } else {
    if (!allowUnknownFormat) {
      throw new Error('Invalid tar header: unknown format.')
    }
  }

  // to support old tar versions that use trailing / to indicate dirs
  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5

  return {
    name,
    mode,
    uid,
    gid,
    size,
    mtime: new Date(1000 * mtime),
    type,
    linkname,
    uname,
    gname,
    devmajor,
    devminor
  }
}


/***/ }),

/***/ 789:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.extract = __nccwpck_require__(7005)
exports.pack = __nccwpck_require__(260)


/***/ }),

/***/ 260:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var constants = __nccwpck_require__(3918)
var eos = __nccwpck_require__(3359)
var inherits = __nccwpck_require__(5588)
var alloc = Buffer.alloc

var Readable = __nccwpck_require__(2298).Readable
var Writable = __nccwpck_require__(2298).Writable
var StringDecoder = __nccwpck_require__(4304).StringDecoder

var headers = __nccwpck_require__(3878)

var DMODE = parseInt('755', 8)
var FMODE = parseInt('644', 8)

var END_OF_TAR = alloc(1024)

var noop = function () {}

var overflow = function (self, size) {
  size &= 511
  if (size) self.push(END_OF_TAR.slice(0, 512 - size))
}

function modeToType (mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

var Sink = function (to) {
  Writable.call(this)
  this.written = 0
  this._to = to
  this._destroyed = false
}

inherits(Sink, Writable)

Sink.prototype._write = function (data, enc, cb) {
  this.written += data.length
  if (this._to.push(data)) return cb()
  this._to._drain = cb
}

Sink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var LinkSink = function () {
  Writable.call(this)
  this.linkname = ''
  this._decoder = new StringDecoder('utf-8')
  this._destroyed = false
}

inherits(LinkSink, Writable)

LinkSink.prototype._write = function (data, enc, cb) {
  this.linkname += this._decoder.write(data)
  cb()
}

LinkSink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Void = function () {
  Writable.call(this)
  this._destroyed = false
}

inherits(Void, Writable)

Void.prototype._write = function (data, enc, cb) {
  cb(new Error('No body allowed for this entry'))
}

Void.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Pack = function (opts) {
  if (!(this instanceof Pack)) return new Pack(opts)
  Readable.call(this, opts)

  this._drain = noop
  this._finalized = false
  this._finalizing = false
  this._destroyed = false
  this._stream = null
}

inherits(Pack, Readable)

Pack.prototype.entry = function (header, buffer, callback) {
  if (this._stream) throw new Error('already piping an entry')
  if (this._finalized || this._destroyed) return

  if (typeof buffer === 'function') {
    callback = buffer
    buffer = null
  }

  if (!callback) callback = noop

  var self = this

  if (!header.size || header.type === 'symlink') header.size = 0
  if (!header.type) header.type = modeToType(header.mode)
  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
  if (!header.uid) header.uid = 0
  if (!header.gid) header.gid = 0
  if (!header.mtime) header.mtime = new Date()

  if (typeof buffer === 'string') buffer = Buffer.from(buffer)
  if (Buffer.isBuffer(buffer)) {
    header.size = buffer.length
    this._encode(header)
    var ok = this.push(buffer)
    overflow(self, header.size)
    if (ok) process.nextTick(callback)
    else this._drain = callback
    return new Void()
  }

  if (header.type === 'symlink' && !header.linkname) {
    var linkSink = new LinkSink()
    eos(linkSink, function (err) {
      if (err) { // stream was closed
        self.destroy()
        return callback(err)
      }

      header.linkname = linkSink.linkname
      self._encode(header)
      callback()
    })

    return linkSink
  }

  this._encode(header)

  if (header.type !== 'file' && header.type !== 'contiguous-file') {
    process.nextTick(callback)
    return new Void()
  }

  var sink = new Sink(this)

  this._stream = sink

  eos(sink, function (err) {
    self._stream = null

    if (err) { // stream was closed
      self.destroy()
      return callback(err)
    }

    if (sink.written !== header.size) { // corrupting tar
      self.destroy()
      return callback(new Error('size mismatch'))
    }

    overflow(self, header.size)
    if (self._finalizing) self.finalize()
    callback()
  })

  return sink
}

Pack.prototype.finalize = function () {
  if (this._stream) {
    this._finalizing = true
    return
  }

  if (this._finalized) return
  this._finalized = true
  this.push(END_OF_TAR)
  this.push(null)
}

Pack.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream && this._stream.destroy) this._stream.destroy()
}

Pack.prototype._encode = function (header) {
  if (!header.pax) {
    var buf = headers.encode(header)
    if (buf) {
      this.push(buf)
      return
    }
  }
  this._encodePax(header)
}

Pack.prototype._encodePax = function (header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  })

  var newHeader = {
    name: 'PaxHeader',
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: 'pax-header',
    linkname: header.linkname && 'PaxHeader',
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  }

  this.push(headers.encode(newHeader))
  this.push(paxHeader)
  overflow(this, paxHeader.length)

  newHeader.size = header.size
  newHeader.type = header.type
  this.push(headers.encode(newHeader))
}

Pack.prototype._read = function (n) {
  var drain = this._drain
  this._drain = noop
  drain()
}

module.exports = Pack


/***/ }),

/***/ 9389:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2413)

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}



/***/ }),

/***/ 8239:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var through = __nccwpck_require__(9389);
var bz2 = __nccwpck_require__(6912);
var bitIterator = __nccwpck_require__(6974);

module.exports = unbzip2Stream;

function unbzip2Stream() {
    var bufferQueue = [];
    var hasBytes = 0;
    var blockSize = 0;
    var broken = false;
    var done = false;
    var bitReader = null;
    var streamCRC = null;

    function decompressBlock(push){
        if(!blockSize){
            blockSize = bz2.header(bitReader);
            //console.error("got header of", blockSize);
            streamCRC = 0;
            return true;
        }else{
            var bufsize = 100000 * blockSize;
            var buf = new Int32Array(bufsize);
            
            var chunk = [];
            var f = function(b) {
                chunk.push(b);
            };

            streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);
            if (streamCRC === null) {
                // reset for next bzip2 header
                blockSize = 0;
                return false;
            }else{
                //console.error('decompressed', chunk.length,'bytes');
                push(Buffer.from(chunk));
                return true;
            }
        }
    }

    var outlength = 0;
    function decompressAndQueue(stream) {
        if (broken) return;
        try {
            return decompressBlock(function(d) {
                stream.queue(d);
                if (d !== null) {
                    //console.error('write at', outlength.toString(16));
                    outlength += d.length;
                } else {
                    //console.error('written EOS');
                }
            });
        } catch(e) {
            //console.error(e);
            stream.emit('error', e);
            broken = true;
            return false;
        }
    }

    return through(
        function write(data) {
            //console.error('received', data.length,'bytes in', typeof data);
            bufferQueue.push(data);
            hasBytes += data.length;
            if (bitReader === null) {
                bitReader = bitIterator(function() {
                    return bufferQueue.shift();
                });
            }
            while (!broken && hasBytes - bitReader.bytesRead + 1 >= ((25000 + 100000 * blockSize) || 4)){
                //console.error('decompressing with', hasBytes - bitReader.bytesRead + 1, 'bytes in buffer');
                decompressAndQueue(this);
            }
        },
        function end(x) {
            //console.error(x,'last compressing with', hasBytes, 'bytes in buffer');
            while (!broken && bitReader && hasBytes > bitReader.bytesRead){
                decompressAndQueue(this);
            }
            if (!broken) {
                if (streamCRC !== null)
                    this.emit('error', new Error("input stream ended prematurely"));
                this.queue(null);
            }
        }
    );
}



/***/ }),

/***/ 6974:
/***/ ((module) => {

var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];

// returns a function that reads bits.
// takes a buffer iterator as input
module.exports = function bitIterator(nextBuffer) {
    var bit = 0, byte = 0;
    var bytes = nextBuffer();
    var f = function(n) {
        if (n === null && bit != 0) {  // align to byte boundary
            bit = 0
            byte++;
            return;
        }
        var result = 0;
        while(n > 0) {
            if (byte >= bytes.length) {
                byte = 0;
                bytes = nextBuffer();
            }
            var left = 8 - bit;
            if (bit === 0 && n > 0)
                f.bytesRead++;
            if (n >= left) {
                result <<= left;
                result |= (BITMASK[left] & bytes[byte++]);
                bit = 0;
                n -= left;
            } else {
                result <<= n;
                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));
                bit += n;
                n = 0;
            }
        }
        return result;
    };
    f.bytesRead = 0;
    return f;
};


/***/ }),

/***/ 6912:
/***/ ((module) => {

/* 
  bzip2.js - a small bzip2 decompression implementation
  
  Copyright 2011 by antimatter15 (antimatter15@gmail.com)
  
  Based on micro-bunzip by Rob Landley (rob@landley.net).

  Copyright (c) 2011 by antimatter15 (antimatter15@gmail.com).

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
function Bzip2Error(message) {
    this.name = 'Bzip2Error';
    this.message = message;
    this.stack = (new Error()).stack;
}
Bzip2Error.prototype = new Error;
 
var message = {
    Error: function(message) {throw new Bzip2Error(message);}
};

var bzip2 = {};
bzip2.Bzip2Error = Bzip2Error;

bzip2.crcTable =
[
   0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
   0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
   0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
   0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
   0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
   0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
   0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
   0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
   0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
   0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
   0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
   0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
   0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
   0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
   0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
   0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
   0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
   0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
   0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
   0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
   0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
   0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
   0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
   0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
   0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
   0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
   0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
   0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
   0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
   0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
   0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
   0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
   0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
   0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
   0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
   0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
   0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
   0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
   0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
   0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
   0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
   0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
   0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
   0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
   0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
   0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
   0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
   0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
   0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
   0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
   0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
   0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
   0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
   0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
   0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
   0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
   0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
   0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
   0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
   0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
   0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
   0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
   0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
   0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
];

bzip2.array = function(bytes) {
    var bit = 0, byte = 0;
    var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF ];
    return function(n) {
        var result = 0;
        while(n > 0) {
            var left = 8 - bit;
            if (n >= left) {
                result <<= left;
                result |= (BITMASK[left] & bytes[byte++]);
                bit = 0;
                n -= left;
            } else {
                result <<= n;
                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));
                bit += n;
                n = 0;
            }
        }
        return result;
    }
}

    
bzip2.simple = function(srcbuffer, stream) {
    var bits = bzip2.array(srcbuffer);
    var size = bzip2.header(bits);
    var ret = false;
    var bufsize = 100000 * size;
    var buf = new Int32Array(bufsize);
    
    do {
        ret = bzip2.decompress(bits, stream, buf, bufsize);        
    } while(!ret);
}

bzip2.header = function(bits) {
    this.byteCount = new Int32Array(256);
    this.symToByte = new Uint8Array(256);
    this.mtfSymbol = new Int32Array(256);
    this.selectors = new Uint8Array(0x8000);

    if (bits(8*3) != 4348520) message.Error("No magic number found");

    var i = bits(8) - 48;
    if (i < 1 || i > 9) message.Error("Not a BZIP archive");
    return i;
};


//takes a function for reading the block data (starting with 0x314159265359)
//a block size (0-9) (optional, defaults to 9)
//a length at which to stop decompressing and return the output
bzip2.decompress = function(bits, stream, buf, bufsize, streamCRC) {
    var MAX_HUFCODE_BITS = 20;
    var MAX_SYMBOLS = 258;
    var SYMBOL_RUNA = 0;
    var SYMBOL_RUNB = 1;
    var GROUP_SIZE = 50;
    var crc = 0 ^ (-1);
    
    for(var h = '', i = 0; i < 6; i++) h += bits(8).toString(16);
    if (h == "177245385090") {
      var finalCRC = bits(32)|0;
      if (finalCRC !== streamCRC) message.Error("Error in bzip2: crc32 do not match");
      // align stream to byte
      bits(null);
      return null; // reset streamCRC for next call
    }
    if (h != "314159265359") message.Error("eek not valid bzip data");
    var crcblock = bits(32)|0; // CRC code
    if (bits(1)) message.Error("unsupported obsolete version");
    var origPtr = bits(24);
    if (origPtr > bufsize) message.Error("Initial position larger than buffer size");
    var t = bits(16);
    var symTotal = 0;
    for (i = 0; i < 16; i++) {
        if (t & (1 << (15 - i))) {
            var k = bits(16);
            for(j = 0; j < 16; j++) {
                if (k & (1 << (15 - j))) {
                    this.symToByte[symTotal++] = (16 * i) + j;
                }
            }
        }
    }

    var groupCount = bits(3);
    if (groupCount < 2 || groupCount > 6) message.Error("another error");
    var nSelectors = bits(15);
    if (nSelectors == 0) message.Error("meh");
    for(var i = 0; i < groupCount; i++) this.mtfSymbol[i] = i;

    for(var i = 0; i < nSelectors; i++) {
        for(var j = 0; bits(1); j++) if (j >= groupCount) message.Error("whoops another error");
        var uc = this.mtfSymbol[j];
        for(var k = j-1; k>=0; k--) {
            this.mtfSymbol[k+1] = this.mtfSymbol[k];
        }
        this.mtfSymbol[0] = uc;
        this.selectors[i] = uc;
    }

    var symCount = symTotal + 2;
    var groups = [];
    var length = new Uint8Array(MAX_SYMBOLS),
    temp = new Uint16Array(MAX_HUFCODE_BITS+1);

    var hufGroup;

    for(var j = 0; j < groupCount; j++) {
        t = bits(5); //lengths
        for(var i = 0; i < symCount; i++) {
            while(true){
                if (t < 1 || t > MAX_HUFCODE_BITS) message.Error("I gave up a while ago on writing error messages");
                if (!bits(1)) break;
                if (!bits(1)) t++;
                else t--;
            }
            length[i] = t;
        }
        var  minLen,  maxLen;
        minLen = maxLen = length[0];
        for(var i = 1; i < symCount; i++) {
            if (length[i] > maxLen) maxLen = length[i];
            else if (length[i] < minLen) minLen = length[i];
        }
        hufGroup = groups[j] = {};
        hufGroup.permute = new Int32Array(MAX_SYMBOLS);
        hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);

        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var base = hufGroup.base;
        var limit = hufGroup.limit;
        var pp = 0;
        for(var i = minLen; i <= maxLen; i++)
        for(var t = 0; t < symCount; t++)
        if (length[t] == i) hufGroup.permute[pp++] = t;
        for(i = minLen; i <= maxLen; i++) temp[i] = limit[i] = 0;
        for(i = 0; i < symCount; i++) temp[length[i]]++;
        pp = t = 0;
        for(i = minLen; i < maxLen; i++) {
            pp += temp[i];
            limit[i] = pp - 1;
            pp <<= 1;
            base[i+1] = pp - (t += temp[i]);
        }
        limit[maxLen] = pp + temp[maxLen] - 1;
        base[minLen] = 0;
    }

    for(var i = 0; i < 256; i++) { 
        this.mtfSymbol[i] = i;
        this.byteCount[i] = 0;
    }
    var runPos, count, symCount, selector;
    runPos = count = symCount = selector = 0;    
    while(true) {
        if (!(symCount--)) {
            symCount = GROUP_SIZE - 1;
            if (selector >= nSelectors) message.Error("meow i'm a kitty, that's an error");
            hufGroup = groups[this.selectors[selector++]];
            base = hufGroup.base;
            limit = hufGroup.limit;
        }
        i = hufGroup.minLen;
        j = bits(i);
        while(true) {
            if (i > hufGroup.maxLen) message.Error("rawr i'm a dinosaur");
            if (j <= limit[i]) break;
            i++;
            j = (j << 1) | bits(1);
        }
        j -= base[i];
        if (j < 0 || j >= MAX_SYMBOLS) message.Error("moo i'm a cow");
        var nextSym = hufGroup.permute[j];
        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
            if (!runPos){
                runPos = 1;
                t = 0;
            }
            if (nextSym == SYMBOL_RUNA) t += runPos;
            else t += 2 * runPos;
            runPos <<= 1;
            continue;
        }
        if (runPos) {
            runPos = 0;
            if (count + t > bufsize) message.Error("Boom.");
            uc = this.symToByte[this.mtfSymbol[0]];
            this.byteCount[uc] += t;
            while(t--) buf[count++] = uc;
        }
        if (nextSym > symTotal) break;
        if (count >= bufsize) message.Error("I can't think of anything. Error");
        i = nextSym - 1;
        uc = this.mtfSymbol[i];
        for(var k = i-1; k>=0; k--) {
            this.mtfSymbol[k+1] = this.mtfSymbol[k];
        }
        this.mtfSymbol[0] = uc
        uc = this.symToByte[uc];
        this.byteCount[uc]++;
        buf[count++] = uc;
    }
    if (origPtr < 0 || origPtr >= count) message.Error("I'm a monkey and I'm throwing something at someone, namely you");
    var j = 0;
    for(var i = 0; i < 256; i++) {
        k = j + this.byteCount[i];
        this.byteCount[i] = j;
        j = k;
    }
    for(var i = 0; i < count; i++) {
        uc = buf[i] & 0xff;
        buf[this.byteCount[uc]] |= (i << 8);
        this.byteCount[uc]++;
    }
    var pos = 0, current = 0, run = 0;
    if (count) {
        pos = buf[origPtr];
        current = (pos & 0xff);
        pos >>= 8;
        run = -1;
    }
    count = count;
    var copies, previous, outbyte;
    while(count) {
        count--;
        previous = current;
        pos = buf[pos];
        current = pos & 0xff;
        pos >>= 8;
        if (run++ == 3) {
            copies = current;
            outbyte = previous;
            current = -1;
        } else {
            copies = 1;
            outbyte = current;
        }
        while(copies--) {
            crc = ((crc << 8) ^ this.crcTable[((crc>>24) ^ outbyte) & 0xFF])&0xFFFFFFFF; // crc32
            stream(outbyte);
        }
        if (current != previous) run = 0;
    }

    crc = (crc ^ (-1)) >>> 0;
    if ((crc|0) != (crcblock|0)) message.Error("Error in bzip2: crc32 do not match");
    streamCRC = (crc ^ ((streamCRC << 1) | (streamCRC >>> 31))) & 0xFFFFFFFF;
    return streamCRC;
}

module.exports = bzip2;


/***/ }),

/***/ 4410:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __nccwpck_require__(1669).deprecate;


/***/ }),

/***/ 7320:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 7550:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const WebSocket = __nccwpck_require__(1000);

WebSocket.createWebSocketStream = __nccwpck_require__(6271);
WebSocket.Server = __nccwpck_require__(8080);
WebSocket.Receiver = __nccwpck_require__(4538);
WebSocket.Sender = __nccwpck_require__(4363);

module.exports = WebSocket;


/***/ }),

/***/ 9588:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { EMPTY_BUFFER } = __nccwpck_require__(9492);

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __nccwpck_require__(7488);
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ 9492:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ 9049:
/***/ ((module) => {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being
   *     closed
   * @param {String} reason A human-readable string explaining why the
   *     connection is closing
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ 5179:
/***/ ((module) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 4701:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 3194:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const zlib = __nccwpck_require__(8761);

const bufferUtil = __nccwpck_require__(9588);
const Limiter = __nccwpck_require__(4701);
const { kStatusCode, NOOP } = __nccwpck_require__(9492);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 4538:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Writable } = __nccwpck_require__(2413);

const PerMessageDeflate = __nccwpck_require__(3194);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __nccwpck_require__(9492);
const { concat, toArrayBuffer, unmask } = __nccwpck_require__(9588);
const { isValidStatusCode, isValidUTF8 } = __nccwpck_require__(3221);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} [binaryType=nodebuffer] The type for binary data
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Boolean} [isServer=false] Specifies whether to operate in client or
   *     server mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ 4363:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { randomFillSync } = __nccwpck_require__(6417);

const PerMessageDeflate = __nccwpck_require__(3194);
const { EMPTY_BUFFER } = __nccwpck_require__(9492);
const { isValidStatusCode } = __nccwpck_require__(3221);
const { mask: applyMask, toBuffer } = __nccwpck_require__(9588);

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {String} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += data.length;
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= data.length;
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ 6271:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Duplex } = __nccwpck_require__(2413);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 3221:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

try {
  let isValidUTF8 = __nccwpck_require__(6365);

  /* istanbul ignore if */
  if (typeof isValidUTF8 === 'object') {
    isValidUTF8 = isValidUTF8.Validation.isValidUTF8; // utf-8-validate@<3.0.0
  }

  module.exports = {
    isValidStatusCode,
    isValidUTF8(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8
  };
}


/***/ }),

/***/ 8080:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(8614);
const { createHash } = __nccwpck_require__(6417);
const { createServer, STATUS_CODES } = __nccwpck_require__(8605);

const PerMessageDeflate = __nccwpck_require__(3194);
const WebSocket = __nccwpck_require__(1000);
const { format, parse } = __nccwpck_require__(5179);
const { GUID, kWebSocket } = __nccwpck_require__(9492);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {http.Server} [options.server] A pre-created HTTP/S server to use
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} [cb] Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.split(',').map(trim);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}

/**
 * Remove whitespace characters from both ends of a string.
 *
 * @param {String} str The string
 * @return {String} A new string representing `str` stripped of whitespace
 *     characters from both its beginning and end
 * @private
 */
function trim(str) {
  return str.trim();
}


/***/ }),

/***/ 1000:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(8614);
const https = __nccwpck_require__(7211);
const http = __nccwpck_require__(8605);
const net = __nccwpck_require__(1631);
const tls = __nccwpck_require__(4016);
const { randomBytes, createHash } = __nccwpck_require__(6417);
const { URL } = __nccwpck_require__(8835);

const PerMessageDeflate = __nccwpck_require__(3194);
const Receiver = __nccwpck_require__(4538);
const Sender = __nccwpck_require__(4363);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __nccwpck_require__(9492);
const { addEventListener, removeEventListener } = __nccwpck_require__(9049);
const { format, parse } = __nccwpck_require__(5179);
const { toBuffer } = __nccwpck_require__(9588);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._extensions = {};
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} [maxPayload=0] The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this.binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {String} [data] A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  const descriptor = { enumerable: true, value: i };

  Object.defineProperty(WebSocket.prototype, readyState, descriptor);
  Object.defineProperty(WebSocket, readyState, descriptor);
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    configurable: true,
    enumerable: true,
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} [protocols] The subprotocols
 * @param {Object} [options] Connection options
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket._url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req.aborted) return;

    req = websocket._req = null;
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[PerMessageDeflate.extensionName] =
            perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket._readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 3265:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var fs = __nccwpck_require__(5747);
var zlib = __nccwpck_require__(8761);
var fd_slicer = __nccwpck_require__(8021);
var crc32 = __nccwpck_require__(8992);
var util = __nccwpck_require__(1669);
var EventEmitter = __nccwpck_require__(8614).EventEmitter;
var Transform = __nccwpck_require__(2413).Transform;
var PassThrough = __nccwpck_require__(2413).PassThrough;
var Writable = __nccwpck_require__(2413).Writable;

exports.open = open;
exports.fromFd = fromFd;
exports.fromBuffer = fromBuffer;
exports.fromRandomAccessReader = fromRandomAccessReader;
exports.dosDateTimeToDate = dosDateTimeToDate;
exports.validateFileName = validateFileName;
exports.ZipFile = ZipFile;
exports.Entry = Entry;
exports.RandomAccessReader = RandomAccessReader;

function open(path, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs.open(path, "r", function(err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function(err, zipfile) {
      if (err) fs.close(fd, defaultCallback);
      callback(err, zipfile);
    });
  });
}

function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs.fstat(fd, function(err, stats) {
    if (err) return callback(err);
    var reader = fd_slicer.createFromFd(fd, {autoClose: true});
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}

function fromBuffer(buffer, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});
  fromRandomAccessReader(reader, buffer.length, options, callback);
}

function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  }

  // the matching unref() call is in zipfile.close()
  reader.ref();

  // eocdr means End of Central Directory Record.
  // search backwards for the eocdr signature.
  // the last field of the eocdr is a variable-length comment.
  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 0xffff; // 2-byte size
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer.length;
  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
    if (err) return callback(err);
    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
      // found eocdr
      var eocdrBuffer = buffer.slice(i);

      // 0 - End of central directory signature = 0x06054b50
      // 4 - Number of this disk
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
      }
      // 6 - Disk where central directory starts
      // 8 - Number of central directory records on this disk
      // 10 - Total number of central directory records
      var entryCount = eocdrBuffer.readUInt16LE(10);
      // 12 - Size of central directory (bytes)
      // 16 - Offset of start of central directory, relative to start of archive
      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
      // 20 - Comment length
      var commentLength = eocdrBuffer.readUInt16LE(20);
      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
      if (commentLength !== expectedCommentLength) {
        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
      }
      // 22 - Comment
      // the encoding is always cp437.
      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)
                                  : eocdrBuffer.slice(22);

      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
      }

      // ZIP64 format

      // ZIP64 Zip64 end of central directory locator
      var zip64EocdlBuffer = newBuffer(20);
      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
        if (err) return callback(err);

        // 0 - zip64 end of central dir locator signature = 0x07064b50
        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
          return callback(new Error("invalid zip64 end of central directory locator signature"));
        }
        // 4 - number of the disk with the start of the zip64 end of central directory
        // 8 - relative offset of the zip64 end of central directory record
        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
        // 16 - total number of disks

        // ZIP64 end of central directory record
        var zip64EocdrBuffer = newBuffer(56);
        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
          if (err) return callback(err);

          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
            return callback(new Error("invalid zip64 end of central directory record signature"));
          }
          // 4 - size of zip64 end of central directory record                8 bytes
          // 12 - version made by                                             2 bytes
          // 14 - version needed to extract                                   2 bytes
          // 16 - number of this disk                                         4 bytes
          // 20 - number of the disk with the start of the central directory  4 bytes
          // 24 - total number of entries in the central directory on this disk         8 bytes
          // 32 - total number of entries in the central directory            8 bytes
          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
          // 40 - size of the central directory                               8 bytes
          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
          // 56 - zip64 extensible data sector                                (variable size)
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        });
      });
      return;
    }
    callback(new Error("end of central directory record signature not found"));
  });
}

util.inherits(ZipFile, EventEmitter);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
  var self = this;
  EventEmitter.call(self);
  self.reader = reader;
  // forward close events
  self.reader.on("error", function(err) {
    // error closing the fd
    emitError(self, err);
  });
  self.reader.once("close", function() {
    self.emit("close");
  });
  self.readEntryCursor = centralDirectoryOffset;
  self.fileSize = fileSize;
  self.entryCount = entryCount;
  self.comment = comment;
  self.entriesRead = 0;
  self.autoClose = !!autoClose;
  self.lazyEntries = !!lazyEntries;
  self.decodeStrings = !!decodeStrings;
  self.validateEntrySizes = !!validateEntrySizes;
  self.strictFileNames = !!strictFileNames;
  self.isOpen = true;
  self.emittedError = false;

  if (!self.lazyEntries) self._readEntry();
}
ZipFile.prototype.close = function() {
  if (!this.isOpen) return;
  this.isOpen = false;
  this.reader.unref();
};

function emitErrorAndAutoClose(self, err) {
  if (self.autoClose) self.close();
  emitError(self, err);
}
function emitError(self, err) {
  if (self.emittedError) return;
  self.emittedError = true;
  self.emit("error", err);
}

ZipFile.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function() {
  var self = this;
  if (self.entryCount === self.entriesRead) {
    // done with metadata
    setImmediate(function() {
      if (self.autoClose) self.close();
      if (self.emittedError) return;
      self.emit("end");
    });
    return;
  }
  if (self.emittedError) return;
  var buffer = newBuffer(46);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
    if (err) return emitErrorAndAutoClose(self, err);
    if (self.emittedError) return;
    var entry = new Entry();
    // 0 - Central directory file header signature
    var signature = buffer.readUInt32LE(0);
    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    // 4 - Version made by
    entry.versionMadeBy = buffer.readUInt16LE(4);
    // 6 - Version needed to extract (minimum)
    entry.versionNeededToExtract = buffer.readUInt16LE(6);
    // 8 - General purpose bit flag
    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
    // 10 - Compression method
    entry.compressionMethod = buffer.readUInt16LE(10);
    // 12 - File last modification time
    entry.lastModFileTime = buffer.readUInt16LE(12);
    // 14 - File last modification date
    entry.lastModFileDate = buffer.readUInt16LE(14);
    // 16 - CRC-32
    entry.crc32 = buffer.readUInt32LE(16);
    // 20 - Compressed size
    entry.compressedSize = buffer.readUInt32LE(20);
    // 24 - Uncompressed size
    entry.uncompressedSize = buffer.readUInt32LE(24);
    // 28 - File name length (n)
    entry.fileNameLength = buffer.readUInt16LE(28);
    // 30 - Extra field length (m)
    entry.extraFieldLength = buffer.readUInt16LE(30);
    // 32 - File comment length (k)
    entry.fileCommentLength = buffer.readUInt16LE(32);
    // 34 - Disk number where file starts
    // 36 - Internal file attributes
    entry.internalFileAttributes = buffer.readUInt16LE(36);
    // 38 - External file attributes
    entry.externalFileAttributes = buffer.readUInt32LE(38);
    // 42 - Relative offset of local file header
    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);

    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));

    self.readEntryCursor += 46;

    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
      if (err) return emitErrorAndAutoClose(self, err);
      if (self.emittedError) return;
      // 46 - File name
      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)
                                          : buffer.slice(0, entry.fileNameLength);

      // 46+n - Extra field
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer,
        });
        i = dataEnd;
      }

      // 46+n+m - File comment
      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)
                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
      entry.comment = entry.fileComment;

      self.readEntryCursor += buffer.length;
      self.entriesRead += 1;

      if (entry.uncompressedSize            === 0xffffffff ||
          entry.compressedSize              === 0xffffffff ||
          entry.relativeOffsetOfLocalHeader === 0xffffffff) {
        // ZIP64 format
        // find the Zip64 Extended Information Extra Field
        var zip64EiefBuffer = null;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x0001) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
        }
        var index = 0;
        // 0 - Original Size          8 bytes
        if (entry.uncompressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 8 - Compressed Size        8 bytes
        if (entry.compressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 16 - Relative Header Offset 8 bytes
        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 24 - Disk Start Number      4 bytes
      }

      // check for Info-ZIP Unicode Path Extra Field (0x7075)
      // see https://github.com/thejoshwolfe/yauzl/issues/33
      if (self.decodeStrings) {
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x7075) {
            if (extraField.data.length < 6) {
              // too short to be meaningful
              continue;
            }
            // Version       1 byte      version of this extra field, currently 1
            if (extraField.data.readUInt8(0) !== 1) {
              // > Changes may not be backward compatible so this extra
              // > field should not be used if the version is not recognized.
              continue;
            }
            // NameCRC32     4 bytes     File Name Field CRC32 Checksum
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              // > If the CRC check fails, this UTF-8 Path Extra Field should be
              // > ignored and the File Name field in the header should be used instead.
              continue;
            }
            // UnicodeName   Variable    UTF-8 version of the entry File Name
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }

      // validate file size
      if (self.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          // traditional encryption prefixes the file data with a header
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self, new Error(msg));
        }
      }

      if (self.decodeStrings) {
        if (!self.strictFileNames) {
          // allow backslash
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
      }
      self.emit("entry", entry);

      if (!self.lazyEntries) self._readEntry();
    });
  });
};

ZipFile.prototype.openReadStream = function(entry, options, callback) {
  var self = this;
  // parameter validation
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    // validate options that the caller has no excuse to get wrong
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
        throw new Error("options.decrypt can only be specified for encrypted entries");
      }
      if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error("options.decompress can only be specified for compressed entries");
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error("invalid options.decompress value: " + options.decompress);
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0) throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0) throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
    }
  }
  // any further errors can either be caused by the zipfile,
  // or were introduced in a minor version of yauzl,
  // so should be passed to the client rather than thrown.
  if (!self.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  // make sure we don't lose the fd before we open the actual read stream
  self.reader.ref();
  var buffer = newBuffer(30);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err) return callback(err);
      // 0 - Local file header signature = 0x04034b50
      var signature = buffer.readUInt32LE(0);
      if (signature !== 0x04034b50) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      // all this should be redundant
      // 4 - Version needed to extract (minimum)
      // 6 - General purpose bit flag
      // 8 - Compression method
      // 10 - File last modification time
      // 12 - File last modification date
      // 14 - CRC-32
      // 18 - Compressed size
      // 22 - Uncompressed size
      // 26 - File name length (n)
      var fileNameLength = buffer.readUInt16LE(26);
      // 28 - Extra field length (m)
      var extraFieldLength = buffer.readUInt16LE(28);
      // 30 - File name
      // 30+n - Extra field
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        // 0 - The file is stored (no compression)
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        // 8 - The file is Deflated
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        // bounds check now, because the read streams will probably not complain loud enough.
        // since we're dealing with an unsigned offset plus an unsigned size,
        // we only have 1 thing to check for.
        if (fileDataEnd > self.fileSize) {
          return callback(new Error("file data overflows file bounds: " +
              fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
        }
      }
      var readStream = self.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd,
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          // setImmediate here because errors can be emitted during the first call to pipe()
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);

        if (self.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
          inflateFilter.on("error", function(err) {
            // forward zlib errors to the client-visible stream
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          // the zlib filter is the client-visible stream
          endpointStream = inflateFilter;
        }
        // this is part of yauzl's API, so implement this function on the client-visible stream
        endpointStream.destroy = function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          // TODO: the inflateFilter may cause a memory leak. see Issue #27.
          readStream.destroy();
        };
      }
      callback(null, endpointStream);
    } finally {
      self.reader.unref();
    }
  });
};

function Entry() {
}
Entry.prototype.getLastModDate = function() {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 0x1) !== 0;
};
Entry.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};

function dosDateTimeToDate(date, time) {
  var day = date & 0x1f; // 1-31
  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108

  var millisecond = 0;
  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
  var minute = time >> 5 & 0x3f; // 0-59
  var hour = time >> 11 & 0x1f; // 0-23

  return new Date(year, month, day, hour, minute, second, millisecond);
}

function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  // all good
  return null;
}

function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
  if (length === 0) {
    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
    return setImmediate(function() { callback(null, newBuffer(0)); });
  }
  reader.read(buffer, offset, length, position, function(err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}

util.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function(cb) {
  if (this.actualByteCount < this.expectedByteCount) {
    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};

util.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
  EventEmitter.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  self.close(onCloseDone);

  function onCloseDone(err) {
    if (err) return self.emit('error', err);
    self.emit('close');
  }
};
RandomAccessReader.prototype.createReadStream = function(options) {
  var start = options.start;
  var end = options.end;
  if (start === end) {
    var emptyStream = new PassThrough();
    setImmediate(function() {
      emptyStream.end();
    });
    return emptyStream;
  }
  var stream = this._readStreamForRange(start, end);

  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function() {
    stream.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream.destroy();
  };

  var byteCounter = new AssertByteCountStream(end - start);
  refUnrefFilter.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function() {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };

  return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
  var readStream = this.createReadStream({start: position, end: position + length});
  var writeStream = new Writable();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream.on("error", function(error) {
    callback(error);
  });
  readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
  setImmediate(callback);
};

util.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
  PassThrough.call(this);
  this.context = context;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
  if (this.unreffedYet) return;
  this.unreffedYet = true;
  this.context.unref();
};

var cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';
function decodeBuffer(buffer, start, end, isUtf8) {
  if (isUtf8) {
    return buffer.toString("utf8", start, end);
  } else {
    var result = "";
    for (var i = start; i < end; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  }
}

function readUInt64LE(buffer, offset) {
  // there is no native function for this, because we can't actually store 64-bit integers precisely.
  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
  var lower32 = buffer.readUInt32LE(offset);
  var upper32 = buffer.readUInt32LE(offset + 4);
  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
  return upper32 * 0x100000000 + lower32;
  // as long as we're bounds checking the result of this function against the total file size,
  // we'll catch any overflow errors, because we already made sure the total file size was within reason.
}

// Node 10 deprecated new Buffer().
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}

function defaultCallback(err) {
  if (err) throw err;
}


/***/ }),

/***/ 3959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var fs = __nccwpck_require__(5747);
var Transform = __nccwpck_require__(2413).Transform;
var PassThrough = __nccwpck_require__(2413).PassThrough;
var zlib = __nccwpck_require__(8761);
var util = __nccwpck_require__(1669);
var EventEmitter = __nccwpck_require__(8614).EventEmitter;
var crc32 = __nccwpck_require__(8992);

exports.ZipFile = ZipFile;
exports.dateToDosDateTime = dateToDosDateTime;

util.inherits(ZipFile, EventEmitter);
function ZipFile() {
  this.outputStream = new PassThrough();
  this.entries = [];
  this.outputStreamCursor = 0;
  this.ended = false; // .end() sets this
  this.allDone = false; // set when we've written the last bytes
  this.forceZip64Eocd = false; // configurable in .end()
}

ZipFile.prototype.addFile = function(realPath, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};

  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  fs.stat(realPath, function(err, stats) {
    if (err) return self.emit("error", err);
    if (!stats.isFile()) return self.emit("error", new Error("not a file: " + realPath));
    entry.uncompressedSize = stats.size;
    if (options.mtime == null) entry.setLastModDate(stats.mtime);
    if (options.mode == null) entry.setFileAttributesMode(stats.mode);
    entry.setFileDataPumpFunction(function() {
      var readStream = fs.createReadStream(realPath);
      entry.state = Entry.FILE_DATA_IN_PROGRESS;
      readStream.on("error", function(err) {
        self.emit("error", err);
      });
      pumpFileDataReadStream(self, entry, readStream);
    });
    pumpEntries(self);
  });
};

ZipFile.prototype.addReadStream = function(readStream, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};
  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    entry.state = Entry.FILE_DATA_IN_PROGRESS;
    pumpFileDataReadStream(self, entry, readStream);
  });
  pumpEntries(self);
};

ZipFile.prototype.addBuffer = function(buffer, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (buffer.length > 0x3fffffff) throw new Error("buffer too large: " + buffer.length + " > " + 0x3fffffff);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  var entry = new Entry(metadataPath, false, options);
  entry.uncompressedSize = buffer.length;
  entry.crc32 = crc32.unsigned(buffer);
  entry.crcAndFileSizeKnown = true;
  self.entries.push(entry);
  if (!entry.compress) {
    setCompressedBuffer(buffer);
  } else {
    zlib.deflateRaw(buffer, function(err, compressedBuffer) {
      setCompressedBuffer(compressedBuffer);
    });
  }
  function setCompressedBuffer(compressedBuffer) {
    entry.compressedSize = compressedBuffer.length;
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self, compressedBuffer);
      writeToOutputStream(self, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;

      // don't call pumpEntries() recursively.
      // (also, don't call process.nextTick recursively.)
      setImmediate(function() {
        pumpEntries(self);
      });
    });
    pumpEntries(self);
  }
};

ZipFile.prototype.addEmptyDirectory = function(metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, true);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  if (options.compress != null) throw new Error("options.compress not allowed");
  var entry = new Entry(metadataPath, true, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    writeToOutputStream(self, entry.getDataDescriptor());
    entry.state = Entry.FILE_DATA_DONE;
    pumpEntries(self);
  });
  pumpEntries(self);
};

var eocdrSignatureBuffer = bufferFrom([0x50, 0x4b, 0x05, 0x06]);

ZipFile.prototype.end = function(options, finalSizeCallback) {
  if (typeof options === "function") {
    finalSizeCallback = options;
    options = null;
  }
  if (options == null) options = {};
  if (this.ended) return;
  this.ended = true;
  this.finalSizeCallback = finalSizeCallback;
  this.forceZip64Eocd = !!options.forceZip64Format;
  if (options.comment) {
    if (typeof options.comment === "string") {
      this.comment = encodeCp437(options.comment);
    } else {
      // It should be a Buffer
      this.comment = options.comment;
    }
    if (this.comment.length > 0xffff) throw new Error("comment is too large");
    // gotta check for this, because the zipfile format is actually ambiguous.
    if (bufferIncludes(this.comment, eocdrSignatureBuffer)) throw new Error("comment contains end of central directory record signature");
  } else {
    // no comment.
    this.comment = EMPTY_BUFFER;
  }
  pumpEntries(this);
};

function writeToOutputStream(self, buffer) {
  self.outputStream.write(buffer);
  self.outputStreamCursor += buffer.length;
}

function pumpFileDataReadStream(self, entry, readStream) {
  var crc32Watcher = new Crc32Watcher();
  var uncompressedSizeCounter = new ByteCounter();
  var compressor = entry.compress ? new zlib.DeflateRaw() : new PassThrough();
  var compressedSizeCounter = new ByteCounter();
  readStream.pipe(crc32Watcher)
            .pipe(uncompressedSizeCounter)
            .pipe(compressor)
            .pipe(compressedSizeCounter)
            .pipe(self.outputStream, {end: false});
  compressedSizeCounter.on("end", function() {
    entry.crc32 = crc32Watcher.crc32;
    if (entry.uncompressedSize == null) {
      entry.uncompressedSize = uncompressedSizeCounter.byteCount;
    } else {
      if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount) return self.emit("error", new Error("file data stream has unexpected number of bytes"));
    }
    entry.compressedSize = compressedSizeCounter.byteCount;
    self.outputStreamCursor += entry.compressedSize;
    writeToOutputStream(self, entry.getDataDescriptor());
    entry.state = Entry.FILE_DATA_DONE;
    pumpEntries(self);
  });
}

function pumpEntries(self) {
  if (self.allDone) return;
  // first check if finalSize is finally known
  if (self.ended && self.finalSizeCallback != null) {
    var finalSize = calculateFinalSize(self);
    if (finalSize != null) {
      // we have an answer
      self.finalSizeCallback(finalSize);
      self.finalSizeCallback = null;
    }
  }

  // pump entries
  var entry = getFirstNotDoneEntry();
  function getFirstNotDoneEntry() {
    for (var i = 0; i < self.entries.length; i++) {
      var entry = self.entries[i];
      if (entry.state < Entry.FILE_DATA_DONE) return entry;
    }
    return null;
  }
  if (entry != null) {
    // this entry is not done yet
    if (entry.state < Entry.READY_TO_PUMP_FILE_DATA) return; // input file not open yet
    if (entry.state === Entry.FILE_DATA_IN_PROGRESS) return; // we'll get there
    // start with local file header
    entry.relativeOffsetOfLocalHeader = self.outputStreamCursor;
    var localFileHeader = entry.getLocalFileHeader();
    writeToOutputStream(self, localFileHeader);
    entry.doFileDataPump();
  } else {
    // all cought up on writing entries
    if (self.ended) {
      // head for the exit
      self.offsetOfStartOfCentralDirectory = self.outputStreamCursor;
      self.entries.forEach(function(entry) {
        var centralDirectoryRecord = entry.getCentralDirectoryRecord();
        writeToOutputStream(self, centralDirectoryRecord);
      });
      writeToOutputStream(self, getEndOfCentralDirectoryRecord(self));
      self.outputStream.end();
      self.allDone = true;
    }
  }
}

function calculateFinalSize(self) {
  var pretendOutputCursor = 0;
  var centralDirectorySize = 0;
  for (var i = 0; i < self.entries.length; i++) {
    var entry = self.entries[i];
    // compression is too hard to predict
    if (entry.compress) return -1;
    if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
      // if addReadStream was called without providing the size, we can't predict the final size
      if (entry.uncompressedSize == null) return -1;
    } else {
      // if we're still waiting for fs.stat, we might learn the size someday
      if (entry.uncompressedSize == null) return null;
    }
    // we know this for sure, and this is important to know if we need ZIP64 format.
    entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
    var useZip64Format = entry.useZip64Format();

    pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
    pretendOutputCursor += entry.uncompressedSize;
    if (!entry.crcAndFileSizeKnown) {
      // use a data descriptor
      if (useZip64Format) {
        pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
      } else {
        pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
      }
    }

    centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
    if (useZip64Format) {
      centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
    }
  }

  var endOfCentralDirectorySize = 0;
  if (self.forceZip64Eocd ||
      self.entries.length >= 0xffff ||
      centralDirectorySize >= 0xffff ||
      pretendOutputCursor >= 0xffffffff) {
    // use zip64 end of central directory stuff
    endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
  }
  endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self.comment.length;
  return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
}

var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
function getEndOfCentralDirectoryRecord(self, actuallyJustTellMeHowLongItWouldBe) {
  var needZip64Format = false;
  var normalEntriesLength = self.entries.length;
  if (self.forceZip64Eocd || self.entries.length >= 0xffff) {
    normalEntriesLength = 0xffff;
    needZip64Format = true;
  }
  var sizeOfCentralDirectory = self.outputStreamCursor - self.offsetOfStartOfCentralDirectory;
  var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
  if (self.forceZip64Eocd || sizeOfCentralDirectory >= 0xffffffff) {
    normalSizeOfCentralDirectory = 0xffffffff;
    needZip64Format = true;
  }
  var normalOffsetOfStartOfCentralDirectory = self.offsetOfStartOfCentralDirectory;
  if (self.forceZip64Eocd || self.offsetOfStartOfCentralDirectory >= 0xffffffff) {
    normalOffsetOfStartOfCentralDirectory = 0xffffffff;
    needZip64Format = true;
  }
  if (actuallyJustTellMeHowLongItWouldBe) {
    if (needZip64Format) {
      return (
        ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE +
        ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE +
        END_OF_CENTRAL_DIRECTORY_RECORD_SIZE
      );
    } else {
      return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
    }
  }

  var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self.comment.length);
  // end of central dir signature                       4 bytes  (0x06054b50)
  eocdrBuffer.writeUInt32LE(0x06054b50, 0);
  // number of this disk                                2 bytes
  eocdrBuffer.writeUInt16LE(0, 4);
  // number of the disk with the start of the central directory  2 bytes
  eocdrBuffer.writeUInt16LE(0, 6);
  // total number of entries in the central directory on this disk  2 bytes
  eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
  // total number of entries in the central directory   2 bytes
  eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
  // size of the central directory                      4 bytes
  eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
  // offset of start of central directory with respect to the starting disk number  4 bytes
  eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
  // .ZIP file comment length                           2 bytes
  eocdrBuffer.writeUInt16LE(self.comment.length, 20);
  // .ZIP file comment                                  (variable size)
  self.comment.copy(eocdrBuffer, 22);

  if (!needZip64Format) return eocdrBuffer;

  // ZIP64 format
  // ZIP64 End of Central Directory Record
  var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
  // zip64 end of central dir signature                                             4 bytes  (0x06064b50)
  zip64EocdrBuffer.writeUInt32LE(0x06064b50, 0);
  // size of zip64 end of central directory record                                  8 bytes
  writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
  // version made by                                                                2 bytes
  zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
  // version needed to extract                                                      2 bytes
  zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
  // number of this disk                                                            4 bytes
  zip64EocdrBuffer.writeUInt32LE(0, 16);
  // number of the disk with the start of the central directory                     4 bytes
  zip64EocdrBuffer.writeUInt32LE(0, 20);
  // total number of entries in the central directory on this disk                  8 bytes
  writeUInt64LE(zip64EocdrBuffer, self.entries.length, 24);
  // total number of entries in the central directory                               8 bytes
  writeUInt64LE(zip64EocdrBuffer, self.entries.length, 32);
  // size of the central directory                                                  8 bytes
  writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
  // offset of start of central directory with respect to the starting disk number  8 bytes
  writeUInt64LE(zip64EocdrBuffer, self.offsetOfStartOfCentralDirectory, 48);
  // zip64 extensible data sector                                                   (variable size)
  // nothing in the zip64 extensible data sector


  // ZIP64 End of Central Directory Locator
  var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
  // zip64 end of central dir locator signature                               4 bytes  (0x07064b50)
  zip64EocdlBuffer.writeUInt32LE(0x07064b50, 0);
  // number of the disk with the start of the zip64 end of central directory  4 bytes
  zip64EocdlBuffer.writeUInt32LE(0, 4);
  // relative offset of the zip64 end of central directory record             8 bytes
  writeUInt64LE(zip64EocdlBuffer, self.outputStreamCursor, 8);
  // total number of disks                                                    4 bytes
  zip64EocdlBuffer.writeUInt32LE(1, 16);


  return Buffer.concat([
    zip64EocdrBuffer,
    zip64EocdlBuffer,
    eocdrBuffer,
  ]);
}

function validateMetadataPath(metadataPath, isDirectory) {
  if (metadataPath === "") throw new Error("empty metadataPath");
  metadataPath = metadataPath.replace(/\\/g, "/");
  if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath)) throw new Error("absolute path: " + metadataPath);
  if (metadataPath.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + metadataPath);
  var looksLikeDirectory = /\/$/.test(metadataPath);
  if (isDirectory) {
    // append a trailing '/' if necessary.
    if (!looksLikeDirectory) metadataPath += "/";
  } else {
    if (looksLikeDirectory) throw new Error("file path cannot end with '/': " + metadataPath);
  }
  return metadataPath;
}

var EMPTY_BUFFER = bufferAlloc(0);

// this class is not part of the public API
function Entry(metadataPath, isDirectory, options) {
  this.utf8FileName = bufferFrom(metadataPath);
  if (this.utf8FileName.length > 0xffff) throw new Error("utf8 file name too long. " + utf8FileName.length + " > " + 0xffff);
  this.isDirectory = isDirectory;
  this.state = Entry.WAITING_FOR_METADATA;
  this.setLastModDate(options.mtime != null ? options.mtime : new Date());
  if (options.mode != null) {
    this.setFileAttributesMode(options.mode);
  } else {
    this.setFileAttributesMode(isDirectory ? 0o40775 : 0o100664);
  }
  if (isDirectory) {
    this.crcAndFileSizeKnown = true;
    this.crc32 = 0;
    this.uncompressedSize = 0;
    this.compressedSize = 0;
  } else {
    // unknown so far
    this.crcAndFileSizeKnown = false;
    this.crc32 = null;
    this.uncompressedSize = null;
    this.compressedSize = null;
    if (options.size != null) this.uncompressedSize = options.size;
  }
  if (isDirectory) {
    this.compress = false;
  } else {
    this.compress = true; // default
    if (options.compress != null) this.compress = !!options.compress;
  }
  this.forceZip64Format = !!options.forceZip64Format;
  if (options.fileComment) {
    if (typeof options.fileComment === "string") {
      this.fileComment = bufferFrom(options.fileComment, "utf-8");
    } else {
      // It should be a Buffer
      this.fileComment = options.fileComment;
    }
    if (this.fileComment.length > 0xffff) throw new Error("fileComment is too large");
  } else {
    // no comment.
    this.fileComment = EMPTY_BUFFER;
  }
}
Entry.WAITING_FOR_METADATA = 0;
Entry.READY_TO_PUMP_FILE_DATA = 1;
Entry.FILE_DATA_IN_PROGRESS = 2;
Entry.FILE_DATA_DONE = 3;
Entry.prototype.setLastModDate = function(date) {
  var dosDateTime = dateToDosDateTime(date);
  this.lastModFileTime = dosDateTime.time;
  this.lastModFileDate = dosDateTime.date;
};
Entry.prototype.setFileAttributesMode = function(mode) {
  if ((mode & 0xffff) !== mode) throw new Error("invalid mode. expected: 0 <= " + mode + " <= " + 0xffff);
  // http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute/14727#14727
  this.externalFileAttributes = (mode << 16) >>> 0;
};
// doFileDataPump() should not call pumpEntries() directly. see issue #9.
Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
  this.doFileDataPump = doFileDataPump;
  this.state = Entry.READY_TO_PUMP_FILE_DATA;
};
Entry.prototype.useZip64Format = function() {
  return (
    (this.forceZip64Format) ||
    (this.uncompressedSize != null && this.uncompressedSize > 0xfffffffe) ||
    (this.compressedSize != null && this.compressedSize > 0xfffffffe) ||
    (this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 0xfffffffe)
  );
}
var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
// 3 = unix. 63 = spec version 6.3
var VERSION_MADE_BY = (3 << 8) | 63;
var FILE_NAME_IS_UTF8 = 1 << 11;
var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
Entry.prototype.getLocalFileHeader = function() {
  var crc32 = 0;
  var compressedSize = 0;
  var uncompressedSize = 0;
  if (this.crcAndFileSizeKnown) {
    crc32 = this.crc32;
    compressedSize = this.compressedSize;
    uncompressedSize = this.uncompressedSize;
  }

  var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
  var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
  if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;

  // local file header signature     4 bytes  (0x04034b50)
  fixedSizeStuff.writeUInt32LE(0x04034b50, 0);
  // version needed to extract       2 bytes
  fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
  // general purpose bit flag        2 bytes
  fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
  // compression method              2 bytes
  fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
  // last mod file time              2 bytes
  fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
  // last mod file date              2 bytes
  fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
  // crc-32                          4 bytes
  fixedSizeStuff.writeUInt32LE(crc32, 14);
  // compressed size                 4 bytes
  fixedSizeStuff.writeUInt32LE(compressedSize, 18);
  // uncompressed size               4 bytes
  fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
  // file name length                2 bytes
  fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
  // extra field length              2 bytes
  fixedSizeStuff.writeUInt16LE(0, 28);
  return Buffer.concat([
    fixedSizeStuff,
    // file name (variable size)
    this.utf8FileName,
    // extra field (variable size)
    // no extra fields
  ]);
};
var DATA_DESCRIPTOR_SIZE = 16;
var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
Entry.prototype.getDataDescriptor = function() {
  if (this.crcAndFileSizeKnown) {
    // the Mac Archive Utility requires this not be present unless we set general purpose bit 3
    return EMPTY_BUFFER;
  }
  if (!this.useZip64Format()) {
    var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
    // optional signature (required according to Archive Utility)
    buffer.writeUInt32LE(0x08074b50, 0);
    // crc-32                          4 bytes
    buffer.writeUInt32LE(this.crc32, 4);
    // compressed size                 4 bytes
    buffer.writeUInt32LE(this.compressedSize, 8);
    // uncompressed size               4 bytes
    buffer.writeUInt32LE(this.uncompressedSize, 12);
    return buffer;
  } else {
    // ZIP64 format
    var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
    // optional signature (unknown if anyone cares about this)
    buffer.writeUInt32LE(0x08074b50, 0);
    // crc-32                          4 bytes
    buffer.writeUInt32LE(this.crc32, 4);
    // compressed size                 8 bytes
    writeUInt64LE(buffer, this.compressedSize, 8);
    // uncompressed size               8 bytes
    writeUInt64LE(buffer, this.uncompressedSize, 16);
    return buffer;
  }
};
var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
Entry.prototype.getCentralDirectoryRecord = function() {
  var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
  var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
  if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;

  var normalCompressedSize = this.compressedSize;
  var normalUncompressedSize = this.uncompressedSize;
  var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
  var versionNeededToExtract;
  var zeiefBuffer;
  if (this.useZip64Format()) {
    normalCompressedSize = 0xffffffff;
    normalUncompressedSize = 0xffffffff;
    normalRelativeOffsetOfLocalHeader = 0xffffffff;
    versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;

    // ZIP64 extended information extra field
    zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
    // 0x0001                  2 bytes    Tag for this "extra" block type
    zeiefBuffer.writeUInt16LE(0x0001, 0);
    // Size                    2 bytes    Size of this "extra" block
    zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
    // Original Size           8 bytes    Original uncompressed file size
    writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
    // Compressed Size         8 bytes    Size of compressed data
    writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
    // Relative Header Offset  8 bytes    Offset of local header record
    writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
    // Disk Start Number       4 bytes    Number of the disk on which this file starts
    // (omit)
  } else {
    versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
    zeiefBuffer = EMPTY_BUFFER;
  }

  // central file header signature   4 bytes  (0x02014b50)
  fixedSizeStuff.writeUInt32LE(0x02014b50, 0);
  // version made by                 2 bytes
  fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
  // version needed to extract       2 bytes
  fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
  // general purpose bit flag        2 bytes
  fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
  // compression method              2 bytes
  fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
  // last mod file time              2 bytes
  fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
  // last mod file date              2 bytes
  fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
  // crc-32                          4 bytes
  fixedSizeStuff.writeUInt32LE(this.crc32, 16);
  // compressed size                 4 bytes
  fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
  // uncompressed size               4 bytes
  fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
  // file name length                2 bytes
  fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
  // extra field length              2 bytes
  fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
  // file comment length             2 bytes
  fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
  // disk number start               2 bytes
  fixedSizeStuff.writeUInt16LE(0, 34);
  // internal file attributes        2 bytes
  fixedSizeStuff.writeUInt16LE(0, 36);
  // external file attributes        4 bytes
  fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
  // relative offset of local header 4 bytes
  fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);

  return Buffer.concat([
    fixedSizeStuff,
    // file name (variable size)
    this.utf8FileName,
    // extra field (variable size)
    zeiefBuffer,
    // file comment (variable size)
    this.fileComment,
  ]);
};
Entry.prototype.getCompressionMethod = function() {
  var NO_COMPRESSION = 0;
  var DEFLATE_COMPRESSION = 8;
  return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
};

function dateToDosDateTime(jsDate) {
  var date = 0;
  date |= jsDate.getDate() & 0x1f; // 1-31
  date |= ((jsDate.getMonth() + 1) & 0xf) << 5; // 0-11, 1-12
  date |= ((jsDate.getFullYear() - 1980) & 0x7f) << 9; // 0-128, 1980-2108

  var time = 0;
  time |= Math.floor(jsDate.getSeconds() / 2); // 0-59, 0-29 (lose odd numbers)
  time |= (jsDate.getMinutes() & 0x3f) << 5; // 0-59
  time |= (jsDate.getHours() & 0x1f) << 11; // 0-23

  return {date: date, time: time};
}

function writeUInt64LE(buffer, n, offset) {
  // can't use bitshift here, because JavaScript only allows bitshifting on 32-bit integers.
  var high = Math.floor(n / 0x100000000);
  var low = n % 0x100000000;
  buffer.writeUInt32LE(low, offset);
  buffer.writeUInt32LE(high, offset + 4);
}

function defaultCallback(err) {
  if (err) throw err;
}

util.inherits(ByteCounter, Transform);
function ByteCounter(options) {
  Transform.call(this, options);
  this.byteCount = 0;
}
ByteCounter.prototype._transform = function(chunk, encoding, cb) {
  this.byteCount += chunk.length;
  cb(null, chunk);
};

util.inherits(Crc32Watcher, Transform);
function Crc32Watcher(options) {
  Transform.call(this, options);
  this.crc32 = 0;
}
Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
  this.crc32 = crc32.unsigned(chunk, this.crc32);
  cb(null, chunk);
};

var cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';
if (cp437.length !== 256) throw new Error("assertion failure");
var reverseCp437 = null;

function encodeCp437(string) {
  if (/^[\x20-\x7e]*$/.test(string)) {
    // CP437, ASCII, and UTF-8 overlap in this range.
    return bufferFrom(string, "utf-8");
  }

  // This is the slow path.
  if (reverseCp437 == null) {
    // cache this once
    reverseCp437 = {};
    for (var i = 0; i < cp437.length; i++) {
      reverseCp437[cp437[i]] = i;
    }
  }

  var result = bufferAlloc(string.length);
  for (var i = 0; i < string.length; i++) {
    var b = reverseCp437[string[i]];
    if (b == null) throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
    result[i] = b;
  }

  return result;
}

function bufferAlloc(size) {
  bufferAlloc = modern;
  try {
    return bufferAlloc(size);
  } catch (e) {
    bufferAlloc = legacy;
    return bufferAlloc(size);
  }
  function modern(size) {
    return Buffer.allocUnsafe(size);
  }
  function legacy(size) {
    return new Buffer(size);
  }
}
function bufferFrom(something, encoding) {
  bufferFrom = modern;
  try {
    return bufferFrom(something, encoding);
  } catch (e) {
    bufferFrom = legacy;
    return bufferFrom(something, encoding);
  }
  function modern(something, encoding) {
    return Buffer.from(something, encoding);
  }
  function legacy(something, encoding) {
    return new Buffer(something, encoding);
  }
}
function bufferIncludes(buffer, content) {
  bufferIncludes = modern;
  try {
    return bufferIncludes(buffer, content);
  } catch (e) {
    bufferIncludes = legacy;
    return bufferIncludes(buffer, content);
  }
  function modern(buffer, content) {
    return buffer.includes(content);
  }
  function legacy(buffer, content) {
    for (var i = 0; i <= buffer.length - content.length; i++) {
      for (var j = 0;; j++) {
        if (j === content.length) return true;
        if (buffer[i + j] !== content[j]) break;
      }
    }
    return false;
  }
}


/***/ }),

/***/ 7488:
/***/ ((module) => {

module.exports = eval("require")("bufferutil");


/***/ }),

/***/ 9506:
/***/ ((module) => {

module.exports = eval("require")("electron/index.js");


/***/ }),

/***/ 3632:
/***/ ((module) => {

module.exports = eval("require")("encoding");


/***/ }),

/***/ 2549:
/***/ ((module) => {

module.exports = eval("require")("supports-color");


/***/ }),

/***/ 6365:
/***/ ((module) => {

module.exports = eval("require")("utf-8-validate");


/***/ }),

/***/ 1956:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Blackberry PlayBook":{"userAgent":"Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+","viewport":{"width":600,"height":1024},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Blackberry PlayBook landscape":{"userAgent":"Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+","viewport":{"width":1024,"height":600},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"BlackBerry Z30":{"userAgent":"Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"BlackBerry Z30 landscape":{"userAgent":"Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note 3":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note 3 landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note II":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note II landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy S III":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy S III landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy S5":{"userAgent":"Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S5 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S8":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":360,"height":740},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S8 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":740,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S9+":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":320,"height":658},"deviceScaleFactor":4.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S9+ landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":658,"height":320},"deviceScaleFactor":4.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy Tab S4":{"userAgent":"Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Safari/537.36","viewport":{"width":712,"height":1138},"deviceScaleFactor":2.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy Tab S4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Safari/537.36","viewport":{"width":1138,"height":712},"deviceScaleFactor":2.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"iPad (gen 6)":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":768,"height":1024},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad (gen 6) landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":1024,"height":768},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad (gen 7)":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":810,"height":1080},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad (gen 7) landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":1080,"height":810},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Mini":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":768,"height":1024},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Mini landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":1024,"height":768},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Pro 11":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":834,"height":1194},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Pro 11 landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","viewport":{"width":1194,"height":834},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":667},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":667,"height":375},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6 Plus":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":414,"height":736},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6 Plus landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":736,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":667},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":667,"height":375},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7 Plus":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":414,"height":736},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7 Plus landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":736,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":667},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":667,"height":375},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8 Plus":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":414,"height":736},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8 Plus landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":736,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone SE":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1","viewport":{"width":320,"height":568},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone SE landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1","viewport":{"width":568,"height":320},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone X":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":812},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone X landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1","viewport":{"width":812,"height":375},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone XR":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1","viewport":{"width":414,"height":896},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone XR landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1","viewport":{"width":896,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":414,"height":715},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":800,"height":364},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":375,"height":635},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":724,"height":325},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro Max":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":414,"height":715},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro Max landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":808,"height":364},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":390,"height":664},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":750,"height":340},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":390,"height":664},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":750,"height":340},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro Max":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1","screen":{"width":428,"height":926},"viewport":{"width":428,"height":746},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro Max landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1","screen":{"width":428,"height":926},"viewport":{"width":832,"height":378},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"JioPhone 2":{"userAgent":"Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5","viewport":{"width":240,"height":320},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"firefox"},"JioPhone 2 landscape":{"userAgent":"Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5","viewport":{"width":320,"height":240},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"firefox"},"Kindle Fire HDX":{"userAgent":"Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true","viewport":{"width":800,"height":1280},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Kindle Fire HDX landscape":{"userAgent":"Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true","viewport":{"width":1280,"height":800},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"LG Optimus L70":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":384,"height":640},"deviceScaleFactor":1.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"LG Optimus L70 landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":640,"height":384},"deviceScaleFactor":1.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 550":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 550 landscape":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 950":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":360,"height":640},"deviceScaleFactor":4,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 950 landscape":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":640,"height":360},"deviceScaleFactor":4,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 10":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Safari/537.36","viewport":{"width":800,"height":1280},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 10 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Safari/537.36","viewport":{"width":1280,"height":800},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 4":{"userAgent":"Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":384,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":640,"height":384},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5X":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":412,"height":732},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5X landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":732,"height":412},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6":{"userAgent":"Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":412,"height":732},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":732,"height":412},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6P":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":412,"height":732},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6P landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":732,"height":412},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 7":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Safari/537.36","viewport":{"width":600,"height":960},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 7 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Safari/537.36","viewport":{"width":960,"height":600},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nokia Lumia 520":{"userAgent":"Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)","viewport":{"width":320,"height":533},"deviceScaleFactor":1.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nokia Lumia 520 landscape":{"userAgent":"Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)","viewport":{"width":533,"height":320},"deviceScaleFactor":1.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nokia N9":{"userAgent":"Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13","viewport":{"width":480,"height":854},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Nokia N9 landscape":{"userAgent":"Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13","viewport":{"width":854,"height":480},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Pixel 2":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":411,"height":731},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 2 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":731,"height":411},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 2 XL":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":411,"height":823},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 2 XL landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":823,"height":411},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 3":{"userAgent":"Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":393,"height":786},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 3 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":786,"height":393},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4":{"userAgent":"Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":353,"height":745},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":745,"height":353},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4a (5G)":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","screen":{"width":412,"height":892},"viewport":{"width":412,"height":765},"deviceScaleFactor":2.63,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4a (5G) landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","screen":{"height":892,"width":412},"viewport":{"width":840,"height":312},"deviceScaleFactor":2.63,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 5":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","screen":{"width":393,"height":851},"viewport":{"width":393,"height":727},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 5 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","screen":{"width":851,"height":393},"viewport":{"width":802,"height":293},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Moto G4":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Moto G4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4530.0 Mobile Safari/537.36","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"}}');

/***/ }),

/***/ 5101:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"playwright","version":"1.12.1","description":"A high-level API to automate web browsers","repository":"github:Microsoft/playwright","engines":{"node":">=12"},"homepage":"https://playwright.dev","main":"index.js","bin":{"playwright":"./lib/cli/cli.js"},"exports":{".":{"import":"./index.mjs","require":"./index.js"},"./":"./"},"scripts":{"install":"node install.js"},"author":{"name":"Microsoft Corporation"},"license":"Apache-2.0","dependencies":{"commander":"^6.1.0","debug":"^4.1.1","extract-zip":"^2.0.1","https-proxy-agent":"^5.0.0","jpeg-js":"^0.4.2","mime":"^2.4.6","pngjs":"^5.0.0","progress":"^2.0.3","proper-lockfile":"^4.1.1","proxy-from-env":"^1.1.0","rimraf":"^3.0.2","stack-utils":"^2.0.3","ws":"^7.4.6","yazl":"^2.5.1"}}');

/***/ }),

/***/ 2357:
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ 4293:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");;

/***/ }),

/***/ 3129:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 7619:
/***/ ((module) => {

"use strict";
module.exports = require("constants");;

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 7211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 2282:
/***/ ((module) => {

"use strict";
module.exports = require("module");;

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 1058:
/***/ ((module) => {

"use strict";
module.exports = require("readline");;

/***/ }),

/***/ 2413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 4304:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 3867:
/***/ ((module) => {

"use strict";
module.exports = require("tty");;

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
const core = __nccwpck_require__(9326);
const puppeteer = __nccwpck_require__(2243);
const { Cluster } = __nccwpck_require__(449);
const { AxePuppeteer } = __nccwpck_require__(7595);
const path = __nccwpck_require__(5622);
const os = __nccwpck_require__(2087);

const opts = ['--no-sandbox', '--disable-setuid-sandbox'];
// const localhost = `file://${process.env.GITHUB_WORKSPACE}${core.getInput('directory')}`;
const localhost = `file:///Users/pro/Documents/projects/british-gas/nucleus/dist/demo/iframe.html`;

if (!localhost) {
  core.warning('Directory was not set');
}

const getChromePath = () => {
  let browserPath;

  if (os.type() === "Windows_NT") {
    // Chrome is usually installed as a 32-bit application, on 64-bit systems it will have a different installation path.
    const programFiles = os.arch() === 'x64' ? process.env["PROGRAMFILES(X86)"] : process.env.PROGRAMFILES;
    browserPath = path.join(programFiles, "Google/Chrome/Application/chrome.exe");
  } else if (os.type() === "Linux") {
    browserPath = "/usr/bin/google-chrome";
  } else {
    browserPath = "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
  }

  if (browserPath && browserPath.length > 0) {
    return path.normalize(browserPath);
  }

  throw new TypeError(`Cannot run action. ${os.type} is not supported.`);
}

const unknownError = (e) => {
  console.log(e);
  const message = 'Something went wrong, please make sure storybook is running or is pointed to the right location.';
  console.error(message.red);
  core.setFailed(message);
  process.exit(1);
}

const logger = (story, violation) => {
  const name = `${story.kind}: ${story.name}`;

  if (violation) {
    const {description, helpUrl, nodes} = violation;

    console.error(
      `
      ${name}
      `.cyan,
      `  ${description}\n`.red,
      `  Please check:`.red, `${helpUrl}\n`.red,
      `  ${nodes[0].failureSummary}`.red
    );
  } else {
    console.log(
      `
      ${name}
      `.cyan,
      '  All accessibility checks passed'.green
    );
  }
};

const getStorybook = async (browser, url) => {
  const context = await browser.newContext();
  const page = await context.createIncognitoBrowserContext();

  await page.goto(url, {
    waitUntil: 'networkidle2'
  }).catch((e) => {
    console.log(e);
    core.setFailed(message);
    process.exit(1);
  });

  const evaluate = await page.evaluate('__STORYBOOK_CLIENT_API__.getStorybook()');
  await page.close();

  return evaluate;
};

const getStories = async (components) => {
  return components.map((component) => {
    const kind = component.kind;

    return component.stories.map((story) => {
      const name = story.name;
      return {
        url: `${localhost}?selectedKind=${kind}&selectedStory=${name}`,
        kind,
        name
      };
    })
  });
};

(async () => {
  const browser = await puppeteer['chromium'].launch({args: opts, executablePath: getChromePath()}).catch((e) => unknownError(e));
  const components = await getStorybook(browser, localhost).catch((e) => unknownError(e));
  const stories = await getStories(components);
  let errors = [];

  await browser.close();

  const cluster = await Cluster.launch({
    concurrency: Cluster.CONCURRENCY_CONTEXT,
    maxConcurrency: 10,
    puppeteerOptions: {
      args: opts,
      executablePath: getChromePath()
    },
    puppeteer: puppeteer['chromium']
  });

  const allStories = stories.reduce((all, value) => {
    return all.concat(value);
  }, []);

  await cluster.task(async ({ page, data }) => {
    const {url} = data;

    try {
      await page.goto(url, { waitUntil: 'networkidle2' }).catch((e) => {
        console.log(e);
        core.setFailed(message);
        process.exit(1);
      });

      const results = await new AxePuppeteer(page).include('#root').analyze();

      await page.close();

      if (results.violations.length < 1) {
        logger(data);
      }

      results.violations.forEach((violation) => {
        errors.push(violation);
        logger(data, violation);
      });

    } catch (err) {
      console.log(err);
      core.setFailed('Page failed to load');
      throw err;
    }
  });

  for (const storyObj of allStories) {
    cluster.queue(storyObj);
  }

  await cluster.idle();
  await cluster.close();

  if (errors.length > 0) {
    console.error(`\n${errors.length} accessibility tests failed`.underline.red);
    core.setFailed(`${errors.length} accessibility tests failed`);
    process.exit(1);
  } else {
    console.log(`\nAll accessibility tests passed`.underline.green);
    process.exit(0);
  }
})();

})();

module.exports = __webpack_exports__;
/******/ })()
;